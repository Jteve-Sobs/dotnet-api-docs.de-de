<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Monitor.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cfafcfe91d4ef6eba6ebbbbe6d7101119c93823a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cfafcfe91d4ef6eba6ebbbbe6d7101119c93823a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Provides a mechanism that synchronizes access to objects.</source>
          <target state="translated">Stellt einen Mechanismus bereit, der den Zugriff auf Objekte synchronisiert.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> -Klasse können Sie den Zugriff auf einen Codebereich synchronisieren, indem eine Sperre für ein bestimmtes Objekt durch Aufrufen der <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType&gt;</ph>, und <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</source>
          <target state="translated">Objektsperren bieten die Möglichkeit, den Zugriff auf einen Codeblock, der so genannte eines kritischen Abschnitts einschränken.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>While a thread owns the lock for an object, no other thread can acquire that lock.</source>
          <target state="translated">Während ein Thread die Sperre für ein Objekt besitzt, kann keine anderen Threads diese Sperre abzurufen.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</source>
          <target state="translated">Sie können auch die <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse, um sicherzustellen, dass keine anderen Threads zugelassen wird, eine Anwendung Zugriff auf code, der Eigentümer der Sperre ausgeführt wird, es sei denn, der andere Thread den Code mithilfe eines anderen gesperrten Objekts ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In this article:</source>
          <target state="translated">In diesem Artikel:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>The Monitor class: An overview<ept id="p1">](#Overview)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Monitor-Klasse: Übersicht<ept id="p1">](#Overview)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>The lock object<ept id="p1">](#Lock)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Das Sperrobjekt<ept id="p1">](#Lock)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>The critical section<ept id="p1">](#CriticalSection)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Der kritische Abschnitt<ept id="p1">](#CriticalSection)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>Pulse, PulseAll, and Wait<ept id="p1">](#Pulse)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Pulse PulseAll und warten<ept id="p1">](#Pulse)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>Monitors and wait handles<ept id="p1">](#WaitHandles)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Monitore und Wait-handles<ept id="p1">](#WaitHandles)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The Monitor class: An overview</source>
          <target state="translated">Monitor-Klasse: Übersicht</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> has the following features:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> bietet die folgenden Features:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It is associated with an object on demand.</source>
          <target state="translated">Es ist ein Objekt bei Bedarf zugeordnet.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It is unbound, which means it can be called directly from any context.</source>
          <target state="translated">Es ist nicht gebundenen, dies bedeutet, er kann direkt aus einem beliebigen Kontext aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class cannot be created; the methods of the <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> class are all static.</source>
          <target state="translated">Eine Instanz von der <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse kann nicht erstellt werden; die Methoden der <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse sind alle statisch.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each method is passed the synchronized object that controls access to the critical section.</source>
          <target state="translated">Jede Methode übergeben das synchronisierte Objekt, das steuert den Zugriff auf den kritischen Abschnitt.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class to lock objects other than strings (that is, reference types other than <ph id="ph2">&lt;xref:System.String&gt;</ph>), not value types.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse, um Objekte als Zeichenfolgen sperren (d. h. Referenztypen außer <ph id="ph2">&lt;xref:System.String&gt;</ph>), nicht Werttypen.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>For details, see the overloads of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> method and <bpt id="p1">[</bpt>The lock object<ept id="p1">](#Lock)</ept> section later in this article.</source>
          <target state="translated">Einzelheiten finden Sie die Überladungen der <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> Methode und <bpt id="p1">[</bpt>das Sperrenobjekt<ept id="p1">](#Lock)</ept> Abschnitt weiter unten in diesem Artikel.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following table describes the actions that can be taken by threads that access synchronized objects:</source>
          <target state="translated">Die folgende Tabelle beschreibt die Aktionen, die von Threads ausgeführt werden können, die Zugriff auf Objekte synchronisiert:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Action</source>
          <target state="translated">Aktion</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Acquires a lock for an object.</source>
          <target state="translated">Ruft eine Sperre für ein Objekt ab.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This action also marks the beginning of a critical section.</source>
          <target state="translated">Diese Aktion werden außerdem den Anfang eines kritischen Abschnitts.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</source>
          <target state="translated">Keine anderen Threads kann den kritischen Abschnitt eingeben, es sei denn, sie die Anweisungen in den kritischen Abschnitt mithilfe eines anderen gesperrten Objekts ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Releases the lock on an object in order to permit other threads to lock and access the object.</source>
          <target state="translated">Gibt die Sperre für ein Objekt zum Zulassen von anderen Threads zu sperren, und greifen auf das Objekt frei.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The calling thread waits while another thread accesses the object.</source>
          <target state="translated">Der aufrufende Thread wartet, während ein anderer Thread das Objekt zugreift.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Pulse signals are used to notify waiting threads about changes to an object's state.</source>
          <target state="translated">Pulse Signale werden verwendet, um wartende Threads über Änderungen an der Status eines Objekts zu benachrichtigen.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> (signal), <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> (signal), <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Sends a signal to one or more waiting threads.</source>
          <target state="translated">Sendet ein Signal an einen oder mehrere wartende Threads.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</source>
          <target state="translated">Das Signal benachrichtigt einen wartenden Thread, den der Zustand des gesperrten Objekts geändert wurde, und der Besitzer der Sperre ist bereit, um die Sperre aufzuheben.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</source>
          <target state="translated">Des wartenden Threads befindet sich in die Warteschlange für abgearbeitete des Objekts, damit er die Sperre für das Objekt schließlich empfangen kann.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</source>
          <target state="translated">Sobald der Thread die Sperre besitzt, kann es durch überprüfen den neuen Zustand des Objekts, um festzustellen, ob die erforderliche Status erreicht wurde.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Releases the lock on an object.</source>
          <target state="translated">Hebt die Sperre für ein Objekt.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This action also marks the end of a critical section protected by the locked object.</source>
          <target state="translated">Diese Aktion werden auch das Ende eines kritischen Abschnitts von gesperrten Objekts geschützt.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, there are two sets of overloads for the <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph> methods.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, es gibt zwei Sätze von Überladungen für die <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> und <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>One set of overloads has a <ph id="ph1">`ref`</ph> (in C#) or <ph id="ph2">`ByRef`</ph> (in Visual Basic) <ph id="ph3">&lt;xref:System.Boolean&gt;</ph> parameter that is atomically set to <ph id="ph4">`true`</ph> if the lock is acquired, even if an exception is thrown when acquiring the lock.</source>
          <target state="translated">Eine Gruppe von Überladungen hat eine <ph id="ph1">`ref`</ph> (in c#) oder <ph id="ph2">`ByRef`</ph> (in Visual Basic) <ph id="ph3">&lt;xref:System.Boolean&gt;</ph> Parameter, der atomar auf <ph id="ph4">`true`</ph> Wenn die Sperre abgerufen wird, auch wenn eine Ausnahme ausgelöst wird, wenn die Sperre abrufen.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</source>
          <target state="translated">Verwenden Sie diese Überladung, wenn es wichtig ist, die Sperre in allen Fällen, selbst wenn die Ressourcen, die die Sperre zu schützen, ist möglicherweise nicht in einem konsistenten Zustand.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The lock object</source>
          <target state="translated">Das Sperrobjekt</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The Monitor class consists of <ph id="ph1">`static`</ph> (in C#) or  <ph id="ph2">`Shared`</ph> (in Visual Basic) methods that operate on an object that controls access to the critical section.</source>
          <target state="translated">Monitor-Klasse besteht aus <ph id="ph1">`static`</ph> (in c#) oder <ph id="ph2">`Shared`</ph> (in Visual Basic) Methoden für ein Objekt, dass für den Zugriff auf den kritischen Abschnitt steuert.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following information is maintained for each synchronized object:</source>
          <target state="translated">Die folgende Informationen wird für jedes synchronisierte Objekt verwaltet:</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>A reference to the thread that currently holds the lock.</source>
          <target state="translated">Ein Verweis auf den Thread, der die Sperre enthält.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>A reference to a ready queue, which contains the threads that are ready to obtain the lock.</source>
          <target state="translated">Ein Verweis auf eine Warteschlange, die Threads enthält, die die Sperre erhalten können.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</source>
          <target state="translated">Ein Verweis auf eine Warteschlange, die die Threads enthält, die für die Benachrichtigung über eine Änderung in den Zustand des gesperrten Objekts warten.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> locks objects (that is, reference types), not value types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> sperrt Objekte (d. h. Referenztypen), nicht Werttypen.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>While you can pass a value type to <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, it is boxed separately for each call.</source>
          <target state="translated">Sie können einen Werttyp an <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> übergeben. Dieser wird jedoch für jeden Aufruf separat geschachtelt.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Since each call creates a separate object, <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> never blocks, and the code it is supposedly protecting is not really synchronized.</source>
          <target state="translated">Da jeder Aufruf ein separates Objekt erstellt, bedingt <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> nie eine Blockierung, und der Code, den die Methode eigentlich schützen soll, wird nicht wirklich synchronisiert.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In addition, the object passed to <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> is different from the object passed to <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, so <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> throws <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception with the message "Object synchronization method was called from an unsynchronized block of code."</source>
          <target state="translated">Darüber hinaus unterscheiden sich das an <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> und das an <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> übergebene Objekt, sodass <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> eine <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> mit der folgenden Meldung auslöst: "Die Objektsynchronisationsmethode wurde von einem nicht synchronisierten Codeblock aufgerufen."</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following example illustrates this problem.</source>
          <target state="translated">Dieses Problem wird anhand des folgenden Beispiels veranschaulicht.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It launches ten tasks, each of which just sleeps for 250 milliseconds.</source>
          <target state="translated">Im Beispiel werden zehn Aufgaben gestartet, wobei jede lediglich 250 Millisekunden inaktiv ist.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each task then updates a counter variable, <ph id="ph1">`nTasks`</ph>, which is intended to count the number of tasks that actually launched and executed.</source>
          <target state="translated">Anschließend aktualisiert jede Aufgabe eine Zählervariable, <ph id="ph1">`nTasks`</ph>, die dazu vorgesehen ist, die Anzahl von Aufgaben zu zählen, die tatsächlich gestartet wurden und ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Because <ph id="ph1">`nTasks`</ph> is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</source>
          <target state="translated">Weil <ph id="ph1">`nTasks`</ph> eine globale Variable ist, die von mehreren Aufgaben gleichzeitig aktualisiert werden kann, wird ein Monitor verwendet, um zu verhindern, dass die Variable gleichzeitig von mehreren Aufgaben geändert wird.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>However, as the output from the example shows, each of the tasks throws a <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception.</source>
          <target state="translated">Wie die Ausgabe des Beispiels zeigt, löst jede dieser Aufgaben jedoch eine <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>-Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each task throws a <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception because the <ph id="ph2">`nTasks`</ph> variable is boxed before the call to the <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> method in each task.</source>
          <target state="translated">Jede Aufgabe löst eine <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>-Ausnahme aus, weil die Variable <ph id="ph2">`nTasks`</ph> gekapselt wird, bevor in jeder Aufgabe die <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph>-Methode aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In other words, each method call is passed a separate variable that is independent of the others.</source>
          <target state="translated">Anders formuliert heißt das, bei jedem Methodenaufruf wird eine separate Variable übergeben, die unabhängig von den anderen ist.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">`nTasks`</ph> is boxed again in the call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`nTasks`</ph> wird im Aufruf der <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph>-Methode erneut gekapselt.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once again, this creates ten new boxed variables, which are independent of each other, <ph id="ph1">`nTasks`</ph>, and the ten boxed variables created in the call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Dadurch werden wiederum zehn neue gekapselte <ph id="ph1">`nTasks`</ph>-Variablen erstellt, die unabhängig voneinander sind. Hinzu kommen die zehn gekapselten Variablen, die im Aufruf der <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph>-Methode erstellt wurden.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</source>
          <target state="translated">Die Ausnahme wird dann ausgelöst, weil im Code versucht wird, eine Sperre für eine neu erstellte Variable freizugeben, die zuvor nicht gesperrt wurde.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Although you can box a value type variable before calling <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</source>
          <target state="translated">Wie das folgende Beispiel zeigt, können Sie eine Werttypvariable zwar vor dem Aufruf von <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> kapseln und dasselbe gekapselte Objekt an beide Methoden übergeben, diese Vorgehensweise bietet jedoch keinerlei Vorteile.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</source>
          <target state="translated">Änderungen an der nicht gekapselten Variablen wirken sich nicht auf die gekapselte Kopie aus, und es ist nicht möglich, den Wert der gekapselten Kopie zu ändern.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When selecting an object on which to synchronize, you should lock only on private or internal objects.</source>
          <target state="translated">Wenn ein Objekt für die Synchronisierung ausgewählt wird, sollten Sie nur auf private oder interne Objekte sperren.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</source>
          <target state="translated">Sperren auf externe Objekte kommen Deadlocks, weil nicht verknüpfte Code So sperren Sie für unterschiedliche Zwecke auf dieselben Objekte auswählen kann.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>.</source>
          <target state="translated">Beachten Sie, die Sie für ein Objekt in mehreren Anwendungsdomänen synchronisieren können, wenn das für die Sperre verwendete Objekt abgeleitet <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The critical section</source>
          <target state="translated">Der kritische Abschnitt</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods to mark the beginning and end of a critical section.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> Methoden, um Anfang und Ende eines kritischen Abschnitts zu markieren.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The functionality provided by the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods is identical to that provided by the <bpt id="p1">[</bpt>lock<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> statement in C# and the <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> statement in Visual Basic, except that the language constructs wrap the <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType&gt;</ph> method overload and the <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> method in a <ph id="ph5">`try`</ph>…<ph id="ph6">`finally`</ph></source>
          <target state="translated">Die Funktionalität von der <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> Methoden ist identisch mit derjenigen der <bpt id="p1">[</bpt>Sperre<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> -Anweisung in c# und die <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> -Anweisung in Visual Basic, außer dass die Sprachkonstrukte Wrap der <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType&gt;</ph> -methodenüberladung und die <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> Methode in einer <ph id="ph5">`try`</ph>...<ph id="ph6">`finally`</ph></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>block to ensure that the monitor is released.</source>
          <target state="translated">Sperren, um sicherzustellen, dass der Monitor freigegeben wird.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>If the critical section is a set of contiguous instructions, then the lock acquired by the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> method guarantees that only a single thread can execute the enclosed code with the locked object.</source>
          <target state="translated">Der kritische Abschnitt ist eine Reihe von zusammenhängenden Anweisungen, und klicken Sie dann auf die Sperre, die von der <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> Methode stellt sicher, dass den eingeschlossenen Code mit gesperrten Objekts nur ein einzigen Thread ausgeführt werden kann.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In this case, we recommend that you place that code in a <ph id="ph1">`try`</ph> block and place the call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> method in a <ph id="ph3">`finally`</ph> block.</source>
          <target state="translated">In diesem Fall wird empfohlen, dass Sie diesen Code in Platzieren einer <ph id="ph1">`try`</ph> blockieren, und platzieren Sie den Aufruf von der <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> Methode in einer <ph id="ph3">`finally`</ph> Block.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This ensures that the lock is released even if an exception occurs.</source>
          <target state="translated">Dadurch ist sichergestellt, dass die Sperre aufgehoben wird, selbst wenn eine Ausnahme auftritt.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following code fragment illustrates this pattern.</source>
          <target state="translated">Das folgende Codefragment veranschaulicht dieses Muster.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This facility is typically used to synchronize access to a static or instance method of a class.</source>
          <target state="translated">Diese Funktion wird normalerweise verwendet, um den Zugriff auf eine statische Methode oder Instanzmethode einer Klasse zu synchronisieren.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>If a critical section spans an entire method, the locking facility can be achieved by placing the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph> on the method, and specifying the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized&gt;</ph> value in the constructor of <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ein kritischen Abschnitt eine gesamte Methode umfasst, kann die Sperre-Funktion erreicht werden, indem Platzieren der <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph> der Methode und Angeben der <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized&gt;</ph> Wert im Konstruktor der <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When you use this attribute, the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> method calls are not needed.</source>
          <target state="translated">Wenn Sie dieses Attribut verwenden die <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> Methodenaufrufe sind nicht erforderlich.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following code fragment illustrates this pattern:</source>
          <target state="translated">Das folgende Codefragment veranschaulicht dieses Muster:</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class, the C# <bpt id="p1">[</bpt>lock<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> statement, or the Visual Basic <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> statement inside of the method instead of the attribute.</source>
          <target state="translated">Beachten Sie, dass das Attribut bewirkt, den aktuellen Thread die Sperre dass, bis die Methode einen Wert zurückgibt. verwenden, wenn die Sperre früher freigegeben werden kann, die <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse, die C#- <bpt id="p1">[</bpt>Sperre<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> -Anweisung oder die Visual Basic <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> Anweisung innerhalb der Methode anstelle der Attributs.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>While it is possible for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</source>
          <target state="translated">Es ist zwar möglich, für die <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> Anweisungen, die Sperren und ein angegebenes Objekt Member und/oder gruppenübergreifende freigeben, dieses Vorgehen wird nicht empfohlen.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Pulse, PulseAll, and Wait</source>
          <target state="translated">Pulse PulseAll und warten</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Sobald ein Thread die Sperre besitzt und hat den kritischen Abschnitt, der die Sperre schützt, rufen sie die <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> releases the lock if it is held, allows a waiting thread or threads to obtain the lock and enter the critical section,   and waits to be notified by a call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Gibt die Sperre frei, falls diese gehalten wird, kann einen wartenden Thread oder Threads an, die die Sperre abrufen und den kritischen Abschnitt und wartet auf eine Benachrichtigung durch einen Aufruf der <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> is notified, it returns and obtains the lock again.</source>
          <target state="translated">Wurde <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> benachrichtigt, führt die Methode einen Rücksprung aus und erhält erneut die Sperre.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Both <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> signal for the next thread in the wait queue to proceed.</source>
          <target state="translated">Sowohl <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> als auch <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> signalisieren, dass der nächste Thread in der Warteschlange verarbeitet werden kann.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Monitors and wait handles</source>
          <target state="translated">Monitore und Wait-handles</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It is important to note the distinction between the use of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class and <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> objects.</source>
          <target state="translated">Es ist wichtig, den Unterschied zwischen der Verwendung von beachten die <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse und <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> Objekte.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse ist rein verwaltete, vollständig übertragbare und möglicherweise effizienter im Hinblick auf die ressourcenanforderungen des Betriebssystems.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph>-Objekte repräsentieren Objekte des Betriebssystems, die in der Lage sind, ihre Ausführung zu unterbrechen und zu warten. Sie sind für die Synchronisierung zwischen verwaltetem und nicht verwaltetem Code von Nutzen und machen einige höhere Betriebssystemfunktionen verfügbar, z. B. die Fähigkeit, auf viele Objekte gleichzeitig zu warten.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class to synchronize access to a single instance of a random number generator represented by the <ph id="ph2">&lt;xref:System.Random&gt;</ph> class.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse zum Synchronisieren des Zugriffs auf eine einzelne Instanz eines Zufallszahlengenerators dargestellt durch die <ph id="ph2">&lt;xref:System.Random&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</source>
          <target state="translated">Das Beispiel erstellt die zehn Aufgaben, von die jede asynchron über einen Threadpoolthread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</source>
          <target state="translated">Jede Aufgabe 10.000 Zufallszahlen generiert, deren Mittelwert berechnet und zwei auf Prozedurebene-Variablen, die eine laufende Summe der Anzahl von Zufallszahlen generiert und deren Summe verwalten aktualisiert.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>After all tasks have executed, these two values are then used to calculate the overall mean.</source>
          <target state="translated">Nachdem alle Aufgaben ausgeführt haben, werden diese beiden Werte berechnet den Mittelwert den insgesamt verwendet.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Because they can be accessed from any task running on a thread pool thread, access to the variables <ph id="ph1">`total`</ph> and <ph id="ph2">`n`</ph> must also be synchronized.</source>
          <target state="translated">Da sie von einer Aufgabe, die über einen Threadpoolthread ausgeführt zugegriffen werden können, der Zugriff auf die Variablen <ph id="ph1">`total`</ph> und <ph id="ph2">`n`</ph> müssen synchronisiert werden.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType&gt;</ph> method is used for this purpose.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType&gt;</ph> Methode für diesen Zweck verwendet wird.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following example demonstrates the combined use of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class (implemented with the <ph id="ph2">`lock`</ph> or <ph id="ph3">`SyncLock`</ph> language construct), the <ph id="ph4">&lt;xref:System.Threading.Interlocked&gt;</ph> class, and the <ph id="ph5">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> class.</source>
          <target state="translated">Im folgende Beispiel wird veranschaulicht, die kombinierte Verwendung von der <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse (implementiert mit der <ph id="ph2">`lock`</ph> oder <ph id="ph3">`SyncLock`</ph> Sprachkonstrukt), wird die <ph id="ph4">&lt;xref:System.Threading.Interlocked&gt;</ph> -Klasse, und die <ph id="ph5">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It defines two <ph id="ph1">`internal`</ph> (in C#) or <ph id="ph2">`Friend`</ph> (in Visual Basic) classes, <ph id="ph3">`SyncResource`</ph> and <ph id="ph4">`UnSyncResource`</ph>, that respectively provide synchronized and unsynchronized access to a resource.</source>
          <target state="translated">Er definiert zwei <ph id="ph1">`internal`</ph> (in c#) oder <ph id="ph2">`Friend`</ph> (in Visual Basic) Klassen <ph id="ph3">`SyncResource`</ph> und <ph id="ph4">`UnSyncResource`</ph>, die entsprechend synchronisierten und nicht synchronisierten Zugriff auf eine Ressource bereitstellen.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> property is even, the method calls <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> to introduce a delay of 2,000 milliseconds.</source>
          <target state="translated">Um sicherzustellen, dass das Beispiel veranschaulicht den Unterschied zwischen dem synchronisierten und nicht synchronisierten Zugriff (das der Fall sein kann, wenn jeder Methodenaufruf schnell abgeschlossen wird), enthält die Methode eine zufällige Verzögerung: für threads, deren <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft geraden Wert hat, ist die Methodenaufrufe <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> um eine Verzögerung von 2.000 Millisekunden einzuführen.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Note that, because the <ph id="ph1">`SyncResource`</ph> class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</source>
          <target state="translated">Beachten Sie Folgendes: Da die <ph id="ph1">`SyncResource`</ph> Klasse ist nicht öffentlich ist, wird keines der Clientcode eine Sperre für die synchronisierte Ressource; die Sperre wird von die interne Klasse selbst ausgelöst.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This prevents malicious code from taking a lock on a public object.</source>
          <target state="translated">Dadurch wird verhindert, dass bösartiger Code eine Sperre für ein öffentliches Objekt auslöst.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The example defines a variable, <ph id="ph1">`numOps`</ph>, that defines the number of threads that will attempt to access the resource.</source>
          <target state="translated">Im Beispiel wird eine Variable, <ph id="ph1">`numOps`</ph>, definiert die Anzahl der Threads, die versucht, auf die Ressource zuzugreifen.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The application thread calls the <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> method for synchronized and unsynchronized access five times each.</source>
          <target state="translated">Der Anwendungsthread Ruft die <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> Methode für synchronisierten und nicht synchronisierten Zugriff auf fünf Mal jedes.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> method has a single parameter, a delegate that accepts no parameters and returns no value.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> Methode verfügt über einen einzelnen Parameter, ein Delegat, der keine Parameter akzeptiert und keinen Wert zurückgibt.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>For synchronized access, it invokes the <ph id="ph1">`SyncUpdateResource`</ph> method; for unsynchronized access, it invokes the <ph id="ph2">`UnSyncUpdateResource`</ph> method.</source>
          <target state="translated">Für synchronisierten Zugriff und ruft die <ph id="ph1">`SyncUpdateResource`</ph> Methode für nicht synchronisierten Zugriff Ruft die <ph id="ph2">`UnSyncUpdateResource`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>After each set of method calls, the application thread calls the <bpt id="p1">[</bpt>AutoResetEvent.WaitOne<ept id="p1">](xref:System.Threading.WaitHandle.WaitOne*)</ept> method so that it blocks until the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> instance is signaled.</source>
          <target state="translated">Nach jedem Satz von Methodenaufrufen, ruft der Anwendungsthread die <bpt id="p1">[</bpt>AutoResetEvent.WaitOne<ept id="p1">](xref:System.Threading.WaitHandle.WaitOne*)</ept> Methode, sodass, bis blockiert die <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> -Instanz signalisiert wird.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each call to the <ph id="ph1">`SyncUpdateResource`</ph> method calls the internal <ph id="ph2">`SyncResource.Access`</ph> method and then calls the <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method to decrement the <ph id="ph4">`numOps`</ph> counter.</source>
          <target state="translated">Bei jedem Aufruf der <ph id="ph1">`SyncUpdateResource`</ph> -Methode wird die interne <ph id="ph2">`SyncResource.Access`</ph> -Methode und ruft dann die <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> Methode dekrementiert die <ph id="ph4">`numOps`</ph> Leistungsindikator.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> Methode wird verwendet, um den Zähler zu verringern, da andernfalls Sie nicht davon ausgehen können, dass ein zweiter Thread den Wert zugreift, vor ein ersten Thread dekrementiert Wert in der Variablen gespeichert wurde.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the <ph id="ph1">`SyncUpdateResource`</ph> method calls the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> method, which signals the main thread to continue execution.</source>
          <target state="translated">Wenn die letzte synchronisierte Arbeitsthread dekrementiert den Zähler auf 0 (null), gibt an, dass alle synchronisierten Threads Zugriff auf die Ressource abgeschlossen haben die <ph id="ph1">`SyncUpdateResource`</ph> Methodenaufrufe der <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> -Methode, die den Hauptthread zu fortfahren signalisiert die Ausführung.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each call to the <ph id="ph1">`UnSyncUpdateResource`</ph> method calls the internal <ph id="ph2">`UnSyncResource.Access`</ph> method and then calls the <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method to decrement the <ph id="ph4">`numOps`</ph> counter.</source>
          <target state="translated">Bei jedem Aufruf der <ph id="ph1">`UnSyncUpdateResource`</ph> -Methode wird die interne <ph id="ph2">`UnSyncResource.Access`</ph> -Methode und ruft dann die <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> Methode dekrementiert die <ph id="ph4">`numOps`</ph> Leistungsindikator.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once again, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</source>
          <target state="translated">Noch einmal: die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> Methode wird verwendet, um die dekrementiert des Zähler, um sicherzustellen, dass ein zweiter Thread nicht den Wert zugreift, bevor der Variablen dekrementierte Wert des ersten Threads zugewiesen wurde.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the <ph id="ph1">`UnSyncUpdateResource`</ph> method calls the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> method, which signals the main thread to continue execution.</source>
          <target state="translated">Bei der letzten Worker dekrementiert den Zähler auf 0 (null) wurden nicht synchronisierte, gibt an, dass keine weiteren Threads nicht synchronisierten Zugriff auf die Ressource benötigen die <ph id="ph1">`UnSyncUpdateResource`</ph> Methodenaufrufe der <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> -Methode, die signalisiert den Hauptthread die Ausführung fortsetzen .</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</source>
          <target state="translated">Wie die Ausgabe des Beispiels zeigt, wird mit synchronisiertem Zugriff sichergestellt, dass der aufrufende Thread die geschützte Ressource beendet, bevor ein anderer Thread auf sie zugreifen kann. Jeder Thread wartet auf seinen Vorgänger.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>On the other hand, without the lock, the <ph id="ph1">`UnSyncResource.Access`</ph> method is called in the order in which threads reach it.</source>
          <target state="translated">Andererseits, ohne die Sperre der <ph id="ph1">`UnSyncResource.Access`</ph> Methode wird aufgerufen, in der Reihenfolge, in der Threads wird erreicht.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This type is thread safe.</source>
          <target state="translated">Dieser Typ ist threadsicher.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Acquires an exclusive lock on a specified object.</source>
          <target state="translated">Erhält eine exklusive Sperre für ein angegebenes Objekt.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>The object on which to acquire the monitor lock.</source>
          <target state="translated">Das Objekt, für das die Monitorsperre erhalten werden soll.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Acquires an exclusive lock on the specified object.</source>
          <target state="translated">Erhält eine exklusive Sperre für das angegebene Objekt.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Use <ph id="ph1">`Enter`</ph> to acquire the <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> on the object passed as the parameter.</source>
          <target state="translated">Verwendung <ph id="ph1">`Enter`</ph> beim Abrufen der <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> für das Objekt als Parameter übergeben.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>If another thread has executed an <ph id="ph1">`Enter`</ph> on the object but has not yet executed the corresponding <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, the current thread will block until the other thread releases the object.</source>
          <target state="translated">Wenn ein anderer Thread ausgeführt hat ein <ph id="ph1">`Enter`</ph> für das Objekt jedoch noch nicht den entsprechenden ausgeführt wurde <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, wird der aktuelle Thread blockiert, bis der andere Thread das Objekt frei.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>It is legal for the same thread to invoke <ph id="ph1">`Enter`</ph> more than once without it blocking; however, an equal number of <ph id="ph2">`Exit`</ph> calls must be invoked before other threads waiting on the object will unblock.</source>
          <target state="translated">Es ist zulässig, für den gleichen Thread aufzurufenden <ph id="ph1">`Enter`</ph> mehr als einmal ohne er blockiert, aber eine gleiche Anzahl von <ph id="ph2">`Exit`</ph> Aufrufe aufgerufen werden müssen, bevor die Blockierung von anderen Threads warten auf das Objekt aufgehoben werden.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>When you pass a value type variable to <ph id="ph1">`Enter`</ph>, it is boxed as an object.</source>
          <target state="translated">Wenn Sie eine Werttypvariable zu übergeben <ph id="ph1">`Enter`</ph>, dieser wird als Objekt geschachtelt.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>If you pass the same variable to <ph id="ph1">`Enter`</ph> again, it is boxed as a separate object, and the thread does not block.</source>
          <target state="translated">Wenn Sie die gleiche Variable übergeben <ph id="ph1">`Enter`</ph> erneut, dieser wird jedoch als separates Objekt geschachtelt und der Thread wird nicht blockiert.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>In this case, the code that <ph id="ph1">`Monitor`</ph> is supposedly protecting is not protected.</source>
          <target state="translated">In diesem Fall wird der Code, <ph id="ph1">`Monitor`</ph> ist eigentlich schützen soll, ist nicht geschützt.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Furthermore, when you pass the variable to <ph id="ph1">`Exit`</ph>, still another separate object is created.</source>
          <target state="translated">Darüber hinaus wird beim Übergeben der Variablen an <ph id="ph1">`Exit`</ph>, noch ein anderes separates Objekt erstellt wird.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Because the object passed to <ph id="ph1">`Exit`</ph> is different from the object passed to <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> throws <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</source>
          <target state="translated">Da das Objekt übergeben <ph id="ph1">`Exit`</ph> unterscheidet sich von der an übergebene Objekt <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> löst <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>For more information, see the conceptual topic <bpt id="p1">[</bpt>Monitors<ept id="p1">](xref:System.Threading.Monitor)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter dem Thema <bpt id="p1">[</bpt>Monitore<ept id="p1">](xref:System.Threading.Monitor)</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> can interrupt threads that are waiting to enter a <ph id="ph2">`Monitor`</ph> on an object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> können unterbrechen, Threads, die darauf warten, geben einen <ph id="ph2">`Monitor`</ph> für ein Objekt.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> will be thrown.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Use a C# <ph id="ph1">`try`</ph>…<ph id="ph2">`finally`</ph></source>
          <target state="translated">Verwenden Sie eine C#- <ph id="ph1">`try`</ph>...<ph id="ph2">`finally`</ph></target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>block (<ph id="ph1">`Try`</ph>…<ph id="ph2">`Finally`</ph></source>
          <target state="translated">Block (<ph id="ph1">`Try`</ph>...<ph id="ph2">`Finally`</ph></target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>in Visual Basic) to ensure that you release the monitor, or use the C# <ph id="ph1">`lock`</ph> statement (<ph id="ph2">`SyncLock`</ph> statement in Visual Basic), which wraps the <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods in a <ph id="ph5">`try`</ph>…<ph id="ph6">`finally`</ph></source>
          <target state="translated">in Visual Basic) stellen Sie sicher, dass den Monitor freigegeben wird, oder verwenden Sie die C#- <ph id="ph1">`lock`</ph> Anweisung (<ph id="ph2">`SyncLock`</ph> -Anweisung in Visual Basic), welche umschließt die <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> und <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> Methoden in einer <ph id="ph5">`try`</ph>...<ph id="ph6">`finally`</ph></target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>block.</source>
          <target state="translated">Block.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">`Enter`</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird die Verwendung der <ph id="ph1">`Enter`</ph>-Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The object on which to wait.</source>
          <target state="translated">Das Objekt, auf das gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Die Eingabe muss <ph id="ph1">&lt;see langword="false" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Die Ausgabe ist <ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Note   If no exception occurs, the output of this method is always <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Hinweis   Wenn keine Ausnahme auftritt, ist die Ausgabe dieser Methode immer <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Erhält eine exklusive Sperre für das angegebene Objekt und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Use <ph id="ph1">`Enter`</ph> to acquire the <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> on the object passed as the <ph id="ph3">`obj`</ph> parameter.</source>
          <target state="translated">Verwendung <ph id="ph1">`Enter`</ph> zum Abrufen der <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> für das Objekt übergeben, als die <ph id="ph3">`obj`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If another thread has executed an <ph id="ph1">`Enter`</ph> on the object but has not yet executed the corresponding <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, the current thread will block until the other thread releases the object.</source>
          <target state="translated">Wenn ein anderer Thread ausgeführt hat ein <ph id="ph1">`Enter`</ph> für das Objekt jedoch noch nicht den entsprechenden ausgeführt wurde <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, wird der aktuelle Thread blockiert, bis der andere Thread das Objekt frei.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>It is legal for the same thread to invoke <ph id="ph1">`Enter`</ph> more than once without it blocking; however, an equal number of <ph id="ph2">`Exit`</ph> calls must be invoked before other threads waiting on the object will unblock.</source>
          <target state="translated">Es ist zulässig, für den gleichen Thread aufzurufenden <ph id="ph1">`Enter`</ph> mehr als einmal ohne er blockiert, aber eine gleiche Anzahl von <ph id="ph2">`Exit`</ph> Aufrufe aufgerufen werden müssen, bevor die Blockierung von anderen Threads warten auf das Objekt aufgehoben werden.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Wenn die Sperre nicht angenommen wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die <ph id="ph1">`lockTaken`</ph> Parameter ist <ph id="ph2">`false`</ph> nachdem diese Methode beendet.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Dadurch wird das Programm in allen Fällen um zu bestimmen, ob die Sperre aufgehoben werden muss.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If this method returns without throwing an exception, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is always <ph id="ph2">`true`</ph>, and there is no need to test it.</source>
          <target state="translated">Wenn diese Methode zurückgibt, ohne eine Ausnahme auszulösen, wird die Variable angegeben, für die <ph id="ph1">`lockTaken`</ph> -Parameter ist immer <ph id="ph2">`true`</ph>, und besteht keine Notwendigkeit zum Testen.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>When you pass a value type variable to <ph id="ph1">`Enter`</ph>, it is boxed as an object.</source>
          <target state="translated">Wenn Sie eine Werttypvariable zu übergeben <ph id="ph1">`Enter`</ph>, dieser wird als Objekt geschachtelt.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If you pass the same variable to <ph id="ph1">`Enter`</ph> again, it is boxed as a separate object, and the thread does not block.</source>
          <target state="translated">Wenn Sie die gleiche Variable übergeben <ph id="ph1">`Enter`</ph> erneut, dieser wird jedoch als separates Objekt geschachtelt und der Thread wird nicht blockiert.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>In this case, the code that <ph id="ph1">`Monitor`</ph> is supposedly protecting is not protected.</source>
          <target state="translated">In diesem Fall wird der Code, <ph id="ph1">`Monitor`</ph> ist eigentlich schützen soll, ist nicht geschützt.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Furthermore, when you pass the variable to <ph id="ph1">`Exit`</ph>, another separate object is created.</source>
          <target state="translated">Darüber hinaus wird beim Übergeben der Variablen an <ph id="ph1">`Exit`</ph>, ein weiteres separates Objekt erstellt wird.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Because the object passed to <ph id="ph1">`Exit`</ph> is different from the object passed to <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> throws <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</source>
          <target state="translated">Da das Objekt übergeben <ph id="ph1">`Exit`</ph> unterscheidet sich von der an übergebene Objekt <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> löst <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>For more information, see the conceptual topic <bpt id="p1">[</bpt>Monitors<ept id="p1">](xref:System.Threading.Monitor)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter dem Thema <bpt id="p1">[</bpt>Monitore<ept id="p1">](xref:System.Threading.Monitor)</ept>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> can interrupt threads that are waiting to enter a <ph id="ph2">`Monitor`</ph> on an object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> können unterbrechen, Threads, die darauf warten, geben einen <ph id="ph2">`Monitor`</ph> für ein Objekt.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> will be thrown.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The following code shows the basic pattern for using the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> method overload.</source>
          <target state="translated">Der folgende Code zeigt das grundlegende Muster für die Verwendung der <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>This overload always sets the value of the variable that is passed to the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</source>
          <target state="translated">Diese Überladung legt immer den Wert der Variablen, die an die <ph id="ph1">`ref`</ph> Parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, selbst wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Überprüfen ist, ob die Sperre besitzt, werden veröffentlicht.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Die Eingabe für <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The object on which to release the lock.</source>
          <target state="translated">Das Objekt, dessen Sperre aufgehoben werden soll.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>Releases an exclusive lock on the specified object.</source>
          <target state="translated">Hebt eine exklusive Sperre für das angegebene Objekt auf.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The calling thread must own the lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Der aufrufende Thread muss Besitzer der Sperre auf die <ph id="ph1">`obj`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If the calling thread owns the lock on the specified object, and has made an equal number of <ph id="ph1">`Exit`</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> calls for the object, then the lock is released.</source>
          <target state="translated">Wenn der aufrufende Thread die Sperre für das angegebene Objekt besitzt und eine gleiche Anzahl von machte <ph id="ph1">`Exit`</ph> und <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> für das Objekt aufgerufen wird, und klicken Sie dann die Sperre aufgehoben wird.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If the calling thread has not invoked <ph id="ph1">`Exit`</ph> as many times as <ph id="ph2">`Enter`</ph>, the lock is not released.</source>
          <target state="translated">Wenn der aufrufende Thread nicht aufgerufen hat <ph id="ph1">`Exit`</ph> so oft wie <ph id="ph2">`Enter`</ph>, die Sperre wird nicht aufgehoben.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</source>
          <target state="translated">Wenn die Sperre wird aufgehoben, und andere Threads befinden sich in die Warteschlange für abgearbeitete für das Objekt, ruft die einem der Threads die Sperre ab.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls <ph id="ph1">`Exit`</ph>.</source>
          <target state="translated">Wenn andere Threads in der Warteschlange darauf warten, die Sperre erhalten werden, sie werden nicht automatisch verschoben, die Warteschlange für abgearbeitete beim Aufrufen des Besitzers der Sperre <ph id="ph1">`Exit`</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>To move one or more waiting threads into the ready queue, call <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> before invoking <ph id="ph3">`Exit`</ph>.</source>
          <target state="translated">Rufen Sie zum Verschieben einer oder mehrere wartende Threads in die Warteschlange für abgearbeitete <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> vor dem Aufrufen <ph id="ph3">`Exit`</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">`Exit`</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird die Verwendung der <ph id="ph1">`Exit`</ph>-Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The current thread does not own the lock for the specified object.</source>
          <target state="translated">Der aktuelle Thread besitzt die Sperre für das angegebene Objekt nicht.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>The object to test.</source>
          <target state="translated">Das zu überprüfende Objekt.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>Determines whether the current thread holds the lock on the specified object.</source>
          <target state="translated">Bestimmt, ob der aktuelle Thread die Sperre für das angegebene Objekt enthält.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread holds the lock on <ph id="ph2">&lt;paramref name="obj" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle Thread die Schreibsperre für <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> enthält, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>This method works only for locks that are acquired by using the methods of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class, or by using the C# <ph id="ph2">`lock`</ph> statement or the Visual Basic <ph id="ph3">`SyncLock`</ph> statement, which are implemented with <ph id="ph4">&lt;xref:System.Threading.Monitor&gt;</ph>.</source>
          <target state="translated">Diese Methode funktioniert nur bei Sperren, die mit den Methoden der erworben wurden die <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse oder mithilfe von C#- <ph id="ph2">`lock`</ph> -Anweisung oder die Visual Basic <ph id="ph3">`SyncLock`</ph> -Anweisung, die mit implementiert werden <ph id="ph4">&lt;xref:System.Threading.Monitor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>Use this method with diagnostic tools, such as the <ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> class, to debug locking issues that involve the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class.</source>
          <target state="translated">Verwenden Sie diese Methode mit Diagnosetools wie z. B. die <ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A&gt;</ph> Methode und die <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> -Klasse, um Probleme zu debuggen, bei denen, die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The object a thread is waiting for.</source>
          <target state="translated">Das Objekt, auf das ein Thread wartet.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Notifies a thread in the waiting queue of a change in the locked object's state.</source>
          <target state="translated">Benachrichtigt einen Thread in der Warteschlange für abzuarbeitende Threads über eine Änderung am Zustand des gesperrten Objekts.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Only the current owner of the lock can signal a waiting object using <ph id="ph1">`Pulse`</ph>.</source>
          <target state="translated">Nur der aktuelle Besitzer der Sperre ein wartende mithilfe signalisieren kann <ph id="ph1">`Pulse`</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</source>
          <target state="translated">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um der nächste Thread in der Zeile für die Sperre zu signalisieren.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Upon receiving the pulse, the waiting thread is moved to the ready queue.</source>
          <target state="translated">Nach dem Empfang der Pulse wird wird des wartenden Threads in die Warteschlange für abgearbeitete verschoben.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>When the thread that invoked <ph id="ph1">`Pulse`</ph> releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</source>
          <target state="translated">Wenn der Thread aufgerufen <ph id="ph1">`Pulse`</ph> hebt die Sperre der nächste Thread in die Warteschlange für abgearbeitete (Dies ist nicht notwendigerweise dem Thread, der Impuls empfangen hat) Ruft die Sperre ab.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class does not maintain state indicating that the <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method has been called.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse behält Status zeigt an, dass die <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> -Methode aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Thus, if you call <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> when no threads are waiting, the next thread that calls <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> blocks as if <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> had never been called.</source>
          <target state="translated">Daher beim Aufrufen <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> Wenn keine Threads warten, den nächsten Thread, der aufruft <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Blöcke wie <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> nie aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>If two threads are using <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> to interact, this could result in a deadlock.</source>
          <target state="translated">Wenn zwei Threads verwenden <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> um interagieren, könnte dies zu einem Deadlock.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> class: If you signal an <ph id="ph2">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> by calling its <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method, and there are no threads waiting, the <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> remains in a signaled state until a thread calls <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>.</source>
          <target state="translated">Vergleichen Sie dies mit dem Verhalten von der <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> Klasse: Wenn Sie zu signalisieren ein <ph id="ph2">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> durch Aufrufen seiner <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> -Methode, und es sind keine Threads, die darauf warten, die <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> verbleibt jedoch in den signalisierten Zustand, bis ein Thread aufruft, <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, oder <ph id="ph7">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> releases that thread and returns to the unsignaled state.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> dieser Thread freigibt und in den nicht signalisierten Zustand zurück.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange auf dem enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">`Pulse`</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Die <ph id="ph1">`Pulse`</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>To signal multiple threads, use the <ph id="ph1">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">Mehrere Threads signalisiert werden, verwenden die <ph id="ph1">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The object that sends the pulse.</source>
          <target state="translated">Das Objekt, das den Impuls sendet.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>Notifies all waiting threads of a change in the object's state.</source>
          <target state="translated">Benachrichtigt alle wartenden Threads über eine Änderung am Zustand des Objekts.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</source>
          <target state="translated">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um alle Threads, die darauf warten, der eine Sperre für das Objekt zu signalisieren.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>After the signal is sent, the waiting threads are moved to the ready queue.</source>
          <target state="translated">Nach dem Senden des Signals werden die wartende Threads in die Warteschlange für abgearbeitete verschoben.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>When the thread that invoked <ph id="ph1">`PulseAll`</ph> releases the lock, the next thread in the ready queue acquires the lock.</source>
          <target state="translated">Wenn der Thread aufgerufen <ph id="ph1">`PulseAll`</ph> hebt die Sperre der nächste Thread in die Warteschlange für abgearbeitete Ruft die Sperre ab.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange auf dem enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">`PulseAll`</ph>, and <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">`PulseAll`</ph>, und <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">Die Hinweise für die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> Methode wird erläutert, was geschieht, wenn <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> wird aufgerufen, wenn keine Threads warten.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>To signal a single thread, use the <ph id="ph1">`Pulse`</ph> method.</source>
          <target state="translated">Verwenden Sie einen einzelnen Thread signalisiert werden, die <ph id="ph1">`Pulse`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Attempts to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Das Objekt, für das die Sperre erhalten werden soll.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>Attempts to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread acquires the lock; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle Thread die Sperre erhält, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>If successful, this method acquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Wenn erfolgreich ist, diese Methode eine exklusive Sperre für erhält die <ph id="ph1">`obj`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>This method returns immediately, whether or not the lock is available.</source>
          <target state="translated">Diese Methode gibt sofort zurück, unabhängig davon, ob die Sperre verfügbar wird.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>This method is similar to <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, but it will never block the current thread.</source>
          <target state="translated">Diese Methode ist vergleichbar mit <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, aber es wird nie blockiert den aktuellen Thread.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>If the thread cannot enter without blocking, the method returns <ph id="ph1">`false,`</ph>.</source>
          <target state="translated">Wenn der Thread ohne Blockierung eingegeben werden kann, gibt die Methode <ph id="ph1">`false,`</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>For details, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> article.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Artikel.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in den kritischen Abschnitt nur, wenn der Rückgabewert ist <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Beachten Sie, die Sie aufrufen sollte <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in einer <ph id="ph2">`finally`</ph> Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The following code example demonstrates how to use the <ph id="ph1">`TryEnter`</ph> method.</source>
          <target state="translated">Das folgende Codebeispiel zeigt, wie Sie die <ph id="ph1">`TryEnter`</ph>-Methode verwenden.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Das Objekt, für das die Sperre erhalten werden soll.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Die Eingabe muss <ph id="ph1">&lt;see langword="false" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Die Ausgabe ist <ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>If successful, this method acquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Wenn erfolgreich ist, diese Methode eine exklusive Sperre für erhält die <ph id="ph1">`obj`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This method returns immediately, whether or not the lock is available.</source>
          <target state="translated">Diese Methode gibt sofort zurück, unabhängig davon, ob die Sperre verfügbar wird.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Wenn die Sperre nicht angenommen wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die <ph id="ph1">`lockTaken`</ph> Parameter ist <ph id="ph2">`false`</ph> nachdem diese Methode beendet.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Dadurch wird das Programm in allen Fällen um zu bestimmen, ob die Sperre aufgehoben werden muss.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This method is similar to <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph>, but it will never block the current thread.</source>
          <target state="translated">Diese Methode ist vergleichbar mit <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph>, aber es wird nie blockiert den aktuellen Thread.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>If the thread cannot enter without blocking, the <ph id="ph1">`lockTaken`</ph> argument is set to <ph id="ph2">`false`</ph> when the method returns.</source>
          <target state="translated">Wenn der Thread nicht, ohne zu blockieren betreten kann, die <ph id="ph1">`lockTaken`</ph> -Argument festgelegt wird <ph id="ph2">`false`</ph> bei Rückgabe der Methode.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> article.</source>
          <target state="translated">Weitere Informationen finden Sie im Artikel <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>To ensure that the thread does not enter the critical section, you should examine the value of <ph id="ph1">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Um sicherzustellen, dass der Thread ist nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der <ph id="ph1">`lockTaken`</ph> und Ausführen von Code in den kritischen Abschnitt nur, wenn der Wert ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Beachten Sie, die Sie aufrufen sollte <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in einer <ph id="ph2">`finally`</ph> Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The following code shows the basic pattern for using the <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> method overload.</source>
          <target state="translated">Der folgende Code zeigt das grundlegende Muster für die Verwendung der <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This overload always sets the value of the variable that is passed to the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</source>
          <target state="translated">Diese Überladung legt immer den Wert der Variablen, die an die <ph id="ph1">`ref`</ph> Parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, selbst wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Überprüfen ist, ob die Sperre besitzt, werden veröffentlicht.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Die Eingabe für <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Das Objekt, für das die Sperre erhalten werden soll.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The number of milliseconds to wait for the lock.</source>
          <target state="translated">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Versucht über eine angegebene Anzahl von Millisekunden hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread acquires the lock; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle Thread die Sperre erhält, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>If the <ph id="ph1">`millisecondsTimeout`</ph> parameter equals <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, this method is equivalent to <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</source>
          <target state="translated">Wenn die <ph id="ph1">`millisecondsTimeout`</ph> entspricht <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, diese Methode ist gleichbedeutend mit <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`millisecondsTimeout`</ph> gleich 0 ist, diese Methode ist gleichbedeutend mit <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>For details, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> article.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> Artikel.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in den kritischen Abschnitt nur, wenn der Rückgabewert ist <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Beachten Sie, die Sie aufrufen sollte <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in einer <ph id="ph2">`finally`</ph> Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, and not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> ist negativ und ungleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Das Objekt, für das die Sperre erhalten werden soll.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to wait for the lock.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph>, die die Zeitspanne darstellt, für die auf die Sperre gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>A value of –1 millisecond specifies an infinite wait.</source>
          <target state="translated">Ein Wert von -1 Millisekunde gibt eine unbegrenzte Wartezeit an.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Versucht über einen angegebenen Zeitraum hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread acquires the lock; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle Thread die Sperre erhält, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>If the value of the <ph id="ph1">`timeout`</ph> parameter converted to milliseconds equals –1, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</source>
          <target state="translated">Wenn der Wert der <ph id="ph1">`timeout`</ph> entspricht in Millisekunden konvertiert – 1, diese Methode ist äquivalent zu <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>If the value of <ph id="ph1">`timeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</source>
          <target state="translated">Wenn der Wert der <ph id="ph1">`timeout`</ph> gleich 0 ist, diese Methode ist gleichbedeutend mit <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>For details, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.</source>
          <target state="translated">Einzelheiten finden Sie in der <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> klassenthema.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in den kritischen Abschnitt nur, wenn der Rückgabewert ist <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Beachten Sie, die Sie aufrufen sollte <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in einer <ph id="ph2">`finally`</ph> Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> in milliseconds is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> in Millisekunden ist negativ und nicht gleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1 Millisekunde) oder ist größer als <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Das Objekt, für das die Sperre erhalten werden soll.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The number of milliseconds to wait for the lock.</source>
          <target state="translated">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Die Eingabe muss <ph id="ph1">&lt;see langword="false" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Die Ausgabe ist <ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Versucht für die angegebene Anzahl von Millisekunden, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>If the <ph id="ph1">`millisecondsTimeout`</ph> parameter equals <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, this method is equivalent to <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Wenn die <ph id="ph1">`millisecondsTimeout`</ph> entspricht <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, diese Methode ist gleichbedeutend mit <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`millisecondsTimeout`</ph> gleich 0 ist, diese Methode ist gleichbedeutend mit <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Wenn die Sperre nicht angenommen wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die <ph id="ph1">`lockTaken`</ph> Parameter ist <ph id="ph2">`false`</ph> nachdem diese Methode beendet.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Dadurch wird das Programm in allen Fällen um zu bestimmen, ob die Sperre aufgehoben werden muss.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> klassenthema.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>To ensure that the thread does not enter the critical section, you should examine the value of <ph id="ph1">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Um sicherzustellen, dass der Thread ist nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der <ph id="ph1">`lockTaken`</ph> und Ausführen von Code in den kritischen Abschnitt nur, wenn der Wert ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Beachten Sie, die Sie aufrufen sollte <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in einer <ph id="ph2">`finally`</ph> Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The following code shows the basic pattern for using the <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> method overload.</source>
          <target state="translated">Der folgende Code zeigt das grundlegende Muster für die Verwendung der <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>This overload always sets the value of the variable that is passed to the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</source>
          <target state="translated">Diese Überladung legt immer den Wert der Variablen, die an die <ph id="ph1">`ref`</ph> Parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, selbst wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Überprüfen ist, ob die Sperre besitzt, werden veröffentlicht.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Die Eingabe für <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, and not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> ist negativ und ungleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Das Objekt, für das die Sperre erhalten werden soll.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The amount of time to wait for the lock.</source>
          <target state="translated">Die Zeitspanne, für die auf die Sperre gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>A value of –1 millisecond specifies an infinite wait.</source>
          <target state="translated">Ein Wert von -1 Millisekunde gibt eine unbegrenzte Wartezeit an.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Die Eingabe muss <ph id="ph1">&lt;see langword="false" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Die Ausgabe ist <ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Versucht für die angegebene Dauer, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>If the value of the <ph id="ph1">`timeout`</ph> parameter converted to milliseconds equals –1, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Wenn der Wert der <ph id="ph1">`timeout`</ph> entspricht in Millisekunden konvertiert – 1, diese Methode ist äquivalent zu <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>If the value of <ph id="ph1">`timeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Wenn der Wert der <ph id="ph1">`timeout`</ph> gleich 0 ist, diese Methode ist gleichbedeutend mit <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Wenn die Sperre nicht angenommen wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die <ph id="ph1">`lockTaken`</ph> Parameter ist <ph id="ph2">`false`</ph> nachdem diese Methode beendet.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Dadurch wird das Programm in allen Fällen um zu bestimmen, ob die Sperre aufgehoben werden muss.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> klassenthema.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>To ensure that the thread does not enter the critical section, you should examine the value of <ph id="ph1">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Um sicherzustellen, dass der Thread ist nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der <ph id="ph1">`lockTaken`</ph> und Ausführen von Code in den kritischen Abschnitt nur, wenn der Wert ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Beachten Sie, die Sie aufrufen sollte <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in einer <ph id="ph2">`finally`</ph> Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Die Eingabe für <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> in milliseconds is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> in Millisekunden ist negativ und nicht gleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1 Millisekunde) oder ist größer als <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The object on which to wait.</source>
          <target state="translated">Das Objekt, auf das gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the call returned because the caller reacquired the lock for the specified object.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Aufruf beendet wurde, weil der Aufrufer die Sperre für das angegebene Objekt erneut erhalten hat.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This method does not return if the lock is not reacquired.</source>
          <target state="translated">Diese Methode wird nicht beendet, wenn die Sperre nicht erneut erhalten wird.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freizugeben, sodass ein anderer Thread darauf zugreifen kann.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">Der Aufrufer ist blockiert, beim Warten auf die Sperre erneut abzurufen.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten, die als Ergebnis von einem anderen Thread ausgeführt werden muss.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.</source>
          <target state="translated">Wenn ein Thread aufruft, <ph id="ph1">`Wait`</ph>, hebt die Sperre für das Objekt ist, und wechselt in die Warteschlange für das Objekt auf.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</source>
          <target state="translated">Der nächste Thread in die Warteschlange für abgearbeitete des Objekts (sofern vorhanden) die Sperre erhält und bietet die exklusive Verwendung des Objekts.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>All threads that call <ph id="ph1">`Wait`</ph> remain in the waiting queue until they receive a signal from <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, sent by the owner of the lock.</source>
          <target state="translated">Alle Threads, die aufgerufen werden <ph id="ph1">`Wait`</ph> in der Warteschlange verbleiben, bis sie ein Signal von empfangen <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, vom Besitzer der Sperre gesendet.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>If <ph id="ph1">`Pulse`</ph> is sent, only the thread at the head of the waiting queue is affected.</source>
          <target state="translated">Wenn <ph id="ph1">`Pulse`</ph> gesendet wird, wird nur der Thread am Anfang der Warteschlange für abzuarbeitende beeinflusst.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>If <ph id="ph1">`PulseAll`</ph> is sent, all threads that are waiting for the object are affected.</source>
          <target state="translated">Wenn <ph id="ph1">`PulseAll`</ph> gesendet wird, werden alle Threads, die für das Objekt warten beeinflusst.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</source>
          <target state="translated">Wenn das Signal empfangen wird, einen oder mehrere Threads die Warteschlange für abzuarbeitende lassen, und geben Sie die Warteschlange für abgearbeitete.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>A thread in the ready queue is permitted to reacquire the lock.</source>
          <target state="translated">Ein Thread in die Warteschlange für abgearbeitete ist zulässig, die Sperre erneut.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This method returns when the calling thread reacquires the lock on the object.</source>
          <target state="translated">Diese Methode gibt zurück, wenn der aufrufende Thread die Sperre für das Objekt erneut erhält.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Note that this method blocks indefinitely if the holder of the lock does not call <ph id="ph1">`Pulse`</ph> or <ph id="ph2">`PulseAll`</ph>.</source>
          <target state="translated">Beachten Sie, die diese Methode auf unbestimmte Zeit blockiert werden, wenn der Besitzer der Sperre nicht aufruft <ph id="ph1">`Pulse`</ph> oder <ph id="ph2">`PulseAll`</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">Der Aufrufer führt <ph id="ph1">`Wait`</ph> einmal, unabhängig davon, wie oft <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> wurde für das angegebene Objekt aufgerufen.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">`Enter`</ph> on the object and invokes <ph id="ph3">`Exit`</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Im Prinzip die <ph id="ph1">`Wait`</ph> Methode speichert die Anzahl der Aufrufe der Aufrufer <ph id="ph2">`Enter`</ph> für das Objekt und ruft <ph id="ph3">`Exit`</ph> so oft wie nötig, um das gesperrte Objekt vollständig freizugeben.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">Der Aufrufer blockiert dann beim Warten auf das Objekt erneut abzurufen.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">`Enter`</ph> as many times as necessary to restore the saved <ph id="ph2">`Enter`</ph> count for the caller.</source>
          <target state="translated">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <ph id="ph1">`Enter`</ph> so oft wie nötig, um die gespeicherte wiederherstellen <ph id="ph2">`Enter`</ph> Anzahl für den Aufrufer.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Aufrufen von <ph id="ph1">`Wait`</ph> hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, werden diese Sperren nicht aufgehoben.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange auf dem enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, und <ph id="ph3">`Wait`</ph> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">Die Hinweise für die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> Methode wird erläutert, was geschieht, wenn <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> wird aufgerufen, wenn keine Threads warten.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">Der Thread, der <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> aufruft, wird später im Wartezustand unterbrochen.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Dies geschieht, wenn ein anderer Thread die <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph>-Methode dieses Threads aufruft.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The object on which to wait.</source>
          <target state="translated">Das Objekt, auf das gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The number of milliseconds to wait before the thread enters the ready queue.</source>
          <target state="translated">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Diese Methode gibt keinen zurück, bis er auf die erneut eine exklusive Sperre erhält die <ph id="ph1">`obj`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freizugeben, sodass ein anderer Thread darauf zugreifen kann.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">Der Aufrufer ist blockiert, beim Warten auf die Sperre erneut abzurufen.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten, die als Ergebnis von einem anderen Thread ausgeführt werden muss.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">Das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">Er verschiebt auch den Thread in die Warteschlange für abgearbeitete Threads in der Warteschlange, damit er die Sperre früher zurückzuerhalten kann.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">Der Thread kann den Rückgabewert der Testen der <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die sie zur Eingabe des Wartevorgangs verursacht auswerten und, wenn notwendig Aufruf der <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> -Methode erneut.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.</source>
          <target state="translated">Wenn ein Thread aufruft, <ph id="ph1">`Wait`</ph>, hebt die Sperre für das Objekt ist, und wechselt in die Warteschlange für das Objekt auf.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</source>
          <target state="translated">Der nächste Thread in die Warteschlange für abgearbeitete des Objekts (sofern vorhanden) die Sperre erhält und bietet die exklusive Verwendung des Objekts.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">Der Thread, der aufgerufen <ph id="ph1">`Wait`</ph> aufruft, verbleibt in der Warteschlange, bis entweder ein Thread die Sperre <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, oder es das nächste in der Warteschlange ist und ein Thread die Sperre wird aufgerufen <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>However, if <ph id="ph1">`millisecondsTimeout`</ph> elapses before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Jedoch wenn <ph id="ph1">`millisecondsTimeout`</ph> verstreicht, bevor ein anderer Thread auf dieses Objekt aufruft <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> -Methode, den ursprünglichen Thread wird in die Warteschlange für abgearbeitete verschoben, um die Sperre erneut erhalten.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> is specified for the <ph id="ph2">`millisecondsTimeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> wird angegeben, für die <ph id="ph2">`millisecondsTimeout`</ph> Parameter, diese Methode blockiert dauerhaft, es sei denn, der Besitzer der Sperre aufruft <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Wenn <ph id="ph1">`millisecondsTimeout`</ph> gleich 0 ist, der aufrufende Thread <ph id="ph2">`Wait`</ph> hebt die Sperre und gelangt anschließend direkt in die Warteschlange für abgearbeitete um die Sperre erneut erhalten.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">Der Aufrufer führt <ph id="ph1">`Wait`</ph> einmal, unabhängig davon, wie oft <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> wurde für das angegebene Objekt aufgerufen.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Im Prinzip die <ph id="ph1">`Wait`</ph> Methode speichert die Anzahl der Aufrufe der Aufrufer <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> für das Objekt und ruft <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> so oft wie nötig, um das gesperrte Objekt vollständig freizugeben.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">Der Aufrufer blockiert dann beim Warten auf das Objekt erneut abzurufen.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> so oft wie nötig, um die gespeicherte wiederherstellen <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> Anzahl für den Aufrufer.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Aufrufen von <ph id="ph1">`Wait`</ph> hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, werden diese Sperren nicht aufgehoben.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange, die enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, und <ph id="ph3">`Wait`</ph> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">Die Hinweise für die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> Methode wird erläutert, was geschieht, wenn <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> wird aufgerufen, wenn keine Threads warten.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">Der Thread, der <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> aufruft, wird später im Wartezustand unterbrochen.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Dies geschieht, wenn ein anderer Thread die <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph>-Methode dieses Threads aufruft.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The value of the <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> parameter is negative, and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">Der Wert des <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph>-Parameters ist negativ und ungleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The object on which to wait.</source>
          <target state="translated">Das Objekt, auf das gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to wait before the thread enters the ready queue.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph>, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Diese Methode gibt keinen zurück, bis er auf die erneut eine exklusive Sperre erhält die <ph id="ph1">`obj`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freizugeben, sodass ein anderer Thread darauf zugreifen kann.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">Der Aufrufer ist blockiert, beim Warten auf die Sperre erneut abzurufen.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten, die als Ergebnis von einem anderen Thread ausgeführt werden muss.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">Das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">Er verschiebt auch den Thread in die Warteschlange für abgearbeitete Threads in der Warteschlange, damit er die Sperre früher zurückzuerhalten kann.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">Der Thread kann den Rückgabewert der Testen der <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die sie zur Eingabe des Wartevorgangs verursacht auswerten und, wenn notwendig Aufruf der <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> -Methode erneut.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.</source>
          <target state="translated">Wenn ein Thread aufruft, <ph id="ph1">`Wait`</ph>, hebt die Sperre für das Objekt ist, und wechselt in die Warteschlange für das Objekt auf.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</source>
          <target state="translated">Der nächste Thread in die Warteschlange für abgearbeitete des Objekts (sofern vorhanden) die Sperre erhält und bietet die exklusive Verwendung des Objekts.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">Der Thread, der aufgerufen <ph id="ph1">`Wait`</ph> aufruft, verbleibt in der Warteschlange, bis entweder ein Thread die Sperre <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, oder es das nächste in der Warteschlange ist und ein Thread die Sperre wird aufgerufen <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>However, if <ph id="ph1">`timeout`</ph> elapses before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Jedoch wenn <ph id="ph1">`timeout`</ph> verstreicht, bevor ein anderer Thread auf dieses Objekt aufruft <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> -Methode, den ursprünglichen Thread wird in die Warteschlange für abgearbeitete verschoben, um die Sperre erneut erhalten.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>If a <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> representing –1 millisecond is specified for the <ph id="ph2">`timeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Wenn eine <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> -1 Millisekunde angegeben ist, für die <ph id="ph2">`timeout`</ph> Parameter, diese Methode blockiert dauerhaft, es sei denn, der Besitzer der Sperre aufruft <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 milliseconds, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Wenn <ph id="ph1">`timeout`</ph> ist 0 Millisekunden, der aufrufende Thread <ph id="ph2">`Wait`</ph> hebt die Sperre und gelangt anschließend direkt in die Warteschlange für abgearbeitete um die Sperre erneut erhalten.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">Der Aufrufer führt <ph id="ph1">`Wait`</ph> einmal, unabhängig davon, wie oft <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> wurde für das angegebene Objekt aufgerufen.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Im Prinzip die <ph id="ph1">`Wait`</ph> Methode speichert die Anzahl der Aufrufe der Aufrufer <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> für das Objekt und ruft <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> so oft wie nötig, um das gesperrte Objekt vollständig freizugeben.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">Der Aufrufer blockiert dann beim Warten auf das Objekt erneut abzurufen.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> so oft wie nötig, um die gespeicherte wiederherstellen <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> Anzahl für den Aufrufer.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Aufrufen von <ph id="ph1">`Wait`</ph> hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, werden diese Sperren nicht aufgehoben.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange, die enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, und <ph id="ph3">`Wait`</ph> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">Die Hinweise für die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> Methode wird erläutert, was geschieht, wenn <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> wird aufgerufen, wenn keine Threads warten.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">Der Thread, der <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> aufruft, wird später im Wartezustand unterbrochen.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Dies geschieht, wenn ein anderer Thread die <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph>-Methode dieses Threads aufruft.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The value of the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter in milliseconds is negative and does not represent <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Der Wert des <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph>-Parameters in Millisekunden ist negativ und stellt nicht <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1 Millisekunde) dar, oder er ist größer als <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The object on which to wait.</source>
          <target state="translated">Das Objekt, auf das gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The number of milliseconds to wait before the thread enters the ready queue.</source>
          <target state="translated">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</source>
          <target state="translated">Diese Methode gibt außerdem an, ob die Synchronisierungsdomäne danach für den Kontext (wenn es sich um einen synchronisierten Kontext handelt) vor dem Warten und erneuten Erhalten verlassen wird.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Diese Methode gibt keinen zurück, bis er auf die erneut eine exklusive Sperre erhält die <ph id="ph1">`obj`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freizugeben, sodass ein anderer Thread darauf zugreifen kann.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">Der Aufrufer ist blockiert, beim Warten auf die Sperre erneut abzurufen.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten, die als Ergebnis von einem anderen Thread ausgeführt werden muss.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">Das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">Er verschiebt auch den Thread in die Warteschlange für abgearbeitete Threads in der Warteschlange, damit er die Sperre früher zurückzuerhalten kann.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">Der Thread kann den Rückgabewert der Testen der <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die sie zur Eingabe des Wartevorgangs verursacht auswerten und, wenn notwendig Aufruf der <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> -Methode erneut.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock and enters the waiting queue.</source>
          <target state="translated">Wenn ein Thread aufruft, <ph id="ph1">`Wait`</ph>, er hebt die Sperre und die Warteschlange für abzuarbeitende eingibt.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</source>
          <target state="translated">An diesem Punkt der nächste Thread in die Warteschlange für abgearbeitete (sofern vorhanden) kann die Steuerung der Sperre.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">Der Thread, der aufgerufen <ph id="ph1">`Wait`</ph> aufruft, verbleibt in der Warteschlange, bis entweder ein Thread die Sperre <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, oder es das nächste in der Warteschlange ist und ein Thread die Sperre wird aufgerufen <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>However, if <ph id="ph1">`millisecondsTimeout`</ph> elapses before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Jedoch wenn <ph id="ph1">`millisecondsTimeout`</ph> verstreicht, bevor ein anderer Thread auf dieses Objekt aufruft <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> -Methode, den ursprünglichen Thread wird in die Warteschlange für abgearbeitete verschoben, um die Sperre erneut erhalten.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> is specified for the <ph id="ph2">`millisecondsTimeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> wird angegeben, für die <ph id="ph2">`millisecondsTimeout`</ph> Parameter, diese Methode blockiert dauerhaft, es sei denn, der Besitzer der Sperre aufruft <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Wenn <ph id="ph1">`millisecondsTimeout`</ph> gleich 0 ist, der aufrufende Thread <ph id="ph2">`Wait`</ph> hebt die Sperre und gelangt anschließend direkt in die Warteschlange für abgearbeitete um die Sperre erneut erhalten.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">Der Aufrufer führt <ph id="ph1">`Wait`</ph> einmal, unabhängig davon, wie oft <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> wurde für das angegebene Objekt aufgerufen.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Im Prinzip die <ph id="ph1">`Wait`</ph> Methode speichert die Anzahl der Aufrufe der Aufrufer <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> für das Objekt und ruft <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> so oft wie nötig, um das gesperrte Objekt vollständig freizugeben.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">Der Aufrufer blockiert dann beim Warten auf das Objekt erneut abzurufen.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> so oft wie nötig, um die gespeicherte wiederherstellen <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> Anzahl für den Aufrufer.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Aufrufen von <ph id="ph1">`Wait`</ph> hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, werden diese Sperren nicht aufgehoben.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange, die enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, und <ph id="ph3">`Wait`</ph> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">Die Hinweise für die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> Methode wird erläutert, was geschieht, wenn <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> wird aufgerufen, wenn keine Threads warten.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Hinweise zum Beenden des Kontexts</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The<ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Die<ph id="ph1">`exitContext`</ph> Parameter hat keine Auswirkungen, es sei denn, die <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Even if you are currently executing a method on a class that is not derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, z. B. <ph id="ph2">&lt;xref:System.String&gt;</ph>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method.</source>
          <target state="translated">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe <ph id="ph1">`true`</ph> für <ph id="ph2">`exitContext`</ph> bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>It returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method completes.</source>
          <target state="translated">Es gibt in den ursprünglich nicht standardmäßige nach dem Aufruf von der <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode abgeschlossen wird.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This can be useful when the context-bound class has the <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribute applied.</source>
          <target state="translated">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über die <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> Attribut angewendet.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Wenn Code in der Aufrufliste eines Members Ruft die <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode und gibt an, <ph id="ph2">`true`</ph> für <ph id="ph3">`exitContext`</ph>, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is not invoked from within a synchronized block of code.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> wird nicht aus einem synchronisierten Codeblock aufgerufen.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">Der Thread, der <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> aufruft, wird später im Wartezustand unterbrochen.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Dies geschieht, wenn ein anderer Thread die <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph>-Methode dieses Threads aufruft.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The value of the <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> parameter is negative, and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">Der Wert des <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph>-Parameters ist negativ und ungleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The object on which to wait.</source>
          <target state="translated">Das Objekt, auf das gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to wait before the thread enters the ready queue.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph>, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</source>
          <target state="translated">Beendet vor dem Warten optional auch die Synchronisierungsdomäne für den synchronisierten Kontext und erhält die Domäne anschließend wieder.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Diese Methode gibt keinen zurück, bis er auf die erneut eine exklusive Sperre erhält die <ph id="ph1">`obj`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freizugeben, sodass ein anderer Thread darauf zugreifen kann.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">Der Aufrufer ist blockiert, beim Warten auf die Sperre erneut abzurufen.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten, die als Ergebnis von einem anderen Thread ausgeführt werden muss.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">Das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">Er verschiebt auch den Thread in die Warteschlange für abgearbeitete Threads in der Warteschlange, damit er die Sperre früher zurückzuerhalten kann.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">Der Thread kann den Rückgabewert der Testen der <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die sie zur Eingabe des Wartevorgangs verursacht auswerten und, wenn notwendig Aufruf der <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> -Methode erneut.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock and enters the waiting queue.</source>
          <target state="translated">Wenn ein Thread aufruft, <ph id="ph1">`Wait`</ph>, er hebt die Sperre und die Warteschlange für abzuarbeitende eingibt.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</source>
          <target state="translated">An diesem Punkt der nächste Thread in die Warteschlange für abgearbeitete (sofern vorhanden) kann die Steuerung der Sperre.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">Der Thread, der aufgerufen <ph id="ph1">`Wait`</ph> aufruft, verbleibt in der Warteschlange, bis entweder ein Thread die Sperre <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, oder es das nächste in der Warteschlange ist und ein Thread die Sperre wird aufgerufen <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>However, if <ph id="ph1">`timeout`</ph> milliseconds elapse before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Jedoch wenn <ph id="ph1">`timeout`</ph> Millisekunden verstreichen, bevor ein anderer Thread auf dieses Objekt aufruft <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> -Methode, den ursprünglichen Thread wird in die Warteschlange für abgearbeitete verschoben, um die Sperre erneut erhalten.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If a <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> representing -1 millisecond is specified for the <ph id="ph2">`timeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Wenn eine <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> -1 Millisekunde angegeben ist, für die <ph id="ph2">`timeout`</ph> Parameter, diese Methode blockiert dauerhaft, es sei denn, der Besitzer der Sperre aufruft <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> oder <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 milliseconds, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Wenn <ph id="ph1">`timeout`</ph> ist 0 Millisekunden, der aufrufende Thread <ph id="ph2">`Wait`</ph> hebt die Sperre und gelangt anschließend direkt in die Warteschlange für abgearbeitete um die Sperre erneut erhalten.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">Der Aufrufer führt <ph id="ph1">`Wait`</ph> einmal, unabhängig davon, wie oft <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> wurde für das angegebene Objekt aufgerufen.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Im Prinzip die <ph id="ph1">`Wait`</ph> Methode speichert die Anzahl der Aufrufe der Aufrufer <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> für das Objekt und ruft <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> so oft wie nötig, um das gesperrte Objekt vollständig freizugeben.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">Der Aufrufer blockiert dann beim Warten auf das Objekt erneut abzurufen.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> so oft wie nötig, um die gespeicherte wiederherstellen <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> Anzahl für den Aufrufer.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Aufrufen von <ph id="ph1">`Wait`</ph> hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, werden diese Sperren nicht aufgehoben.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange, die enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, und <ph id="ph3">`Wait`</ph> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">Die Hinweise für die <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> Methode wird erläutert, was geschieht, wenn <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> wird aufgerufen, wenn keine Threads warten.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Hinweise zum Beenden des Kontexts</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The<ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Die<ph id="ph1">`exitContext`</ph> Parameter hat keine Auswirkungen, es sei denn, die <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Even if you are currently executing a method on a class that is not derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, z. B. <ph id="ph2">&lt;xref:System.String&gt;</ph>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method.</source>
          <target state="translated">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe <ph id="ph1">`true`</ph> für <ph id="ph2">`exitContext`</ph> bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>It returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method completes.</source>
          <target state="translated">Es gibt in den ursprünglich nicht standardmäßige nach dem Aufruf von der <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode abgeschlossen wird.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This can be useful when the context-bound class has the <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribute applied.</source>
          <target state="translated">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über die <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> Attribut angewendet.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Wenn Code in der Aufrufliste eines Members Ruft die <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode und gibt an, <ph id="ph2">`true`</ph> für <ph id="ph3">`exitContext`</ph>, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is not invoked from within a synchronized block of code.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> wird nicht aus einem synchronisierten Codeblock aufgerufen.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread that invokes Wait is later interrupted from the waiting state.</source>
          <target state="translated">Der Thread, der „Wait“ aufruft, wird später im Wartezustand unterbrochen.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Dies geschieht, wenn ein anderer Thread die <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph>-Methode dieses Threads aufruft.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is negative and does not represent <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph>-Parameter ist negativ und stellt nicht <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> dar (-1 Millisekunde), oder er ist größer als <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>