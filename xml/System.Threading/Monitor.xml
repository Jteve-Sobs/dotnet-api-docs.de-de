<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d58d6a0efb68c5aa8f86e7ce2a4724830e2b18b9" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82309612" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <TypeSignature Language="C#" Value="public sealed class Monitor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Monitor extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Monitor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor sealed" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Mechanismus bereit, der den Zugriff auf Objekte synchronisiert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Monitor>-Klasse ermöglicht es Ihnen, den Zugriff auf einen Code Bereich zu synchronisieren, indem Sie eine Sperre für ein bestimmtes-Objekt durch Aufrufen der Methoden <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>und <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> aufrufen und freigeben. Objekt Sperren bieten die Möglichkeit, den Zugriff auf einen Codeblock einzuschränken, der in der Regel als kritischer Abschnitt bezeichnet wird. Während ein Thread die Sperre für ein Objekt besitzt, kann kein anderer Thread diese Sperre erwerben. Sie können auch die <xref:System.Threading.Monitor>-Klasse verwenden, um sicherzustellen, dass kein anderer Thread auf einen Abschnitt von Anwendungscode zugreifen darf, der vom Sperrenbesitzer ausgeführt wird, es sei denn, der andere Thread führt den Code mit einem anderen gesperrten Objekt aus.  
  
 Inhalt dieses Artikels:  
  
 [Die Monitor-Klasse: eine Übersicht](#Overview)   
 [Das Sperr Objekt](#Lock)   
 [Der kritische Abschnitt](#CriticalSection)   
 [Pulse, pulall und Wait](#Pulse)   
 [Monitore und Wait-Handles](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Die Monitor-Klasse: eine Übersicht  
 <xref:System.Threading.Monitor> verfügt über die folgenden Features:  
  
-   Sie ist einem Objekt bei Bedarf zugeordnet.  
  
-   Die Bindung ist aufgehoben, d. h., Sie kann direkt aus jedem beliebigen Kontext aufgerufen werden.  
  
-   Eine Instanz der <xref:System.Threading.Monitor> Klasse kann nicht erstellt werden. die Methoden der <xref:System.Threading.Monitor>-Klasse sind alle statisch. Jeder Methode wird das synchronisierte Objekt, das den Zugriff auf den kritischen Abschnitt steuert, weitergegeben.  
  
> [!NOTE]
>  Verwenden Sie die <xref:System.Threading.Monitor>-Klasse, um andere Objekte als Zeichen folgen (d. h. andere Verweis Typen als <xref:System.String>) und keine Werttypen zu sperren. Weitere Informationen finden Sie im Abschnitt über Ladungen der <xref:System.Threading.Monitor.Enter%2A>-Methode und [des Sperr Objekts](#Lock) weiter unten in diesem Artikel.  
  
 In der folgenden Tabelle werden die Aktionen beschrieben, die von Threads durchgeführt werden können, die auf Synchronisierte Objekte zugreifen:  
  
|Action|BESCHREIBUNG|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|Ruft eine Sperre für ein Objekt ab. Diese Aktion markiert auch den Anfang eines kritischen Abschnitts. Es kann kein anderer Thread in den kritischen Abschnitt eintreten, es sei denn, er führt die Anweisungen im kritischen Abschnitt mithilfe eines anderen gesperrten Objekts aus.|  
|<xref:System.Threading.Monitor.Wait%2A>|Gibt die Sperre für ein Objekt frei, um anderen Threads das Sperren und Zugreifen auf das Objekt zu gestatten. Der aufrufenden Thread wartet, während ein anderer Thread auf das Objekt zugreift. Impuls Signale werden verwendet, um wartende Threads über Änderungen am Zustand eines Objekts zu benachrichtigen.|  
|<xref:System.Threading.Monitor.Pulse%2A> (Signal), <xref:System.Threading.Monitor.PulseAll%2A>|Sendet ein Signal an einen oder mehrere wartende Threads. Das Signal benachrichtigt einen wartenden Thread, dass sich der Zustand des gesperrten Objekts geändert hat, und der Besitzer der Sperre ist bereit, die Sperre freizugeben. Der wartende Thread wird in die bereite Warteschlange des Objekts eingefügt, sodass er möglicherweise die Sperre für das Objekt erhält. Sobald der Thread über die Sperre verfügt, kann er den neuen Status des Objekts überprüfen, um festzustellen, ob der erforderliche Zustand erreicht wurde.|  
|<xref:System.Threading.Monitor.Exit%2A>|Gibt die Sperre für ein Objekt frei. Diese Aktion markiert auch das Ende eines kritischen Abschnitts, der durch das gesperrte-Objekt geschützt wird.|  
  
 Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]gibt es zwei Sätze von über Ladungen für die Methoden <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.TryEnter%2A>. Ein Satz von über Ladungen verfügt über einen `ref` ( C#in) oder `ByRef` (in Visual Basic) <xref:System.Boolean> Parameter, der atomisch auf `true` festgelegt ist, wenn die Sperre abgerufen wird, selbst wenn beim Abrufen der Sperre eine Ausnahme ausgelöst wird. Verwenden Sie diese über Ladungen, wenn es wichtig ist, die Sperre in allen Fällen aufzuheben, auch wenn sich die Ressourcen, die von der Sperre geschützt werden, möglicherweise nicht in einem konsistenten Zustand befinden.  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>Das Sperr Objekt  
 Die Monitor-Klasse besteht aus `static` ( C#in) oder `Shared` (in Visual Basic)-Methoden, die auf ein Objekt angewendet werden, das den Zugriff auf den kritischen Abschnitt steuert.  Die folgenden Informationen werden für jedes synchronisierte Objekt verwaltet:  
  
-   Ein Verweis auf den Thread, der die Sperre zurzeit enthält.  
  
-   Ein Verweis auf eine bereite Warteschlange, die die Threads enthält, die zum Abrufen der Sperre bereit sind.  
  
-   Ein Verweis auf eine Warteschlange, die die Threads enthält, die auf eine Änderung des Status des gesperrten Objekts warten.  
  
 <xref:System.Threading.Monitor> sperrt Objekte (d. h. Referenztypen), nicht Werttypen. Sie können einen Werttyp an <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> übergeben. Dieser wird jedoch für jeden Aufruf separat geschachtelt. Da jeder Aufruf ein separates Objekt erstellt, bedingt <xref:System.Threading.Monitor.Enter%2A> nie eine Blockierung, und der Code, den die Methode eigentlich schützen soll, wird nicht wirklich synchronisiert. Darüber hinaus unterscheiden sich das an <xref:System.Threading.Monitor.Exit%2A> und das an <xref:System.Threading.Monitor.Enter%2A> übergebene Objekt, sodass <xref:System.Threading.Monitor> eine <xref:System.Threading.SynchronizationLockException> mit der folgenden Meldung auslöst: „Die Objektsynchronisierungsmethode wurde von einem nicht synchronisierten Codeblock aufgerufen.“  
  
 Dieses Problem wird anhand des folgenden Beispiels veranschaulicht. Im Beispiel werden zehn Aufgaben gestartet, wobei jede lediglich 250 Millisekunden inaktiv ist. Anschließend aktualisiert jede Aufgabe eine Zählervariable, `nTasks`, die dazu vorgesehen ist, die Anzahl von Aufgaben zu zählen, die tatsächlich gestartet wurden und ausgeführt werden. Weil `nTasks` eine globale Variable ist, die von mehreren Aufgaben gleichzeitig aktualisiert werden kann, wird ein Monitor verwendet, um zu verhindern, dass die Variable gleichzeitig von mehreren Aufgaben geändert wird. Wie die Ausgabe des Beispiels zeigt, löst jede dieser Aufgaben jedoch eine <xref:System.Threading.SynchronizationLockException>-Ausnahme aus.  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 Jede Aufgabe löst eine <xref:System.Threading.SynchronizationLockException>-Ausnahme aus, weil die Variable `nTasks` gekapselt wird, bevor in jeder Aufgabe die <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>-Methode aufgerufen wird. Anders formuliert heißt das, bei jedem Methodenaufruf wird eine separate Variable übergeben, die unabhängig von den anderen ist. `nTasks` wird im Aufruf der <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>-Methode erneut gekapselt. Dadurch werden wiederum zehn neue gekapselte `nTasks`-Variablen erstellt, die unabhängig voneinander sind. Hinzu kommen die zehn gekapselten Variablen, die im Aufruf der <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>-Methode erstellt wurden. Die Ausnahme wird dann ausgelöst, weil im Code versucht wird, eine Sperre für eine neu erstellte Variable freizugeben, die zuvor nicht gesperrt wurde.  
  
 Wie das folgende Beispiel zeigt, können Sie eine Werttypvariable zwar vor dem Aufruf von <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> kapseln und dasselbe gekapselte Objekt an beide Methoden übergeben, diese Vorgehensweise bietet jedoch keinerlei Vorteile. Änderungen an der nicht gekapselten Variablen wirken sich nicht auf die gekapselte Kopie aus, und es ist nicht möglich, den Wert der gekapselten Kopie zu ändern.  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 Wenn Sie ein Objekt auswählen, das synchronisiert werden soll, sollten Sie nur private oder interne Objekte sperren. Sperren für externe Objekte können zu Deadlocks führen, da nicht verknüpften Code die gleichen Objekte auswählen kann, die für unterschiedliche Zwecke gesperrt werden sollen.  
  
 Beachten Sie, dass Sie ein Objekt in mehreren Anwendungs Domänen synchronisieren können, wenn das für die Sperre verwendete Objekt von <xref:System.MarshalByRefObject>abgeleitet ist.  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>Kritischer Abschnitt  
 Verwenden Sie die Methoden <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A>, um den Anfang und das Ende eines kritischen Abschnitts zu markieren.  
  
> [!NOTE]
>  Die Funktionen der Methoden <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> sind identisch mit denen, die von der [Lock](~/docs/csharp/language-reference/keywords/lock-statement.md) -Anweisung in C# und der [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) -Anweisung in Visual Basic bereitgestellt werden, mit dem Unterschied, dass die Sprachkonstrukte die <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> Methoden Überladung und die <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>-Methode in einer `try`... einschließen`finally` blockieren, um sicherzustellen, dass der Monitor freigegeben wird.  
  
 Wenn der kritische Abschnitt aus einer Reihe von zusammenhängenden Anweisungen besteht, gewährleistet die durch die <xref:System.Threading.Monitor.Enter%2A>-Methode erworbene Sperre, dass nur ein einzelner Thread den eingeschlossenen Code mit dem gesperrten Objekt ausführen kann. In diesem Fall wird empfohlen, dass Sie diesen Code in einem `try` Block platzieren und den aufzurufenden <xref:System.Threading.Monitor.Exit%2A> Methode in einem `finally`-Block platzieren. Dadurch ist sichergestellt, dass die Sperre aufgehoben wird, selbst wenn eine Ausnahme auftritt. Dieses Muster wird im folgenden Code Fragment veranschaulicht.  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 Diese Funktion wird normalerweise verwendet, um den Zugriff auf eine statische Methode oder Instanzmethode einer Klasse zu synchronisieren.  
  
 Wenn ein kritischer Abschnitt eine gesamte Methode umfasst, kann die Sperre erreicht werden, indem die <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> der Methode platziert und der <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> Wert im Konstruktor von <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>angegeben wird. Wenn Sie dieses Attribut verwenden, werden die Methodenaufrufe <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> nicht benötigt. Dieses Muster wird im folgenden Code Fragment veranschaulicht:  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 Beachten Sie, dass das-Attribut bewirkt, dass der aktuelle Thread die Sperre aufrecht hat, bis die Methode zurückgibt. Wenn die Sperre früher freigegeben werden kann, verwenden Sie die <xref:System.Threading.Monitor>- C# Klasse, die [Lock](~/docs/csharp/language-reference/keywords/lock-statement.md) -Anweisung oder die Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) -Anweisung innerhalb der-Methode anstelle des-Attributs.  
  
 Obwohl es möglich ist, dass die Anweisungen <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> ein bestimmtes Objekt für übergreifende Member-oder Klassengrenzen oder beides Sperren und freigeben, wird diese Vorgehensweise nicht empfohlen.  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Pulse, pulall und Wait  
 Sobald ein Thread die Sperre besitzt und den kritischen Abschnitt eingegeben hat, den die Sperre schützt, kann er die Methoden <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>und <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> abrufen.  
  
 Wenn der Thread, der die Sperre enthält, <xref:System.Threading.Monitor.Wait%2A>aufruft, wird die Sperre freigegeben, und der Thread wird der Warteschlange für das synchronisierte Objekt hinzugefügt. Der erste Thread in der Warteschlange, sofern vorhanden, erhält die Sperre und wechselt in den kritischen Abschnitt. Der Thread, der <xref:System.Threading.Monitor.Wait%2A> aufgerufen hat, wird von der Warteschlange in die Warteschlange verschoben, wenn entweder der <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> oder die <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>-Methode von dem Thread aufgerufen wird, der die Sperre besitzt (zu verschieben, muss sich der Thread an der Spitze der Warteschlange befinden). Die <xref:System.Threading.Monitor.Wait%2A>-Methode gibt zurück, wenn der aufrufenden Thread die Sperre erneut erhält.  
  
 Wenn der Thread, der die Sperre enthält, <xref:System.Threading.Monitor.Pulse%2A>aufruft, wird der Thread am Anfang der Warteschlange in die bereite Warteschlange verschoben. Beim Abrufen der <xref:System.Threading.Monitor.PulseAll%2A>-Methode werden alle Threads aus der Warteschlange in die bereite Warteschlange verschoben.  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>Monitore und Wait-Handles  
 Es ist wichtig, den Unterschied zwischen der Verwendung der <xref:System.Threading.Monitor> Klasse und <xref:System.Threading.WaitHandle> Objekten zu beachten.  
  
-   Die <xref:System.Threading.Monitor>-Klasse ist rein verwaltet, vollständig portabel und im Hinblick auf Betriebssystem-Ressourcenanforderungen effizienter.  
  
-   <xref:System.Threading.WaitHandle>-Objekte repräsentieren Objekte des Betriebssystems, die in der Lage sind, ihre Ausführung zu unterbrechen und zu warten. Sie sind für die Synchronisierung zwischen verwaltetem und nicht verwaltetem Code von Nutzen und machen einige höhere Betriebssystemfunktionen verfügbar, z. B. die Fähigkeit, auf viele Objekte gleichzeitig zu warten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Monitor>-Klasse verwendet, um den Zugriff auf eine einzelne Instanz eines Zufallszahlengenerators zu synchronisieren, der durch die <xref:System.Random>-Klasse dargestellt wird. Im Beispiel werden zehn Aufgaben erstellt, von denen jede asynchron in einem Thread Pool Thread ausgeführt wird. Jede Aufgabe generiert 10.000 Zufallszahlen, berechnet ihren Durchschnitt und aktualisiert zwei Variablen auf Prozedur Ebene, die eine laufende Gesamtzahl der generierten Zufallszahlen und deren Summe beibehalten. Nachdem alle Tasks ausgeführt wurden, werden diese beiden Werte verwendet, um den allgemeinen Mittelwert zu berechnen.  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 Da auf Sie von jeder Aufgabe aus zugegriffen werden kann, die in einem Thread Pool Thread ausgeführt wird, muss der Zugriff auf die Variablen `total` und `n` ebenfalls synchronisiert werden. Zu diesem Zweck wird die <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType>-Methode verwendet.  
  
 Im folgenden Beispiel wird die kombinierte Verwendung der <xref:System.Threading.Monitor>-Klasse (implementiert mit dem-`lock` oder `SyncLock`-Sprachkonstrukt), der <xref:System.Threading.Interlocked>-Klasse und der <xref:System.Threading.AutoResetEvent>-Klasse veranschaulicht. Im Beispiel werden zwei `internal`- (in C#) oder `Friend`-Klassen (in Visual Basic), `SyncResource` und `UnSyncResource`, definiert, die entsprechend synchronisierten und nicht synchronisierten Zugriff auf eine Ressource bereitstellen. Damit sichergestellt ist, dass der Unterschied zwischen dem synchronisierten und dem nicht synchronisierten Zugriff im Beispiel deutlich wird (was der Fall sein kann, wenn jeder Methodenaufruf schnell abgeschlossen wird), enthält die Methode eine zufällige Verzögerung: Für Threads, deren <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>-Eigenschaft einen geraden Wert hat, ruft die Methode die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode auf, um eine Verzögerung von 2.000 Millisekunden einzuführen. Weil die `SyncResource`-Klasse nicht öffentlich ist, löst keiner der Clientcodes eine Sperre für die synchronisierte Ressource aus, sondern die Sperre wird von der internen Klasse selbst ausgelöst. Dadurch wird verhindert, dass bösartiger Code eine Sperre für ein öffentliches Objekt auslöst.  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 Im Beispiel wird eine Variable, `numOps`, definiert, mit der die Anzahl von Threads festgelegt wird, die versuchen, auf die Ressource zuzugreifen. Der Anwendungsthread ruft die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType>-Methode jeweils fünf Mal für synchronisierten und nicht synchronisierten Zugriff auf. Die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType>-Methode hat einen einzigen Parameter: ein Delegat, der keine Parameter akzeptiert und keinen Wert zurückgibt. Für synchronisierten Zugriff und ruft die Methode die `SyncUpdateResource`Methode auf, für nicht synchronisierten Zugriff ruft sie die `UnSyncUpdateResource`-Methode auf. Nach jedem Satz von Methoden aufrufen ruft der Anwendungs Thread die [AutoResetEvent. WaitOne](xref:System.Threading.WaitHandle.WaitOne*) -Methode auf, sodass er blockiert wird, bis die <xref:System.Threading.AutoResetEvent> Instanz signalisiert wird.  
  
 Bei jedem Aufruf der `SyncUpdateResource`-Methode wird die interne `SyncResource.Access`-Methode und dann die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>-Methode aufgerufen, um den `numOps`-Zähler zu dekrementieren. Die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>-Methode wird verwendet, um den Leistungsdaten Wert zu verringern, da Sie andernfalls nicht sicher sein können, dass ein zweiter Thread auf den Wert zugreift, bevor der dekrementierte Wert des ersten Threads in der Variablen gespeichert wurde. Wenn der letzte synchronisierte Arbeits Thread den Wert auf 0 (null) verringert, um anzugeben, dass alle synchronisierten Threads den Zugriff auf die Ressource abgeschlossen haben, ruft die `SyncUpdateResource`-Methode die <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>-Methode auf, die den Haupt Thread signalisiert, die Ausführung fortzusetzen.  
  
 Bei jedem Aufruf der `UnSyncUpdateResource`-Methode wird die interne `UnSyncResource.Access`-Methode und dann die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>-Methode aufgerufen, um den `numOps`-Zähler zu dekrementieren. Die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>-Methode wird verwendet, um den Leistungswert zu verringern, um sicherzustellen, dass ein zweiter Thread nicht auf den Wert zugreift, bevor der Variablen der Wert eines ersten Threads zugewiesen wurde. Wenn der letzte nicht synchronisierte Arbeits Thread den Wert auf NULL Dekremente und angibt, dass keine nicht synchronisierten Threads auf die Ressource zugreifen müssen, ruft die `UnSyncUpdateResource`-Methode die <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>-Methode auf, die dem Haupt Thread signalisiert, die Ausführung fortzusetzen.  
  
 Wie die Ausgabe des Beispiels zeigt, wird mit synchronisiertem Zugriff sichergestellt, dass der aufrufende Thread die geschützte Ressource beendet, bevor ein anderer Thread auf sie zugreifen kann. Jeder Thread wartet auf seinen Vorgänger. Andererseits, ohne die Sperre, wird die `UnSyncResource.Access`-Methode in der Reihenfolge aufgerufen, in der sie von Threads erreicht wird.  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">Threadingobjekte und -funktionen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erhält eine exklusive Sperre für ein angegebenes Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Monitorsperre erhalten werden soll.</param>
        <summary>Erhält eine exklusive Sperre für das angegebene Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie `Enter`, um den <xref:System.Threading.Monitor> für das Objekt abzurufen, das als-Parameter übergeben wird. Wenn ein anderer Thread eine `Enter` für das Objekt ausgeführt hat, aber noch nicht die entsprechende <xref:System.Threading.Monitor.Exit%2A>ausgeführt hat, wird der aktuelle Thread blockiert, bis der andere Thread das Objekt freigibt. Es ist für denselben Thread zulässig, `Enter` mehrmals aufzurufen, ohne dass er blockiert wird. Es muss jedoch eine gleichmäßige Anzahl von `Exit` aufrufen aufgerufen werden, bevor andere Threads, die auf das Objekt warten, die Blockierung blockieren.  
  
 Verwenden Sie <xref:System.Threading.Monitor>, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren. Wenn Sie eine Werttyp Variable an `Enter`übergeben, wird Sie als Objekt gekapselt. Wenn Sie dieselbe Variable erneut an `Enter` übergeben, wird Sie als separates Objekt gekapselt, und der Thread wird nicht blockiert. In diesem Fall ist der Code, den `Monitor` angeblich schützt, nicht geschützt. Wenn Sie die Variable an `Exit`übergeben, wird weiterhin ein anderes separates Objekt erstellt. Da sich das an `Exit` über gegebene Objekt von dem Objekt unterscheidet, das an `Enter`übermittelt wird, löst `Monitor` <xref:System.Threading.SynchronizationLockException>aus. Weitere Informationen finden Sie im Thema über [Wachen](xref:System.Threading.Monitor)von konzeptionellen Themen.  
  
 <xref:System.Threading.Thread.Interrupt%2A> können Threads unterbrechen, die auf die Eingabe einer `Monitor` für ein Objekt warten. Eine <xref:System.Threading.ThreadInterruptedException> wird ausgelöst.  
  
 C# `try``finally` verwenden... Block (`Try`...`Finally` in Visual Basic), um sicherzustellen, dass Sie den Monitor freigeben, C# oder verwenden Sie die `lock`-Anweisung (`SyncLock`-Anweisung in Visual Basic), die die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methoden in einer `try`...`finally` Baustein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Enter`-Methode veranschaulicht.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <param name="lockTaken">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.  
  
Hinweis   Wenn keine Ausnahme auftritt, ist die Ausgabe dieser Methode immer <see langword="true" />.</param>
        <summary>Erhält eine exklusive Sperre für das angegebene Objekt und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie `Enter`, um den <xref:System.Threading.Monitor> für das Objekt abzurufen, das als `obj`-Parameter übergeben wird. Wenn ein anderer Thread eine `Enter` für das Objekt ausgeführt hat, aber noch nicht die entsprechende <xref:System.Threading.Monitor.Exit%2A>ausgeführt hat, wird der aktuelle Thread blockiert, bis der andere Thread das Objekt freigibt. Es ist für denselben Thread zulässig, `Enter` mehrmals aufzurufen, ohne dass er blockiert wird. Es muss jedoch eine gleichmäßige Anzahl von `Exit` aufrufen aufgerufen werden, bevor andere Threads, die auf das Objekt warten, die Blockierung blockieren.  
  
 Wenn die Sperre nicht übernommen wurde, weil eine Ausnahme ausgelöst wurde, wird die für den `lockTaken`-Parameter angegebene Variable `false`, nachdem diese Methode beendet wurde. Dadurch kann das Programm in allen Fällen ermitteln, ob es erforderlich ist, die Sperre freizugeben. Wenn diese Methode zurückgegeben wird, ohne eine Ausnahme auszulösen, wird die für den `lockTaken`-Parameter angegebene Variable immer `true`, und es ist nicht erforderlich, Sie zu testen.  
  
 Verwenden Sie <xref:System.Threading.Monitor>, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren. Wenn Sie eine Werttyp Variable an `Enter`übergeben, wird Sie als Objekt gekapselt. Wenn Sie dieselbe Variable erneut an `Enter` übergeben, wird Sie als separates Objekt gekapselt, und der Thread wird nicht blockiert. In diesem Fall ist der Code, den `Monitor` angeblich schützt, nicht geschützt. Wenn Sie die Variable außerdem an `Exit`übergeben, wird ein anderes separates Objekt erstellt. Da sich das an `Exit` über gegebene Objekt von dem Objekt unterscheidet, das an `Enter`übermittelt wird, löst `Monitor` <xref:System.Threading.SynchronizationLockException>aus. Weitere Informationen finden Sie im Thema über [Wachen](xref:System.Threading.Monitor)von konzeptionellen Themen.  
  
 <xref:System.Threading.Thread.Interrupt%2A> können Threads unterbrechen, die auf die Eingabe einer `Monitor` für ein Objekt warten. Eine <xref:System.Threading.ThreadInterruptedException> wird ausgelöst.  
  
   
  
## Examples  
 Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>-Methoden Überladung. Diese Überladung legt immer den Wert der Variablen fest, die an den `ref`-Parameter übergeben wird (`ByRef` in Visual Basic) `lockTaken`, auch wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Methode ist, um zu testen, ob die Sperre freigegeben werden muss.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, dessen Sperre aufgehoben werden soll.</param>
        <summary>Hebt eine exklusive Sperre für das angegebene Objekt auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der aufrufenden Thread muss die Sperre für den `obj`-Parameter besitzen. Wenn der aufrufende Thread die Sperre für das angegebene Objekt besitzt und eine gleiche Anzahl von `Exit` und <xref:System.Threading.Monitor.Enter%2A> Aufrufe für das Objekt vorgenommen hat, wird die Sperre freigegeben. Wenn der aufrufende Thread nicht `Exit` so oft wie `Enter`aufgerufen wurde, wird die Sperre nicht freigegeben.  
  
 Wenn die Sperre aufgehoben wird und sich andere Threads in der Warteschlange für das Objekt befinden, erhält einer der Threads die Sperre. Wenn sich andere Threads in der Warteschlange befinden, die darauf warten, die Sperre abzurufen, werden Sie nicht automatisch in die Warteschlange "Ready" verschoben, wenn der Besitzer der Sperre `Exit`aufruft. Um einen oder mehrere wartende Threads in die bereite Warteschlange zu verschieben, rufen Sie <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> auf, bevor Sie `Exit`aufrufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Exit`-Methode veranschaulicht.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aktuelle Thread besitzt die Sperre für das angegebene Objekt nicht.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu überprüfende Objekt.</param>
        <summary>Bestimmt, ob der aktuelle Thread die Sperre für das angegebene Objekt enthält.</summary>
        <returns><see langword="true" />, wenn der aktuelle Thread die Schreibsperre für <paramref name="obj" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nur für Sperren verwendet werden, die mit den Methoden der <xref:System.Threading.Monitor>-Klasse abgerufen werden, oder mithilfe C# der `lock`-Anweisung oder der Visual Basic `SyncLock`-Anweisung, die mit <xref:System.Threading.Monitor>implementiert werden.  
  
 Verwenden Sie diese Methode mit Diagnosetools, z. b. der <xref:System.Diagnostics.Debug.Assert%2A>-Methode und der <xref:System.Diagnostics.Contracts.Contract>-Klasse, um Sperr Probleme zu debuggen, die die <xref:System.Threading.Monitor>-Klasse einschließen  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="LockContentionCount">
      <MemberSignature Language="C#" Value="public static long LockContentionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 LockContentionCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Monitor.LockContentionCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LockContentionCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long LockContentionCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LockContentionCount : int64" Usage="System.Threading.Monitor.LockContentionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Konflikte ab beim Versuch, die Sperre des Monitors aufzuheben.</summary>
        <value>Gibt an, wie oft Konflikte aufgetreten sind, als versucht wurde, die Sperre des Monitors zu übernehmen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das ein Thread wartet.</param>
        <summary>Benachrichtigt einen Thread in der Warteschlange für abzuarbeitende Threads über eine Änderung am Zustand des gesperrten Objekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur der aktuelle Besitzer der Sperre kann ein wartender Objekt mithilfe `Pulse`signalisieren.  
  
 Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um den nächsten Thread in der Zeile für die Sperre zu signalisieren. Beim Empfang des Pulse wird der wartende Thread in die bereite Warteschlange verschoben. Wenn der Thread, der `Pulse` aufgerufen hat, die Sperre freigibt, erhält der nächste Thread in der Warteschlange (der nicht unbedingt der Thread ist, der gepultet wurde) die Sperre.  
  
> [!IMPORTANT]
>  Die <xref:System.Threading.Monitor> Klasse behält den Zustand nicht bei, der angibt, dass die <xref:System.Threading.Monitor.Pulse%2A>-Methode aufgerufen wurde. Wenn Sie also <xref:System.Threading.Monitor.Pulse%2A> aufrufen, wenn keine Threads warten, wird der nächste Thread, der <xref:System.Threading.Monitor.Wait%2A> aufruft, so blockiert, als wäre <xref:System.Threading.Monitor.Pulse%2A> nie aufgerufen worden. Wenn zwei Threads <xref:System.Threading.Monitor.Pulse%2A> und <xref:System.Threading.Monitor.Wait%2A> für die Interaktion verwenden, könnte dies zu einem Deadlock führen. Vergleichen Sie dies mit dem Verhalten der <xref:System.Threading.AutoResetEvent>-Klasse: Wenn Sie eine <xref:System.Threading.AutoResetEvent> durch Aufrufen der <xref:System.Threading.EventWaitHandle.Set%2A>-Methode signalisieren und keine Threads warten, verbleibt der <xref:System.Threading.AutoResetEvent> in einem signalisierten Zustand, bis ein Thread <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>oder <xref:System.Threading.WaitHandle.WaitAll%2A>aufruft. Der <xref:System.Threading.AutoResetEvent> gibt diesen Thread frei und kehrt in den nicht signalisierten Zustand zurück.  
  
 Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die bereit sind, die Sperre abzurufen, und einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.  
  
 Die Methoden `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>und <xref:System.Threading.Monitor.Wait%2A> müssen innerhalb eines synchronisierten Codeblocks aufgerufen werden.  
  
 Verwenden Sie die <xref:System.Threading.Monitor.PulseAll%2A>-Methode, um mehrere Threads zu signalisieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das den Impuls sendet.</param>
        <summary>Benachrichtigt alle wartenden Threads über eine Änderung am Zustand des Objekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um alle Threads zu signalisieren, die auf das Abrufen der Sperre für das Objekt warten. Nachdem das Signal gesendet wurde, werden die wartenden Threads in die bereite Warteschlange verschoben. Wenn der Thread, der `PulseAll` aufgerufen hat, die Sperre freigibt, erhält der nächste Thread in der Ready-Warteschlange die Sperre.  
  
 Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die bereit sind, die Sperre abzurufen, und einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.  
  
 Die Methoden <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`und <xref:System.Threading.Monitor.Wait%2A> müssen innerhalb eines synchronisierten Codeblocks aufgerufen werden.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A>-Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.  
  
 Verwenden Sie die `Pulse`-Methode, um einen einzelnen Thread zu signalisieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <summary>Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</summary>
        <returns><see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Ausführung erhält diese Methode eine exklusive Sperre für den `obj`-Parameter. Diese Methode wird sofort zurückgegeben, unabhängig davon, ob die Sperre verfügbar ist.  
  
 Diese Methode ähnelt <xref:System.Threading.Monitor.Enter%2A>, aber der aktuelle Thread wird nie blockiert. Wenn der Thread nicht ohne Blockierung eingegeben werden kann, gibt die Methode `false,`zurück.  
  
> [!NOTE]
>  Verwenden Sie <xref:System.Threading.Monitor>, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren. Weitere Informationen finden Sie im Artikel <xref:System.Threading.Monitor>.  
  
 Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Rückgabewert der Methode überprüfen und Code nur im kritischen Abschnitt ausführen, wenn der Rückgabewert `true`ist. Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird. Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem `finally`-Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die `TryEnter`-Methode verwenden.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <param name="lockTaken">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</param>
        <summary>Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Ausführung erhält diese Methode eine exklusive Sperre für den `obj`-Parameter. Diese Methode wird sofort zurückgegeben, unabhängig davon, ob die Sperre verfügbar ist.  
  
 Wenn die Sperre nicht übernommen wurde, weil eine Ausnahme ausgelöst wurde, wird die für den `lockTaken`-Parameter angegebene Variable `false`, nachdem diese Methode beendet wurde. Dadurch kann das Programm in allen Fällen ermitteln, ob es erforderlich ist, die Sperre freizugeben.  
  
 Diese Methode ähnelt <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, aber der aktuelle Thread wird nie blockiert. Wenn der Thread nicht ohne Blockierung eingegeben werden kann, wird das `lockTaken`-Argument auf `false` festgelegt, wenn die Methode zurückgegeben wird.  
  
> [!NOTE]
>  Verwenden Sie <xref:System.Threading.Monitor>, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren. Weitere Informationen finden Sie im Artikel <xref:System.Threading.Monitor>.  
  
 Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Wert von `lockTaken` untersuchen und Code nur im kritischen Abschnitt ausführen, wenn sein Wert `true`ist. Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird. Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem `finally`-Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>-Methoden Überladung. Diese Überladung legt immer den Wert der Variablen fest, die an den `ref`-Parameter übergeben wird (`ByRef` in Visual Basic) `lockTaken`, auch wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Methode ist, um zu testen, ob die Sperre freigegeben werden muss.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</param>
        <summary>Versucht über eine angegebene Anzahl von Millisekunden hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</summary>
        <returns><see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der `millisecondsTimeout`-Parameter <xref:System.Threading.Timeout.Infinite>entspricht, entspricht diese Methode <xref:System.Threading.Monitor.Enter%2A>. Wenn `millisecondsTimeout` gleich 0 ist, entspricht diese Methode <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Verwenden Sie <xref:System.Threading.Monitor>, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren. Weitere Informationen finden Sie im Artikel <xref:System.Threading.Monitor>.  
  
 Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Rückgabewert der Methode überprüfen und Code nur im kritischen Abschnitt ausführen, wenn der Rückgabewert `true`ist. Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird. Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem `finally`-Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne darstellt, für die auf die Sperre gewartet werden soll. Ein Wert von –1 Millisekunde gibt eine unbegrenzte Wartezeit an.</param>
        <summary>Versucht über einen angegebenen Zeitraum hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</summary>
        <returns><see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert des `timeout`-Parameters, der in Millisekunden konvertiert wurde, gleich-1 ist, entspricht diese Methode <xref:System.Threading.Monitor.Enter%2A>. Wenn der Wert von `timeout` gleich 0 ist, entspricht diese Methode <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Verwenden Sie <xref:System.Threading.Monitor>, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren. Weitere Informationen finden Sie im Thema <xref:System.Threading.Monitor>-Klasse.  
  
 Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Rückgabewert der Methode überprüfen und Code nur im kritischen Abschnitt ausführen, wenn der Rückgabewert `true`ist. Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird. Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem `finally`-Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</param>
        <param name="lockTaken">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</param>
        <summary>Versucht für die angegebene Anzahl von Millisekunden, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der `millisecondsTimeout`-Parameter <xref:System.Threading.Timeout.Infinite>entspricht, entspricht diese Methode <xref:System.Threading.Monitor.Enter%28System.Object%29>. Wenn `millisecondsTimeout` gleich 0 ist, entspricht diese Methode <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Wenn die Sperre nicht übernommen wurde, weil eine Ausnahme ausgelöst wurde, wird die für den `lockTaken`-Parameter angegebene Variable `false`, nachdem diese Methode beendet wurde. Dadurch kann das Programm in allen Fällen ermitteln, ob es erforderlich ist, die Sperre freizugeben.  
  
> [!NOTE]
>  Verwenden Sie <xref:System.Threading.Monitor>, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren. Weitere Informationen finden Sie im Thema <xref:System.Threading.Monitor>-Klasse.  
  
 Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Wert von `lockTaken` untersuchen und Code nur im kritischen Abschnitt ausführen, wenn sein Wert `true`ist. Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird. Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem `finally`-Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>-Methoden Überladung. Diese Überladung legt immer den Wert der Variablen fest, die an den `ref`-Parameter übergeben wird (`ByRef` in Visual Basic) `lockTaken`, auch wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Methode ist, um zu testen, ob die Sperre freigegeben werden muss.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <param name="timeout">Die Zeitspanne, für die auf die Sperre gewartet werden soll. Ein Wert von –1 Millisekunde gibt eine unbegrenzte Wartezeit an.</param>
        <param name="lockTaken">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</param>
        <summary>Versucht für die angegebene Dauer, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert des `timeout`-Parameters, der in Millisekunden konvertiert wurde, gleich-1 ist, entspricht diese Methode <xref:System.Threading.Monitor.Enter%28System.Object%29>. Wenn der Wert von `timeout` gleich 0 ist, entspricht diese Methode <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Wenn die Sperre nicht übernommen wurde, weil eine Ausnahme ausgelöst wurde, wird die für den `lockTaken`-Parameter angegebene Variable `false`, nachdem diese Methode beendet wurde. Dadurch kann das Programm in allen Fällen ermitteln, ob es erforderlich ist, die Sperre freizugeben.  
  
> [!NOTE]
>  Verwenden Sie <xref:System.Threading.Monitor>, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren. Weitere Informationen finden Sie im Thema <xref:System.Threading.Monitor>-Klasse.  
  
 Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Wert von `lockTaken` untersuchen und Code nur im kritischen Abschnitt ausführen, wenn sein Wert `true`ist. Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird. Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem `finally`-Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</summary>
        <returns><see langword="true" />, wenn der Aufruf beendet wurde, weil der Aufrufer die Sperre für das angegebene Objekt erneut erhalten hat. Diese Methode wird nicht beendet, wenn die Sperre nicht erneut erhalten wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um das Objekt freizugeben, damit ein anderer Thread darauf zugreifen kann. Der Aufrufer ist blockiert, während er darauf wartet, die Sperre erneut abzurufen. Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten muss, die als Ergebnis der Vorgänge eines anderen Threads auftritt.  
  
 Wenn ein Thread `Wait`aufruft, gibt er die Sperre für das Objekt frei und wechselt in die Warteschlange des Objekts. Der nächste Thread in der Ready-Warteschlange des-Objekts (sofern vorhanden) erhält die Sperre und verfügt über eine exklusive Verwendung des-Objekts. Alle Threads, die `Wait` aufzurufen, bleiben in der Warteschlange, bis Sie ein Signal von <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>erhalten, das vom Besitzer der Sperre gesendet wird. Wenn `Pulse` gesendet wird, ist nur der Thread an der Spitze der Warteschlange betroffen. Wenn `PulseAll` gesendet wird, sind alle Threads betroffen, die auf das-Objekt warten. Wenn das Signal empfangen wird, verlässt mindestens ein Thread die Warteschlange, und die Warteschlange wird in die Warteschlange eingereiht. Ein Thread in der Warteschlange ist berechtigt, die Sperre erneut abzurufen.  
  
 Diese Methode gibt zurück, wenn der aufrufenden Thread die Sperre für das Objekt wieder erhält. Beachten Sie, dass diese Methode unbegrenzt blockiert wird, wenn der Inhaber der Sperre weder `Pulse` noch `PulseAll`aufruft.  
  
 Der Aufrufer führt `Wait` einmal aus, unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> für das angegebene Objekt aufgerufen wurde. Konzeptionell speichert die `Wait`-Methode, wie oft der Aufrufer `Enter` für das Objekt aufgerufen hat, und ruft `Exit` so oft wie nötig auf, um das gesperrte Objekt vollständig freizugeben. Der Aufrufer blockiert dann, während er darauf wartet, das Objekt erneut abzurufen. Wenn der Aufrufer die Sperre erneut erhält, ruft das System `Enter` so oft wie nötig auf, um die gespeicherte `Enter` Anzahl für den Aufrufer wiederherzustellen. Durch Aufrufen von `Wait` wird nur die Sperre für das angegebene Objekt freigegeben. Wenn der Aufrufer der Besitzer von Sperren für andere Objekte ist, werden diese Sperren nicht freigegeben.  
  
 Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die bereit sind, die Sperre abzurufen, und einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.  
  
 Die Methoden <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>und `Wait` müssen innerhalb eines synchronisierten Codeblocks aufgerufen werden.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A>-Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</summary>
        <returns><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt erst zurück, wenn Sie eine exklusive Sperre für den `obj`-Parameter erhält.  
  
 Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um das Objekt freizugeben, damit ein anderer Thread darauf zugreifen kann. Der Aufrufer ist blockiert, während er darauf wartet, die Sperre erneut abzurufen. Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten muss, die als Ergebnis der Vorgänge eines anderen Threads auftritt.  
  
 Durch das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt blockiert wird, wenn ein anderer Thread die Sperre freigibt, ohne zuvor die <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode aufrufen zu dürfen. Außerdem wird der Thread in die Warteschlange für die Warteschlange verschoben, sodass andere Threads vor ihm in der Warteschlange umgangen werden, damit die Sperre früher wieder hergestellt werden kann. Der Thread kann den Rückgabewert der <xref:System.Threading.Monitor.Wait%2A>-Methode testen, um zu bestimmen, ob die Sperre vor dem Timeout erneut abgerufen wurde. Der Thread kann die Bedingungen auswerten, die dazu geführt haben, dass der Warte Vorgang in den Wartezustand geraten ist, und bei Bedarf erneut die <xref:System.Threading.Monitor.Wait%2A> Methode aufruft.  
  
 Wenn ein Thread `Wait`aufruft, gibt er die Sperre für das Objekt frei und wechselt in die Warteschlange des Objekts. Der nächste Thread in der Ready-Warteschlange des-Objekts (sofern vorhanden) erhält die Sperre und verfügt über eine exklusive Verwendung des-Objekts. Der Thread, der `Wait` aufgerufen hat, verbleibt in der Warteschlange, bis entweder ein Thread, der die Sperre besitzt, <xref:System.Threading.Monitor.PulseAll%2A>aufruft, oder er ist der nächste in der Warteschlange, und ein Thread, der die Sperre enthält, ruft <xref:System.Threading.Monitor.Pulse%2A>auf. Wenn `millisecondsTimeout` jedoch abläuft, bevor ein anderer Thread die <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode dieses Objekts aufruft, wird der ursprüngliche Thread in die bereite Warteschlange verschoben, um die Sperre wiederherzustellen.  
  
> [!NOTE]
>  Wenn <xref:System.Threading.Timeout.Infinite> für den `millisecondsTimeout` Parameter angegeben wird, blockiert diese Methode unbegrenzt, es sei denn, der Inhaber der Sperre ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>auf. Wenn `millisecondsTimeout` gleich 0 ist, gibt der Thread, der `Wait` aufruft, die Sperre frei und wechselt dann sofort in die bereite Warteschlange, um die Sperre wiederherzustellen.  
  
 Der Aufrufer führt `Wait` einmal aus, unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> für das angegebene Objekt aufgerufen wurde. Konzeptionell speichert die `Wait`-Methode, wie oft der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt aufgerufen hat, und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig auf, um das gesperrte Objekt vollständig freizugeben. Der Aufrufer blockiert dann, während er darauf wartet, das Objekt erneut abzurufen. Wenn der Aufrufer die Sperre erneut erhält, ruft das System <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig auf, um die gespeicherte <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer wiederherzustellen. Durch Aufrufen von `Wait` wird nur die Sperre für das angegebene Objekt freigegeben. Wenn der Aufrufer der Besitzer von Sperren für andere Objekte ist, werden diese Sperren nicht freigegeben.  
  
> [!NOTE]
>  Ein synchronisiertes Objekt enthält mehrere Verweise, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die zum Abrufen der Sperre bereit sind, sowie einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.  
  
 Die Methoden <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>und `Wait` müssen innerhalb eines synchronisierten Codeblocks aufgerufen werden.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A>-Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</summary>
        <returns><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt erst zurück, wenn Sie eine exklusive Sperre für den `obj`-Parameter erhält.  
  
 Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um das Objekt freizugeben, damit ein anderer Thread darauf zugreifen kann. Der Aufrufer ist blockiert, während er darauf wartet, die Sperre erneut abzurufen. Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten muss, die als Ergebnis der Vorgänge eines anderen Threads auftritt.  
  
 Durch das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt blockiert wird, wenn ein anderer Thread die Sperre freigibt, ohne zuvor die <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode aufrufen zu dürfen. Außerdem wird der Thread in die Warteschlange für die Warteschlange verschoben, sodass andere Threads vor ihm in der Warteschlange umgangen werden, damit die Sperre früher wieder hergestellt werden kann. Der Thread kann den Rückgabewert der <xref:System.Threading.Monitor.Wait%2A>-Methode testen, um zu bestimmen, ob die Sperre vor dem Timeout erneut abgerufen wurde. Der Thread kann die Bedingungen auswerten, die dazu geführt haben, dass der Warte Vorgang in den Wartezustand geraten ist, und bei Bedarf erneut die <xref:System.Threading.Monitor.Wait%2A> Methode aufruft.  
  
 Wenn ein Thread `Wait`aufruft, gibt er die Sperre für das Objekt frei und wechselt in die Warteschlange des Objekts. Der nächste Thread in der Ready-Warteschlange des-Objekts (sofern vorhanden) erhält die Sperre und verfügt über eine exklusive Verwendung des-Objekts. Der Thread, der `Wait` aufgerufen hat, verbleibt in der Warteschlange, bis entweder ein Thread, der die Sperre besitzt, <xref:System.Threading.Monitor.PulseAll%2A>aufruft, oder er ist der nächste in der Warteschlange, und ein Thread, der die Sperre enthält, ruft <xref:System.Threading.Monitor.Pulse%2A>auf. Wenn `timeout` jedoch abläuft, bevor ein anderer Thread die <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode dieses Objekts aufruft, wird der ursprüngliche Thread in die bereite Warteschlange verschoben, um die Sperre wiederherzustellen.  
  
> [!NOTE]
>  Wenn ein <xref:System.TimeSpan>, der-1 Millisekunde darstellt, für den `timeout` Parameter angegeben wird, blockiert diese Methode unbegrenzt, es sei denn, der Inhaber der Sperre ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>auf. Wenn `timeout` 0 Millisekunden beträgt, gibt der Thread, der `Wait` aufruft, die Sperre frei und wechselt dann sofort in die bereite Warteschlange, um die Sperre wiederherzustellen.  
  
 Der Aufrufer führt `Wait` einmal aus, unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> für das angegebene Objekt aufgerufen wurde. Konzeptionell speichert die `Wait`-Methode, wie oft der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt aufgerufen hat, und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig auf, um das gesperrte Objekt vollständig freizugeben. Der Aufrufer blockiert dann, während er darauf wartet, das Objekt erneut abzurufen. Wenn der Aufrufer die Sperre erneut erhält, ruft das System <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig auf, um die gespeicherte <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer wiederherzustellen. Durch Aufrufen von `Wait` wird nur die Sperre für das angegebene Objekt freigegeben. Wenn der Aufrufer der Besitzer von Sperren für andere Objekte ist, werden diese Sperren nicht freigegeben.  
  
> [!NOTE]
>  Ein synchronisiertes Objekt enthält mehrere Verweise, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die zum Abrufen der Sperre bereit sind, sowie einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.  
  
 Die Methoden <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>und `Wait` müssen innerhalb eines synchronisierten Codeblocks aufgerufen werden.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A>-Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert des <paramref name="timeout" />-Parameters in Millisekunden ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) dar, oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</param>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein. Diese Methode gibt außerdem an, ob die Synchronisierungsdomäne danach für den Kontext (wenn es sich um einen synchronisierten Kontext handelt) vor dem Warten und erneuten Erhalten verlassen wird.</summary>
        <returns><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt erst zurück, wenn Sie eine exklusive Sperre für den `obj`-Parameter erhält.  
  
 Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um das Objekt freizugeben, damit ein anderer Thread darauf zugreifen kann. Der Aufrufer ist blockiert, während er darauf wartet, die Sperre erneut abzurufen. Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten muss, die als Ergebnis der Vorgänge eines anderen Threads auftritt.  
  
 Durch das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt blockiert wird, wenn ein anderer Thread die Sperre freigibt, ohne zuvor die <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode aufrufen zu dürfen. Außerdem wird der Thread in die Warteschlange für die Warteschlange verschoben, sodass andere Threads vor ihm in der Warteschlange umgangen werden, damit die Sperre früher wieder hergestellt werden kann. Der Thread kann den Rückgabewert der <xref:System.Threading.Monitor.Wait%2A>-Methode testen, um zu bestimmen, ob die Sperre vor dem Timeout erneut abgerufen wurde. Der Thread kann die Bedingungen auswerten, die dazu geführt haben, dass der Warte Vorgang in den Wartezustand geraten ist, und bei Bedarf erneut die <xref:System.Threading.Monitor.Wait%2A> Methode aufruft.  
  
 Wenn ein Thread `Wait`aufruft, gibt er die Sperre frei und wechselt in die Warteschlange. An diesem Punkt kann der nächste Thread in der Warteschlange (sofern vorhanden) die Kontrolle über die Sperre übernehmen. Der Thread, der `Wait` aufgerufen hat, verbleibt in der Warteschlange, bis entweder ein Thread, der die Sperre besitzt, <xref:System.Threading.Monitor.PulseAll%2A>aufruft, oder er ist der nächste in der Warteschlange, und ein Thread, der die Sperre enthält, ruft <xref:System.Threading.Monitor.Pulse%2A>auf. Wenn `millisecondsTimeout` jedoch abläuft, bevor ein anderer Thread die <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode dieses Objekts aufruft, wird der ursprüngliche Thread in die bereite Warteschlange verschoben, um die Sperre wiederherzustellen.  
  
> [!NOTE]
>  Wenn <xref:System.Threading.Timeout.Infinite> für den `millisecondsTimeout` Parameter angegeben wird, blockiert diese Methode unbegrenzt, es sei denn, der Inhaber der Sperre ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>auf. Wenn `millisecondsTimeout` gleich 0 ist, gibt der Thread, der `Wait` aufruft, die Sperre frei und wechselt dann sofort in die bereite Warteschlange, um die Sperre wiederherzustellen.  
  
 Der Aufrufer führt `Wait` einmal aus, unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> für das angegebene Objekt aufgerufen wurde. Konzeptionell speichert die `Wait`-Methode, wie oft der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt aufgerufen hat, und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig auf, um das gesperrte Objekt vollständig freizugeben. Der Aufrufer blockiert dann, während er darauf wartet, das Objekt erneut abzurufen. Wenn der Aufrufer die Sperre erneut erhält, ruft das System <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig auf, um die gespeicherte <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer wiederherzustellen. Durch Aufrufen von `Wait` wird nur die Sperre für das angegebene Objekt freigegeben. Wenn der Aufrufer der Besitzer von Sperren für andere Objekte ist, werden diese Sperren nicht freigegeben.  
  
> [!NOTE]
>  Ein synchronisiertes Objekt enthält mehrere Verweise, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die zum Abrufen der Sperre bereit sind, sowie einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.  
  
 Die Methoden <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>und `Wait` müssen innerhalb eines synchronisierten Codeblocks aufgerufen werden.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A>-Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Der`exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.Monitor.Wait%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen. Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist. Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie z. b. <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.  
  
 Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.Monitor.Wait%2A>-Methode ausgeführt wird. Sie kehrt zum ursprünglichen, nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.Monitor.Wait%2A> Methode abgeschlossen wurde.  
  
 Dies kann hilfreich sein, wenn für die Kontext gebundene Klasse das <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>-Attribut angewendet wurde. In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse. Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.Monitor.Wait%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann. Wenn die <xref:System.Threading.Monitor.Wait%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</param>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein. Beendet vor dem Warten optional auch die Synchronisierungsdomäne für den synchronisierten Kontext und erhält die Domäne anschließend wieder.</summary>
        <returns><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt erst zurück, wenn Sie eine exklusive Sperre für den `obj`-Parameter erhält.  
  
 Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um das Objekt freizugeben, damit ein anderer Thread darauf zugreifen kann. Der Aufrufer ist blockiert, während er darauf wartet, die Sperre erneut abzurufen. Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten muss, die als Ergebnis der Vorgänge eines anderen Threads auftritt.  
  
 Durch das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt blockiert wird, wenn ein anderer Thread die Sperre freigibt, ohne zuvor die <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode aufrufen zu dürfen. Außerdem wird der Thread in die Warteschlange für die Warteschlange verschoben, sodass andere Threads vor ihm in der Warteschlange umgangen werden, damit die Sperre früher wieder hergestellt werden kann. Der Thread kann den Rückgabewert der <xref:System.Threading.Monitor.Wait%2A>-Methode testen, um zu bestimmen, ob die Sperre vor dem Timeout erneut abgerufen wurde. Der Thread kann die Bedingungen auswerten, die dazu geführt haben, dass der Warte Vorgang in den Wartezustand geraten ist, und bei Bedarf erneut die <xref:System.Threading.Monitor.Wait%2A> Methode aufruft.  
  
 Wenn ein Thread `Wait`aufruft, gibt er die Sperre frei und wechselt in die Warteschlange. An diesem Punkt kann der nächste Thread in der Warteschlange (sofern vorhanden) die Kontrolle über die Sperre übernehmen. Der Thread, der `Wait` aufgerufen hat, verbleibt in der Warteschlange, bis entweder ein Thread, der die Sperre besitzt, <xref:System.Threading.Monitor.PulseAll%2A>aufruft, oder er ist der nächste in der Warteschlange, und ein Thread, der die Sperre enthält, ruft <xref:System.Threading.Monitor.Pulse%2A>auf. Wenn jedoch `timeout` Millisekunden vergehen, bevor ein anderer Thread das <xref:System.Threading.Monitor.Pulse%2A> oder die <xref:System.Threading.Monitor.PulseAll%2A> Methode dieses Objekts aufruft, wird der ursprüngliche Thread in die Warteschlange für bereite Warteschlangen verschoben, um die Sperre wiederherzustellen.  
  
> [!NOTE]
>  Wenn ein <xref:System.TimeSpan>, der-1 Millisekunde darstellt, für den `timeout` Parameter angegeben wird, blockiert diese Methode unbegrenzt, es sei denn, der Inhaber der Sperre ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>auf. Wenn `timeout` 0 Millisekunden beträgt, gibt der Thread, der `Wait` aufruft, die Sperre frei und wechselt dann sofort in die bereite Warteschlange, um die Sperre wiederherzustellen.  
  
 Der Aufrufer führt `Wait` einmal aus, unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> für das angegebene Objekt aufgerufen wurde. Konzeptionell speichert die `Wait`-Methode, wie oft der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt aufgerufen hat, und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig auf, um das gesperrte Objekt vollständig freizugeben. Der Aufrufer blockiert dann, während er darauf wartet, das Objekt erneut abzurufen. Wenn der Aufrufer die Sperre erneut erhält, ruft das System <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig auf, um die gespeicherte <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer wiederherzustellen. Durch Aufrufen von `Wait` wird nur die Sperre für das angegebene Objekt freigegeben. Wenn der Aufrufer der Besitzer von Sperren für andere Objekte ist, werden diese Sperren nicht freigegeben.  
  
> [!NOTE]
>  Ein synchronisiertes Objekt enthält mehrere Verweise, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die zum Abrufen der Sperre bereit sind, sowie einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.  
  
 Die Methoden <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>und `Wait` müssen innerhalb eines synchronisierten Codeblocks aufgerufen werden.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A>-Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Der`exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.Monitor.Wait%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen. Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist. Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie z. b. <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.  
  
 Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.Monitor.Wait%2A>-Methode ausgeführt wird. Sie kehrt zum ursprünglichen, nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.Monitor.Wait%2A> Methode abgeschlossen wurde.  
  
 Dies kann hilfreich sein, wenn für die Kontext gebundene Klasse das <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>-Attribut angewendet wurde. In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse. Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.Monitor.Wait%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann. Wenn die <xref:System.Threading.Monitor.Wait%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="obj" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread, der „Wait“ aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="timeout" />-Parameter ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> dar (–1 Millisekunde), oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
  </Members>
</Type>
