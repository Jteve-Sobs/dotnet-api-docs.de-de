<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cfafcfe91d4ef6eba6ebbbbe6d7101119c93823a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531374" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="88e9a-101">Stellt einen Mechanismus bereit, der den Zugriff auf Objekte synchronisiert.</span>
      <span class="sxs-lookup">
        <span data-stu-id="88e9a-101">Provides a mechanism that synchronizes access to objects.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-102">Die <xref:System.Threading.Monitor> -Klasse können Sie den Zugriff auf einen Codebereich synchronisieren, indem eine Sperre für ein bestimmtes Objekt durch Aufrufen der <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, und <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> Methoden.</span><span class="sxs-lookup"><span data-stu-id="88e9a-102">The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="88e9a-103">Objektsperren bieten die Möglichkeit, den Zugriff auf einen Codeblock, der so genannte eines kritischen Abschnitts einschränken.</span><span class="sxs-lookup"><span data-stu-id="88e9a-103">Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</span></span> <span data-ttu-id="88e9a-104">Während ein Thread die Sperre für ein Objekt besitzt, kann keine anderen Threads diese Sperre abzurufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-104">While a thread owns the lock for an object, no other thread can acquire that lock.</span></span> <span data-ttu-id="88e9a-105">Sie können auch die <xref:System.Threading.Monitor> Klasse, um sicherzustellen, dass keine anderen Threads zugelassen wird, eine Anwendung Zugriff auf code, der Eigentümer der Sperre ausgeführt wird, es sei denn, der andere Thread den Code mithilfe eines anderen gesperrten Objekts ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-105">You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</span></span>  
  
 <span data-ttu-id="88e9a-106">In diesem Artikel:</span><span class="sxs-lookup"><span data-stu-id="88e9a-106">In this article:</span></span>  
  
 <span data-ttu-id="88e9a-107">[Monitor-Klasse: Übersicht](#Overview) </span><span class="sxs-lookup"><span data-stu-id="88e9a-107">[The Monitor class: An overview](#Overview) </span></span>  
 <span data-ttu-id="88e9a-108">[Das Sperrobjekt](#Lock) </span><span class="sxs-lookup"><span data-stu-id="88e9a-108">[The lock object](#Lock) </span></span>  
 <span data-ttu-id="88e9a-109">[Der kritische Abschnitt](#CriticalSection) </span><span class="sxs-lookup"><span data-stu-id="88e9a-109">[The critical section](#CriticalSection) </span></span>  
 <span data-ttu-id="88e9a-110">[Pulse PulseAll und warten](#Pulse) </span><span class="sxs-lookup"><span data-stu-id="88e9a-110">[Pulse, PulseAll, and Wait](#Pulse) </span></span>  
 [<span data-ttu-id="88e9a-111">Monitore und Wait-handles</span><span class="sxs-lookup"><span data-stu-id="88e9a-111">Monitors and wait handles</span></span>](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a><span data-ttu-id="88e9a-112">Monitor-Klasse: Übersicht</span><span class="sxs-lookup"><span data-stu-id="88e9a-112">The Monitor class: An overview</span></span>  
 <span data-ttu-id="88e9a-113"><xref:System.Threading.Monitor> bietet die folgenden Features:</span><span class="sxs-lookup"><span data-stu-id="88e9a-113"><xref:System.Threading.Monitor> has the following features:</span></span>  
  
-   <span data-ttu-id="88e9a-114">Es ist ein Objekt bei Bedarf zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-114">It is associated with an object on demand.</span></span>  
  
-   <span data-ttu-id="88e9a-115">Es ist nicht gebundenen, dies bedeutet, er kann direkt aus einem beliebigen Kontext aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="88e9a-115">It is unbound, which means it can be called directly from any context.</span></span>  
  
-   <span data-ttu-id="88e9a-116">Eine Instanz von der <xref:System.Threading.Monitor> Klasse kann nicht erstellt werden; die Methoden der <xref:System.Threading.Monitor> Klasse sind alle statisch.</span><span class="sxs-lookup"><span data-stu-id="88e9a-116">An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static.</span></span> <span data-ttu-id="88e9a-117">Jede Methode übergeben das synchronisierte Objekt, das steuert den Zugriff auf den kritischen Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-117">Each method is passed the synchronized object that controls access to the critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-118">Verwenden der <xref:System.Threading.Monitor> Klasse, um Objekte als Zeichenfolgen sperren (d. h. Referenztypen außer <xref:System.String>), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-118">Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types.</span></span> <span data-ttu-id="88e9a-119">Einzelheiten finden Sie die Überladungen der <xref:System.Threading.Monitor.Enter%2A> Methode und [das Sperrenobjekt](#Lock) Abschnitt weiter unten in diesem Artikel.</span><span class="sxs-lookup"><span data-stu-id="88e9a-119">For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.</span></span>  
  
 <span data-ttu-id="88e9a-120">Die folgende Tabelle beschreibt die Aktionen, die von Threads ausgeführt werden können, die Zugriff auf Objekte synchronisiert:</span><span class="sxs-lookup"><span data-stu-id="88e9a-120">The following table describes the actions that can be taken by threads that access synchronized objects:</span></span>  
  
|<span data-ttu-id="88e9a-121">Aktion</span><span class="sxs-lookup"><span data-stu-id="88e9a-121">Action</span></span>|<span data-ttu-id="88e9a-122">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="88e9a-122">Description</span></span>|  
|------------|-----------------|  
|<span data-ttu-id="88e9a-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span><span class="sxs-lookup"><span data-stu-id="88e9a-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span></span>|<span data-ttu-id="88e9a-124">Ruft eine Sperre für ein Objekt ab.</span><span class="sxs-lookup"><span data-stu-id="88e9a-124">Acquires a lock for an object.</span></span> <span data-ttu-id="88e9a-125">Diese Aktion werden außerdem den Anfang eines kritischen Abschnitts.</span><span class="sxs-lookup"><span data-stu-id="88e9a-125">This action also marks the beginning of a critical section.</span></span> <span data-ttu-id="88e9a-126">Keine anderen Threads kann den kritischen Abschnitt eingeben, es sei denn, sie die Anweisungen in den kritischen Abschnitt mithilfe eines anderen gesperrten Objekts ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-126">No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</span></span>|  
|<xref:System.Threading.Monitor.Wait%2A>|<span data-ttu-id="88e9a-127">Gibt die Sperre für ein Objekt zum Zulassen von anderen Threads zu sperren, und greifen auf das Objekt frei.</span><span class="sxs-lookup"><span data-stu-id="88e9a-127">Releases the lock on an object in order to permit other threads to lock and access the object.</span></span> <span data-ttu-id="88e9a-128">Der aufrufende Thread wartet, während ein anderer Thread das Objekt zugreift.</span><span class="sxs-lookup"><span data-stu-id="88e9a-128">The calling thread waits while another thread accesses the object.</span></span> <span data-ttu-id="88e9a-129">Pulse Signale werden verwendet, um wartende Threads über Änderungen an der Status eines Objekts zu benachrichtigen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-129">Pulse signals are used to notify waiting threads about changes to an object's state.</span></span>|  
|<span data-ttu-id="88e9a-130"><xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A></span><span class="sxs-lookup"><span data-stu-id="88e9a-130"><xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A></span></span>|<span data-ttu-id="88e9a-131">Sendet ein Signal an einen oder mehrere wartende Threads.</span><span class="sxs-lookup"><span data-stu-id="88e9a-131">Sends a signal to one or more waiting threads.</span></span> <span data-ttu-id="88e9a-132">Das Signal benachrichtigt einen wartenden Thread, den der Zustand des gesperrten Objekts geändert wurde, und der Besitzer der Sperre ist bereit, um die Sperre aufzuheben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-132">The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</span></span> <span data-ttu-id="88e9a-133">Des wartenden Threads befindet sich in die Warteschlange für abgearbeitete des Objekts, damit er die Sperre für das Objekt schließlich empfangen kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-133">The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</span></span> <span data-ttu-id="88e9a-134">Sobald der Thread die Sperre besitzt, kann es durch überprüfen den neuen Zustand des Objekts, um festzustellen, ob die erforderliche Status erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="88e9a-134">Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</span></span>|  
|<xref:System.Threading.Monitor.Exit%2A>|<span data-ttu-id="88e9a-135">Hebt die Sperre für ein Objekt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-135">Releases the lock on an object.</span></span> <span data-ttu-id="88e9a-136">Diese Aktion werden auch das Ende eines kritischen Abschnitts von gesperrten Objekts geschützt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-136">This action also marks the end of a critical section protected by the locked object.</span></span>|  
  
 <span data-ttu-id="88e9a-137">Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], es gibt zwei Sätze von Überladungen für die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.TryEnter%2A> Methoden.</span><span class="sxs-lookup"><span data-stu-id="88e9a-137">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods.</span></span> <span data-ttu-id="88e9a-138">Eine Gruppe von Überladungen hat eine `ref` (in c#) oder `ByRef` (in Visual Basic) <xref:System.Boolean> Parameter, der atomar auf `true` Wenn die Sperre abgerufen wird, auch wenn eine Ausnahme ausgelöst wird, wenn die Sperre abrufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-138">One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock.</span></span> <span data-ttu-id="88e9a-139">Verwenden Sie diese Überladung, wenn es wichtig ist, die Sperre in allen Fällen, selbst wenn die Ressourcen, die die Sperre zu schützen, ist möglicherweise nicht in einem konsistenten Zustand.</span><span class="sxs-lookup"><span data-stu-id="88e9a-139">Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</span></span>  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a><span data-ttu-id="88e9a-140">Das Sperrobjekt</span><span class="sxs-lookup"><span data-stu-id="88e9a-140">The lock object</span></span>  
 <span data-ttu-id="88e9a-141">Monitor-Klasse besteht aus `static` (in c#) oder `Shared` (in Visual Basic) Methoden für ein Objekt, dass für den Zugriff auf den kritischen Abschnitt steuert.</span><span class="sxs-lookup"><span data-stu-id="88e9a-141">The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.</span></span>  <span data-ttu-id="88e9a-142">Die folgende Informationen wird für jedes synchronisierte Objekt verwaltet:</span><span class="sxs-lookup"><span data-stu-id="88e9a-142">The following information is maintained for each synchronized object:</span></span>  
  
-   <span data-ttu-id="88e9a-143">Ein Verweis auf den Thread, der die Sperre enthält.</span><span class="sxs-lookup"><span data-stu-id="88e9a-143">A reference to the thread that currently holds the lock.</span></span>  
  
-   <span data-ttu-id="88e9a-144">Ein Verweis auf eine Warteschlange, die Threads enthält, die die Sperre erhalten können.</span><span class="sxs-lookup"><span data-stu-id="88e9a-144">A reference to a ready queue, which contains the threads that are ready to obtain the lock.</span></span>  
  
-   <span data-ttu-id="88e9a-145">Ein Verweis auf eine Warteschlange, die die Threads enthält, die für die Benachrichtigung über eine Änderung in den Zustand des gesperrten Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-145">A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</span></span>  
  
 <span data-ttu-id="88e9a-146"><xref:System.Threading.Monitor> sperrt Objekte (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-146"><xref:System.Threading.Monitor> locks objects (that is, reference types), not value types.</span></span> <span data-ttu-id="88e9a-147">Sie können einen Werttyp an <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> übergeben. Dieser wird jedoch für jeden Aufruf separat geschachtelt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-147">While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call.</span></span> <span data-ttu-id="88e9a-148">Da jeder Aufruf ein separates Objekt erstellt, bedingt <xref:System.Threading.Monitor.Enter%2A> nie eine Blockierung, und der Code, den die Methode eigentlich schützen soll, wird nicht wirklich synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="88e9a-148">Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized.</span></span> <span data-ttu-id="88e9a-149">Darüber hinaus unterscheiden sich das an <xref:System.Threading.Monitor.Exit%2A> und das an <xref:System.Threading.Monitor.Enter%2A> übergebene Objekt, sodass <xref:System.Threading.Monitor> eine <xref:System.Threading.SynchronizationLockException> mit der folgenden Meldung auslöst: "Die Objektsynchronisationsmethode wurde von einem nicht synchronisierten Codeblock aufgerufen."</span><span class="sxs-lookup"><span data-stu-id="88e9a-149">In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message "Object synchronization method was called from an unsynchronized block of code."</span></span>  
  
 <span data-ttu-id="88e9a-150">Dieses Problem wird anhand des folgenden Beispiels veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="88e9a-150">The following example illustrates this problem.</span></span> <span data-ttu-id="88e9a-151">Im Beispiel werden zehn Aufgaben gestartet, wobei jede lediglich 250 Millisekunden inaktiv ist.</span><span class="sxs-lookup"><span data-stu-id="88e9a-151">It launches ten tasks, each of which just sleeps for 250 milliseconds.</span></span> <span data-ttu-id="88e9a-152">Anschließend aktualisiert jede Aufgabe eine Zählervariable, `nTasks`, die dazu vorgesehen ist, die Anzahl von Aufgaben zu zählen, die tatsächlich gestartet wurden und ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="88e9a-152">Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed.</span></span> <span data-ttu-id="88e9a-153">Weil `nTasks` eine globale Variable ist, die von mehreren Aufgaben gleichzeitig aktualisiert werden kann, wird ein Monitor verwendet, um zu verhindern, dass die Variable gleichzeitig von mehreren Aufgaben geändert wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-153">Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</span></span> <span data-ttu-id="88e9a-154">Wie die Ausgabe des Beispiels zeigt, löst jede dieser Aufgaben jedoch eine <xref:System.Threading.SynchronizationLockException>-Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="88e9a-154">However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 <span data-ttu-id="88e9a-155">Jede Aufgabe löst eine <xref:System.Threading.SynchronizationLockException>-Ausnahme aus, weil die Variable `nTasks` gekapselt wird, bevor in jeder Aufgabe die <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-155">Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method in each task.</span></span> <span data-ttu-id="88e9a-156">Anders formuliert heißt das, bei jedem Methodenaufruf wird eine separate Variable übergeben, die unabhängig von den anderen ist.</span><span class="sxs-lookup"><span data-stu-id="88e9a-156">In other words, each method call is passed a separate variable that is independent of the others.</span></span> <span data-ttu-id="88e9a-157">`nTasks` wird im Aufruf der <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>-Methode erneut gekapselt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-157">`nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="88e9a-158">Dadurch werden wiederum zehn neue gekapselte `nTasks`-Variablen erstellt, die unabhängig voneinander sind. Hinzu kommen die zehn gekapselten Variablen, die im Aufruf der <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>-Methode erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="88e9a-158">Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="88e9a-159">Die Ausnahme wird dann ausgelöst, weil im Code versucht wird, eine Sperre für eine neu erstellte Variable freizugeben, die zuvor nicht gesperrt wurde.</span><span class="sxs-lookup"><span data-stu-id="88e9a-159">The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</span></span>  
  
 <span data-ttu-id="88e9a-160">Wie das folgende Beispiel zeigt, können Sie eine Werttypvariable zwar vor dem Aufruf von <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> kapseln und dasselbe gekapselte Objekt an beide Methoden übergeben, diese Vorgehensweise bietet jedoch keinerlei Vorteile.</span><span class="sxs-lookup"><span data-stu-id="88e9a-160">Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</span></span> <span data-ttu-id="88e9a-161">Änderungen an der nicht gekapselten Variablen wirken sich nicht auf die gekapselte Kopie aus, und es ist nicht möglich, den Wert der gekapselten Kopie zu ändern.</span><span class="sxs-lookup"><span data-stu-id="88e9a-161">Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 <span data-ttu-id="88e9a-162">Wenn ein Objekt für die Synchronisierung ausgewählt wird, sollten Sie nur auf private oder interne Objekte sperren.</span><span class="sxs-lookup"><span data-stu-id="88e9a-162">When selecting an object on which to synchronize, you should lock only on private or internal objects.</span></span> <span data-ttu-id="88e9a-163">Sperren auf externe Objekte kommen Deadlocks, weil nicht verknüpfte Code So sperren Sie für unterschiedliche Zwecke auf dieselben Objekte auswählen kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-163">Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</span></span>  
  
 <span data-ttu-id="88e9a-164">Beachten Sie, die Sie für ein Objekt in mehreren Anwendungsdomänen synchronisieren können, wenn das für die Sperre verwendete Objekt abgeleitet <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-164">Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a><span data-ttu-id="88e9a-165">Der kritische Abschnitt</span><span class="sxs-lookup"><span data-stu-id="88e9a-165">The critical section</span></span>  
 <span data-ttu-id="88e9a-166">Verwenden der <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methoden, um Anfang und Ende eines kritischen Abschnitts zu markieren.</span><span class="sxs-lookup"><span data-stu-id="88e9a-166">Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-167">Die Funktionalität von der <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methoden ist identisch mit derjenigen der [Sperre](~/docs/csharp/language-reference/keywords/lock-statement.md) -Anweisung in c# und die [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) -Anweisung in Visual Basic, außer dass die Sprachkonstrukte Wrap der <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> -methodenüberladung und die <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> Methode in einer `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="88e9a-167">The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method in a `try`…`finally`</span></span> <span data-ttu-id="88e9a-168">Sperren, um sicherzustellen, dass der Monitor freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-168">block to ensure that the monitor is released.</span></span>  
  
 <span data-ttu-id="88e9a-169">Der kritische Abschnitt ist eine Reihe von zusammenhängenden Anweisungen, und klicken Sie dann auf die Sperre, die von der <xref:System.Threading.Monitor.Enter%2A> Methode stellt sicher, dass den eingeschlossenen Code mit gesperrten Objekts nur ein einzigen Thread ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-169">If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object.</span></span> <span data-ttu-id="88e9a-170">In diesem Fall wird empfohlen, dass Sie diesen Code in Platzieren einer `try` blockieren, und platzieren Sie den Aufruf von der <xref:System.Threading.Monitor.Exit%2A> Methode in einer `finally` Block.</span><span class="sxs-lookup"><span data-stu-id="88e9a-170">In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block.</span></span> <span data-ttu-id="88e9a-171">Dadurch ist sichergestellt, dass die Sperre aufgehoben wird, selbst wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-171">This ensures that the lock is released even if an exception occurs.</span></span> <span data-ttu-id="88e9a-172">Das folgende Codefragment veranschaulicht dieses Muster.</span><span class="sxs-lookup"><span data-stu-id="88e9a-172">The following code fragment illustrates this pattern.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 <span data-ttu-id="88e9a-173">Diese Funktion wird normalerweise verwendet, um den Zugriff auf eine statische Methode oder Instanzmethode einer Klasse zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="88e9a-173">This facility is typically used to synchronize access to a static or instance method of a class.</span></span>  
  
 <span data-ttu-id="88e9a-174">Ein kritischen Abschnitt eine gesamte Methode umfasst, kann die Sperre-Funktion erreicht werden, indem Platzieren der <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> der Methode und Angeben der <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> Wert im Konstruktor der <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-174">If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="88e9a-175">Wenn Sie dieses Attribut verwenden die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methodenaufrufe sind nicht erforderlich.</span><span class="sxs-lookup"><span data-stu-id="88e9a-175">When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed.</span></span> <span data-ttu-id="88e9a-176">Das folgende Codefragment veranschaulicht dieses Muster:</span><span class="sxs-lookup"><span data-stu-id="88e9a-176">The following code fragment illustrates this pattern:</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 <span data-ttu-id="88e9a-177">Beachten Sie, dass das Attribut bewirkt, den aktuellen Thread die Sperre dass, bis die Methode einen Wert zurückgibt. verwenden, wenn die Sperre früher freigegeben werden kann, die <xref:System.Threading.Monitor> Klasse, die C#- [Sperre](~/docs/csharp/language-reference/keywords/lock-statement.md) -Anweisung oder die Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) Anweisung innerhalb der Methode anstelle der Attributs.</span><span class="sxs-lookup"><span data-stu-id="88e9a-177">Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement, or the Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement inside of the method instead of the attribute.</span></span>  
  
 <span data-ttu-id="88e9a-178">Es ist zwar möglich, für die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Anweisungen, die Sperren und ein angegebenes Objekt Member und/oder gruppenübergreifende freigeben, dieses Vorgehen wird nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-178">While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</span></span>  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a><span data-ttu-id="88e9a-179">Pulse PulseAll und warten</span><span class="sxs-lookup"><span data-stu-id="88e9a-179">Pulse, PulseAll, and Wait</span></span>  
 <span data-ttu-id="88e9a-180">Sobald ein Thread die Sperre besitzt und hat den kritischen Abschnitt, der die Sperre schützt, rufen sie die <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, und <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> Methoden.</span><span class="sxs-lookup"><span data-stu-id="88e9a-180">Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="88e9a-181"><xref:System.Threading.Monitor.Wait%2A> Gibt die Sperre frei, falls diese gehalten wird, kann einen wartenden Thread oder Threads an, die die Sperre abrufen und den kritischen Abschnitt und wartet auf eine Benachrichtigung durch einen Aufruf der <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> oder <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="88e9a-181"><xref:System.Threading.Monitor.Wait%2A> releases the lock if it is held, allows a waiting thread or threads to obtain the lock and enter the critical section,   and waits to be notified by a call to the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> or <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="88e9a-182">Wurde <xref:System.Threading.Monitor.Wait%2A> benachrichtigt, führt die Methode einen Rücksprung aus und erhält erneut die Sperre.</span><span class="sxs-lookup"><span data-stu-id="88e9a-182">When <xref:System.Threading.Monitor.Wait%2A> is notified, it returns and obtains the lock again.</span></span>  
  
 <span data-ttu-id="88e9a-183">Sowohl <xref:System.Threading.Monitor.Pulse%2A> als auch <xref:System.Threading.Monitor.PulseAll%2A> signalisieren, dass der nächste Thread in der Warteschlange verarbeitet werden kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-183">Both <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> signal for the next thread in the wait queue to proceed.</span></span>  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a><span data-ttu-id="88e9a-184">Monitore und Wait-handles</span><span class="sxs-lookup"><span data-stu-id="88e9a-184">Monitors and wait handles</span></span>  
 <span data-ttu-id="88e9a-185">Es ist wichtig, den Unterschied zwischen der Verwendung von beachten die <xref:System.Threading.Monitor> Klasse und <xref:System.Threading.WaitHandle> Objekte.</span><span class="sxs-lookup"><span data-stu-id="88e9a-185">It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.</span></span>  
  
-   <span data-ttu-id="88e9a-186">Die <xref:System.Threading.Monitor> Klasse ist rein verwaltete, vollständig übertragbare und möglicherweise effizienter im Hinblick auf die ressourcenanforderungen des Betriebssystems.</span><span class="sxs-lookup"><span data-stu-id="88e9a-186">The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</span></span>  
  
-   <span data-ttu-id="88e9a-187"><xref:System.Threading.WaitHandle>-Objekte repräsentieren Objekte des Betriebssystems, die in der Lage sind, ihre Ausführung zu unterbrechen und zu warten. Sie sind für die Synchronisierung zwischen verwaltetem und nicht verwaltetem Code von Nutzen und machen einige höhere Betriebssystemfunktionen verfügbar, z. B. die Fähigkeit, auf viele Objekte gleichzeitig zu warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-187"><xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="88e9a-188">Im folgenden Beispiel wird die <xref:System.Threading.Monitor> Klasse zum Synchronisieren des Zugriffs auf eine einzelne Instanz eines Zufallszahlengenerators dargestellt durch die <xref:System.Random> Klasse.</span><span class="sxs-lookup"><span data-stu-id="88e9a-188">The following example uses the <xref:System.Threading.Monitor> class to synchronize access to a single instance of a random number generator represented by the <xref:System.Random> class.</span></span> <span data-ttu-id="88e9a-189">Das Beispiel erstellt die zehn Aufgaben, von die jede asynchron über einen Threadpoolthread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-189">The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</span></span> <span data-ttu-id="88e9a-190">Jede Aufgabe 10.000 Zufallszahlen generiert, deren Mittelwert berechnet und zwei auf Prozedurebene-Variablen, die eine laufende Summe der Anzahl von Zufallszahlen generiert und deren Summe verwalten aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="88e9a-190">Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</span></span> <span data-ttu-id="88e9a-191">Nachdem alle Aufgaben ausgeführt haben, werden diese beiden Werte berechnet den Mittelwert den insgesamt verwendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-191">After all tasks have executed, these two values are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="88e9a-192">Da sie von einer Aufgabe, die über einen Threadpoolthread ausgeführt zugegriffen werden können, der Zugriff auf die Variablen `total` und `n` müssen synchronisiert werden.</span><span class="sxs-lookup"><span data-stu-id="88e9a-192">Because they can be accessed from any task running on a thread pool thread, access to the variables `total` and `n` must also be synchronized.</span></span> <span data-ttu-id="88e9a-193">Die <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> Methode für diesen Zweck verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-193">The <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> method is used for this purpose.</span></span>  
  
 <span data-ttu-id="88e9a-194">Im folgende Beispiel wird veranschaulicht, die kombinierte Verwendung von der <xref:System.Threading.Monitor> Klasse (implementiert mit der `lock` oder `SyncLock` Sprachkonstrukt), wird die <xref:System.Threading.Interlocked> -Klasse, und die <xref:System.Threading.AutoResetEvent> Klasse.</span><span class="sxs-lookup"><span data-stu-id="88e9a-194">The following example demonstrates the combined use of the <xref:System.Threading.Monitor> class (implemented with the `lock` or `SyncLock` language construct), the <xref:System.Threading.Interlocked> class, and the <xref:System.Threading.AutoResetEvent> class.</span></span> <span data-ttu-id="88e9a-195">Er definiert zwei `internal` (in c#) oder `Friend` (in Visual Basic) Klassen `SyncResource` und `UnSyncResource`, die entsprechend synchronisierten und nicht synchronisierten Zugriff auf eine Ressource bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-195">It defines two `internal` (in C#) or `Friend` (in Visual Basic) classes, `SyncResource` and `UnSyncResource`, that respectively provide synchronized and unsynchronized access to a resource.</span></span> <span data-ttu-id="88e9a-196">Um sicherzustellen, dass das Beispiel veranschaulicht den Unterschied zwischen dem synchronisierten und nicht synchronisierten Zugriff (das der Fall sein kann, wenn jeder Methodenaufruf schnell abgeschlossen wird), enthält die Methode eine zufällige Verzögerung: für threads, deren <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> Eigenschaft geraden Wert hat, ist die Methodenaufrufe <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> um eine Verzögerung von 2.000 Millisekunden einzuführen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-196">To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property is even, the method calls <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> to introduce a delay of 2,000 milliseconds.</span></span> <span data-ttu-id="88e9a-197">Beachten Sie Folgendes: Da die `SyncResource` Klasse ist nicht öffentlich ist, wird keines der Clientcode eine Sperre für die synchronisierte Ressource; die Sperre wird von die interne Klasse selbst ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="88e9a-197">Note that, because the `SyncResource` class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</span></span> <span data-ttu-id="88e9a-198">Dadurch wird verhindert, dass bösartiger Code eine Sperre für ein öffentliches Objekt auslöst.</span><span class="sxs-lookup"><span data-stu-id="88e9a-198">This prevents malicious code from taking a lock on a public object.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 <span data-ttu-id="88e9a-199">Im Beispiel wird eine Variable, `numOps`, definiert die Anzahl der Threads, die versucht, auf die Ressource zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-199">The example defines a variable, `numOps`, that defines the number of threads that will attempt to access the resource.</span></span> <span data-ttu-id="88e9a-200">Der Anwendungsthread Ruft die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> Methode für synchronisierten und nicht synchronisierten Zugriff auf fünf Mal jedes.</span><span class="sxs-lookup"><span data-stu-id="88e9a-200">The application thread calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method for synchronized and unsynchronized access five times each.</span></span> <span data-ttu-id="88e9a-201">Die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> Methode verfügt über einen einzelnen Parameter, ein Delegat, der keine Parameter akzeptiert und keinen Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-201">The <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method has a single parameter, a delegate that accepts no parameters and returns no value.</span></span> <span data-ttu-id="88e9a-202">Für synchronisierten Zugriff und ruft die `SyncUpdateResource` Methode für nicht synchronisierten Zugriff Ruft die `UnSyncUpdateResource` Methode.</span><span class="sxs-lookup"><span data-stu-id="88e9a-202">For synchronized access, it invokes the `SyncUpdateResource` method; for unsynchronized access, it invokes the `UnSyncUpdateResource` method.</span></span> <span data-ttu-id="88e9a-203">Nach jedem Satz von Methodenaufrufen, ruft der Anwendungsthread die [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) Methode, sodass, bis blockiert die <xref:System.Threading.AutoResetEvent> -Instanz signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-203">After each set of method calls, the application thread calls the [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) method so that it blocks until the <xref:System.Threading.AutoResetEvent> instance is signaled.</span></span>  
  
 <span data-ttu-id="88e9a-204">Bei jedem Aufruf der `SyncUpdateResource` -Methode wird die interne `SyncResource.Access` -Methode und ruft dann die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode dekrementiert die `numOps` Leistungsindikator.</span><span class="sxs-lookup"><span data-stu-id="88e9a-204">Each call to the `SyncUpdateResource` method calls the internal `SyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="88e9a-205">Die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode wird verwendet, um den Zähler zu verringern, da andernfalls Sie nicht davon ausgehen können, dass ein zweiter Thread den Wert zugreift, vor ein ersten Thread dekrementiert Wert in der Variablen gespeichert wurde.</span><span class="sxs-lookup"><span data-stu-id="88e9a-205">The <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</span></span> <span data-ttu-id="88e9a-206">Wenn die letzte synchronisierte Arbeitsthread dekrementiert den Zähler auf 0 (null), gibt an, dass alle synchronisierten Threads Zugriff auf die Ressource abgeschlossen haben die `SyncUpdateResource` Methodenaufrufe der <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> -Methode, die den Hauptthread zu fortfahren signalisiert die Ausführung.</span><span class="sxs-lookup"><span data-stu-id="88e9a-206">When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the `SyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="88e9a-207">Bei jedem Aufruf der `UnSyncUpdateResource` -Methode wird die interne `UnSyncResource.Access` -Methode und ruft dann die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode dekrementiert die `numOps` Leistungsindikator.</span><span class="sxs-lookup"><span data-stu-id="88e9a-207">Each call to the `UnSyncUpdateResource` method calls the internal `UnSyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="88e9a-208">Noch einmal: die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode wird verwendet, um die dekrementiert des Zähler, um sicherzustellen, dass ein zweiter Thread nicht den Wert zugreift, bevor der Variablen dekrementierte Wert des ersten Threads zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="88e9a-208">Once again, the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</span></span> <span data-ttu-id="88e9a-209">Bei der letzten Worker dekrementiert den Zähler auf 0 (null) wurden nicht synchronisierte, gibt an, dass keine weiteren Threads nicht synchronisierten Zugriff auf die Ressource benötigen die `UnSyncUpdateResource` Methodenaufrufe der <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> -Methode, die signalisiert den Hauptthread die Ausführung fortsetzen .</span><span class="sxs-lookup"><span data-stu-id="88e9a-209">When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the `UnSyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="88e9a-210">Wie die Ausgabe des Beispiels zeigt, wird mit synchronisiertem Zugriff sichergestellt, dass der aufrufende Thread die geschützte Ressource beendet, bevor ein anderer Thread auf sie zugreifen kann. Jeder Thread wartet auf seinen Vorgänger.</span><span class="sxs-lookup"><span data-stu-id="88e9a-210">As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</span></span> <span data-ttu-id="88e9a-211">Andererseits, ohne die Sperre der `UnSyncResource.Access` Methode wird aufgerufen, in der Reihenfolge, in der Threads wird erreicht.</span><span class="sxs-lookup"><span data-stu-id="88e9a-211">On the other hand, without the lock, the `UnSyncResource.Access` method is called in the order in which threads reach it.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="88e9a-212">Dieser Typ ist threadsicher.</span>
      <span class="sxs-lookup">
        <span data-stu-id="88e9a-212">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="88e9a-213">Erhält eine exklusive Sperre für ein angegebenes Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-213">Acquires an exclusive lock on a specified object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-214">Das Objekt, für das die Monitorsperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-214">The object on which to acquire the monitor lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-215">Erhält eine exklusive Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-215">Acquires an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-216">Verwendung `Enter` beim Abrufen der <xref:System.Threading.Monitor> für das Objekt als Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-216">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter.</span></span> <span data-ttu-id="88e9a-217">Wenn ein anderer Thread ausgeführt hat ein `Enter` für das Objekt jedoch noch nicht den entsprechenden ausgeführt wurde <xref:System.Threading.Monitor.Exit%2A>, wird der aktuelle Thread blockiert, bis der andere Thread das Objekt frei.</span><span class="sxs-lookup"><span data-stu-id="88e9a-217">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="88e9a-218">Es ist zulässig, für den gleichen Thread aufzurufenden `Enter` mehr als einmal ohne er blockiert, aber eine gleiche Anzahl von `Exit` Aufrufe aufgerufen werden müssen, bevor die Blockierung von anderen Threads warten auf das Objekt aufgehoben werden.</span><span class="sxs-lookup"><span data-stu-id="88e9a-218">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="88e9a-219">Verwendung <xref:System.Threading.Monitor> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-219">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="88e9a-220">Wenn Sie eine Werttypvariable zu übergeben `Enter`, dieser wird als Objekt geschachtelt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-220">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="88e9a-221">Wenn Sie die gleiche Variable übergeben `Enter` erneut, dieser wird jedoch als separates Objekt geschachtelt und der Thread wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="88e9a-221">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="88e9a-222">In diesem Fall wird der Code, `Monitor` ist eigentlich schützen soll, ist nicht geschützt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-222">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="88e9a-223">Darüber hinaus wird beim Übergeben der Variablen an `Exit`, noch ein anderes separates Objekt erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-223">Furthermore, when you pass the variable to `Exit`, still another separate object is created.</span></span> <span data-ttu-id="88e9a-224">Da das Objekt übergeben `Exit` unterscheidet sich von der an übergebene Objekt `Enter`, `Monitor` löst <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-224">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="88e9a-225">Weitere Informationen finden Sie unter dem Thema [Monitore](xref:System.Threading.Monitor).</span><span class="sxs-lookup"><span data-stu-id="88e9a-225">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="88e9a-226"><xref:System.Threading.Thread.Interrupt%2A> können unterbrechen, Threads, die darauf warten, geben einen `Monitor` für ein Objekt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-226"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="88e9a-227">Ein <xref:System.Threading.ThreadInterruptedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="88e9a-227">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
 <span data-ttu-id="88e9a-228">Verwenden Sie eine C#- `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="88e9a-228">Use a C# `try`…`finally`</span></span> <span data-ttu-id="88e9a-229">Block (`Try`...`Finally`</span><span class="sxs-lookup"><span data-stu-id="88e9a-229">block (`Try`…`Finally`</span></span> <span data-ttu-id="88e9a-230">in Visual Basic) stellen Sie sicher, dass den Monitor freigegeben wird, oder verwenden Sie die C#- `lock` Anweisung (`SyncLock` -Anweisung in Visual Basic), welche umschließt die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methoden in einer `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="88e9a-230">in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`…`finally`</span></span> <span data-ttu-id="88e9a-231">Block.</span><span class="sxs-lookup"><span data-stu-id="88e9a-231">block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="88e9a-232">Im folgenden Beispiel wird die Verwendung der `Enter`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="88e9a-232">The following example demonstrates how to use the `Enter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-233">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-233">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-234">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-234">The object on which to wait.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="88e9a-235">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-235">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="88e9a-236">Die Eingabe muss <see langword="false" /> sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-236">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="88e9a-237">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-237">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="88e9a-238">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-238">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
          <span data-ttu-id="88e9a-239">Hinweis   Wenn keine Ausnahme auftritt, ist die Ausgabe dieser Methode immer <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-239">Note   If no exception occurs, the output of this method is always <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-240">Erhält eine exklusive Sperre für das angegebene Objekt und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-240">Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-241">Verwendung `Enter` zum Abrufen der <xref:System.Threading.Monitor> für das Objekt übergeben, als die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="88e9a-241">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter.</span></span> <span data-ttu-id="88e9a-242">Wenn ein anderer Thread ausgeführt hat ein `Enter` für das Objekt jedoch noch nicht den entsprechenden ausgeführt wurde <xref:System.Threading.Monitor.Exit%2A>, wird der aktuelle Thread blockiert, bis der andere Thread das Objekt frei.</span><span class="sxs-lookup"><span data-stu-id="88e9a-242">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="88e9a-243">Es ist zulässig, für den gleichen Thread aufzurufenden `Enter` mehr als einmal ohne er blockiert, aber eine gleiche Anzahl von `Exit` Aufrufe aufgerufen werden müssen, bevor die Blockierung von anderen Threads warten auf das Objekt aufgehoben werden.</span><span class="sxs-lookup"><span data-stu-id="88e9a-243">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="88e9a-244">Wenn die Sperre nicht angenommen wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` Parameter ist `false` nachdem diese Methode beendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-244">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="88e9a-245">Dadurch wird das Programm in allen Fällen um zu bestimmen, ob die Sperre aufgehoben werden muss.</span><span class="sxs-lookup"><span data-stu-id="88e9a-245">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span> <span data-ttu-id="88e9a-246">Wenn diese Methode zurückgibt, ohne eine Ausnahme auszulösen, wird die Variable angegeben, für die `lockTaken` -Parameter ist immer `true`, und besteht keine Notwendigkeit zum Testen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-246">If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.</span></span>  
  
 <span data-ttu-id="88e9a-247">Verwendung <xref:System.Threading.Monitor> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-247">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="88e9a-248">Wenn Sie eine Werttypvariable zu übergeben `Enter`, dieser wird als Objekt geschachtelt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-248">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="88e9a-249">Wenn Sie die gleiche Variable übergeben `Enter` erneut, dieser wird jedoch als separates Objekt geschachtelt und der Thread wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="88e9a-249">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="88e9a-250">In diesem Fall wird der Code, `Monitor` ist eigentlich schützen soll, ist nicht geschützt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-250">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="88e9a-251">Darüber hinaus wird beim Übergeben der Variablen an `Exit`, ein weiteres separates Objekt erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-251">Furthermore, when you pass the variable to `Exit`, another separate object is created.</span></span> <span data-ttu-id="88e9a-252">Da das Objekt übergeben `Exit` unterscheidet sich von der an übergebene Objekt `Enter`, `Monitor` löst <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-252">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="88e9a-253">Weitere Informationen finden Sie unter dem Thema [Monitore](xref:System.Threading.Monitor).</span><span class="sxs-lookup"><span data-stu-id="88e9a-253">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="88e9a-254"><xref:System.Threading.Thread.Interrupt%2A> können unterbrechen, Threads, die darauf warten, geben einen `Monitor` für ein Objekt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-254"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="88e9a-255">Ein <xref:System.Threading.ThreadInterruptedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="88e9a-255">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="88e9a-256">Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> -methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="88e9a-256">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="88e9a-257">Diese Überladung legt immer den Wert der Variablen, die an die `ref` Parameter (`ByRef` in Visual Basic) `lockTaken`, selbst wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Überprüfen ist, ob die Sperre besitzt, werden veröffentlicht.</span><span class="sxs-lookup"><span data-stu-id="88e9a-257">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="88e9a-258">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-258">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-259">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-259">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-260">Das Objekt, dessen Sperre aufgehoben werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-260">The object on which to release the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-261">Hebt eine exklusive Sperre für das angegebene Objekt auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-261">Releases an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-262">Der aufrufende Thread muss Besitzer der Sperre auf die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="88e9a-262">The calling thread must own the lock on the `obj` parameter.</span></span> <span data-ttu-id="88e9a-263">Wenn der aufrufende Thread die Sperre für das angegebene Objekt besitzt und eine gleiche Anzahl von machte `Exit` und <xref:System.Threading.Monitor.Enter%2A> für das Objekt aufgerufen wird, und klicken Sie dann die Sperre aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-263">If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released.</span></span> <span data-ttu-id="88e9a-264">Wenn der aufrufende Thread nicht aufgerufen hat `Exit` so oft wie `Enter`, die Sperre wird nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-264">If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.</span></span>  
  
 <span data-ttu-id="88e9a-265">Wenn die Sperre wird aufgehoben, und andere Threads befinden sich in die Warteschlange für abgearbeitete für das Objekt, ruft die einem der Threads die Sperre ab.</span><span class="sxs-lookup"><span data-stu-id="88e9a-265">If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</span></span> <span data-ttu-id="88e9a-266">Wenn andere Threads in der Warteschlange darauf warten, die Sperre erhalten werden, sie werden nicht automatisch verschoben, die Warteschlange für abgearbeitete beim Aufrufen des Besitzers der Sperre `Exit`.</span><span class="sxs-lookup"><span data-stu-id="88e9a-266">If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`.</span></span> <span data-ttu-id="88e9a-267">Rufen Sie zum Verschieben einer oder mehrere wartende Threads in die Warteschlange für abgearbeitete <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> vor dem Aufrufen `Exit`.</span><span class="sxs-lookup"><span data-stu-id="88e9a-267">To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="88e9a-268">Im folgenden Beispiel wird die Verwendung der `Exit`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="88e9a-268">The following example demonstrates how to use the `Exit` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-269">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-269">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="88e9a-270">Der aktuelle Thread besitzt die Sperre für das angegebene Objekt nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-270">The current thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-271">Das zu überprüfende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-271">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-272">Bestimmt, ob der aktuelle Thread die Sperre für das angegebene Objekt enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-272">Determines whether the current thread holds the lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="88e9a-273">
            <see langword="true" />, wenn der aktuelle Thread die Schreibsperre für <paramref name="obj" /> enthält, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-273">
              <see langword="true" /> if the current thread holds the lock on <paramref name="obj" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-274">Diese Methode funktioniert nur bei Sperren, die mit den Methoden der erworben wurden die <xref:System.Threading.Monitor> Klasse oder mithilfe von C#- `lock` -Anweisung oder die Visual Basic `SyncLock` -Anweisung, die mit implementiert werden <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-274">This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="88e9a-275">Verwenden Sie diese Methode mit Diagnosetools wie z. B. die <xref:System.Diagnostics.Debug.Assert%2A> Methode und die <xref:System.Diagnostics.Contracts.Contract> -Klasse, um Probleme zu debuggen, bei denen, die <xref:System.Threading.Monitor> Klasse.</span><span class="sxs-lookup"><span data-stu-id="88e9a-275">Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-276">
            <paramref name="obj" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-276">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-277">Das Objekt, auf das ein Thread wartet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-277">The object a thread is waiting for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-278">Benachrichtigt einen Thread in der Warteschlange für abzuarbeitende Threads über eine Änderung am Zustand des gesperrten Objekts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-278">Notifies a thread in the waiting queue of a change in the locked object's state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-279">Nur der aktuelle Besitzer der Sperre ein wartende mithilfe signalisieren kann `Pulse`.</span><span class="sxs-lookup"><span data-stu-id="88e9a-279">Only the current owner of the lock can signal a waiting object using `Pulse`.</span></span>  
  
 <span data-ttu-id="88e9a-280">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um der nächste Thread in der Zeile für die Sperre zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="88e9a-280">The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</span></span> <span data-ttu-id="88e9a-281">Nach dem Empfang der Pulse wird wird des wartenden Threads in die Warteschlange für abgearbeitete verschoben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-281">Upon receiving the pulse, the waiting thread is moved to the ready queue.</span></span> <span data-ttu-id="88e9a-282">Wenn der Thread aufgerufen `Pulse` hebt die Sperre der nächste Thread in die Warteschlange für abgearbeitete (Dies ist nicht notwendigerweise dem Thread, der Impuls empfangen hat) Ruft die Sperre ab.</span><span class="sxs-lookup"><span data-stu-id="88e9a-282">When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="88e9a-283">Die <xref:System.Threading.Monitor> Klasse behält Status zeigt an, dass die <xref:System.Threading.Monitor.Pulse%2A> -Methode aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="88e9a-283">The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called.</span></span> <span data-ttu-id="88e9a-284">Daher beim Aufrufen <xref:System.Threading.Monitor.Pulse%2A> Wenn keine Threads warten, den nächsten Thread, der aufruft <xref:System.Threading.Monitor.Wait%2A> Blöcke wie <xref:System.Threading.Monitor.Pulse%2A> nie aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="88e9a-284">Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called.</span></span> <span data-ttu-id="88e9a-285">Wenn zwei Threads verwenden <xref:System.Threading.Monitor.Pulse%2A> und <xref:System.Threading.Monitor.Wait%2A> um interagieren, könnte dies zu einem Deadlock.</span><span class="sxs-lookup"><span data-stu-id="88e9a-285">If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock.</span></span> <span data-ttu-id="88e9a-286">Vergleichen Sie dies mit dem Verhalten von der <xref:System.Threading.AutoResetEvent> Klasse: Wenn Sie zu signalisieren ein <xref:System.Threading.AutoResetEvent> durch Aufrufen seiner <xref:System.Threading.EventWaitHandle.Set%2A> -Methode, und es sind keine Threads, die darauf warten, die <xref:System.Threading.AutoResetEvent> verbleibt jedoch in den signalisierten Zustand, bis ein Thread aufruft, <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, oder <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-286">Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="88e9a-287">Die <xref:System.Threading.AutoResetEvent> dieser Thread freigibt und in den nicht signalisierten Zustand zurück.</span><span class="sxs-lookup"><span data-stu-id="88e9a-287">The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.</span></span>  
  
 <span data-ttu-id="88e9a-288">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange auf dem enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-288">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="88e9a-289">Die `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, und <xref:System.Threading.Monitor.Wait%2A> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-289">The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="88e9a-290">Mehrere Threads signalisiert werden, verwenden die <xref:System.Threading.Monitor.PulseAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="88e9a-290">To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-291">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-291">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="88e9a-292">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-292">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-293">Das Objekt, das den Impuls sendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-293">The object that sends the pulse.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-294">Benachrichtigt alle wartenden Threads über eine Änderung am Zustand des Objekts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-294">Notifies all waiting threads of a change in the object's state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-295">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um alle Threads, die darauf warten, der eine Sperre für das Objekt zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="88e9a-295">The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</span></span> <span data-ttu-id="88e9a-296">Nach dem Senden des Signals werden die wartende Threads in die Warteschlange für abgearbeitete verschoben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-296">After the signal is sent, the waiting threads are moved to the ready queue.</span></span> <span data-ttu-id="88e9a-297">Wenn der Thread aufgerufen `PulseAll` hebt die Sperre der nächste Thread in die Warteschlange für abgearbeitete Ruft die Sperre ab.</span><span class="sxs-lookup"><span data-stu-id="88e9a-297">When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.</span></span>  
  
 <span data-ttu-id="88e9a-298">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange auf dem enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-298">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="88e9a-299">Die <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, und <xref:System.Threading.Monitor.Wait%2A> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-299">The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="88e9a-300">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode wird erläutert, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-300">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 <span data-ttu-id="88e9a-301">Verwenden Sie einen einzelnen Thread signalisiert werden, die `Pulse` Methode.</span><span class="sxs-lookup"><span data-stu-id="88e9a-301">To signal a single thread, use the `Pulse` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-302">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-302">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="88e9a-303">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-303">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="88e9a-304">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-304">Attempts to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-305">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-305">The object on which to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-306">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-306">Attempts to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="88e9a-307">
            <see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-307">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-308">Wenn erfolgreich ist, diese Methode eine exklusive Sperre für erhält die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="88e9a-308">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="88e9a-309">Diese Methode gibt sofort zurück, unabhängig davon, ob die Sperre verfügbar wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-309">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="88e9a-310">Diese Methode ist vergleichbar mit <xref:System.Threading.Monitor.Enter%2A>, aber es wird nie blockiert den aktuellen Thread.</span><span class="sxs-lookup"><span data-stu-id="88e9a-310">This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread.</span></span> <span data-ttu-id="88e9a-311">Wenn der Thread ohne Blockierung eingegeben werden kann, gibt die Methode `false,`.</span><span class="sxs-lookup"><span data-stu-id="88e9a-311">If the thread cannot enter without blocking, the method returns `false,`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-312">Verwendung <xref:System.Threading.Monitor> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-312">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="88e9a-313">Weitere Informationen finden Sie unter der <xref:System.Threading.Monitor> Artikel.</span><span class="sxs-lookup"><span data-stu-id="88e9a-313">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="88e9a-314">Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in den kritischen Abschnitt nur, wenn der Rückgabewert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="88e9a-314">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="88e9a-315">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-315">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="88e9a-316">Beachten Sie, die Sie aufrufen sollte <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-316">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="88e9a-317">Das folgende Codebeispiel zeigt, wie Sie die `TryEnter`-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="88e9a-317">The following code example demonstrates how to use the `TryEnter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-318">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-318">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-319">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-319">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="88e9a-320">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-320">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="88e9a-321">Die Eingabe muss <see langword="false" /> sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-321">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="88e9a-322">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-322">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="88e9a-323">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-323">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-324">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-324">Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-325">Wenn erfolgreich ist, diese Methode eine exklusive Sperre für erhält die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="88e9a-325">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="88e9a-326">Diese Methode gibt sofort zurück, unabhängig davon, ob die Sperre verfügbar wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-326">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="88e9a-327">Wenn die Sperre nicht angenommen wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` Parameter ist `false` nachdem diese Methode beendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-327">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="88e9a-328">Dadurch wird das Programm in allen Fällen um zu bestimmen, ob die Sperre aufgehoben werden muss.</span><span class="sxs-lookup"><span data-stu-id="88e9a-328">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
 <span data-ttu-id="88e9a-329">Diese Methode ist vergleichbar mit <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, aber es wird nie blockiert den aktuellen Thread.</span><span class="sxs-lookup"><span data-stu-id="88e9a-329">This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread.</span></span> <span data-ttu-id="88e9a-330">Wenn der Thread nicht, ohne zu blockieren betreten kann, die `lockTaken` -Argument festgelegt wird `false` bei Rückgabe der Methode.</span><span class="sxs-lookup"><span data-stu-id="88e9a-330">If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-331">Verwendung <xref:System.Threading.Monitor> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-331">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="88e9a-332">Weitere Informationen finden Sie im Artikel <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-332">For more information, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="88e9a-333">Um sicherzustellen, dass der Thread ist nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der `lockTaken` und Ausführen von Code in den kritischen Abschnitt nur, wenn der Wert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="88e9a-333">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="88e9a-334">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-334">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="88e9a-335">Beachten Sie, die Sie aufrufen sollte <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-335">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="88e9a-336">Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> -methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="88e9a-336">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="88e9a-337">Diese Überladung legt immer den Wert der Variablen, die an die `ref` Parameter (`ByRef` in Visual Basic) `lockTaken`, selbst wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Überprüfen ist, ob die Sperre besitzt, werden veröffentlicht.</span><span class="sxs-lookup"><span data-stu-id="88e9a-337">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="88e9a-338">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-338">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-339">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-339">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-340">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-340">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="88e9a-341">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-341">The number of milliseconds to wait for the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-342">Versucht über eine angegebene Anzahl von Millisekunden hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-342">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="88e9a-343">
            <see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-343">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-344">Wenn die `millisecondsTimeout` entspricht <xref:System.Threading.Timeout.Infinite>, diese Methode ist gleichbedeutend mit <xref:System.Threading.Monitor.Enter%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-344">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="88e9a-345">Wenn `millisecondsTimeout` gleich 0 ist, diese Methode ist gleichbedeutend mit <xref:System.Threading.Monitor.TryEnter%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-345">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-346">Verwendung <xref:System.Threading.Monitor> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-346">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="88e9a-347">Weitere Informationen finden Sie unter der <xref:System.Threading.Monitor> Artikel.</span><span class="sxs-lookup"><span data-stu-id="88e9a-347">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="88e9a-348">Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in den kritischen Abschnitt nur, wenn der Rückgabewert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="88e9a-348">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="88e9a-349">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-349">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="88e9a-350">Beachten Sie, die Sie aufrufen sollte <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-350">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-351">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-351">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="88e9a-352">
            <paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-352">
              <paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-353">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-353">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="88e9a-354">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne darstellt, für die auf die Sperre gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-354">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait for the lock.</span>
          </span>
          <span data-ttu-id="88e9a-355">Ein Wert von -1 Millisekunde gibt eine unbegrenzte Wartezeit an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-355">A value of –1 millisecond specifies an infinite wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-356">Versucht über einen angegebenen Zeitraum hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-356">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="88e9a-357">
            <see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-357">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-358">Wenn der Wert der `timeout` entspricht in Millisekunden konvertiert – 1, diese Methode ist äquivalent zu <xref:System.Threading.Monitor.Enter%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-358">If the value of the `timeout` parameter converted to milliseconds equals –1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="88e9a-359">Wenn der Wert der `timeout` gleich 0 ist, diese Methode ist gleichbedeutend mit <xref:System.Threading.Monitor.TryEnter%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-359">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-360">Verwendung <xref:System.Threading.Monitor> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-360">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="88e9a-361">Einzelheiten finden Sie in der <xref:System.Threading.Monitor> klassenthema.</span><span class="sxs-lookup"><span data-stu-id="88e9a-361">For details, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="88e9a-362">Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in den kritischen Abschnitt nur, wenn der Rückgabewert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="88e9a-362">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="88e9a-363">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-363">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="88e9a-364">Beachten Sie, die Sie aufrufen sollte <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-364">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-365">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-365">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="88e9a-366">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-366">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-367">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-367">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="88e9a-368">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-368">The number of milliseconds to wait for the lock.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="88e9a-369">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-369">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="88e9a-370">Die Eingabe muss <see langword="false" /> sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-370">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="88e9a-371">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-371">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="88e9a-372">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-372">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-373">Versucht für die angegebene Anzahl von Millisekunden, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-373">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-374">Wenn die `millisecondsTimeout` entspricht <xref:System.Threading.Timeout.Infinite>, diese Methode ist gleichbedeutend mit <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-374">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="88e9a-375">Wenn `millisecondsTimeout` gleich 0 ist, diese Methode ist gleichbedeutend mit <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-375">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="88e9a-376">Wenn die Sperre nicht angenommen wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` Parameter ist `false` nachdem diese Methode beendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-376">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="88e9a-377">Dadurch wird das Programm in allen Fällen um zu bestimmen, ob die Sperre aufgehoben werden muss.</span><span class="sxs-lookup"><span data-stu-id="88e9a-377">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-378">Verwendung <xref:System.Threading.Monitor> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-378">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="88e9a-379">Weitere Informationen finden Sie unter der <xref:System.Threading.Monitor> klassenthema.</span><span class="sxs-lookup"><span data-stu-id="88e9a-379">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="88e9a-380">Um sicherzustellen, dass der Thread ist nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der `lockTaken` und Ausführen von Code in den kritischen Abschnitt nur, wenn der Wert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="88e9a-380">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="88e9a-381">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-381">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="88e9a-382">Beachten Sie, die Sie aufrufen sollte <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-382">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="88e9a-383">Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> -methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="88e9a-383">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="88e9a-384">Diese Überladung legt immer den Wert der Variablen, die an die `ref` Parameter (`ByRef` in Visual Basic) `lockTaken`, selbst wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Überprüfen ist, ob die Sperre besitzt, werden veröffentlicht.</span><span class="sxs-lookup"><span data-stu-id="88e9a-384">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="88e9a-385">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-385">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-386">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-386">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="88e9a-387">
            <paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-387">
              <paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-388">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-388">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="88e9a-389">Die Zeitspanne, für die auf die Sperre gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-389">The amount of time to wait for the lock.</span>
          </span>
          <span data-ttu-id="88e9a-390">Ein Wert von -1 Millisekunde gibt eine unbegrenzte Wartezeit an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-390">A value of –1 millisecond specifies an infinite wait.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="88e9a-391">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-391">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="88e9a-392">Die Eingabe muss <see langword="false" /> sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-392">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="88e9a-393">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-393">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="88e9a-394">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-394">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-395">Versucht für die angegebene Dauer, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-395">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-396">Wenn der Wert der `timeout` entspricht in Millisekunden konvertiert – 1, diese Methode ist äquivalent zu <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-396">If the value of the `timeout` parameter converted to milliseconds equals –1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="88e9a-397">Wenn der Wert der `timeout` gleich 0 ist, diese Methode ist gleichbedeutend mit <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-397">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="88e9a-398">Wenn die Sperre nicht angenommen wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` Parameter ist `false` nachdem diese Methode beendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-398">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="88e9a-399">Dadurch wird das Programm in allen Fällen um zu bestimmen, ob die Sperre aufgehoben werden muss.</span><span class="sxs-lookup"><span data-stu-id="88e9a-399">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-400">Verwendung <xref:System.Threading.Monitor> zum Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-400">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="88e9a-401">Weitere Informationen finden Sie unter der <xref:System.Threading.Monitor> klassenthema.</span><span class="sxs-lookup"><span data-stu-id="88e9a-401">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="88e9a-402">Um sicherzustellen, dass der Thread ist nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der `lockTaken` und Ausführen von Code in den kritischen Abschnitt nur, wenn der Wert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="88e9a-402">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="88e9a-403">Das folgende Codefragment zeigt das Muster für Instanzenmethoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-403">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="88e9a-404">Beachten Sie, die Sie aufrufen sollte <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für die kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-404">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="88e9a-405">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-405">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-406">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-406">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="88e9a-407">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-407">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="88e9a-408">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-408">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-409">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-409">The object on which to wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-410">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-410">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="88e9a-411">
            <see langword="true" />, wenn der Aufruf beendet wurde, weil der Aufrufer die Sperre für das angegebene Objekt erneut erhalten hat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-411">
              <see langword="true" /> if the call returned because the caller reacquired the lock for the specified object.</span>
          </span>
          <span data-ttu-id="88e9a-412">Diese Methode wird nicht beendet, wenn die Sperre nicht erneut erhalten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-412">This method does not return if the lock is not reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-413">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freizugeben, sodass ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-413">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="88e9a-414">Der Aufrufer ist blockiert, beim Warten auf die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-414">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="88e9a-415">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten, die als Ergebnis von einem anderen Thread ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="88e9a-415">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="88e9a-416">Wenn ein Thread aufruft, `Wait`, hebt die Sperre für das Objekt ist, und wechselt in die Warteschlange für das Objekt auf.</span><span class="sxs-lookup"><span data-stu-id="88e9a-416">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="88e9a-417">Der nächste Thread in die Warteschlange für abgearbeitete des Objekts (sofern vorhanden) die Sperre erhält und bietet die exklusive Verwendung des Objekts.</span><span class="sxs-lookup"><span data-stu-id="88e9a-417">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="88e9a-418">Alle Threads, die aufgerufen werden `Wait` in der Warteschlange verbleiben, bis sie ein Signal von empfangen <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>, vom Besitzer der Sperre gesendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-418">All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock.</span></span> <span data-ttu-id="88e9a-419">Wenn `Pulse` gesendet wird, wird nur der Thread am Anfang der Warteschlange für abzuarbeitende beeinflusst.</span><span class="sxs-lookup"><span data-stu-id="88e9a-419">If `Pulse` is sent, only the thread at the head of the waiting queue is affected.</span></span> <span data-ttu-id="88e9a-420">Wenn `PulseAll` gesendet wird, werden alle Threads, die für das Objekt warten beeinflusst.</span><span class="sxs-lookup"><span data-stu-id="88e9a-420">If `PulseAll` is sent, all threads that are waiting for the object are affected.</span></span> <span data-ttu-id="88e9a-421">Wenn das Signal empfangen wird, einen oder mehrere Threads die Warteschlange für abzuarbeitende lassen, und geben Sie die Warteschlange für abgearbeitete.</span><span class="sxs-lookup"><span data-stu-id="88e9a-421">When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</span></span> <span data-ttu-id="88e9a-422">Ein Thread in die Warteschlange für abgearbeitete ist zulässig, die Sperre erneut.</span><span class="sxs-lookup"><span data-stu-id="88e9a-422">A thread in the ready queue is permitted to reacquire the lock.</span></span>  
  
 <span data-ttu-id="88e9a-423">Diese Methode gibt zurück, wenn der aufrufende Thread die Sperre für das Objekt erneut erhält.</span><span class="sxs-lookup"><span data-stu-id="88e9a-423">This method returns when the calling thread reacquires the lock on the object.</span></span> <span data-ttu-id="88e9a-424">Beachten Sie, die diese Methode auf unbestimmte Zeit blockiert werden, wenn der Besitzer der Sperre nicht aufruft `Pulse` oder `PulseAll`.</span><span class="sxs-lookup"><span data-stu-id="88e9a-424">Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.</span></span>  
  
 <span data-ttu-id="88e9a-425">Der Aufrufer führt `Wait` einmal, unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-425">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="88e9a-426">Im Prinzip die `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer `Enter` für das Objekt und ruft `Exit` so oft wie nötig, um das gesperrte Objekt vollständig freizugeben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-426">Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="88e9a-427">Der Aufrufer blockiert dann beim Warten auf das Objekt erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-427">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="88e9a-428">Wenn der Aufrufer die Sperre erneut erhält, das System ruft `Enter` so oft wie nötig, um die gespeicherte wiederherstellen `Enter` Anzahl für den Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="88e9a-428">When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller.</span></span> <span data-ttu-id="88e9a-429">Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, werden diese Sperren nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-429">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
 <span data-ttu-id="88e9a-430">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange auf dem enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-430">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="88e9a-431">Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-431">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="88e9a-432">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode wird erläutert, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-432">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-433">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-433">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="88e9a-434">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-434">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="88e9a-435">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-435">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="88e9a-436">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-436">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-437">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-437">The object on which to wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="88e9a-438">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-438">The number of milliseconds to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-439">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-439">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="88e9a-440">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-440">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="88e9a-441">
            <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-441">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="88e9a-442">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-442">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-443">Diese Methode gibt keinen zurück, bis er auf die erneut eine exklusive Sperre erhält die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="88e9a-443">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="88e9a-444">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freizugeben, sodass ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-444">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="88e9a-445">Der Aufrufer ist blockiert, beim Warten auf die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-445">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="88e9a-446">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten, die als Ergebnis von einem anderen Thread ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="88e9a-446">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="88e9a-447">Das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="88e9a-447">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="88e9a-448">Er verschiebt auch den Thread in die Warteschlange für abgearbeitete Threads in der Warteschlange, damit er die Sperre früher zurückzuerhalten kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-448">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="88e9a-449">Der Thread kann den Rückgabewert der Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die sie zur Eingabe des Wartevorgangs verursacht auswerten und, wenn notwendig Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut.</span><span class="sxs-lookup"><span data-stu-id="88e9a-449">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="88e9a-450">Wenn ein Thread aufruft, `Wait`, hebt die Sperre für das Objekt ist, und wechselt in die Warteschlange für das Objekt auf.</span><span class="sxs-lookup"><span data-stu-id="88e9a-450">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="88e9a-451">Der nächste Thread in die Warteschlange für abgearbeitete des Objekts (sofern vorhanden) die Sperre erhält und bietet die exklusive Verwendung des Objekts.</span><span class="sxs-lookup"><span data-stu-id="88e9a-451">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="88e9a-452">Der Thread, der aufgerufen `Wait` aufruft, verbleibt in der Warteschlange, bis entweder ein Thread die Sperre <xref:System.Threading.Monitor.PulseAll%2A>, oder es das nächste in der Warteschlange ist und ein Thread die Sperre wird aufgerufen <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-452">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="88e9a-453">Jedoch wenn `millisecondsTimeout` verstreicht, bevor ein anderer Thread auf dieses Objekt aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> -Methode, den ursprünglichen Thread wird in die Warteschlange für abgearbeitete verschoben, um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-453">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-454">Wenn <xref:System.Threading.Timeout.Infinite> wird angegeben, für die `millisecondsTimeout` Parameter, diese Methode blockiert dauerhaft, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-454">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="88e9a-455">Wenn `millisecondsTimeout` gleich 0 ist, der aufrufende Thread `Wait` hebt die Sperre und gelangt anschließend direkt in die Warteschlange für abgearbeitete um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-455">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="88e9a-456">Der Aufrufer führt `Wait` einmal, unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-456">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="88e9a-457">Im Prinzip die `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um das gesperrte Objekt vollständig freizugeben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-457">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="88e9a-458">Der Aufrufer blockiert dann beim Warten auf das Objekt erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-458">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="88e9a-459">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherte wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="88e9a-459">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="88e9a-460">Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, werden diese Sperren nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-460">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-461">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange, die enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-461">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="88e9a-462">Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-462">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="88e9a-463">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode wird erläutert, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-463">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-464">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-464">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="88e9a-465">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-465">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="88e9a-466">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-466">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="88e9a-467">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-467">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="88e9a-468">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-468">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-469">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-469">The object on which to wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="88e9a-470">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-470">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-471">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-471">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="88e9a-472">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-472">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="88e9a-473">
            <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-473">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="88e9a-474">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-474">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-475">Diese Methode gibt keinen zurück, bis er auf die erneut eine exklusive Sperre erhält die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="88e9a-475">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="88e9a-476">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freizugeben, sodass ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-476">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="88e9a-477">Der Aufrufer ist blockiert, beim Warten auf die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-477">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="88e9a-478">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten, die als Ergebnis von einem anderen Thread ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="88e9a-478">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="88e9a-479">Das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="88e9a-479">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="88e9a-480">Er verschiebt auch den Thread in die Warteschlange für abgearbeitete Threads in der Warteschlange, damit er die Sperre früher zurückzuerhalten kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-480">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="88e9a-481">Der Thread kann den Rückgabewert der Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die sie zur Eingabe des Wartevorgangs verursacht auswerten und, wenn notwendig Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut.</span><span class="sxs-lookup"><span data-stu-id="88e9a-481">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="88e9a-482">Wenn ein Thread aufruft, `Wait`, hebt die Sperre für das Objekt ist, und wechselt in die Warteschlange für das Objekt auf.</span><span class="sxs-lookup"><span data-stu-id="88e9a-482">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="88e9a-483">Der nächste Thread in die Warteschlange für abgearbeitete des Objekts (sofern vorhanden) die Sperre erhält und bietet die exklusive Verwendung des Objekts.</span><span class="sxs-lookup"><span data-stu-id="88e9a-483">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="88e9a-484">Der Thread, der aufgerufen `Wait` aufruft, verbleibt in der Warteschlange, bis entweder ein Thread die Sperre <xref:System.Threading.Monitor.PulseAll%2A>, oder es das nächste in der Warteschlange ist und ein Thread die Sperre wird aufgerufen <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-484">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="88e9a-485">Jedoch wenn `timeout` verstreicht, bevor ein anderer Thread auf dieses Objekt aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> -Methode, den ursprünglichen Thread wird in die Warteschlange für abgearbeitete verschoben, um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-485">However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-486">Wenn eine <xref:System.TimeSpan> -1 Millisekunde angegeben ist, für die `timeout` Parameter, diese Methode blockiert dauerhaft, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-486">If a <xref:System.TimeSpan> representing –1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="88e9a-487">Wenn `timeout` ist 0 Millisekunden, der aufrufende Thread `Wait` hebt die Sperre und gelangt anschließend direkt in die Warteschlange für abgearbeitete um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-487">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="88e9a-488">Der Aufrufer führt `Wait` einmal, unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-488">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="88e9a-489">Im Prinzip die `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um das gesperrte Objekt vollständig freizugeben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-489">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="88e9a-490">Der Aufrufer blockiert dann beim Warten auf das Objekt erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-490">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="88e9a-491">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherte wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="88e9a-491">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="88e9a-492">Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, werden diese Sperren nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-492">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-493">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange, die enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-493">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="88e9a-494">Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-494">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="88e9a-495">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode wird erläutert, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-495">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-496">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-496">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="88e9a-497">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-497">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="88e9a-498">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-498">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="88e9a-499">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-499">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="88e9a-500">Der Wert des <paramref name="timeout" />-Parameters in Millisekunden ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> (-1 Millisekunde) dar, oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-500">The value of the <paramref name="timeout" /> parameter in milliseconds is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-501">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-501">The object on which to wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="88e9a-502">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-502">The number of milliseconds to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="88e9a-503">
            <see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-503">
              <see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-504">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-504">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="88e9a-505">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-505">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
          <span data-ttu-id="88e9a-506">Diese Methode gibt außerdem an, ob die Synchronisierungsdomäne danach für den Kontext (wenn es sich um einen synchronisierten Kontext handelt) vor dem Warten und erneuten Erhalten verlassen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-506">This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="88e9a-507">
            <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-507">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="88e9a-508">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-508">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-509">Diese Methode gibt keinen zurück, bis er auf die erneut eine exklusive Sperre erhält die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="88e9a-509">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="88e9a-510">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freizugeben, sodass ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-510">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="88e9a-511">Der Aufrufer ist blockiert, beim Warten auf die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-511">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="88e9a-512">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten, die als Ergebnis von einem anderen Thread ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="88e9a-512">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="88e9a-513">Das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="88e9a-513">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="88e9a-514">Er verschiebt auch den Thread in die Warteschlange für abgearbeitete Threads in der Warteschlange, damit er die Sperre früher zurückzuerhalten kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-514">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="88e9a-515">Der Thread kann den Rückgabewert der Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die sie zur Eingabe des Wartevorgangs verursacht auswerten und, wenn notwendig Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut.</span><span class="sxs-lookup"><span data-stu-id="88e9a-515">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="88e9a-516">Wenn ein Thread aufruft, `Wait`, er hebt die Sperre und die Warteschlange für abzuarbeitende eingibt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-516">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="88e9a-517">An diesem Punkt der nächste Thread in die Warteschlange für abgearbeitete (sofern vorhanden) kann die Steuerung der Sperre.</span><span class="sxs-lookup"><span data-stu-id="88e9a-517">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="88e9a-518">Der Thread, der aufgerufen `Wait` aufruft, verbleibt in der Warteschlange, bis entweder ein Thread die Sperre <xref:System.Threading.Monitor.PulseAll%2A>, oder es das nächste in der Warteschlange ist und ein Thread die Sperre wird aufgerufen <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-518">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="88e9a-519">Jedoch wenn `millisecondsTimeout` verstreicht, bevor ein anderer Thread auf dieses Objekt aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> -Methode, den ursprünglichen Thread wird in die Warteschlange für abgearbeitete verschoben, um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-519">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-520">Wenn <xref:System.Threading.Timeout.Infinite> wird angegeben, für die `millisecondsTimeout` Parameter, diese Methode blockiert dauerhaft, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-520">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="88e9a-521">Wenn `millisecondsTimeout` gleich 0 ist, der aufrufende Thread `Wait` hebt die Sperre und gelangt anschließend direkt in die Warteschlange für abgearbeitete um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-521">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="88e9a-522">Der Aufrufer führt `Wait` einmal, unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-522">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="88e9a-523">Im Prinzip die `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um das gesperrte Objekt vollständig freizugeben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-523">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="88e9a-524">Der Aufrufer blockiert dann beim Warten auf das Objekt erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-524">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="88e9a-525">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherte wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="88e9a-525">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="88e9a-526">Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, werden diese Sperren nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-526">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-527">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange, die enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-527">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="88e9a-528">Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-528">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="88e9a-529">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode wird erläutert, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-529">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="88e9a-530">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="88e9a-530">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="88e9a-531">Die`exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.Monitor.Wait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-531">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="88e9a-532">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-532">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="88e9a-533">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="88e9a-533">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="88e9a-534">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.Monitor.Wait%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="88e9a-534">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="88e9a-535">Es gibt in den ursprünglich nicht standardmäßige nach dem Aufruf von der <xref:System.Threading.Monitor.Wait%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-535">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="88e9a-536">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über die <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> Attribut angewendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-536">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="88e9a-537">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="88e9a-537">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="88e9a-538">Wenn Code in der Aufrufliste eines Members Ruft die <xref:System.Threading.Monitor.Wait%2A> Methode und gibt an, `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-538">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="88e9a-539">Wenn die <xref:System.Threading.Monitor.Wait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="88e9a-539">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-540">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-540">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="88e9a-541">
            <see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-541">
              <see langword="Wait" /> is not invoked from within a synchronized block of code.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="88e9a-542">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-542">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="88e9a-543">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-543">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="88e9a-544">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-544">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="88e9a-545">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-545">The object on which to wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="88e9a-546">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-546">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="88e9a-547">
            <see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-547">
              <see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="88e9a-548">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-548">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="88e9a-549">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-549">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
          <span data-ttu-id="88e9a-550">Beendet vor dem Warten optional auch die Synchronisierungsdomäne für den synchronisierten Kontext und erhält die Domäne anschließend wieder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-550">Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="88e9a-551">
            <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-551">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="88e9a-552">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-552">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e9a-553">Diese Methode gibt keinen zurück, bis er auf die erneut eine exklusive Sperre erhält die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="88e9a-553">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="88e9a-554">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freizugeben, sodass ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-554">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="88e9a-555">Der Aufrufer ist blockiert, beim Warten auf die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-555">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="88e9a-556">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten, die als Ergebnis von einem anderen Thread ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="88e9a-556">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="88e9a-557">Das Timeout wird sichergestellt, dass der aktuelle Thread nicht unbegrenzt gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="88e9a-557">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="88e9a-558">Er verschiebt auch den Thread in die Warteschlange für abgearbeitete Threads in der Warteschlange, damit er die Sperre früher zurückzuerhalten kann.</span><span class="sxs-lookup"><span data-stu-id="88e9a-558">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="88e9a-559">Der Thread kann den Rückgabewert der Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die sie zur Eingabe des Wartevorgangs verursacht auswerten und, wenn notwendig Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut.</span><span class="sxs-lookup"><span data-stu-id="88e9a-559">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="88e9a-560">Wenn ein Thread aufruft, `Wait`, er hebt die Sperre und die Warteschlange für abzuarbeitende eingibt.</span><span class="sxs-lookup"><span data-stu-id="88e9a-560">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="88e9a-561">An diesem Punkt der nächste Thread in die Warteschlange für abgearbeitete (sofern vorhanden) kann die Steuerung der Sperre.</span><span class="sxs-lookup"><span data-stu-id="88e9a-561">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="88e9a-562">Der Thread, der aufgerufen `Wait` aufruft, verbleibt in der Warteschlange, bis entweder ein Thread die Sperre <xref:System.Threading.Monitor.PulseAll%2A>, oder es das nächste in der Warteschlange ist und ein Thread die Sperre wird aufgerufen <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-562">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="88e9a-563">Jedoch wenn `timeout` Millisekunden verstreichen, bevor ein anderer Thread auf dieses Objekt aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> -Methode, den ursprünglichen Thread wird in die Warteschlange für abgearbeitete verschoben, um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-563">However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-564">Wenn eine <xref:System.TimeSpan> -1 Millisekunde angegeben ist, für die `timeout` Parameter, diese Methode blockiert dauerhaft, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-564">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="88e9a-565">Wenn `timeout` ist 0 Millisekunden, der aufrufende Thread `Wait` hebt die Sperre und gelangt anschließend direkt in die Warteschlange für abgearbeitete um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-565">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="88e9a-566">Der Aufrufer führt `Wait` einmal, unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-566">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="88e9a-567">Im Prinzip die `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um das gesperrte Objekt vollständig freizugeben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-567">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="88e9a-568">Der Aufrufer blockiert dann beim Warten auf das Objekt erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-568">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="88e9a-569">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherte wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="88e9a-569">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="88e9a-570">Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, werden diese Sperren nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="88e9a-570">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="88e9a-571">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf die Warteschlange, die enthält die Threads, die für die Benachrichtigung über eine Änderung am Zustand des Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-571">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="88e9a-572">Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="88e9a-572">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="88e9a-573">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode wird erläutert, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="88e9a-573">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="88e9a-574">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="88e9a-574">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="88e9a-575">Die`exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.Monitor.Wait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-575">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="88e9a-576">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="88e9a-576">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="88e9a-577">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="88e9a-577">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="88e9a-578">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.Monitor.Wait%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="88e9a-578">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="88e9a-579">Es gibt in den ursprünglich nicht standardmäßige nach dem Aufruf von der <xref:System.Threading.Monitor.Wait%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-579">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="88e9a-580">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über die <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> Attribut angewendet.</span><span class="sxs-lookup"><span data-stu-id="88e9a-580">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="88e9a-581">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="88e9a-581">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="88e9a-582">Wenn Code in der Aufrufliste eines Members Ruft die <xref:System.Threading.Monitor.Wait%2A> Methode und gibt an, `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="88e9a-582">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="88e9a-583">Wenn die <xref:System.Threading.Monitor.Wait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="88e9a-583">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="88e9a-584">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-584">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="88e9a-585">
            <see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-585">
              <see langword="Wait" /> is not invoked from within a synchronized block of code.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="88e9a-586">Der Thread, der „Wait“ aufruft, wird später im Wartezustand unterbrochen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-586">The thread that invokes Wait is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="88e9a-587">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-587">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="88e9a-588">Der <paramref name="timeout" />-Parameter ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> dar (-1 Millisekunde), oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="88e9a-588">The <paramref name="timeout" /> parameter is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
  </Members>
</Type>