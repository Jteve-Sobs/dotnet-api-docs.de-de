<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="954622f2462225c1791594afeb678ab93b5bb509" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39989887" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="7eb02-101">Stellt einen Mechanismus bereit, der den Zugriff auf Objekte synchronisiert.</span>
      <span class="sxs-lookup">
        <span data-stu-id="7eb02-101">Provides a mechanism that synchronizes access to objects.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-102">Die <xref:System.Threading.Monitor> Klasse können Sie den Zugriff auf einen Codebereich synchronisieren, indem eine Sperre für ein bestimmtes Objekt durch Aufrufen der <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, und <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> Methoden.</span><span class="sxs-lookup"><span data-stu-id="7eb02-102">The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="7eb02-103">Objektsperren bieten die Möglichkeit, den Zugriff auf einen Codeblock, im Allgemeinen bezeichnet einen kritischen Abschnitt beschränken.</span><span class="sxs-lookup"><span data-stu-id="7eb02-103">Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</span></span> <span data-ttu-id="7eb02-104">Während ein Thread die Sperre für ein Objekt besitzt, kann kein anderer Thread diese Sperre abrufen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-104">While a thread owns the lock for an object, no other thread can acquire that lock.</span></span> <span data-ttu-id="7eb02-105">Sie können auch die <xref:System.Threading.Monitor> Klasse, um sicherzustellen, dass kein anderer Thread zulässig ist, eine Anwendung Zugriff auf code von der Besitzer der Sperre ausgeführt wird, es sei denn, der andere Thread den Code mithilfe eines anderen gesperrten Objekts ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-105">You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</span></span>  
  
 <span data-ttu-id="7eb02-106">In diesem Artikel:</span><span class="sxs-lookup"><span data-stu-id="7eb02-106">In this article:</span></span>  
  
 <span data-ttu-id="7eb02-107">[Die Monitor-Klasse: eine Übersicht über die](#Overview) </span><span class="sxs-lookup"><span data-stu-id="7eb02-107">[The Monitor class: An overview](#Overview) </span></span>  
 <span data-ttu-id="7eb02-108">[Das Sperrobjekt](#Lock) </span><span class="sxs-lookup"><span data-stu-id="7eb02-108">[The lock object](#Lock) </span></span>  
 <span data-ttu-id="7eb02-109">[Der kritische Abschnitt](#CriticalSection) </span><span class="sxs-lookup"><span data-stu-id="7eb02-109">[The critical section](#CriticalSection) </span></span>  
 <span data-ttu-id="7eb02-110">[Pulse "," PulseAll ", und warten](#Pulse) </span><span class="sxs-lookup"><span data-stu-id="7eb02-110">[Pulse, PulseAll, and Wait](#Pulse) </span></span>  
 [<span data-ttu-id="7eb02-111">Monitore und Wait-handles</span><span class="sxs-lookup"><span data-stu-id="7eb02-111">Monitors and wait handles</span></span>](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a><span data-ttu-id="7eb02-112">Die Monitor-Klasse: eine Übersicht über die</span><span class="sxs-lookup"><span data-stu-id="7eb02-112">The Monitor class: An overview</span></span>  
 <span data-ttu-id="7eb02-113"><xref:System.Threading.Monitor> bietet die folgenden Features:</span><span class="sxs-lookup"><span data-stu-id="7eb02-113"><xref:System.Threading.Monitor> has the following features:</span></span>  
  
-   <span data-ttu-id="7eb02-114">Es ist ein Objekt nach Bedarf zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="7eb02-114">It is associated with an object on demand.</span></span>  
  
-   <span data-ttu-id="7eb02-115">Es wird aufgehoben, was bedeutet, dass direkt aus einem beliebigen Kontext aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-115">It is unbound, which means it can be called directly from any context.</span></span>  
  
-   <span data-ttu-id="7eb02-116">Eine Instanz von der <xref:System.Threading.Monitor> Klasse kann nicht erstellt werden; die Methoden der <xref:System.Threading.Monitor> Klasse sind alle statisch.</span><span class="sxs-lookup"><span data-stu-id="7eb02-116">An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static.</span></span> <span data-ttu-id="7eb02-117">Jede Methode übergeben wird das synchronisierte Objekt, das steuert den Zugriff auf den kritischen Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-117">Each method is passed the synchronized object that controls access to the critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-118">Verwenden der <xref:System.Threading.Monitor> Klasse, um Objekte als Zeichenfolgen sperren (d. h. Referenztypen außer <xref:System.String>), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-118">Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types.</span></span> <span data-ttu-id="7eb02-119">Ausführliche Informationen finden Sie die Überladungen der <xref:System.Threading.Monitor.Enter%2A> Methode und [das Sperrobjekt](#Lock) weiter unten in diesem Artikel.</span><span class="sxs-lookup"><span data-stu-id="7eb02-119">For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.</span></span>  
  
 <span data-ttu-id="7eb02-120">Die folgende Tabelle beschreibt die Aktionen, die von Threads ausgeführt werden können, die synchronisierte Objekte zugreifen:</span><span class="sxs-lookup"><span data-stu-id="7eb02-120">The following table describes the actions that can be taken by threads that access synchronized objects:</span></span>  
  
|<span data-ttu-id="7eb02-121">Aktion</span><span class="sxs-lookup"><span data-stu-id="7eb02-121">Action</span></span>|<span data-ttu-id="7eb02-122">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="7eb02-122">Description</span></span>|  
|------------|-----------------|  
|<span data-ttu-id="7eb02-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span><span class="sxs-lookup"><span data-stu-id="7eb02-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span></span>|<span data-ttu-id="7eb02-124">Ruft eine Sperre für ein Objekt ab.</span><span class="sxs-lookup"><span data-stu-id="7eb02-124">Acquires a lock for an object.</span></span> <span data-ttu-id="7eb02-125">Diese Aktion werden auch den Anfang eines kritischen Abschnitts.</span><span class="sxs-lookup"><span data-stu-id="7eb02-125">This action also marks the beginning of a critical section.</span></span> <span data-ttu-id="7eb02-126">Kein anderer Thread kann den kritischen Abschnitt eingeben, es sei denn, sie die Anweisungen in den kritischen Abschnitt, der mithilfe eines anderen gesperrten Objekts ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-126">No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</span></span>|  
|<xref:System.Threading.Monitor.Wait%2A>|<span data-ttu-id="7eb02-127">Gibt die Sperre für ein Objekt zum Zulassen von anderen Threads zu sperren, und greifen auf das Objekt frei.</span><span class="sxs-lookup"><span data-stu-id="7eb02-127">Releases the lock on an object in order to permit other threads to lock and access the object.</span></span> <span data-ttu-id="7eb02-128">Der aufrufende Thread wartet, während ein anderer Thread auf das Objekt zugreift.</span><span class="sxs-lookup"><span data-stu-id="7eb02-128">The calling thread waits while another thread accesses the object.</span></span> <span data-ttu-id="7eb02-129">Pulse-Signale werden verwendet, um wartende Threads über Änderungen des Zustands eines Objekts zu benachrichtigen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-129">Pulse signals are used to notify waiting threads about changes to an object's state.</span></span>|  
|<span data-ttu-id="7eb02-130"><xref:System.Threading.Monitor.Pulse%2A> (Signal) <xref:System.Threading.Monitor.PulseAll%2A></span><span class="sxs-lookup"><span data-stu-id="7eb02-130"><xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A></span></span>|<span data-ttu-id="7eb02-131">Sendet ein Signal an einem oder mehreren wartenden Threads.</span><span class="sxs-lookup"><span data-stu-id="7eb02-131">Sends a signal to one or more waiting threads.</span></span> <span data-ttu-id="7eb02-132">Das Signal benachrichtigt einen wartenden Thread, den der Zustand des gesperrten Objekts geändert wurde, und der Besitzer der Sperre ist bereit, um die Sperre aufzuheben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-132">The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</span></span> <span data-ttu-id="7eb02-133">Der wartende Thread befindet sich in der Warteschlange des Objekts, damit er die Sperre für das Objekt schließlich empfangen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-133">The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</span></span> <span data-ttu-id="7eb02-134">Sobald der Thread die Sperre verfügt, kann es durch überprüfen den neuen Status des Objekts, um festzustellen, ob es sich bei der erforderliche Zustand erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="7eb02-134">Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</span></span>|  
|<xref:System.Threading.Monitor.Exit%2A>|<span data-ttu-id="7eb02-135">Hebt die Sperre für ein Objekt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-135">Releases the lock on an object.</span></span> <span data-ttu-id="7eb02-136">Diese Aktion werden auch das Ende eines kritischen Abschnitts von gesperrten Objekts geschützt werden.</span><span class="sxs-lookup"><span data-stu-id="7eb02-136">This action also marks the end of a critical section protected by the locked object.</span></span>|  
  
 <span data-ttu-id="7eb02-137">Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], es gibt zwei Sätze von Überladungen für die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.TryEnter%2A> Methoden.</span><span class="sxs-lookup"><span data-stu-id="7eb02-137">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods.</span></span> <span data-ttu-id="7eb02-138">Hat eine Reihe von Überladungen einer `ref` (in c#) oder `ByRef` (in Visual Basic) <xref:System.Boolean> Parameter, die atomar, um festgelegt wird `true` , wenn die Sperre abgerufen wurde, auch wenn eine Ausnahme ausgelöst wird, wenn die Sperre abrufen,.</span><span class="sxs-lookup"><span data-stu-id="7eb02-138">One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock.</span></span> <span data-ttu-id="7eb02-139">Verwenden Sie diese Überladungen, wenn es wichtig ist, die Sperre in allen Fällen auch, wenn die Ressourcen, die die Sperre zu schützen, ist möglicherweise nicht in einem konsistenten Zustand.</span><span class="sxs-lookup"><span data-stu-id="7eb02-139">Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</span></span>  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a><span data-ttu-id="7eb02-140">Das Sperrobjekt</span><span class="sxs-lookup"><span data-stu-id="7eb02-140">The lock object</span></span>  
 <span data-ttu-id="7eb02-141">Die Monitor-Klasse besteht aus `static` (in c#) oder `Shared` (in Visual Basic) Methoden für ein Objekt, das Zugriff auf den kritischen Abschnitt steuert.</span><span class="sxs-lookup"><span data-stu-id="7eb02-141">The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.</span></span>  <span data-ttu-id="7eb02-142">Die folgende Informationen werden für jedes synchronisierte Objekt verwaltet:</span><span class="sxs-lookup"><span data-stu-id="7eb02-142">The following information is maintained for each synchronized object:</span></span>  
  
-   <span data-ttu-id="7eb02-143">Ein Verweis auf den Thread, der derzeit die Sperre enthält.</span><span class="sxs-lookup"><span data-stu-id="7eb02-143">A reference to the thread that currently holds the lock.</span></span>  
  
-   <span data-ttu-id="7eb02-144">Ein Verweis auf eine Warteschlange enthält die Threads, die die Sperre erhalten können.</span><span class="sxs-lookup"><span data-stu-id="7eb02-144">A reference to a ready queue, which contains the threads that are ready to obtain the lock.</span></span>  
  
-   <span data-ttu-id="7eb02-145">Ein Verweis auf einer Warteschlange, die die Threads enthält, die für die Benachrichtigung über eine Änderung in den Zustand des gesperrten Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-145">A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</span></span>  
  
 <span data-ttu-id="7eb02-146"><xref:System.Threading.Monitor> sperrt Objekte (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-146"><xref:System.Threading.Monitor> locks objects (that is, reference types), not value types.</span></span> <span data-ttu-id="7eb02-147">Sie können einen Werttyp an <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> übergeben. Dieser wird jedoch für jeden Aufruf separat geschachtelt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-147">While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call.</span></span> <span data-ttu-id="7eb02-148">Da jeder Aufruf ein separates Objekt erstellt, bedingt <xref:System.Threading.Monitor.Enter%2A> nie eine Blockierung, und der Code, den die Methode eigentlich schützen soll, wird nicht wirklich synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="7eb02-148">Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized.</span></span> <span data-ttu-id="7eb02-149">Darüber hinaus unterscheiden sich das an <xref:System.Threading.Monitor.Exit%2A> und das an <xref:System.Threading.Monitor.Enter%2A> übergebene Objekt, sodass <xref:System.Threading.Monitor> eine <xref:System.Threading.SynchronizationLockException> mit der folgenden Meldung auslöst: "Die Objektsynchronisationsmethode wurde von einem nicht synchronisierten Codeblock aufgerufen."</span><span class="sxs-lookup"><span data-stu-id="7eb02-149">In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message "Object synchronization method was called from an unsynchronized block of code."</span></span>  
  
 <span data-ttu-id="7eb02-150">Dieses Problem wird anhand des folgenden Beispiels veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="7eb02-150">The following example illustrates this problem.</span></span> <span data-ttu-id="7eb02-151">Im Beispiel werden zehn Aufgaben gestartet, wobei jede lediglich 250 Millisekunden inaktiv ist.</span><span class="sxs-lookup"><span data-stu-id="7eb02-151">It launches ten tasks, each of which just sleeps for 250 milliseconds.</span></span> <span data-ttu-id="7eb02-152">Anschließend aktualisiert jede Aufgabe eine Zählervariable, `nTasks`, die dazu vorgesehen ist, die Anzahl von Aufgaben zu zählen, die tatsächlich gestartet wurden und ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="7eb02-152">Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed.</span></span> <span data-ttu-id="7eb02-153">Weil `nTasks` eine globale Variable ist, die von mehreren Aufgaben gleichzeitig aktualisiert werden kann, wird ein Monitor verwendet, um zu verhindern, dass die Variable gleichzeitig von mehreren Aufgaben geändert wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-153">Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</span></span> <span data-ttu-id="7eb02-154">Wie die Ausgabe des Beispiels zeigt, löst jede dieser Aufgaben jedoch eine <xref:System.Threading.SynchronizationLockException>-Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="7eb02-154">However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 <span data-ttu-id="7eb02-155">Jede Aufgabe löst eine <xref:System.Threading.SynchronizationLockException>-Ausnahme aus, weil die Variable `nTasks` gekapselt wird, bevor in jeder Aufgabe die <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-155">Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method in each task.</span></span> <span data-ttu-id="7eb02-156">Anders formuliert heißt das, bei jedem Methodenaufruf wird eine separate Variable übergeben, die unabhängig von den anderen ist.</span><span class="sxs-lookup"><span data-stu-id="7eb02-156">In other words, each method call is passed a separate variable that is independent of the others.</span></span> <span data-ttu-id="7eb02-157">`nTasks` wird im Aufruf der <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>-Methode erneut gekapselt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-157">`nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="7eb02-158">Dadurch werden wiederum zehn neue gekapselte `nTasks`-Variablen erstellt, die unabhängig voneinander sind. Hinzu kommen die zehn gekapselten Variablen, die im Aufruf der <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>-Methode erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="7eb02-158">Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="7eb02-159">Die Ausnahme wird dann ausgelöst, weil im Code versucht wird, eine Sperre für eine neu erstellte Variable freizugeben, die zuvor nicht gesperrt wurde.</span><span class="sxs-lookup"><span data-stu-id="7eb02-159">The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</span></span>  
  
 <span data-ttu-id="7eb02-160">Wie das folgende Beispiel zeigt, können Sie eine Werttypvariable zwar vor dem Aufruf von <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> kapseln und dasselbe gekapselte Objekt an beide Methoden übergeben, diese Vorgehensweise bietet jedoch keinerlei Vorteile.</span><span class="sxs-lookup"><span data-stu-id="7eb02-160">Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</span></span> <span data-ttu-id="7eb02-161">Änderungen an der nicht gekapselten Variablen wirken sich nicht auf die gekapselte Kopie aus, und es ist nicht möglich, den Wert der gekapselten Kopie zu ändern.</span><span class="sxs-lookup"><span data-stu-id="7eb02-161">Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 <span data-ttu-id="7eb02-162">Wenn Sie ein Objekt auf die Synchronisierung auswählen zu können, sollten Sie nur auf private oder interne Objekte sperren.</span><span class="sxs-lookup"><span data-stu-id="7eb02-162">When selecting an object on which to synchronize, you should lock only on private or internal objects.</span></span> <span data-ttu-id="7eb02-163">Sperren auf externe Objekte möglicherweise in Deadlocks führen, da es sich bei nicht verknüpfte Code So sperren Sie für unterschiedliche Zwecke auf dieselben Objekte auswählen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-163">Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</span></span>  
  
 <span data-ttu-id="7eb02-164">Beachten Sie, die Sie für ein Objekt in mehreren Anwendungsdomänen synchronisieren können, wenn das für die Sperre verwendete Objekt abgeleitet <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-164">Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a><span data-ttu-id="7eb02-165">Der kritische Abschnitt</span><span class="sxs-lookup"><span data-stu-id="7eb02-165">The critical section</span></span>  
 <span data-ttu-id="7eb02-166">Verwenden der <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methoden, um den Anfang und Ende eines kritischen Abschnitts zu markieren.</span><span class="sxs-lookup"><span data-stu-id="7eb02-166">Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-167">Die Funktionalität von der <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methoden ist identisch mit derjenigen der [Sperre](~/docs/csharp/language-reference/keywords/lock-statement.md) -Anweisung in c# und die [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) -Anweisung in Visual Basic, außer dass die Sprachkonstrukte Wrap der <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> -methodenüberladung, und die <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> -Methode in einer `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="7eb02-167">The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method in a `try`…`finally`</span></span> <span data-ttu-id="7eb02-168">Block, um sicherzustellen, dass der Monitor freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-168">block to ensure that the monitor is released.</span></span>  
  
 <span data-ttu-id="7eb02-169">Der kritische Abschnitt ist eine Reihe von zusammenhängenden Anweisungen, und klicken Sie dann auf Sperre, die von der <xref:System.Threading.Monitor.Enter%2A> Methode stellt sicher, dass nur ein einzelner Thread des eingeschlossenen Codes mit gesperrten Objekts ausführen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-169">If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object.</span></span> <span data-ttu-id="7eb02-170">In diesem Fall wird empfohlen, dass Sie diesen Code in platzieren eine `try` blockieren, und platzieren Sie den Aufruf der <xref:System.Threading.Monitor.Exit%2A> -Methode in der ein `finally` Block.</span><span class="sxs-lookup"><span data-stu-id="7eb02-170">In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block.</span></span> <span data-ttu-id="7eb02-171">Dadurch ist sichergestellt, dass die Sperre aufgehoben wird, selbst wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-171">This ensures that the lock is released even if an exception occurs.</span></span> <span data-ttu-id="7eb02-172">Das folgende Codefragment veranschaulicht dieses Muster.</span><span class="sxs-lookup"><span data-stu-id="7eb02-172">The following code fragment illustrates this pattern.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 <span data-ttu-id="7eb02-173">Diese Funktion wird normalerweise verwendet, um den Zugriff auf eine statische Methode oder Instanzmethode einer Klasse zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="7eb02-173">This facility is typically used to synchronize access to a static or instance method of a class.</span></span>  
  
 <span data-ttu-id="7eb02-174">Ein kritischen Abschnitt eine gesamte Methode umfasst, kann das Sperre Gebäude erreicht werden, indem Sie platzieren die <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> für die Methode, und geben Sie die <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> Wert im Konstruktor der <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-174">If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7eb02-175">Wenn Sie dieses Attribut verwenden die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methodenaufrufe sind nicht erforderlich.</span><span class="sxs-lookup"><span data-stu-id="7eb02-175">When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed.</span></span> <span data-ttu-id="7eb02-176">Das folgende Codefragment veranschaulicht dieses Muster:</span><span class="sxs-lookup"><span data-stu-id="7eb02-176">The following code fragment illustrates this pattern:</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 <span data-ttu-id="7eb02-177">Beachten Sie, dass das Attribut der aktuelle Thread die Sperre wird, bis die Methode zurückgibt. Wenn die Sperre früher aufgehoben werden kann, verwenden Sie die <xref:System.Threading.Monitor> Klasse, die C#- [Sperre](~/docs/csharp/language-reference/keywords/lock-statement.md) -Anweisung oder in der Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) Anweisung innerhalb der Methode anstatt des Attributs.</span><span class="sxs-lookup"><span data-stu-id="7eb02-177">Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement, or the Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement inside of the method instead of the attribute.</span></span>  
  
 <span data-ttu-id="7eb02-178">Es ist zwar möglich, für die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Anweisungen, die Sperren und ein bestimmtes Objekt Cross-Element und/oder release, dies wird nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-178">While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</span></span>  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a><span data-ttu-id="7eb02-179">Pulse "," PulseAll ", und warten</span><span class="sxs-lookup"><span data-stu-id="7eb02-179">Pulse, PulseAll, and Wait</span></span>  
 <span data-ttu-id="7eb02-180">Sobald ein Thread die Sperre besitzt und hat den kritischen Abschnitt, die die Sperre geschützt, können sie Aufrufen der <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, und <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> Methoden.</span><span class="sxs-lookup"><span data-stu-id="7eb02-180">Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="7eb02-181"><xref:System.Threading.Monitor.Wait%2A> Hebt die Sperre, wenn aufrechterhalten wird, können einen wartenden Thread oder Threads, um die Sperre, und geben den kritischen Abschnitt und wartet auf eine Benachrichtigung durch einen Aufruf der <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> oder <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="7eb02-181"><xref:System.Threading.Monitor.Wait%2A> releases the lock if it is held, allows a waiting thread or threads to obtain the lock and enter the critical section,   and waits to be notified by a call to the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> or <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="7eb02-182">Wurde <xref:System.Threading.Monitor.Wait%2A> benachrichtigt, führt die Methode einen Rücksprung aus und erhält erneut die Sperre.</span><span class="sxs-lookup"><span data-stu-id="7eb02-182">When <xref:System.Threading.Monitor.Wait%2A> is notified, it returns and obtains the lock again.</span></span>  
  
 <span data-ttu-id="7eb02-183">Sowohl <xref:System.Threading.Monitor.Pulse%2A> als auch <xref:System.Threading.Monitor.PulseAll%2A> signalisieren, dass der nächste Thread in der Warteschlange verarbeitet werden kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-183">Both <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> signal for the next thread in the wait queue to proceed.</span></span>  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a><span data-ttu-id="7eb02-184">Monitore und Wait-handles</span><span class="sxs-lookup"><span data-stu-id="7eb02-184">Monitors and wait handles</span></span>  
 <span data-ttu-id="7eb02-185">Es ist wichtig, beachten Sie den Unterschied zwischen der Verwendung von der <xref:System.Threading.Monitor> Klasse und <xref:System.Threading.WaitHandle> Objekte.</span><span class="sxs-lookup"><span data-stu-id="7eb02-185">It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.</span></span>  
  
-   <span data-ttu-id="7eb02-186">Die <xref:System.Threading.Monitor> Klasse ist rein verwaltete, vollständig übertragbar und kann in Bezug auf die Anforderungen an die Betriebssystem-Ressourcen effizienter sein.</span><span class="sxs-lookup"><span data-stu-id="7eb02-186">The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</span></span>  
  
-   <span data-ttu-id="7eb02-187"><xref:System.Threading.WaitHandle>-Objekte repräsentieren Objekte des Betriebssystems, die in der Lage sind, ihre Ausführung zu unterbrechen und zu warten. Sie sind für die Synchronisierung zwischen verwaltetem und nicht verwaltetem Code von Nutzen und machen einige höhere Betriebssystemfunktionen verfügbar, z. B. die Fähigkeit, auf viele Objekte gleichzeitig zu warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-187"><xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7eb02-188">Im folgenden Beispiel wird die <xref:System.Threading.Monitor> Klasse zum Synchronisieren des Zugriffs auf eine einzelne Instanz von einem Zufallszahlengenerator, dargestellt durch die <xref:System.Random> Klasse.</span><span class="sxs-lookup"><span data-stu-id="7eb02-188">The following example uses the <xref:System.Threading.Monitor> class to synchronize access to a single instance of a random number generator represented by the <xref:System.Random> class.</span></span> <span data-ttu-id="7eb02-189">Das Beispiel erstellt die zehn Aufgaben, von die jede auf einem Threadpool-Thread asynchron ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-189">The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</span></span> <span data-ttu-id="7eb02-190">Jede Aufgabe 10.000 Zufallszahlen generiert, deren Durchschnitt berechnet und aktualisiert zwei auf Prozedurebene-Variablen, die eine laufende Summe der Anzahl von Zufallszahlen generiert und deren Summe zu gewährleisten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-190">Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</span></span> <span data-ttu-id="7eb02-191">Nachdem alle Aufgaben ausgeführt haben, werden diese beiden Werte zum Berechnen des gesamtmittelwerts verwendet.</span><span class="sxs-lookup"><span data-stu-id="7eb02-191">After all tasks have executed, these two values are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="7eb02-192">Da sie von jeder Aufgabe, die auf einem Threadpoolthread ausgeführt zugegriffen werden kann, der Zugriff auf die Variablen `total` und `n` muss ebenfalls synchronisiert werden.</span><span class="sxs-lookup"><span data-stu-id="7eb02-192">Because they can be accessed from any task running on a thread pool thread, access to the variables `total` and `n` must also be synchronized.</span></span> <span data-ttu-id="7eb02-193">Die <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> Methode für diesen Zweck verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-193">The <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> method is used for this purpose.</span></span>  
  
 <span data-ttu-id="7eb02-194">Das folgende Beispiel zeigt die kombinierte Verwendung der <xref:System.Threading.Monitor> Klasse (mit implementiert die `lock` oder `SyncLock` Sprachkonstrukt), wird die <xref:System.Threading.Interlocked> -Klasse, und die <xref:System.Threading.AutoResetEvent> Klasse.</span><span class="sxs-lookup"><span data-stu-id="7eb02-194">The following example demonstrates the combined use of the <xref:System.Threading.Monitor> class (implemented with the `lock` or `SyncLock` language construct), the <xref:System.Threading.Interlocked> class, and the <xref:System.Threading.AutoResetEvent> class.</span></span> <span data-ttu-id="7eb02-195">Es definiert zwei `internal` (in c#) oder `Friend` (in Visual Basic) Klassen `SyncResource` und `UnSyncResource`, die entsprechend synchronisierten und nicht synchronisierten Zugriff auf eine Ressource bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-195">It defines two `internal` (in C#) or `Friend` (in Visual Basic) classes, `SyncResource` and `UnSyncResource`, that respectively provide synchronized and unsynchronized access to a resource.</span></span> <span data-ttu-id="7eb02-196">Um sicherzustellen, dass das Beispiel veranschaulicht den Unterschied zwischen dem synchronisierten und nicht synchronisierten Zugriff (die der Fall sein kann, wenn jeder Methodenaufruf schnell abgeschlossen wird), die Methode umfasst eine zufällige Verzögerung: für threads, deren <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> Eigenschaft gerade ist, die Methodenaufrufe <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> , tritt eine Verzögerung von 2.000 Millisekunden einzuführen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-196">To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property is even, the method calls <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> to introduce a delay of 2,000 milliseconds.</span></span> <span data-ttu-id="7eb02-197">Beachten Sie, dass, weil die `SyncResource` Klasse ist nicht öffentlich, keiner der Clientcodes eine Sperre für die synchronisierte Ressource akzeptiert, die interne Klasse selbst sperrt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-197">Note that, because the `SyncResource` class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</span></span> <span data-ttu-id="7eb02-198">Dadurch wird verhindert, dass bösartiger Code eine Sperre für ein öffentliches Objekt auslöst.</span><span class="sxs-lookup"><span data-stu-id="7eb02-198">This prevents malicious code from taking a lock on a public object.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 <span data-ttu-id="7eb02-199">Im Beispiel wird eine Variable, `numOps`, definiert die Anzahl der Threads, die auf die Ressource zuzugreifen versucht.</span><span class="sxs-lookup"><span data-stu-id="7eb02-199">The example defines a variable, `numOps`, that defines the number of threads that will attempt to access the resource.</span></span> <span data-ttu-id="7eb02-200">Der Anwendungsthread Ruft die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> Methode für synchronisierten und nicht synchronisierten Zugriff auf fünf Mal jedes.</span><span class="sxs-lookup"><span data-stu-id="7eb02-200">The application thread calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method for synchronized and unsynchronized access five times each.</span></span> <span data-ttu-id="7eb02-201">Die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> Methode verfügt über einen einzelnen Parameter, ein Delegat, der keine Parameter akzeptiert und keinen Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-201">The <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method has a single parameter, a delegate that accepts no parameters and returns no value.</span></span> <span data-ttu-id="7eb02-202">Für synchronisierten Zugriff und ruft die `SyncUpdateResource` Methode für den nicht synchronisierten Zugriff Ruft die `UnSyncUpdateResource` Methode.</span><span class="sxs-lookup"><span data-stu-id="7eb02-202">For synchronized access, it invokes the `SyncUpdateResource` method; for unsynchronized access, it invokes the `UnSyncUpdateResource` method.</span></span> <span data-ttu-id="7eb02-203">Nach jedem Satz von Methodenaufrufen, ruft der Anwendungsthread die [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) Methode, sodass, bis blockiert die <xref:System.Threading.AutoResetEvent> -Instanz signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-203">After each set of method calls, the application thread calls the [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) method so that it blocks until the <xref:System.Threading.AutoResetEvent> instance is signaled.</span></span>  
  
 <span data-ttu-id="7eb02-204">Jeder Aufruf von der `SyncUpdateResource` -Methode wird die interne `SyncResource.Access` -Methode und ruft dann die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode zum Verringern der `numOps` Leistungsindikator.</span><span class="sxs-lookup"><span data-stu-id="7eb02-204">Each call to the `SyncUpdateResource` method calls the internal `SyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="7eb02-205">Die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode wird verwendet, um den Zähler verringert, da andernfalls Sie bestimmte nicht sein können, dass ein zweiter Thread den Wert zugreift, bevor Sie ein ersten Thread der dekrementierte Wert in der Variablen gespeichert wurde.</span><span class="sxs-lookup"><span data-stu-id="7eb02-205">The <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</span></span> <span data-ttu-id="7eb02-206">Wenn die letzte Worker dekrementiert den Zähler auf 0 (null) synchronisiert, gibt an, dass alle synchronisierten Threads haben Zugriff auf die Ressource, die `SyncUpdateResource` Methodenaufrufe der <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> -Methode, die signalisiert den Hauptthread, um den Vorgang fortzusetzen die Ausführung.</span><span class="sxs-lookup"><span data-stu-id="7eb02-206">When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the `SyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="7eb02-207">Jeder Aufruf von der `UnSyncUpdateResource` -Methode wird die interne `UnSyncResource.Access` -Methode und ruft dann die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode zum Verringern der `numOps` Leistungsindikator.</span><span class="sxs-lookup"><span data-stu-id="7eb02-207">Each call to the `UnSyncUpdateResource` method calls the internal `UnSyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="7eb02-208">Auch hier die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode wird verwendet, um die verringert des Zähler, um sicherzustellen, dass ein zweiter Thread nicht den Wert zugreift, bevor der dekrementierte Wert des ersten Threads auf die Variable zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="7eb02-208">Once again, the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</span></span> <span data-ttu-id="7eb02-209">Bei der letzten dekrementiert Worker nicht den Zähler auf 0 (null) synchronisierte, gibt an, dass keine weiteren synchronisierten Threads Zugriff auf die Ressource, müssen die `UnSyncUpdateResource` Methodenaufrufe der <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> -Methode, die signalisiert den Hauptthread die Ausführung fortsetzen .</span><span class="sxs-lookup"><span data-stu-id="7eb02-209">When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the `UnSyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="7eb02-210">Wie die Ausgabe des Beispiels zeigt, wird mit synchronisiertem Zugriff sichergestellt, dass der aufrufende Thread die geschützte Ressource beendet, bevor ein anderer Thread auf sie zugreifen kann. Jeder Thread wartet auf seinen Vorgänger.</span><span class="sxs-lookup"><span data-stu-id="7eb02-210">As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</span></span> <span data-ttu-id="7eb02-211">Andererseits, ohne die Sperre die `UnSyncResource.Access` Methode wird aufgerufen, in der Reihenfolge, in dem von Threads wird erreicht.</span><span class="sxs-lookup"><span data-stu-id="7eb02-211">On the other hand, without the lock, the `UnSyncResource.Access` method is called in the order in which threads reach it.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="7eb02-212">Dieser Typ ist threadsicher.</span>
      <span class="sxs-lookup">
        <span data-stu-id="7eb02-212">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7eb02-213">Erhält eine exklusive Sperre für ein angegebenes Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-213">Acquires an exclusive lock on a specified object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-214">Das Objekt, für das die Monitorsperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-214">The object on which to acquire the monitor lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-215">Erhält eine exklusive Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-215">Acquires an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-216">Verwendung `Enter` zum Abrufen der <xref:System.Threading.Monitor> für das Objekt, das als Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-216">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter.</span></span> <span data-ttu-id="7eb02-217">Wenn ein anderer Thread ausgeführt wurde ein `Enter` für das Objekt aber noch nicht die entsprechenden ausgeführt wurde <xref:System.Threading.Monitor.Exit%2A>, der aktuelle Thread blockiert, bis der andere Thread das Objekt freigegeben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-217">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="7eb02-218">Es ist zulässig, dass im gleichen Thread Aufrufen `Enter` mehr als einmal ohne diese Blockierung jedoch eine gleiche Anzahl von `Exit` Aufrufe aufgerufen werden müssen, bevor Sie andere Threads warten auf das Objekt aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-218">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="7eb02-219">Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-219">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="7eb02-220">Wenn Sie eine Werttypvariable zum übergeben `Enter`, wird Sie als ein Objekt geschachtelt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-220">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="7eb02-221">Wenn Sie die gleiche Variable übergeben `Enter` in diesem Fall wird als separates Objekt geschachtelt werden, und der Thread nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="7eb02-221">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="7eb02-222">In diesem Fall ist der Code, `Monitor` ist die Methode eigentlich schützen ist nicht geschützt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-222">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="7eb02-223">Wenn Sie außerdem die Variable übergeben `Exit`, noch ein anderes Objekt erstellt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-223">Furthermore, when you pass the variable to `Exit`, still another separate object is created.</span></span> <span data-ttu-id="7eb02-224">Da das Objekt an übergeben `Exit` unterscheidet sich von der an übergebene Objekt `Enter`, `Monitor` löst <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-224">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="7eb02-225">Weitere Informationen finden Sie unter dem Thema [Monitore](xref:System.Threading.Monitor).</span><span class="sxs-lookup"><span data-stu-id="7eb02-225">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="7eb02-226"><xref:System.Threading.Thread.Interrupt%2A> unterbrechen, können Threads, die darauf warten, geben einen `Monitor` für ein Objekt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-226"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="7eb02-227">Ein <xref:System.Threading.ThreadInterruptedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="7eb02-227">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
 <span data-ttu-id="7eb02-228">Verwenden Sie eine C#- `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="7eb02-228">Use a C# `try`…`finally`</span></span> <span data-ttu-id="7eb02-229">Block (`Try`...`Finally`</span><span class="sxs-lookup"><span data-stu-id="7eb02-229">block (`Try`…`Finally`</span></span> <span data-ttu-id="7eb02-230">in Visual Basic) stellen Sie sicher, dass den Monitor freigegeben wird, oder verwenden Sie die C#- `lock` Anweisung (`SyncLock` -Anweisung in Visual Basic), welche umschließt die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methoden in einer `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="7eb02-230">in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`…`finally`</span></span> <span data-ttu-id="7eb02-231">Block.</span><span class="sxs-lookup"><span data-stu-id="7eb02-231">block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7eb02-232">Im folgenden Beispiel wird die Verwendung der `Enter`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="7eb02-232">The following example demonstrates how to use the `Enter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-233">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-233">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-234">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-234">The object on which to wait.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="7eb02-235">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-235">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="7eb02-236">Die Eingabe muss <see langword="false" /> sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-236">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="7eb02-237">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-237">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="7eb02-238">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-238">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
          <span data-ttu-id="7eb02-239">Hinweis   Wenn keine Ausnahme auftritt, ist die Ausgabe dieser Methode immer <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-239">Note   If no exception occurs, the output of this method is always <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-240">Erhält eine exklusive Sperre für das angegebene Objekt und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-240">Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-241">Verwenden `Enter` zum Abrufen der <xref:System.Threading.Monitor> für das Objekt übergeben, als die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="7eb02-241">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter.</span></span> <span data-ttu-id="7eb02-242">Wenn ein anderer Thread ausgeführt wurde ein `Enter` für das Objekt aber noch nicht die entsprechenden ausgeführt wurde <xref:System.Threading.Monitor.Exit%2A>, der aktuelle Thread blockiert, bis der andere Thread das Objekt freigegeben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-242">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="7eb02-243">Es ist zulässig, dass im gleichen Thread Aufrufen `Enter` mehr als einmal ohne diese Blockierung jedoch eine gleiche Anzahl von `Exit` Aufrufe aufgerufen werden müssen, bevor Sie andere Threads warten auf das Objekt aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-243">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="7eb02-244">Wenn die Sperre nicht erstellt wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` -Parameter ist `false` nach diese Methode beendet.</span><span class="sxs-lookup"><span data-stu-id="7eb02-244">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="7eb02-245">Dadurch wird das Programm in allen Fällen, um zu bestimmen, ob es erforderlich, um die Sperre aufzuheben ist.</span><span class="sxs-lookup"><span data-stu-id="7eb02-245">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span> <span data-ttu-id="7eb02-246">Wenn diese Methode zurückgibt, ohne eine Ausnahme auszulösen, wird die Variable angegeben, für die `lockTaken` Parameter ist immer `true`, und es ist nicht erforderlich, um sie zu testen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-246">If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.</span></span>  
  
 <span data-ttu-id="7eb02-247">Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-247">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="7eb02-248">Wenn Sie eine Werttypvariable zum übergeben `Enter`, wird Sie als ein Objekt geschachtelt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-248">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="7eb02-249">Wenn Sie die gleiche Variable übergeben `Enter` in diesem Fall wird als separates Objekt geschachtelt werden, und der Thread nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="7eb02-249">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="7eb02-250">In diesem Fall ist der Code, `Monitor` ist die Methode eigentlich schützen ist nicht geschützt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-250">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="7eb02-251">Wenn Sie außerdem die Variable übergeben `Exit`, einem anderen Objekt erstellt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-251">Furthermore, when you pass the variable to `Exit`, another separate object is created.</span></span> <span data-ttu-id="7eb02-252">Da das Objekt an übergeben `Exit` unterscheidet sich von der an übergebene Objekt `Enter`, `Monitor` löst <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-252">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="7eb02-253">Weitere Informationen finden Sie unter dem Thema [Monitore](xref:System.Threading.Monitor).</span><span class="sxs-lookup"><span data-stu-id="7eb02-253">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="7eb02-254"><xref:System.Threading.Thread.Interrupt%2A> unterbrechen, können Threads, die darauf warten, geben einen `Monitor` für ein Objekt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-254"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="7eb02-255">Ein <xref:System.Threading.ThreadInterruptedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="7eb02-255">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7eb02-256">Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> -methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="7eb02-256">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="7eb02-257">Diese Überladung legt immer den Wert der Variablen, die an die `ref` Parameter (`ByRef` in Visual Basic) `lockTaken`, auch wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Testen ist, ob die Sperre sein veröffentlicht.</span><span class="sxs-lookup"><span data-stu-id="7eb02-257">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7eb02-258">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-258">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-259">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-259">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-260">Das Objekt, dessen Sperre aufgehoben werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-260">The object on which to release the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-261">Hebt eine exklusive Sperre für das angegebene Objekt auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-261">Releases an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-262">Der aufrufende Thread die Sperre besitzen muss, auf die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="7eb02-262">The calling thread must own the lock on the `obj` parameter.</span></span> <span data-ttu-id="7eb02-263">Wenn der aufrufende Thread die Sperre für das angegebene Objekt besitzt, hat eine gleiche Anzahl von `Exit` und <xref:System.Threading.Monitor.Enter%2A> für das Objekt aufgerufen wird, und klicken Sie dann die Sperre aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-263">If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released.</span></span> <span data-ttu-id="7eb02-264">Wenn der aufrufende Thread nicht aufgerufen hat `Exit` so oft wie `Enter`, die Sperre wird nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-264">If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.</span></span>  
  
 <span data-ttu-id="7eb02-265">Wenn die Sperre wird aufgehoben, und andere Threads befinden sich in die Warteschlange für das Objekt, ruft einer der Threads die Sperre.</span><span class="sxs-lookup"><span data-stu-id="7eb02-265">If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</span></span> <span data-ttu-id="7eb02-266">Wenn andere Threads in der Warteschlange darauf warten, der eine Sperre sind, sie werden nicht automatisch verschoben in die Warteschlange, wenn der Besitzer der Sperre ruft `Exit`.</span><span class="sxs-lookup"><span data-stu-id="7eb02-266">If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`.</span></span> <span data-ttu-id="7eb02-267">Aufrufen, um eine oder mehrere wartende Threads in die Warteschlange zu verschieben, <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> vor dem Aufrufen `Exit`.</span><span class="sxs-lookup"><span data-stu-id="7eb02-267">To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7eb02-268">Im folgenden Beispiel wird die Verwendung der `Exit`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="7eb02-268">The following example demonstrates how to use the `Exit` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-269">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-269">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="7eb02-270">Der aktuelle Thread besitzt die Sperre für das angegebene Objekt nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-270">The current thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-271">Das zu überprüfende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-271">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-272">Bestimmt, ob der aktuelle Thread die Sperre für das angegebene Objekt enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-272">Determines whether the current thread holds the lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7eb02-273">
            <see langword="true" />, wenn der aktuelle Thread die Schreibsperre für <paramref name="obj" /> enthält, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-273">
              <see langword="true" /> if the current thread holds the lock on <paramref name="obj" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-274">Diese Methode funktioniert nur für Sperren, die aktiviert werden, mithilfe der Methoden von der <xref:System.Threading.Monitor> -Klasse oder durch die Verwendung der C#- `lock` -Anweisung oder die Visual Basic `SyncLock` -Anweisung, die mit implementiert werden <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-274">This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="7eb02-275">Verwenden Sie diese Methode mit den Diagnosetools, z. B. die <xref:System.Diagnostics.Debug.Assert%2A> Methode und die <xref:System.Diagnostics.Contracts.Contract> -Klasse, um Probleme mit Datenbanksperren zu debuggen, bei denen die <xref:System.Threading.Monitor> Klasse.</span><span class="sxs-lookup"><span data-stu-id="7eb02-275">Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-276">
            <paramref name="obj" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-276">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-277">Das Objekt, auf das ein Thread wartet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-277">The object a thread is waiting for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-278">Benachrichtigt einen Thread in der Warteschlange für abzuarbeitende Threads über eine Änderung am Zustand des gesperrten Objekts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-278">Notifies a thread in the waiting queue of a change in the locked object's state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-279">Nur der aktuelle Besitzer der Sperre ein warten mit signalisieren kann `Pulse`.</span><span class="sxs-lookup"><span data-stu-id="7eb02-279">Only the current owner of the lock can signal a waiting object using `Pulse`.</span></span>  
  
 <span data-ttu-id="7eb02-280">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um die nächsten Threads in der Zeile, für die Sperre zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="7eb02-280">The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</span></span> <span data-ttu-id="7eb02-281">Nach dem Empfang des Schritts, wird der wartende Thread in die Warteschlange verschoben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-281">Upon receiving the pulse, the waiting thread is moved to the ready queue.</span></span> <span data-ttu-id="7eb02-282">Wenn der Thread aufgerufen, die `Pulse` hebt die Sperre der nächste Thread in die Warteschlange (dies nicht unbedingt der Thread, der Impuls empfangen hat), ruft die Sperre.</span><span class="sxs-lookup"><span data-stu-id="7eb02-282">When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="7eb02-283">Die <xref:System.Threading.Monitor> -Klasse verwaltet nicht den Status Gibt an, dass die <xref:System.Threading.Monitor.Pulse%2A> -Methode aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="7eb02-283">The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called.</span></span> <span data-ttu-id="7eb02-284">Daher Aufrufen <xref:System.Threading.Monitor.Pulse%2A> Wenn keine Threads warten, den aufrufende Thread nächsten <xref:System.Threading.Monitor.Wait%2A> Blöcke wie <xref:System.Threading.Monitor.Pulse%2A> noch nicht aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="7eb02-284">Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called.</span></span> <span data-ttu-id="7eb02-285">Wenn zwei Threads verwenden <xref:System.Threading.Monitor.Pulse%2A> und <xref:System.Threading.Monitor.Wait%2A> interagieren, könnte dies zu einem Deadlock.</span><span class="sxs-lookup"><span data-stu-id="7eb02-285">If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock.</span></span> <span data-ttu-id="7eb02-286">Vergleichen Sie dies mit dem Verhalten von der <xref:System.Threading.AutoResetEvent> Klasse:, wenn Sie zu signalisieren eine <xref:System.Threading.AutoResetEvent> durch Aufrufen der <xref:System.Threading.EventWaitHandle.Set%2A> -Methode, und es sind keine Threads warten, die <xref:System.Threading.AutoResetEvent> bleibt in einem signalisierten Zustand, bis ein Thread ruft <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, oder <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-286">Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="7eb02-287">Die <xref:System.Threading.AutoResetEvent> gibt den Thread frei, und in den nicht signalisierten Zustand zurück.</span><span class="sxs-lookup"><span data-stu-id="7eb02-287">The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.</span></span>  
  
 <span data-ttu-id="7eb02-288">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise, die einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält enthält, und einen Verweis auf die Warteschlange für abzuarbeitende, einschließlich der enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts darauf warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-288">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="7eb02-289">Die `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, und <xref:System.Threading.Monitor.Wait%2A> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-289">The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="7eb02-290">Mehrere Threads signalisiert werden, verwenden Sie die <xref:System.Threading.Monitor.PulseAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="7eb02-290">To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-291">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-291">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="7eb02-292">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-292">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-293">Das Objekt, das den Impuls sendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-293">The object that sends the pulse.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-294">Benachrichtigt alle wartenden Threads über eine Änderung am Zustand des Objekts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-294">Notifies all waiting threads of a change in the object's state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-295">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um alle Threads, die darauf warten, die Sperre für das Objekt zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="7eb02-295">The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</span></span> <span data-ttu-id="7eb02-296">Wenn das Signal gesendet wurde, werden den wartenden Threads in die Warteschlange verschoben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-296">After the signal is sent, the waiting threads are moved to the ready queue.</span></span> <span data-ttu-id="7eb02-297">Wenn der Thread aufgerufen, die `PulseAll` hebt die Sperre der nächste Thread in die Warteschlange erfolgreich sperren.</span><span class="sxs-lookup"><span data-stu-id="7eb02-297">When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.</span></span>  
  
 <span data-ttu-id="7eb02-298">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise, die einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält enthält, und einen Verweis auf die Warteschlange für abzuarbeitende, einschließlich der enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts darauf warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-298">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="7eb02-299">Die <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, und <xref:System.Threading.Monitor.Wait%2A> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-299">The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="7eb02-300">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-300">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 <span data-ttu-id="7eb02-301">Verwenden Sie einen einzelnen Thread signalisiert werden, die `Pulse` Methode.</span><span class="sxs-lookup"><span data-stu-id="7eb02-301">To signal a single thread, use the `Pulse` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-302">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-302">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="7eb02-303">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-303">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7eb02-304">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-304">Attempts to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-305">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-305">The object on which to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-306">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-306">Attempts to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7eb02-307">
            <see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-307">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-308">Wenn erfolgreich, diese Methode eine exklusive Sperre für Ruft die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="7eb02-308">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="7eb02-309">Diese Methode gibt sofort zurück, ob die Sperre verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="7eb02-309">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="7eb02-310">Diese Methode ähnelt <xref:System.Threading.Monitor.Enter%2A>, aber es wird nie blockiert den aktuellen Thread.</span><span class="sxs-lookup"><span data-stu-id="7eb02-310">This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread.</span></span> <span data-ttu-id="7eb02-311">Wenn der Thread kann nicht ohne Blockierung eingegeben haben, gibt die Methode `false,`.</span><span class="sxs-lookup"><span data-stu-id="7eb02-311">If the thread cannot enter without blocking, the method returns `false,`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-312">Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-312">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="7eb02-313">Weitere Informationen finden Sie unter den <xref:System.Threading.Monitor> Artikel.</span><span class="sxs-lookup"><span data-stu-id="7eb02-313">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="7eb02-314">Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in einem kritischen Abschnitt nur, wenn der Rückgabewert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="7eb02-314">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="7eb02-315">Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-315">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="7eb02-316">Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-316">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="7eb02-317">Das folgende Codebeispiel zeigt, wie Sie die `TryEnter`-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="7eb02-317">The following code example demonstrates how to use the `TryEnter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-318">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-318">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-319">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-319">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="7eb02-320">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-320">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="7eb02-321">Die Eingabe muss <see langword="false" /> sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-321">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="7eb02-322">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-322">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="7eb02-323">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-323">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-324">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-324">Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-325">Wenn erfolgreich, diese Methode eine exklusive Sperre für Ruft die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="7eb02-325">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="7eb02-326">Diese Methode gibt sofort zurück, ob die Sperre verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="7eb02-326">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="7eb02-327">Wenn die Sperre nicht erstellt wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` -Parameter ist `false` nach diese Methode beendet.</span><span class="sxs-lookup"><span data-stu-id="7eb02-327">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="7eb02-328">Dadurch wird das Programm in allen Fällen, um zu bestimmen, ob es erforderlich, um die Sperre aufzuheben ist.</span><span class="sxs-lookup"><span data-stu-id="7eb02-328">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
 <span data-ttu-id="7eb02-329">Diese Methode ähnelt <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, aber es wird nie blockiert den aktuellen Thread.</span><span class="sxs-lookup"><span data-stu-id="7eb02-329">This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread.</span></span> <span data-ttu-id="7eb02-330">Wenn der Thread ohne Blockierung, eingeben kann nicht die `lockTaken` Argument nastaven NA hodnotu `false` bei Rückgabe der Methode.</span><span class="sxs-lookup"><span data-stu-id="7eb02-330">If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-331">Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-331">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="7eb02-332">Weitere Informationen finden Sie im Artikel <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-332">For more information, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="7eb02-333">Um sicherzustellen, dass der Thread wird nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der `lockTaken` und Ausführen von Code in einem kritischen Abschnitt nur, wenn der Wert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="7eb02-333">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="7eb02-334">Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-334">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="7eb02-335">Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-335">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="7eb02-336">Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> -methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="7eb02-336">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="7eb02-337">Diese Überladung legt immer den Wert der Variablen, die an die `ref` Parameter (`ByRef` in Visual Basic) `lockTaken`, auch wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Testen ist, ob die Sperre sein veröffentlicht.</span><span class="sxs-lookup"><span data-stu-id="7eb02-337">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7eb02-338">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-338">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-339">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-339">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-340">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-340">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="7eb02-341">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-341">The number of milliseconds to wait for the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-342">Versucht über eine angegebene Anzahl von Millisekunden hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-342">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7eb02-343">
            <see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-343">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-344">Wenn die `millisecondsTimeout` entspricht <xref:System.Threading.Timeout.Infinite>, diese Methode entspricht dem <xref:System.Threading.Monitor.Enter%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-344">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="7eb02-345">Wenn `millisecondsTimeout` gleich 0 ist, diese Methode entspricht <xref:System.Threading.Monitor.TryEnter%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-345">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-346">Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-346">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="7eb02-347">Weitere Informationen finden Sie unter den <xref:System.Threading.Monitor> Artikel.</span><span class="sxs-lookup"><span data-stu-id="7eb02-347">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="7eb02-348">Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in einem kritischen Abschnitt nur, wenn der Rückgabewert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="7eb02-348">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="7eb02-349">Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-349">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="7eb02-350">Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-350">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-351">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-351">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7eb02-352">
            <paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-352">
              <paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-353">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-353">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="7eb02-354">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne darstellt, für die auf die Sperre gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-354">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait for the lock.</span>
          </span>
          <span data-ttu-id="7eb02-355">Ein Wert von -1 Millisekunde gibt eine unbegrenzte Wartezeit an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-355">A value of –1 millisecond specifies an infinite wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-356">Versucht über einen angegebenen Zeitraum hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-356">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7eb02-357">
            <see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-357">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-358">Wenn der Wert des der `timeout` Parameter, die in Millisekunden konvertiert gleich – 1, ist diese Methode entspricht <xref:System.Threading.Monitor.Enter%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-358">If the value of the `timeout` parameter converted to milliseconds equals –1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="7eb02-359">Wenn der Wert des `timeout` gleich 0 ist, diese Methode entspricht <xref:System.Threading.Monitor.TryEnter%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-359">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-360">Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-360">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="7eb02-361">Weitere Informationen finden Sie unter den <xref:System.Threading.Monitor> Thema-Klasse.</span><span class="sxs-lookup"><span data-stu-id="7eb02-361">For details, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="7eb02-362">Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in einem kritischen Abschnitt nur, wenn der Rückgabewert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="7eb02-362">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="7eb02-363">Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-363">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="7eb02-364">Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-364">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-365">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-365">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7eb02-366">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-366">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-367">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-367">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="7eb02-368">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-368">The number of milliseconds to wait for the lock.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="7eb02-369">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-369">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="7eb02-370">Die Eingabe muss <see langword="false" /> sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-370">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="7eb02-371">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-371">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="7eb02-372">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-372">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-373">Versucht für die angegebene Anzahl von Millisekunden, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-373">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-374">Wenn die `millisecondsTimeout` entspricht <xref:System.Threading.Timeout.Infinite>, diese Methode entspricht dem <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-374">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="7eb02-375">Wenn `millisecondsTimeout` gleich 0 ist, diese Methode entspricht <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-375">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="7eb02-376">Wenn die Sperre nicht erstellt wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` -Parameter ist `false` nach diese Methode beendet.</span><span class="sxs-lookup"><span data-stu-id="7eb02-376">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="7eb02-377">Dadurch wird das Programm in allen Fällen, um zu bestimmen, ob es erforderlich, um die Sperre aufzuheben ist.</span><span class="sxs-lookup"><span data-stu-id="7eb02-377">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-378">Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-378">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="7eb02-379">Weitere Informationen finden Sie unter den <xref:System.Threading.Monitor> Thema-Klasse.</span><span class="sxs-lookup"><span data-stu-id="7eb02-379">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="7eb02-380">Um sicherzustellen, dass der Thread wird nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der `lockTaken` und Ausführen von Code in einem kritischen Abschnitt nur, wenn der Wert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="7eb02-380">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="7eb02-381">Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-381">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="7eb02-382">Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-382">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="7eb02-383">Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> -methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="7eb02-383">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="7eb02-384">Diese Überladung legt immer den Wert der Variablen, die an die `ref` Parameter (`ByRef` in Visual Basic) `lockTaken`, auch wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Testen ist, ob die Sperre sein veröffentlicht.</span><span class="sxs-lookup"><span data-stu-id="7eb02-384">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7eb02-385">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-385">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-386">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-386">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7eb02-387">
            <paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-387">
              <paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-388">Das Objekt, für das die Sperre erhalten werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-388">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="7eb02-389">Die Zeitspanne, für die auf die Sperre gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-389">The amount of time to wait for the lock.</span>
          </span>
          <span data-ttu-id="7eb02-390">Ein Wert von -1 Millisekunde gibt eine unbegrenzte Wartezeit an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-390">A value of –1 millisecond specifies an infinite wait.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="7eb02-391">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-391">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="7eb02-392">Die Eingabe muss <see langword="false" /> sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-392">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="7eb02-393">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-393">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="7eb02-394">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-394">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-395">Versucht für die angegebene Dauer, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-395">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-396">Wenn der Wert des der `timeout` Parameter, die in Millisekunden konvertiert gleich – 1, ist diese Methode entspricht <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-396">If the value of the `timeout` parameter converted to milliseconds equals –1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="7eb02-397">Wenn der Wert des `timeout` gleich 0 ist, diese Methode entspricht <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-397">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="7eb02-398">Wenn die Sperre nicht erstellt wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` -Parameter ist `false` nach diese Methode beendet.</span><span class="sxs-lookup"><span data-stu-id="7eb02-398">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="7eb02-399">Dadurch wird das Programm in allen Fällen, um zu bestimmen, ob es erforderlich, um die Sperre aufzuheben ist.</span><span class="sxs-lookup"><span data-stu-id="7eb02-399">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-400">Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-400">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="7eb02-401">Weitere Informationen finden Sie unter den <xref:System.Threading.Monitor> Thema-Klasse.</span><span class="sxs-lookup"><span data-stu-id="7eb02-401">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="7eb02-402">Um sicherzustellen, dass der Thread wird nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der `lockTaken` und Ausführen von Code in einem kritischen Abschnitt nur, wenn der Wert ist `true`.</span><span class="sxs-lookup"><span data-stu-id="7eb02-402">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="7eb02-403">Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-403">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="7eb02-404">Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-404">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7eb02-405">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-405">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-406">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-406">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7eb02-407">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-407">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7eb02-408">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-408">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-409">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-409">The object on which to wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-410">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-410">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7eb02-411">
            <see langword="true" />, wenn der Aufruf beendet wurde, weil der Aufrufer die Sperre für das angegebene Objekt erneut erhalten hat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-411">
              <see langword="true" /> if the call returned because the caller reacquired the lock for the specified object.</span>
          </span>
          <span data-ttu-id="7eb02-412">Diese Methode wird nicht beendet, wenn die Sperre nicht erneut erhalten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-412">This method does not return if the lock is not reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-413">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freigeben, sodass ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-413">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="7eb02-414">Der Aufrufer gesperrt, beim Warten auf die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-414">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="7eb02-415">Diese Methode wird aufgerufen, wenn der Aufrufer muss auf eine Zustandsänderung warten, die aufgrund von einem anderen Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-415">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="7eb02-416">Wenn ein Thread ruft `Wait`, es hebt die Sperre für das Objekt und gibt das Objekt in der Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="7eb02-416">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="7eb02-417">Der nächste Thread in die Warteschlange des Objekts (sofern vorhanden), ruft Sie die Sperre und verfügt über die exklusive Verwendung des Objekts.</span><span class="sxs-lookup"><span data-stu-id="7eb02-417">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="7eb02-418">Alle Threads, die aufgerufen werden `Wait` in der Warteschlange verbleiben, bis sie ein Signal von empfangen <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>, durch den Besitzer der Sperre gesendet.</span><span class="sxs-lookup"><span data-stu-id="7eb02-418">All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock.</span></span> <span data-ttu-id="7eb02-419">Wenn `Pulse` gesendet wird, wird nur der Thread am Anfang der Warteschlange für abzuarbeitende betroffen ist.</span><span class="sxs-lookup"><span data-stu-id="7eb02-419">If `Pulse` is sent, only the thread at the head of the waiting queue is affected.</span></span> <span data-ttu-id="7eb02-420">Wenn `PulseAll` gesendet wird, werden alle Threads, die für das Objekt darauf warten, sind betroffen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-420">If `PulseAll` is sent, all threads that are waiting for the object are affected.</span></span> <span data-ttu-id="7eb02-421">Das Signal empfangen wird, ein oder mehrere Threads verlassen die Warteschlange und geben Sie die Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="7eb02-421">When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</span></span> <span data-ttu-id="7eb02-422">Ein Thread in die Warteschlange ist zulässig, die Sperre erneut zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-422">A thread in the ready queue is permitted to reacquire the lock.</span></span>  
  
 <span data-ttu-id="7eb02-423">Diese Methode gibt zurück, wenn der aufrufende Thread die Sperre für das Objekt erneut erhält.</span><span class="sxs-lookup"><span data-stu-id="7eb02-423">This method returns when the calling thread reacquires the lock on the object.</span></span> <span data-ttu-id="7eb02-424">Beachten Sie, die diese Methode wird auf unbestimmte Zeit blockiert, wenn der Besitzer der Sperre nicht aufruft `Pulse` oder `PulseAll`.</span><span class="sxs-lookup"><span data-stu-id="7eb02-424">Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.</span></span>  
  
 <span data-ttu-id="7eb02-425">Der Aufrufer führt `Wait` , unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-425">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="7eb02-426">Vom Konzept her der `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer `Enter` für das Objekt und ruft `Exit` so oft wie nötig, um vollständig gesperrten Objekts freizugeben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-426">Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="7eb02-427">Der Aufrufer ist dann beim Warten auf das Objekt erneut blockiert.</span><span class="sxs-lookup"><span data-stu-id="7eb02-427">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="7eb02-428">Wenn der Aufrufer die Sperre erneut erhält, das System ruft `Enter` so oft wie nötig, um die gespeicherten wiederherstellen `Enter` Anzahl für den Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="7eb02-428">When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller.</span></span> <span data-ttu-id="7eb02-429">Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, diese Sperren werden nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-429">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
 <span data-ttu-id="7eb02-430">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise, die einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält enthält, und einen Verweis auf die Warteschlange für abzuarbeitende, einschließlich der enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts darauf warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-430">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="7eb02-431">Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-431">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="7eb02-432">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-432">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-433">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-433">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="7eb02-434">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-434">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="7eb02-435">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-435">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="7eb02-436">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-436">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-437">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-437">The object on which to wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="7eb02-438">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-438">The number of milliseconds to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-439">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-439">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="7eb02-440">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-440">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7eb02-441">
            <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-441">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="7eb02-442">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-442">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-443">Diese Methode wird nicht zurückgegeben, bis er eine exklusive Sperre auf erneut erhält die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="7eb02-443">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="7eb02-444">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freigeben, sodass ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-444">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="7eb02-445">Der Aufrufer gesperrt, beim Warten auf die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-445">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="7eb02-446">Diese Methode wird aufgerufen, wenn der Aufrufer muss auf eine Zustandsänderung warten, die aufgrund von einem anderen Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-446">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="7eb02-447">Das Timeout stellt sicher, dass der aktuelle Thread nicht auf unbestimmte Zeit gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="7eb02-447">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="7eb02-448">Er verschiebt außerdem den Thread auf die Warteschlange für abgearbeitete Threads in der Warteschlange, so, dass er die Sperre früher erneut abrufen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-448">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="7eb02-449">Der Thread kann den Rückgabewert von Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die die Wartezeit, geben verursacht hat auswerten und, wenn erforderlichen Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut auf.</span><span class="sxs-lookup"><span data-stu-id="7eb02-449">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="7eb02-450">Wenn ein Thread ruft `Wait`, es hebt die Sperre für das Objekt und gibt das Objekt in der Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="7eb02-450">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="7eb02-451">Der nächste Thread in die Warteschlange des Objekts (sofern vorhanden), ruft Sie die Sperre und verfügt über die exklusive Verwendung des Objekts.</span><span class="sxs-lookup"><span data-stu-id="7eb02-451">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="7eb02-452">Der Thread, der aufgerufen `Wait` bleibt in der Warteschlange warten, bis ein Thread, der die Sperre aufrechterhält ruft <xref:System.Threading.Monitor.PulseAll%2A>, oder es ist die nächste in der Warteschlange und ruft Sie ein Thread, der die Sperre aufrechterhält <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-452">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="7eb02-453">Aber wenn `millisecondsTimeout` verstreicht, bevor ein anderer Thread auf dieses Objekts ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> der ursprüngliche Thread-Methode wird in die Warteschlange verschoben, um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-453">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-454">Wenn <xref:System.Threading.Timeout.Infinite> angegeben ist, für die `millisecondsTimeout` Parameter dieser Methode blockiert unbegrenzt, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-454">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="7eb02-455">Wenn `millisecondsTimeout` gleich 0 ist, der aufrufende Thread `Wait` hebt die Sperre, und wird sofort in die Warteschlange um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-455">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="7eb02-456">Der Aufrufer führt `Wait` , unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-456">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="7eb02-457">Vom Konzept her der `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um vollständig gesperrten Objekts freizugeben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-457">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="7eb02-458">Der Aufrufer ist dann beim Warten auf das Objekt erneut blockiert.</span><span class="sxs-lookup"><span data-stu-id="7eb02-458">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="7eb02-459">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherten wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="7eb02-459">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="7eb02-460">Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, diese Sperren werden nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-460">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-461">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf der Warteschlange, enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-461">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="7eb02-462">Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-462">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="7eb02-463">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-463">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-464">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-464">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="7eb02-465">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-465">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="7eb02-466">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-466">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="7eb02-467">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-467">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7eb02-468">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-468">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-469">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-469">The object on which to wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="7eb02-470">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-470">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-471">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-471">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="7eb02-472">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-472">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7eb02-473">
            <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-473">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="7eb02-474">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-474">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-475">Diese Methode wird nicht zurückgegeben, bis er eine exklusive Sperre auf erneut erhält die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="7eb02-475">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="7eb02-476">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freigeben, sodass ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-476">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="7eb02-477">Der Aufrufer gesperrt, beim Warten auf die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-477">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="7eb02-478">Diese Methode wird aufgerufen, wenn der Aufrufer muss auf eine Zustandsänderung warten, die aufgrund von einem anderen Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-478">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="7eb02-479">Das Timeout stellt sicher, dass der aktuelle Thread nicht auf unbestimmte Zeit gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="7eb02-479">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="7eb02-480">Er verschiebt außerdem den Thread auf die Warteschlange für abgearbeitete Threads in der Warteschlange, so, dass er die Sperre früher erneut abrufen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-480">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="7eb02-481">Der Thread kann den Rückgabewert von Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die die Wartezeit, geben verursacht hat auswerten und, wenn erforderlichen Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut auf.</span><span class="sxs-lookup"><span data-stu-id="7eb02-481">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="7eb02-482">Wenn ein Thread ruft `Wait`, es hebt die Sperre für das Objekt und gibt das Objekt in der Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="7eb02-482">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="7eb02-483">Der nächste Thread in die Warteschlange des Objekts (sofern vorhanden), ruft Sie die Sperre und verfügt über die exklusive Verwendung des Objekts.</span><span class="sxs-lookup"><span data-stu-id="7eb02-483">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="7eb02-484">Der Thread, der aufgerufen `Wait` bleibt in der Warteschlange warten, bis ein Thread, der die Sperre aufrechterhält ruft <xref:System.Threading.Monitor.PulseAll%2A>, oder es ist die nächste in der Warteschlange und ruft Sie ein Thread, der die Sperre aufrechterhält <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-484">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="7eb02-485">Aber wenn `timeout` verstreicht, bevor ein anderer Thread auf dieses Objekts ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> der ursprüngliche Thread-Methode wird in die Warteschlange verschoben, um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-485">However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-486">Wenn eine <xref:System.TimeSpan> -1 Millisekunde angegeben ist, für die `timeout` Parameter dieser Methode blockiert unbegrenzt, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-486">If a <xref:System.TimeSpan> representing –1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="7eb02-487">Wenn `timeout` ist 0 Millisekunden, der aufrufende Thread `Wait` hebt die Sperre, und wird sofort in die Warteschlange um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-487">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="7eb02-488">Der Aufrufer führt `Wait` , unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-488">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="7eb02-489">Vom Konzept her der `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um vollständig gesperrten Objekts freizugeben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-489">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="7eb02-490">Der Aufrufer ist dann beim Warten auf das Objekt erneut blockiert.</span><span class="sxs-lookup"><span data-stu-id="7eb02-490">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="7eb02-491">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherten wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="7eb02-491">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="7eb02-492">Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, diese Sperren werden nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-492">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-493">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf der Warteschlange, enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-493">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="7eb02-494">Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-494">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="7eb02-495">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-495">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-496">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-496">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="7eb02-497">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-497">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="7eb02-498">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-498">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="7eb02-499">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-499">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7eb02-500">Der Wert des <paramref name="timeout" />-Parameters in Millisekunden ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> (-1 Millisekunde) dar, oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-500">The value of the <paramref name="timeout" /> parameter in milliseconds is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-501">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-501">The object on which to wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="7eb02-502">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-502">The number of milliseconds to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="7eb02-503">
            <see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-503">
              <see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-504">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-504">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="7eb02-505">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-505">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
          <span data-ttu-id="7eb02-506">Diese Methode gibt außerdem an, ob die Synchronisierungsdomäne danach für den Kontext (wenn es sich um einen synchronisierten Kontext handelt) vor dem Warten und erneuten Erhalten verlassen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-506">This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7eb02-507">
            <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-507">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="7eb02-508">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-508">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-509">Diese Methode wird nicht zurückgegeben, bis er eine exklusive Sperre auf erneut erhält die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="7eb02-509">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="7eb02-510">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freigeben, sodass ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-510">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="7eb02-511">Der Aufrufer gesperrt, beim Warten auf die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-511">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="7eb02-512">Diese Methode wird aufgerufen, wenn der Aufrufer muss auf eine Zustandsänderung warten, die aufgrund von einem anderen Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-512">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="7eb02-513">Das Timeout stellt sicher, dass der aktuelle Thread nicht auf unbestimmte Zeit gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="7eb02-513">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="7eb02-514">Er verschiebt außerdem den Thread auf die Warteschlange für abgearbeitete Threads in der Warteschlange, so, dass er die Sperre früher erneut abrufen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-514">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="7eb02-515">Der Thread kann den Rückgabewert von Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die die Wartezeit, geben verursacht hat auswerten und, wenn erforderlichen Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut auf.</span><span class="sxs-lookup"><span data-stu-id="7eb02-515">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="7eb02-516">Wenn ein Thread ruft `Wait`, es hebt die Sperre und die Warteschlange für abzuarbeitende eingibt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-516">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="7eb02-517">An diesem Punkt ist der nächste Thread in die Warteschlange (sofern vorhanden) zulässig, die Kontrolle über die Sperre zu übernehmen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-517">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="7eb02-518">Der Thread, der aufgerufen `Wait` bleibt in der Warteschlange warten, bis ein Thread, der die Sperre aufrechterhält ruft <xref:System.Threading.Monitor.PulseAll%2A>, oder es ist die nächste in der Warteschlange und ruft Sie ein Thread, der die Sperre aufrechterhält <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-518">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="7eb02-519">Aber wenn `millisecondsTimeout` verstreicht, bevor ein anderer Thread auf dieses Objekts ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> der ursprüngliche Thread-Methode wird in die Warteschlange verschoben, um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-519">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-520">Wenn <xref:System.Threading.Timeout.Infinite> angegeben ist, für die `millisecondsTimeout` Parameter dieser Methode blockiert unbegrenzt, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-520">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="7eb02-521">Wenn `millisecondsTimeout` gleich 0 ist, der aufrufende Thread `Wait` hebt die Sperre, und wird sofort in die Warteschlange um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-521">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="7eb02-522">Der Aufrufer führt `Wait` , unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-522">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="7eb02-523">Vom Konzept her der `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um vollständig gesperrten Objekts freizugeben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-523">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="7eb02-524">Der Aufrufer ist dann beim Warten auf das Objekt erneut blockiert.</span><span class="sxs-lookup"><span data-stu-id="7eb02-524">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="7eb02-525">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherten wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="7eb02-525">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="7eb02-526">Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, diese Sperren werden nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-526">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-527">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf der Warteschlange, enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-527">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="7eb02-528">Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-528">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="7eb02-529">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-529">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="7eb02-530">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="7eb02-530">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="7eb02-531">Die`exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.Monitor.Wait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-531">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="7eb02-532">Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-532">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="7eb02-533">Selbst wenn derzeit eine Methode einer Klasse ausgeführt wird, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="7eb02-533">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="7eb02-534">Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.Monitor.Wait%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="7eb02-534">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="7eb02-535">Nach dem Aufruf des ursprünglichen Kontexts der vom Standard abweichenden gibt die <xref:System.Threading.Monitor.Wait%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-535">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="7eb02-536">Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über die <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> -Attribut.</span><span class="sxs-lookup"><span data-stu-id="7eb02-536">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="7eb02-537">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="7eb02-537">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="7eb02-538">Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.Monitor.Wait%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-538">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="7eb02-539">Wenn die <xref:System.Threading.Monitor.Wait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-539">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-540">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-540">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="7eb02-541">
            <see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-541">
              <see langword="Wait" /> is not invoked from within a synchronized block of code.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="7eb02-542">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-542">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="7eb02-543">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-543">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7eb02-544">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-544">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7eb02-545">Das Objekt, auf das gewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-545">The object on which to wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="7eb02-546">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-546">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="7eb02-547">
            <see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-547">
              <see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7eb02-548">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-548">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="7eb02-549">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-549">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
          <span data-ttu-id="7eb02-550">Beendet vor dem Warten optional auch die Synchronisierungsdomäne für den synchronisierten Kontext und erhält die Domäne anschließend wieder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-550">Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7eb02-551">
            <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-551">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="7eb02-552">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-552">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7eb02-553">Diese Methode wird nicht zurückgegeben, bis er eine exklusive Sperre auf erneut erhält die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="7eb02-553">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="7eb02-554">Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freigeben, sodass ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-554">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="7eb02-555">Der Aufrufer gesperrt, beim Warten auf die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-555">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="7eb02-556">Diese Methode wird aufgerufen, wenn der Aufrufer muss auf eine Zustandsänderung warten, die aufgrund von einem anderen Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-556">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="7eb02-557">Das Timeout stellt sicher, dass der aktuelle Thread nicht auf unbestimmte Zeit gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="7eb02-557">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="7eb02-558">Er verschiebt außerdem den Thread auf die Warteschlange für abgearbeitete Threads in der Warteschlange, so, dass er die Sperre früher erneut abrufen kann.</span><span class="sxs-lookup"><span data-stu-id="7eb02-558">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="7eb02-559">Der Thread kann den Rückgabewert von Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die die Wartezeit, geben verursacht hat auswerten und, wenn erforderlichen Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut auf.</span><span class="sxs-lookup"><span data-stu-id="7eb02-559">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="7eb02-560">Wenn ein Thread ruft `Wait`, es hebt die Sperre und die Warteschlange für abzuarbeitende eingibt.</span><span class="sxs-lookup"><span data-stu-id="7eb02-560">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="7eb02-561">An diesem Punkt ist der nächste Thread in die Warteschlange (sofern vorhanden) zulässig, die Kontrolle über die Sperre zu übernehmen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-561">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="7eb02-562">Der Thread, der aufgerufen `Wait` bleibt in der Warteschlange warten, bis ein Thread, der die Sperre aufrechterhält ruft <xref:System.Threading.Monitor.PulseAll%2A>, oder es ist die nächste in der Warteschlange und ruft Sie ein Thread, der die Sperre aufrechterhält <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-562">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="7eb02-563">Aber wenn `timeout` Millisekunden ablaufen, bevor ein anderer Thread auf dieses Objekts ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> der ursprüngliche Thread-Methode wird in die Warteschlange verschoben, um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-563">However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-564">Wenn eine <xref:System.TimeSpan> -1 Millisekunde angegeben ist, für die `timeout` Parameter dieser Methode blockiert unbegrenzt, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-564">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="7eb02-565">Wenn `timeout` ist 0 Millisekunden, der aufrufende Thread `Wait` hebt die Sperre, und wird sofort in die Warteschlange um die Sperre erneut erhalten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-565">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="7eb02-566">Der Aufrufer führt `Wait` , unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-566">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="7eb02-567">Vom Konzept her der `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um vollständig gesperrten Objekts freizugeben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-567">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="7eb02-568">Der Aufrufer ist dann beim Warten auf das Objekt erneut blockiert.</span><span class="sxs-lookup"><span data-stu-id="7eb02-568">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="7eb02-569">Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherten wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="7eb02-569">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="7eb02-570">Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, diese Sperren werden nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="7eb02-570">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7eb02-571">Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf der Warteschlange, enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-571">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="7eb02-572">Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="7eb02-572">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="7eb02-573">Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-573">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="7eb02-574">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="7eb02-574">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="7eb02-575">Die`exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.Monitor.Wait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-575">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="7eb02-576">Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="7eb02-576">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="7eb02-577">Selbst wenn derzeit eine Methode einer Klasse ausgeführt wird, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="7eb02-577">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="7eb02-578">Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.Monitor.Wait%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="7eb02-578">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="7eb02-579">Nach dem Aufruf des ursprünglichen Kontexts der vom Standard abweichenden gibt die <xref:System.Threading.Monitor.Wait%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-579">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="7eb02-580">Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über die <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> -Attribut.</span><span class="sxs-lookup"><span data-stu-id="7eb02-580">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="7eb02-581">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="7eb02-581">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="7eb02-582">Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.Monitor.Wait%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="7eb02-582">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="7eb02-583">Wenn die <xref:System.Threading.Monitor.Wait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.</span><span class="sxs-lookup"><span data-stu-id="7eb02-583">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7eb02-584">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-584">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="7eb02-585">
            <see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-585">
              <see langword="Wait" /> is not invoked from within a synchronized block of code.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="7eb02-586">Der Thread, der „Wait“ aufruft, wird später im Wartezustand unterbrochen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-586">The thread that invokes Wait is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="7eb02-587">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-587">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7eb02-588">Der <paramref name="timeout" />-Parameter ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> dar (-1 Millisekunde), oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7eb02-588">The <paramref name="timeout" /> parameter is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
  </Members>
</Type>