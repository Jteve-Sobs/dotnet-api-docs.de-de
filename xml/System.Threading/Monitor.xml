<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b32ac14c8b359aac4fdc30946b80cbf052e13741" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86849011" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <TypeSignature Language="C#" Value="public sealed class Monitor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Monitor extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Monitor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor sealed" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="39e32-101">Stellt einen Mechanismus bereit, der den Zugriff auf Objekte synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="39e32-101">Provides a mechanism that synchronizes access to objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-102">Mit der- <xref:System.Threading.Monitor> Klasse können Sie den Zugriff auf einen Code Bereich synchronisieren, indem Sie eine Sperre für ein bestimmtes-Objekt durch Aufrufen <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> der <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> Methoden, und aufrufen <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="39e32-102">The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="39e32-103">Objekt Sperren bieten die Möglichkeit, den Zugriff auf einen Codeblock einzuschränken, der in der Regel als kritischer Abschnitt bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-103">Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</span></span> <span data-ttu-id="39e32-104">Während ein Thread die Sperre für ein Objekt besitzt, kann kein anderer Thread diese Sperre erwerben.</span><span class="sxs-lookup"><span data-stu-id="39e32-104">While a thread owns the lock for an object, no other thread can acquire that lock.</span></span> <span data-ttu-id="39e32-105">Sie können auch die- <xref:System.Threading.Monitor> Klasse verwenden, um sicherzustellen, dass kein anderer Thread auf einen Abschnitt von Anwendungscode zugreifen darf, der vom Sperrenbesitzer ausgeführt wird, es sei denn, der andere Thread führt den Code mit einem anderen gesperrten Objekt aus.</span><span class="sxs-lookup"><span data-stu-id="39e32-105">You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</span></span>  
  
 <span data-ttu-id="39e32-106">Inhalt dieses Artikels:</span><span class="sxs-lookup"><span data-stu-id="39e32-106">In this article:</span></span>  
  
 <span data-ttu-id="39e32-107">[Die Monitor-Klasse: eine Übersicht](#Overview) </span><span class="sxs-lookup"><span data-stu-id="39e32-107">[The Monitor class: An overview](#Overview) </span></span>  
 <span data-ttu-id="39e32-108">[Das Sperr Objekt](#Lock) </span><span class="sxs-lookup"><span data-stu-id="39e32-108">[The lock object](#Lock) </span></span>  
 <span data-ttu-id="39e32-109">[Kritischer Abschnitt](#CriticalSection) </span><span class="sxs-lookup"><span data-stu-id="39e32-109">[The critical section](#CriticalSection) </span></span>  
 <span data-ttu-id="39e32-110">[Pulse, pulall und Wait](#Pulse) </span><span class="sxs-lookup"><span data-stu-id="39e32-110">[Pulse, PulseAll, and Wait](#Pulse) </span></span>  
 [<span data-ttu-id="39e32-111">Monitore und Wait-Handles</span><span class="sxs-lookup"><span data-stu-id="39e32-111">Monitors and wait handles</span></span>](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a><span data-ttu-id="39e32-112">Die Monitor-Klasse: eine Übersicht</span><span class="sxs-lookup"><span data-stu-id="39e32-112">The Monitor class: An overview</span></span>  
 <span data-ttu-id="39e32-113"><xref:System.Threading.Monitor> bietet die folgenden Features:</span><span class="sxs-lookup"><span data-stu-id="39e32-113"><xref:System.Threading.Monitor> has the following features:</span></span>  
  
-   <span data-ttu-id="39e32-114">Sie ist einem Objekt bei Bedarf zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="39e32-114">It is associated with an object on demand.</span></span>  
  
-   <span data-ttu-id="39e32-115">Die Bindung ist aufgehoben, d. h., Sie kann direkt aus jedem beliebigen Kontext aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="39e32-115">It is unbound, which means it can be called directly from any context.</span></span>  
  
-   <span data-ttu-id="39e32-116">Eine Instanz der- <xref:System.Threading.Monitor> Klasse kann nicht erstellt werden. die Methoden der- <xref:System.Threading.Monitor> Klasse sind alle statisch.</span><span class="sxs-lookup"><span data-stu-id="39e32-116">An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static.</span></span> <span data-ttu-id="39e32-117">Jeder Methode wird das synchronisierte Objekt, das den Zugriff auf den kritischen Abschnitt steuert, weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-117">Each method is passed the synchronized object that controls access to the critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-118">Verwenden Sie die- <xref:System.Threading.Monitor> Klasse, um andere Objekte als Zeichen folgen (d. h. andere Verweis Typen als <xref:System.String> ) und keine Werttypen zu sperren.</span><span class="sxs-lookup"><span data-stu-id="39e32-118">Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types.</span></span> <span data-ttu-id="39e32-119">Weitere Informationen finden Sie in den über Ladungen der <xref:System.Threading.Monitor.Enter%2A> -Methode und [im Abschnitt Sperr Objekt](#Lock) weiter unten in diesem Artikel.</span><span class="sxs-lookup"><span data-stu-id="39e32-119">For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.</span></span>  
  
 <span data-ttu-id="39e32-120">In der folgenden Tabelle werden die Aktionen beschrieben, die von Threads durchgeführt werden können, die auf Synchronisierte Objekte zugreifen:</span><span class="sxs-lookup"><span data-stu-id="39e32-120">The following table describes the actions that can be taken by threads that access synchronized objects:</span></span>  
  
|<span data-ttu-id="39e32-121">Aktion</span><span class="sxs-lookup"><span data-stu-id="39e32-121">Action</span></span>|<span data-ttu-id="39e32-122">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="39e32-122">Description</span></span>|  
|------------|-----------------|  
|<span data-ttu-id="39e32-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span><span class="sxs-lookup"><span data-stu-id="39e32-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span></span>|<span data-ttu-id="39e32-124">Ruft eine Sperre für ein Objekt ab.</span><span class="sxs-lookup"><span data-stu-id="39e32-124">Acquires a lock for an object.</span></span> <span data-ttu-id="39e32-125">Diese Aktion markiert auch den Anfang eines kritischen Abschnitts.</span><span class="sxs-lookup"><span data-stu-id="39e32-125">This action also marks the beginning of a critical section.</span></span> <span data-ttu-id="39e32-126">Es kann kein anderer Thread in den kritischen Abschnitt eintreten, es sei denn, er führt die Anweisungen im kritischen Abschnitt mithilfe eines anderen gesperrten Objekts aus.</span><span class="sxs-lookup"><span data-stu-id="39e32-126">No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</span></span>|  
|<xref:System.Threading.Monitor.Wait%2A>|<span data-ttu-id="39e32-127">Gibt die Sperre für ein Objekt frei, um anderen Threads das Sperren und Zugreifen auf das Objekt zu gestatten.</span><span class="sxs-lookup"><span data-stu-id="39e32-127">Releases the lock on an object in order to permit other threads to lock and access the object.</span></span> <span data-ttu-id="39e32-128">Der aufrufenden Thread wartet, während ein anderer Thread auf das Objekt zugreift.</span><span class="sxs-lookup"><span data-stu-id="39e32-128">The calling thread waits while another thread accesses the object.</span></span> <span data-ttu-id="39e32-129">Impuls Signale werden verwendet, um wartende Threads über Änderungen am Zustand eines Objekts zu benachrichtigen.</span><span class="sxs-lookup"><span data-stu-id="39e32-129">Pulse signals are used to notify waiting threads about changes to an object's state.</span></span>|  
|<span data-ttu-id="39e32-130"><xref:System.Threading.Monitor.Pulse%2A> (Signal), <xref:System.Threading.Monitor.PulseAll%2A></span><span class="sxs-lookup"><span data-stu-id="39e32-130"><xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A></span></span>|<span data-ttu-id="39e32-131">Sendet ein Signal an einen oder mehrere wartende Threads.</span><span class="sxs-lookup"><span data-stu-id="39e32-131">Sends a signal to one or more waiting threads.</span></span> <span data-ttu-id="39e32-132">Das Signal benachrichtigt einen wartenden Thread, dass sich der Zustand des gesperrten Objekts geändert hat, und der Besitzer der Sperre ist bereit, die Sperre freizugeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-132">The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</span></span> <span data-ttu-id="39e32-133">Der wartende Thread wird in die bereite Warteschlange des Objekts eingefügt, sodass er möglicherweise die Sperre für das Objekt erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-133">The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</span></span> <span data-ttu-id="39e32-134">Sobald der Thread über die Sperre verfügt, kann er den neuen Status des Objekts überprüfen, um festzustellen, ob der erforderliche Zustand erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-134">Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</span></span>|  
|<xref:System.Threading.Monitor.Exit%2A>|<span data-ttu-id="39e32-135">Gibt die Sperre für ein Objekt frei.</span><span class="sxs-lookup"><span data-stu-id="39e32-135">Releases the lock on an object.</span></span> <span data-ttu-id="39e32-136">Diese Aktion markiert auch das Ende eines kritischen Abschnitts, der durch das gesperrte-Objekt geschützt wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-136">This action also marks the end of a critical section protected by the locked object.</span></span>|  
  
 <span data-ttu-id="39e32-137">Ab [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] gibt es zwei Sätze von über Ladungen für die <xref:System.Threading.Monitor.Enter%2A> -Methode und die- <xref:System.Threading.Monitor.TryEnter%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="39e32-137">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods.</span></span> <span data-ttu-id="39e32-138">Ein Satz von über Ladungen verfügt über einen- `ref` Parameter (in c#) oder `ByRef` (in Visual Basic) <xref:System.Boolean> , der atomisch auf festgelegt ist, `true` Wenn die Sperre abgerufen wird, selbst wenn eine Ausnahme ausgelöst wird, wenn die Sperre abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-138">One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock.</span></span> <span data-ttu-id="39e32-139">Verwenden Sie diese über Ladungen, wenn es wichtig ist, die Sperre in allen Fällen aufzuheben, auch wenn sich die Ressourcen, die von der Sperre geschützt werden, möglicherweise nicht in einem konsistenten Zustand befinden.</span><span class="sxs-lookup"><span data-stu-id="39e32-139">Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</span></span>  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a><span data-ttu-id="39e32-140">Das Sperr Objekt</span><span class="sxs-lookup"><span data-stu-id="39e32-140">The lock object</span></span>  
 <span data-ttu-id="39e32-141">Die Monitor-Klasse besteht aus `static` (in c#) oder  `Shared` (in Visual Basic) Methoden, die auf ein Objekt angewendet werden, das den Zugriff auf den kritischen Abschnitt steuert.</span><span class="sxs-lookup"><span data-stu-id="39e32-141">The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.</span></span>  <span data-ttu-id="39e32-142">Die folgenden Informationen werden für jedes synchronisierte Objekt verwaltet:</span><span class="sxs-lookup"><span data-stu-id="39e32-142">The following information is maintained for each synchronized object:</span></span>  
  
-   <span data-ttu-id="39e32-143">Ein Verweis auf den Thread, der die Sperre zurzeit enthält.</span><span class="sxs-lookup"><span data-stu-id="39e32-143">A reference to the thread that currently holds the lock.</span></span>  
  
-   <span data-ttu-id="39e32-144">Ein Verweis auf eine bereite Warteschlange, die die Threads enthält, die zum Abrufen der Sperre bereit sind.</span><span class="sxs-lookup"><span data-stu-id="39e32-144">A reference to a ready queue, which contains the threads that are ready to obtain the lock.</span></span>  
  
-   <span data-ttu-id="39e32-145">Ein Verweis auf eine Warteschlange, die die Threads enthält, die auf eine Änderung des Status des gesperrten Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-145">A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</span></span>  
  
 <span data-ttu-id="39e32-146"><xref:System.Threading.Monitor> sperrt Objekte (d. h. Referenztypen), nicht Werttypen.</span><span class="sxs-lookup"><span data-stu-id="39e32-146"><xref:System.Threading.Monitor> locks objects (that is, reference types), not value types.</span></span> <span data-ttu-id="39e32-147">Sie können einen Werttyp an <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> übergeben. Dieser wird jedoch für jeden Aufruf separat geschachtelt.</span><span class="sxs-lookup"><span data-stu-id="39e32-147">While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call.</span></span> <span data-ttu-id="39e32-148">Da jeder Aufruf ein separates Objekt erstellt, bedingt <xref:System.Threading.Monitor.Enter%2A> nie eine Blockierung, und der Code, den die Methode eigentlich schützen soll, wird nicht wirklich synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="39e32-148">Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized.</span></span> <span data-ttu-id="39e32-149">Darüber hinaus unterscheiden sich das an <xref:System.Threading.Monitor.Exit%2A> und das an <xref:System.Threading.Monitor.Enter%2A> übergebene Objekt, sodass <xref:System.Threading.Monitor> eine <xref:System.Threading.SynchronizationLockException> mit der folgenden Meldung auslöst: „Die Objektsynchronisierungsmethode wurde von einem nicht synchronisierten Codeblock aufgerufen.“</span><span class="sxs-lookup"><span data-stu-id="39e32-149">In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message "Object synchronization method was called from an unsynchronized block of code."</span></span>  
  
 <span data-ttu-id="39e32-150">Dieses Problem wird anhand des folgenden Beispiels veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="39e32-150">The following example illustrates this problem.</span></span> <span data-ttu-id="39e32-151">Im Beispiel werden zehn Aufgaben gestartet, wobei jede lediglich 250 Millisekunden inaktiv ist.</span><span class="sxs-lookup"><span data-stu-id="39e32-151">It launches ten tasks, each of which just sleeps for 250 milliseconds.</span></span> <span data-ttu-id="39e32-152">Anschließend aktualisiert jede Aufgabe eine Zählervariable, `nTasks`, die dazu vorgesehen ist, die Anzahl von Aufgaben zu zählen, die tatsächlich gestartet wurden und ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="39e32-152">Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed.</span></span> <span data-ttu-id="39e32-153">Weil `nTasks` eine globale Variable ist, die von mehreren Aufgaben gleichzeitig aktualisiert werden kann, wird ein Monitor verwendet, um zu verhindern, dass die Variable gleichzeitig von mehreren Aufgaben geändert wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-153">Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</span></span> <span data-ttu-id="39e32-154">Wie die Ausgabe des Beispiels zeigt, löst jede dieser Aufgaben jedoch eine <xref:System.Threading.SynchronizationLockException>-Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="39e32-154">However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 <span data-ttu-id="39e32-155">Jede Aufgabe löst eine <xref:System.Threading.SynchronizationLockException>-Ausnahme aus, weil die Variable `nTasks` gekapselt wird, bevor in jeder Aufgabe die <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-155">Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method in each task.</span></span> <span data-ttu-id="39e32-156">Anders formuliert heißt das, bei jedem Methodenaufruf wird eine separate Variable übergeben, die unabhängig von den anderen ist.</span><span class="sxs-lookup"><span data-stu-id="39e32-156">In other words, each method call is passed a separate variable that is independent of the others.</span></span> <span data-ttu-id="39e32-157">`nTasks` wird im Aufruf der <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>-Methode erneut gekapselt.</span><span class="sxs-lookup"><span data-stu-id="39e32-157">`nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="39e32-158">Dadurch werden wiederum zehn neue gekapselte `nTasks`-Variablen erstellt, die unabhängig voneinander sind. Hinzu kommen die zehn gekapselten Variablen, die im Aufruf der <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>-Methode erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="39e32-158">Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="39e32-159">Die Ausnahme wird dann ausgelöst, weil im Code versucht wird, eine Sperre für eine neu erstellte Variable freizugeben, die zuvor nicht gesperrt wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-159">The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</span></span>  
  
 <span data-ttu-id="39e32-160">Wie das folgende Beispiel zeigt, können Sie eine Werttypvariable zwar vor dem Aufruf von <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> kapseln und dasselbe gekapselte Objekt an beide Methoden übergeben, diese Vorgehensweise bietet jedoch keinerlei Vorteile.</span><span class="sxs-lookup"><span data-stu-id="39e32-160">Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</span></span> <span data-ttu-id="39e32-161">Änderungen an der nicht gekapselten Variablen wirken sich nicht auf die gekapselte Kopie aus, und es ist nicht möglich, den Wert der gekapselten Kopie zu ändern.</span><span class="sxs-lookup"><span data-stu-id="39e32-161">Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 <span data-ttu-id="39e32-162">Wenn Sie ein Objekt auswählen, das synchronisiert werden soll, sollten Sie nur private oder interne Objekte sperren.</span><span class="sxs-lookup"><span data-stu-id="39e32-162">When selecting an object on which to synchronize, you should lock only on private or internal objects.</span></span> <span data-ttu-id="39e32-163">Sperren für externe Objekte können zu Deadlocks führen, da nicht verknüpften Code die gleichen Objekte auswählen kann, die für unterschiedliche Zwecke gesperrt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="39e32-163">Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</span></span>  
  
 <span data-ttu-id="39e32-164">Beachten Sie, dass Sie die Synchronisierung für ein Objekt in mehreren Anwendungs Domänen durchzuführen, wenn das für die Sperre verwendete Objekt von abgeleitet ist <xref:System.MarshalByRefObject> .</span><span class="sxs-lookup"><span data-stu-id="39e32-164">Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a><span data-ttu-id="39e32-165">Kritischer Abschnitt</span><span class="sxs-lookup"><span data-stu-id="39e32-165">The critical section</span></span>  
 <span data-ttu-id="39e32-166">Verwenden <xref:System.Threading.Monitor.Enter%2A> Sie die-Methode und die- <xref:System.Threading.Monitor.Exit%2A> Methode, um den Anfang und das Ende eines kritischen Abschnitts zu markieren.</span><span class="sxs-lookup"><span data-stu-id="39e32-166">Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-167">Die von der-Methode und der-Methode bereitgestellte Funktionalität ist mit der <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.Exit%2A> von der [Lock](/dotnet/csharp/language-reference/keywords/lock-statement) -Anweisung in c# und der [SyncLock](/dotnet/visual-basic/language-reference/statements/synclock-statement) -Anweisung in Visual Basic bereitgestellten Funktionalität identisch, mit der Ausnahme, dass die Sprachkonstrukte die <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> -Methoden Überladung und die- <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> Methode in `try``finally`</span><span class="sxs-lookup"><span data-stu-id="39e32-167">The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](/dotnet/csharp/language-reference/keywords/lock-statement) statement in C# and the [SyncLock](/dotnet/visual-basic/language-reference/statements/synclock-statement) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method in a `try`…`finally`</span></span> <span data-ttu-id="39e32-168">blockieren, um sicherzustellen, dass der Monitor freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-168">block to ensure that the monitor is released.</span></span>  
  
 <span data-ttu-id="39e32-169">Wenn der kritische Abschnitt aus einer Reihe von zusammenhängenden Anweisungen besteht, gewährleistet die von der-Methode abgerufene Sperre <xref:System.Threading.Monitor.Enter%2A> , dass nur ein einzelner Thread den eingeschlossenen Code mit dem gesperrten Objekt ausführen kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-169">If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object.</span></span> <span data-ttu-id="39e32-170">In diesem Fall wird empfohlen, dass Sie diesen Code in einem `try` -Block platzieren und den-Befehl in einem-Block an die-Methode anordnen <xref:System.Threading.Monitor.Exit%2A> `finally` .</span><span class="sxs-lookup"><span data-stu-id="39e32-170">In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block.</span></span> <span data-ttu-id="39e32-171">Dadurch ist sichergestellt, dass die Sperre aufgehoben wird, selbst wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-171">This ensures that the lock is released even if an exception occurs.</span></span> <span data-ttu-id="39e32-172">Dieses Muster wird im folgenden Code Fragment veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="39e32-172">The following code fragment illustrates this pattern.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 <span data-ttu-id="39e32-173">Diese Funktion wird normalerweise verwendet, um den Zugriff auf eine statische Methode oder Instanzmethode einer Klasse zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="39e32-173">This facility is typically used to synchronize access to a static or instance method of a class.</span></span>  
  
 <span data-ttu-id="39e32-174">Wenn ein kritischer Abschnitt eine gesamte Methode umfasst, kann die Sperre erreicht werden, indem das <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> -Objekt auf der-Methode platziert und der <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> Wert im Konstruktor von angegeben wird <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="39e32-174">If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="39e32-175">Wenn Sie dieses Attribut verwenden, <xref:System.Threading.Monitor.Enter%2A> werden die-und- <xref:System.Threading.Monitor.Exit%2A> Methodenaufrufe nicht benötigt.</span><span class="sxs-lookup"><span data-stu-id="39e32-175">When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed.</span></span> <span data-ttu-id="39e32-176">Dieses Muster wird im folgenden Code Fragment veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="39e32-176">The following code fragment illustrates this pattern:</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 <span data-ttu-id="39e32-177">Beachten Sie, dass das-Attribut bewirkt, dass der aktuelle Thread die Sperre aufrecht hat, bis die Methode zurückgibt. Wenn die Sperre früher freigegeben werden kann, verwenden Sie die- <xref:System.Threading.Monitor> Klasse, die c#- [Lock](/dotnet/csharp/language-reference/keywords/lock-statement) -Anweisung oder die Visual Basic [SyncLock](/dotnet/visual-basic/language-reference/statements/synclock-statement) -Anweisung innerhalb der-Methode anstelle des-Attributs.</span><span class="sxs-lookup"><span data-stu-id="39e32-177">Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](/dotnet/csharp/language-reference/keywords/lock-statement) statement, or the Visual Basic [SyncLock](/dotnet/visual-basic/language-reference/statements/synclock-statement) statement inside of the method instead of the attribute.</span></span>  
  
 <span data-ttu-id="39e32-178">Es ist zwar möglich, <xref:System.Threading.Monitor.Enter%2A> dass die-und- <xref:System.Threading.Monitor.Exit%2A> Anweisungen, die ein angegebenes-Objekt Sperren und für übergreifende Member-oder Klassengrenzen oder beides freigeben, dies jedoch nicht empfehlenswert ist.</span><span class="sxs-lookup"><span data-stu-id="39e32-178">While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</span></span>  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a><span data-ttu-id="39e32-179">Pulse, pulall und Wait</span><span class="sxs-lookup"><span data-stu-id="39e32-179">Pulse, PulseAll, and Wait</span></span>  
 <span data-ttu-id="39e32-180">Sobald ein Thread die Sperre besitzt und den kritischen Abschnitt eingegeben hat, den die Sperre schützt, kann er die <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType> Methoden, und aufzurufen <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="39e32-180">Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="39e32-181">Wenn der Thread, der die Sperre enthält <xref:System.Threading.Monitor.Wait%2A> , aufgerufen wird, wird die Sperre freigegeben, und der Thread wird der Warteschlange für das synchronisierte Objekt hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="39e32-181">When the thread that holds the lock calls <xref:System.Threading.Monitor.Wait%2A>, the lock is released and the thread is added to the waiting queue of the synchronized object.</span></span> <span data-ttu-id="39e32-182">Der erste Thread in der Warteschlange, sofern vorhanden, erhält die Sperre und wechselt in den kritischen Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="39e32-182">The first thread in the ready queue, if any, acquires the lock and enters the critical section.</span></span> <span data-ttu-id="39e32-183">Der Thread, der aufgerufen hat, <xref:System.Threading.Monitor.Wait%2A> wird aus der Warteschlange in die Warteschlange verschoben, wenn entweder die- <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> Methode oder die- <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> Methode von dem Thread aufgerufen wird, der die Sperre besitzt (der Thread muss sich an der Spitze der Warteschlange befinden).</span><span class="sxs-lookup"><span data-stu-id="39e32-183">The thread that called <xref:System.Threading.Monitor.Wait%2A> is moved from the waiting queue to the ready queue when either the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> or the <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> method is called by the thread that holds the lock (to be moved, the thread must be at the head of the waiting queue).</span></span> <span data-ttu-id="39e32-184">Die <xref:System.Threading.Monitor.Wait%2A> Methode gibt zurück, wenn der aufrufenden Thread die Sperre erneut erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-184">The <xref:System.Threading.Monitor.Wait%2A> method returns when the calling thread reacquires the lock.</span></span>  
  
 <span data-ttu-id="39e32-185">Wenn der Thread, der die Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> , aufruft, wird der Thread an der Spitze der Warteschlange in die bereite Warteschlange verschoben.</span><span class="sxs-lookup"><span data-stu-id="39e32-185">When the thread that holds the lock calls <xref:System.Threading.Monitor.Pulse%2A>, the thread at the head of the waiting queue is moved to the ready queue.</span></span> <span data-ttu-id="39e32-186">Durch den-Methodenaufrufe werden <xref:System.Threading.Monitor.PulseAll%2A> alle Threads aus der Warteschlange in die bereite Warteschlange verschoben.</span><span class="sxs-lookup"><span data-stu-id="39e32-186">The call to the <xref:System.Threading.Monitor.PulseAll%2A> method moves all the threads from the waiting queue to the ready queue.</span></span>  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a><span data-ttu-id="39e32-187">Monitore und Wait-Handles</span><span class="sxs-lookup"><span data-stu-id="39e32-187">Monitors and wait handles</span></span>  
 <span data-ttu-id="39e32-188">Es ist wichtig, den Unterschied zwischen der Verwendung der <xref:System.Threading.Monitor> -Klasse und der-Objekte zu beachten <xref:System.Threading.WaitHandle> .</span><span class="sxs-lookup"><span data-stu-id="39e32-188">It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.</span></span>  
  
-   <span data-ttu-id="39e32-189">Die <xref:System.Threading.Monitor> Klasse ist rein verwaltet, vollständig portabel und im Hinblick auf Betriebssystem-Ressourcenanforderungen effizienter.</span><span class="sxs-lookup"><span data-stu-id="39e32-189">The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</span></span>  
  
-   <span data-ttu-id="39e32-190"><xref:System.Threading.WaitHandle>-Objekte repräsentieren Objekte des Betriebssystems, die in der Lage sind, ihre Ausführung zu unterbrechen und zu warten. Sie sind für die Synchronisierung zwischen verwaltetem und nicht verwaltetem Code von Nutzen und machen einige höhere Betriebssystemfunktionen verfügbar, z. B. die Fähigkeit, auf viele Objekte gleichzeitig zu warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-190"><xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39e32-191">Im folgenden Beispiel wird die- <xref:System.Threading.Monitor> Klasse verwendet, um den Zugriff auf eine einzelne Instanz eines Zufallszahlengenerators zu synchronisieren, der durch die-Klasse dargestellt wird <xref:System.Random> .</span><span class="sxs-lookup"><span data-stu-id="39e32-191">The following example uses the <xref:System.Threading.Monitor> class to synchronize access to a single instance of a random number generator represented by the <xref:System.Random> class.</span></span> <span data-ttu-id="39e32-192">Im Beispiel werden zehn Aufgaben erstellt, von denen jede asynchron in einem Thread Pool Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-192">The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</span></span> <span data-ttu-id="39e32-193">Jede Aufgabe generiert 10.000 Zufallszahlen, berechnet ihren Durchschnitt und aktualisiert zwei Variablen auf Prozedur Ebene, die eine laufende Gesamtzahl der generierten Zufallszahlen und deren Summe beibehalten.</span><span class="sxs-lookup"><span data-stu-id="39e32-193">Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</span></span> <span data-ttu-id="39e32-194">Nachdem alle Tasks ausgeführt wurden, werden diese beiden Werte verwendet, um den allgemeinen Mittelwert zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="39e32-194">After all tasks have executed, these two values are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="39e32-195">Da auf Sie von jeder Aufgabe aus zugegriffen werden kann, die in einem Thread Pool Thread ausgeführt wird, muss der Zugriff auf die Variablen `total` und `n` ebenfalls synchronisiert werden.</span><span class="sxs-lookup"><span data-stu-id="39e32-195">Because they can be accessed from any task running on a thread pool thread, access to the variables `total` and `n` must also be synchronized.</span></span> <span data-ttu-id="39e32-196"><xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType>Zu diesem Zweck wird die-Methode verwendet.</span><span class="sxs-lookup"><span data-stu-id="39e32-196">The <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> method is used for this purpose.</span></span>  
  
 <span data-ttu-id="39e32-197">Im folgenden Beispiel wird die kombinierte Verwendung der <xref:System.Threading.Monitor> -Klasse (implementiert mit dem- `lock` oder- `SyncLock` Sprachkonstrukt), der <xref:System.Threading.Interlocked> -Klasse und der- <xref:System.Threading.AutoResetEvent> Klasse veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="39e32-197">The following example demonstrates the combined use of the <xref:System.Threading.Monitor> class (implemented with the `lock` or `SyncLock` language construct), the <xref:System.Threading.Interlocked> class, and the <xref:System.Threading.AutoResetEvent> class.</span></span> <span data-ttu-id="39e32-198">Im Beispiel werden zwei `internal`- (in C#) oder `Friend`-Klassen (in Visual Basic), `SyncResource` und `UnSyncResource`, definiert, die entsprechend synchronisierten und nicht synchronisierten Zugriff auf eine Ressource bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-198">It defines two `internal` (in C#) or `Friend` (in Visual Basic) classes, `SyncResource` and `UnSyncResource`, that respectively provide synchronized and unsynchronized access to a resource.</span></span> <span data-ttu-id="39e32-199">Damit sichergestellt ist, dass der Unterschied zwischen dem synchronisierten und dem nicht synchronisierten Zugriff im Beispiel deutlich wird (was der Fall sein kann, wenn jeder Methodenaufruf schnell abgeschlossen wird), enthält die Methode eine zufällige Verzögerung: Für Threads, deren <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>-Eigenschaft einen geraden Wert hat, ruft die Methode die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode auf, um eine Verzögerung von 2.000 Millisekunden einzuführen.</span><span class="sxs-lookup"><span data-stu-id="39e32-199">To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property is even, the method calls <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> to introduce a delay of 2,000 milliseconds.</span></span> <span data-ttu-id="39e32-200">Weil die `SyncResource`-Klasse nicht öffentlich ist, löst keiner der Clientcodes eine Sperre für die synchronisierte Ressource aus, sondern die Sperre wird von der internen Klasse selbst ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="39e32-200">Note that, because the `SyncResource` class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</span></span> <span data-ttu-id="39e32-201">Dadurch wird verhindert, dass bösartiger Code eine Sperre für ein öffentliches Objekt auslöst.</span><span class="sxs-lookup"><span data-stu-id="39e32-201">This prevents malicious code from taking a lock on a public object.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 <span data-ttu-id="39e32-202">Im Beispiel wird eine Variable, `numOps`, definiert, mit der die Anzahl von Threads festgelegt wird, die versuchen, auf die Ressource zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="39e32-202">The example defines a variable, `numOps`, that defines the number of threads that will attempt to access the resource.</span></span> <span data-ttu-id="39e32-203">Der Anwendungsthread ruft die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType>-Methode jeweils fünf Mal für synchronisierten und nicht synchronisierten Zugriff auf.</span><span class="sxs-lookup"><span data-stu-id="39e32-203">The application thread calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method for synchronized and unsynchronized access five times each.</span></span> <span data-ttu-id="39e32-204">Die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType>-Methode hat einen einzigen Parameter: ein Delegat, der keine Parameter akzeptiert und keinen Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="39e32-204">The <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method has a single parameter, a delegate that accepts no parameters and returns no value.</span></span> <span data-ttu-id="39e32-205">Für synchronisierten Zugriff und ruft die Methode die `SyncUpdateResource`Methode auf, für nicht synchronisierten Zugriff ruft sie die `UnSyncUpdateResource`-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="39e32-205">For synchronized access, it invokes the `SyncUpdateResource` method; for unsynchronized access, it invokes the `UnSyncUpdateResource` method.</span></span> <span data-ttu-id="39e32-206">Nach jedem Satz von Methoden aufrufen ruft der Anwendungs Thread die [AutoResetEvent. WaitOne](xref:System.Threading.WaitHandle.WaitOne*) -Methode auf, sodass er blockiert wird, bis die <xref:System.Threading.AutoResetEvent> Instanz signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-206">After each set of method calls, the application thread calls the [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) method so that it blocks until the <xref:System.Threading.AutoResetEvent> instance is signaled.</span></span>  
  
 <span data-ttu-id="39e32-207">Bei jedem Aufruf der `SyncUpdateResource`-Methode wird die interne `SyncResource.Access`-Methode und dann die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>-Methode aufgerufen, um den `numOps`-Zähler zu dekrementieren.</span><span class="sxs-lookup"><span data-stu-id="39e32-207">Each call to the `SyncUpdateResource` method calls the internal `SyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="39e32-208">Die- <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode wird verwendet, um den Leistungswert zu verringern, da Sie andernfalls nicht sicher sein können, dass ein zweiter Thread auf den Wert zugreift, bevor der dekrementierte Wert des ersten Threads in der Variablen gespeichert wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-208">The <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</span></span> <span data-ttu-id="39e32-209">Wenn der letzte synchronisierte Arbeits Thread den Wert auf 0 (null) verringert und angibt, dass alle synchronisierten Threads den Zugriff auf die Ressource abgeschlossen haben, ruft die- `SyncUpdateResource` Methode die- <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> Methode auf, die den Haupt Thread signalisiert, die Ausführung fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="39e32-209">When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the `SyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="39e32-210">Bei jedem Aufruf der `UnSyncUpdateResource`-Methode wird die interne `UnSyncResource.Access`-Methode und dann die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>-Methode aufgerufen, um den `numOps`-Zähler zu dekrementieren.</span><span class="sxs-lookup"><span data-stu-id="39e32-210">Each call to the `UnSyncUpdateResource` method calls the internal `UnSyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="39e32-211">Auch hier wird die- <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode verwendet, um den Leistungswert zu dekrementiert, um sicherzustellen, dass ein zweiter Thread nicht auf den Wert zugreift, bevor der Variablen der Wert eines ersten Threads zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-211">Once again, the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</span></span> <span data-ttu-id="39e32-212">Wenn der letzte nicht synchronisierte Arbeits Thread den Wert auf 0 (null) verringert, um anzugeben, dass keine nicht synchronisierten Threads auf die Ressource zugreifen müssen, `UnSyncUpdateResource` Ruft die Methode die- <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> Methode auf, die den Haupt Thread signalisiert, die Ausführung fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="39e32-212">When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the `UnSyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="39e32-213">Wie die Ausgabe des Beispiels zeigt, wird mit synchronisiertem Zugriff sichergestellt, dass der aufrufende Thread die geschützte Ressource beendet, bevor ein anderer Thread auf sie zugreifen kann. Jeder Thread wartet auf seinen Vorgänger.</span><span class="sxs-lookup"><span data-stu-id="39e32-213">As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</span></span> <span data-ttu-id="39e32-214">Andererseits, ohne die Sperre, wird die `UnSyncResource.Access`-Methode in der Reihenfolge aufgerufen, in der sie von Threads erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-214">On the other hand, without the lock, the `UnSyncResource.Access` method is called in the order in which threads reach it.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="39e32-215">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="39e32-215">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-216">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-216">Managed Threading</span></span></related>
    <related type="Article" href="/dotnet/standard/threading/threading-objects-and-features"><span data-ttu-id="39e32-217">Threadingobjekte und -funktionen</span><span class="sxs-lookup"><span data-stu-id="39e32-217">Threading Objects and Features</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="39e32-218">Erhält eine exklusive Sperre für ein angegebenes Objekt.</span><span class="sxs-lookup"><span data-stu-id="39e32-218">Acquires an exclusive lock on a specified object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-219">Das Objekt, für das die Monitorsperre erhalten werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-219">The object on which to acquire the monitor lock.</span></span></param>
        <summary><span data-ttu-id="39e32-220">Erhält eine exklusive Sperre für das angegebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="39e32-220">Acquires an exclusive lock on the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-221">Verwenden `Enter` Sie, um den <xref:System.Threading.Monitor> für das Objekt abzurufen, das als-Parameter übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-221">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter.</span></span> <span data-ttu-id="39e32-222">Wenn ein anderer Thread einen `Enter` für das-Objekt ausgeführt hat, aber noch nicht den entsprechenden ausgeführt hat <xref:System.Threading.Monitor.Exit%2A> , wird der aktuelle Thread blockiert, bis der andere Thread das-Objekt freigibt.</span><span class="sxs-lookup"><span data-stu-id="39e32-222">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="39e32-223">Es ist zulässig, dass derselbe Thread mehrmals aufgerufen wird, `Enter` ohne dass er blockiert wird. es muss jedoch eine gleichzeitige Anzahl von `Exit` aufrufen aufgerufen werden, bevor andere Threads, die auf das Objekt warten, die Blockierung aufheben.</span><span class="sxs-lookup"><span data-stu-id="39e32-223">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="39e32-224">Verwenden <xref:System.Threading.Monitor> Sie, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren.</span><span class="sxs-lookup"><span data-stu-id="39e32-224">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="39e32-225">Wenn Sie eine Werttyp Variable an übergeben `Enter` , wird Sie als-Objekt gekapselt.</span><span class="sxs-lookup"><span data-stu-id="39e32-225">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="39e32-226">Wenn Sie dieselbe Variable erneut an übergeben `Enter` , wird Sie als separates Objekt gekapselt, und der Thread wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="39e32-226">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="39e32-227">In diesem Fall ist der Code, der `Monitor` angeblich schützt, nicht geschützt.</span><span class="sxs-lookup"><span data-stu-id="39e32-227">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="39e32-228">Wenn Sie die-Variable an übergeben `Exit` , wird weiterhin ein anderes separates-Objekt erstellt.</span><span class="sxs-lookup"><span data-stu-id="39e32-228">Furthermore, when you pass the variable to `Exit`, still another separate object is created.</span></span> <span data-ttu-id="39e32-229">Das an über gegebene Objekt `Exit` unterscheidet sich von dem-Objekt, das an das-Objekt übermittelt wird `Enter` `Monitor` <xref:System.Threading.SynchronizationLockException> .</span><span class="sxs-lookup"><span data-stu-id="39e32-229">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="39e32-230">Weitere Informationen finden Sie im Thema über [Wachen](xref:System.Threading.Monitor)von konzeptionellen Themen.</span><span class="sxs-lookup"><span data-stu-id="39e32-230">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="39e32-231"><xref:System.Threading.Thread.Interrupt%2A> kann Threads unterbrechen, die auf das Eintreten eines `Monitor` für ein Objekt warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-231"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="39e32-232">Eine <xref:System.Threading.ThreadInterruptedException> wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="39e32-232">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
 <span data-ttu-id="39e32-233">C# verwenden `try` ...`finally`</span><span class="sxs-lookup"><span data-stu-id="39e32-233">Use a C# `try`…`finally`</span></span> <span data-ttu-id="39e32-234">Block ( `Try` ...`Finally`</span><span class="sxs-lookup"><span data-stu-id="39e32-234">block (`Try`…`Finally`</span></span> <span data-ttu-id="39e32-235">in Visual Basic), um sicherzustellen, dass Sie den Monitor freigeben, oder verwenden Sie die c# `lock` -Anweisung ( `SyncLock` Anweisung in Visual Basic), die die <xref:System.Threading.Monitor.Enter%2A> -Methode und die- <xref:System.Threading.Monitor.Exit%2A> Methode in einem umschließt `try` ...`finally`</span><span class="sxs-lookup"><span data-stu-id="39e32-235">in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`…`finally`</span></span> <span data-ttu-id="39e32-236">Baustein.</span><span class="sxs-lookup"><span data-stu-id="39e32-236">block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39e32-237">Im folgenden Beispiel wird die Verwendung der `Enter`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="39e32-237">The following example demonstrates how to use the `Enter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-238">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-238">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-239">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-239">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-240">Das Objekt, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-240">The object on which to wait.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="39e32-241">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span><span class="sxs-lookup"><span data-stu-id="39e32-241">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="39e32-242">Die Eingabe muss <see langword="false" /> sein.</span><span class="sxs-lookup"><span data-stu-id="39e32-242">The input must be <see langword="false" />.</span></span> <span data-ttu-id="39e32-243">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-243">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="39e32-244">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-244">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span>  
  
<span data-ttu-id="39e32-245">Hinweis   Wenn keine Ausnahme auftritt, ist die Ausgabe dieser Methode immer <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-245">Note   If no exception occurs, the output of this method is always <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="39e32-246">Erhält eine exklusive Sperre für das angegebene Objekt und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-246">Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-247">Verwenden `Enter` Sie, um den <xref:System.Threading.Monitor> für das Objekt abzurufen, das als-Parameter übergeben wird `obj` .</span><span class="sxs-lookup"><span data-stu-id="39e32-247">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter.</span></span> <span data-ttu-id="39e32-248">Wenn ein anderer Thread einen `Enter` für das-Objekt ausgeführt hat, aber noch nicht den entsprechenden ausgeführt hat <xref:System.Threading.Monitor.Exit%2A> , wird der aktuelle Thread blockiert, bis der andere Thread das-Objekt freigibt.</span><span class="sxs-lookup"><span data-stu-id="39e32-248">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="39e32-249">Es ist zulässig, dass derselbe Thread mehrmals aufgerufen wird, `Enter` ohne dass er blockiert wird. es muss jedoch eine gleichzeitige Anzahl von `Exit` aufrufen aufgerufen werden, bevor andere Threads, die auf das Objekt warten, die Blockierung aufheben.</span><span class="sxs-lookup"><span data-stu-id="39e32-249">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="39e32-250">Wenn die Sperre nicht übernommen wurde, weil eine Ausnahme ausgelöst wurde, ist die für den-Parameter angegebene Variable, `lockTaken` `false` nachdem diese Methode beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-250">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="39e32-251">Dadurch kann das Programm in allen Fällen ermitteln, ob es erforderlich ist, die Sperre freizugeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-251">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span> <span data-ttu-id="39e32-252">Wenn diese Methode zurückgegeben wird, ohne eine Ausnahme auszulösen, ist die für den-Parameter angegebene Variable `lockTaken` immer `true` , und es ist nicht erforderlich, Sie zu testen.</span><span class="sxs-lookup"><span data-stu-id="39e32-252">If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.</span></span>  
  
 <span data-ttu-id="39e32-253">Verwenden <xref:System.Threading.Monitor> Sie, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren.</span><span class="sxs-lookup"><span data-stu-id="39e32-253">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="39e32-254">Wenn Sie eine Werttyp Variable an übergeben `Enter` , wird Sie als-Objekt gekapselt.</span><span class="sxs-lookup"><span data-stu-id="39e32-254">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="39e32-255">Wenn Sie dieselbe Variable erneut an übergeben `Enter` , wird Sie als separates Objekt gekapselt, und der Thread wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="39e32-255">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="39e32-256">In diesem Fall ist der Code, der `Monitor` angeblich schützt, nicht geschützt.</span><span class="sxs-lookup"><span data-stu-id="39e32-256">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="39e32-257">Wenn Sie die-Variable an übergeben `Exit` , wird außerdem ein anderes separates-Objekt erstellt.</span><span class="sxs-lookup"><span data-stu-id="39e32-257">Furthermore, when you pass the variable to `Exit`, another separate object is created.</span></span> <span data-ttu-id="39e32-258">Das an über gegebene Objekt `Exit` unterscheidet sich von dem-Objekt, das an das-Objekt übermittelt wird `Enter` `Monitor` <xref:System.Threading.SynchronizationLockException> .</span><span class="sxs-lookup"><span data-stu-id="39e32-258">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="39e32-259">Weitere Informationen finden Sie im Thema über [Wachen](xref:System.Threading.Monitor)von konzeptionellen Themen.</span><span class="sxs-lookup"><span data-stu-id="39e32-259">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="39e32-260"><xref:System.Threading.Thread.Interrupt%2A> kann Threads unterbrechen, die auf das Eintreten eines `Monitor` für ein Objekt warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-260"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="39e32-261">Eine <xref:System.Threading.ThreadInterruptedException> wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="39e32-261">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39e32-262">Der folgende Code zeigt das grundlegende Muster für die Verwendung der- <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="39e32-262">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="39e32-263">Diese Überladung legt den Wert der Variablen fest, die an den- `ref` Parameter übergeben wird ( `ByRef` in Visual Basic) `lockTaken` . Dies gilt auch, wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Methode ist, um zu testen, ob die Sperre freigegeben werden muss.</span><span class="sxs-lookup"><span data-stu-id="39e32-263">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39e32-264">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-264">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-265">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-265">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-266">Das Objekt, dessen Sperre aufgehoben werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-266">The object on which to release the lock.</span></span></param>
        <summary><span data-ttu-id="39e32-267">Hebt eine exklusive Sperre für das angegebene Objekt auf.</span><span class="sxs-lookup"><span data-stu-id="39e32-267">Releases an exclusive lock on the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-268">Der aufrufenden Thread muss die Sperre für den `obj` Parameter besitzen.</span><span class="sxs-lookup"><span data-stu-id="39e32-268">The calling thread must own the lock on the `obj` parameter.</span></span> <span data-ttu-id="39e32-269">Wenn der aufrufende Thread die Sperre für das angegebene Objekt besitzt und eine gleiche Anzahl von `Exit` -und- <xref:System.Threading.Monitor.Enter%2A> Aufrufen für das-Objekt erstellt hat, wird die Sperre freigegeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-269">If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released.</span></span> <span data-ttu-id="39e32-270">Wenn der aufrufende Thread nicht `Exit` so oft wie aufgerufen wurde `Enter` , wird die Sperre nicht freigegeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-270">If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.</span></span>  
  
 <span data-ttu-id="39e32-271">Wenn die Sperre aufgehoben wird und sich andere Threads in der Warteschlange für das Objekt befinden, erhält einer der Threads die Sperre.</span><span class="sxs-lookup"><span data-stu-id="39e32-271">If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</span></span> <span data-ttu-id="39e32-272">Wenn sich andere Threads in der Warteschlange befinden, die darauf warten, die Sperre abzurufen, werden Sie nicht automatisch in die Warteschlange "Ready" verschoben, wenn der Besitzer der Sperre aufruft `Exit` .</span><span class="sxs-lookup"><span data-stu-id="39e32-272">If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`.</span></span> <span data-ttu-id="39e32-273">Um einen oder mehrere wartende Threads in die bereite Warteschlange zu verschieben, rufen Sie oder auf, bevor Sie aufrufen <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> `Exit` .</span><span class="sxs-lookup"><span data-stu-id="39e32-273">To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39e32-274">Im folgenden Beispiel wird die Verwendung der `Exit`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="39e32-274">The following example demonstrates how to use the `Exit` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-275">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-275">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="39e32-276">Der aktuelle Thread besitzt die Sperre für das angegebene Objekt nicht.</span><span class="sxs-lookup"><span data-stu-id="39e32-276">The current thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-277">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-277">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-278">Das zu überprüfende Objekt.</span><span class="sxs-lookup"><span data-stu-id="39e32-278">The object to test.</span></span></param>
        <summary><span data-ttu-id="39e32-279">Bestimmt, ob der aktuelle Thread die Sperre für das angegebene Objekt enthält.</span><span class="sxs-lookup"><span data-stu-id="39e32-279">Determines whether the current thread holds the lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="39e32-280"><see langword="true" />, wenn der aktuelle Thread die Schreibsperre für <paramref name="obj" /> enthält, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-280"><see langword="true" /> if the current thread holds the lock on <paramref name="obj" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-281">Diese Methode kann nur für Sperren verwendet werden, die mithilfe der-Methoden der- <xref:System.Threading.Monitor> Klasse oder mithilfe der c#- `lock` Anweisung oder der Visual Basic- `SyncLock` Anweisung, die mit implementiert werden, abgerufen werden <xref:System.Threading.Monitor> .</span><span class="sxs-lookup"><span data-stu-id="39e32-281">This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="39e32-282">Verwenden Sie diese Methode mit Diagnosetools wie der <xref:System.Diagnostics.Debug.Assert%2A> -Methode und der- <xref:System.Diagnostics.Contracts.Contract> Klasse, um Sperr Probleme zu debuggen, die die- <xref:System.Threading.Monitor> Klasse betreffen.</span><span class="sxs-lookup"><span data-stu-id="39e32-282">Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-283"><paramref name="obj" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-283"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LockContentionCount">
      <MemberSignature Language="C#" Value="public static long LockContentionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 LockContentionCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Monitor.LockContentionCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LockContentionCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long LockContentionCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LockContentionCount : int64" Usage="System.Threading.Monitor.LockContentionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="39e32-284">Ruft die Anzahl der Konflikte ab beim Versuch, die Sperre des Monitors aufzuheben.</span><span class="sxs-lookup"><span data-stu-id="39e32-284">Gets the number of times there was contention when trying to take the monitor's lock.</span></span></summary>
        <value><span data-ttu-id="39e32-285">Gibt an, wie oft Konflikte aufgetreten sind, als versucht wurde, die Sperre des Monitors zu übernehmen.</span><span class="sxs-lookup"><span data-stu-id="39e32-285">The number of times there was contention when trying to take the monitor's lock.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-286">Das Objekt, auf das ein Thread wartet.</span><span class="sxs-lookup"><span data-stu-id="39e32-286">The object a thread is waiting for.</span></span></param>
        <summary><span data-ttu-id="39e32-287">Benachrichtigt einen Thread in der Warteschlange für abzuarbeitende Threads über eine Änderung am Zustand des gesperrten Objekts.</span><span class="sxs-lookup"><span data-stu-id="39e32-287">Notifies a thread in the waiting queue of a change in the locked object's state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-288">Nur der aktuelle Besitzer der Sperre kann ein wartender Objekt mithilfe von signalisieren `Pulse` .</span><span class="sxs-lookup"><span data-stu-id="39e32-288">Only the current owner of the lock can signal a waiting object using `Pulse`.</span></span>  
  
 <span data-ttu-id="39e32-289">Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um den nächsten Thread in der Zeile für die Sperre zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="39e32-289">The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</span></span> <span data-ttu-id="39e32-290">Beim Empfang des Pulse wird der wartende Thread in die bereite Warteschlange verschoben.</span><span class="sxs-lookup"><span data-stu-id="39e32-290">Upon receiving the pulse, the waiting thread is moved to the ready queue.</span></span> <span data-ttu-id="39e32-291">Wenn der Thread, `Pulse` der die Sperre aufgerufen hat, die Sperre freigibt, erhält der nächste Thread in der Warteschlange (der nicht unbedingt der Thread ist, der gepultet wurde) die Sperre.</span><span class="sxs-lookup"><span data-stu-id="39e32-291">When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="39e32-292">Die- <xref:System.Threading.Monitor> Klasse behält den Zustand nicht bei, der angibt, dass die- <xref:System.Threading.Monitor.Pulse%2A> Methode aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-292">The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called.</span></span> <span data-ttu-id="39e32-293">Wenn Sie also aufrufen, <xref:System.Threading.Monitor.Pulse%2A> Wenn keine Threads warten, wird der nächste Thread, der <xref:System.Threading.Monitor.Wait%2A> Blöcke aufruft, als, wenn <xref:System.Threading.Monitor.Pulse%2A> nie aufgerufen wurde, aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-293">Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called.</span></span> <span data-ttu-id="39e32-294">Wenn zwei Threads <xref:System.Threading.Monitor.Pulse%2A> und <xref:System.Threading.Monitor.Wait%2A> für die Interaktion verwenden, könnte dies zu einem Deadlock führen.</span><span class="sxs-lookup"><span data-stu-id="39e32-294">If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock.</span></span> <span data-ttu-id="39e32-295">Vergleichen Sie dies mit dem Verhalten der- <xref:System.Threading.AutoResetEvent> Klasse: Wenn Sie ein signalisieren, indem Sie die zugehörige <xref:System.Threading.AutoResetEvent> <xref:System.Threading.EventWaitHandle.Set%2A> -Methode aufrufen und keine Threads warten, <xref:System.Threading.AutoResetEvent> verbleibt der in einem signalisierten Zustand, bis ein Thread <xref:System.Threading.WaitHandle.WaitOne%2A> , <xref:System.Threading.WaitHandle.WaitAny%2A> oder aufruft <xref:System.Threading.WaitHandle.WaitAll%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-295">Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="39e32-296">Der <xref:System.Threading.AutoResetEvent> gibt diesen Thread frei und kehrt in den nicht signalisierten Zustand zurück.</span><span class="sxs-lookup"><span data-stu-id="39e32-296">The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.</span></span>  
  
 <span data-ttu-id="39e32-297">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die bereit sind, die Sperre abzurufen, und einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-297">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="39e32-298">Die `Pulse` <xref:System.Threading.Monitor.PulseAll%2A> Methoden, und <xref:System.Threading.Monitor.Wait%2A> müssen in einem synchronisierten Codeblock aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="39e32-298">The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="39e32-299">Verwenden Sie die-Methode, um mehrere Threads zu signalisieren <xref:System.Threading.Monitor.PulseAll%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-299">To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-300">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-300">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="39e32-301">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="39e32-301">The calling thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-302">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-302">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-303">Das Objekt, das den Impuls sendet.</span><span class="sxs-lookup"><span data-stu-id="39e32-303">The object that sends the pulse.</span></span></param>
        <summary><span data-ttu-id="39e32-304">Benachrichtigt alle wartenden Threads über eine Änderung am Zustand des Objekts.</span><span class="sxs-lookup"><span data-stu-id="39e32-304">Notifies all waiting threads of a change in the object's state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-305">Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um alle Threads zu signalisieren, die auf das Abrufen der Sperre für das Objekt warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-305">The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</span></span> <span data-ttu-id="39e32-306">Nachdem das Signal gesendet wurde, werden die wartenden Threads in die bereite Warteschlange verschoben.</span><span class="sxs-lookup"><span data-stu-id="39e32-306">After the signal is sent, the waiting threads are moved to the ready queue.</span></span> <span data-ttu-id="39e32-307">Wenn der Thread, `PulseAll` der die Sperre ausgelöst hat, die Sperre freigibt, erhält der nächste Thread in der Ready-Warteschlange die Sperre.</span><span class="sxs-lookup"><span data-stu-id="39e32-307">When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.</span></span>  
  
 <span data-ttu-id="39e32-308">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die bereit sind, die Sperre abzurufen, und einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-308">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="39e32-309">Die <xref:System.Threading.Monitor.Pulse%2A> `PulseAll` Methoden, und <xref:System.Threading.Monitor.Wait%2A> müssen in einem synchronisierten Codeblock aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="39e32-309">The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="39e32-310">Die Hinweise für die- <xref:System.Threading.Monitor.Pulse%2A> Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-310">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 <span data-ttu-id="39e32-311">Verwenden Sie die-Methode, um einen einzelnen Thread zu signalisieren `Pulse` .</span><span class="sxs-lookup"><span data-stu-id="39e32-311">To signal a single thread, use the `Pulse` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-312">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-312">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="39e32-313">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="39e32-313">The calling thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-314">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-314">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="39e32-315">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="39e32-315">Attempts to acquire an exclusive lock on the specified object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-316">Das Objekt, für das die Sperre erhalten werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-316">The object on which to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="39e32-317">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="39e32-317">Attempts to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="39e32-318"><see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-318"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-319">Bei erfolgreicher Ausführung erhält diese Methode eine exklusive Sperre für den `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="39e32-319">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="39e32-320">Diese Methode wird sofort zurückgegeben, unabhängig davon, ob die Sperre verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="39e32-320">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="39e32-321">Diese Methode ähnelt <xref:System.Threading.Monitor.Enter%2A> , aber der aktuelle Thread wird nie blockiert.</span><span class="sxs-lookup"><span data-stu-id="39e32-321">This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread.</span></span> <span data-ttu-id="39e32-322">Wenn der Thread nicht ohne Blockierung eingegeben werden kann, gibt die Methode zurück `false,` .</span><span class="sxs-lookup"><span data-stu-id="39e32-322">If the thread cannot enter without blocking, the method returns `false,`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-323">Verwenden <xref:System.Threading.Monitor> Sie, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren.</span><span class="sxs-lookup"><span data-stu-id="39e32-323">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="39e32-324">Weitere Informationen finden Sie im <xref:System.Threading.Monitor> Artikel.</span><span class="sxs-lookup"><span data-stu-id="39e32-324">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="39e32-325">Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Rückgabewert der Methode überprüfen und Code im kritischen Abschnitt nur dann ausführen, wenn der Rückgabewert ist `true` .</span><span class="sxs-lookup"><span data-stu-id="39e32-325">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="39e32-326">Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-326">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="39e32-327">Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem- `finally` Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-327">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="39e32-328">Das folgende Codebeispiel zeigt, wie Sie die `TryEnter`-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="39e32-328">The following code example demonstrates how to use the `TryEnter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-329">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-329">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-330">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-330">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-331">Das Objekt, für das die Sperre erhalten werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-331">The object on which to acquire the lock.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="39e32-332">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span><span class="sxs-lookup"><span data-stu-id="39e32-332">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="39e32-333">Die Eingabe muss <see langword="false" /> sein.</span><span class="sxs-lookup"><span data-stu-id="39e32-333">The input must be <see langword="false" />.</span></span> <span data-ttu-id="39e32-334">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-334">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="39e32-335">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-335">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="39e32-336">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-336">Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-337">Bei erfolgreicher Ausführung erhält diese Methode eine exklusive Sperre für den `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="39e32-337">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="39e32-338">Diese Methode wird sofort zurückgegeben, unabhängig davon, ob die Sperre verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="39e32-338">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="39e32-339">Wenn die Sperre nicht übernommen wurde, weil eine Ausnahme ausgelöst wurde, ist die für den-Parameter angegebene Variable, `lockTaken` `false` nachdem diese Methode beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-339">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="39e32-340">Dadurch kann das Programm in allen Fällen ermitteln, ob es erforderlich ist, die Sperre freizugeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-340">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
 <span data-ttu-id="39e32-341">Diese Methode ähnelt <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> , aber der aktuelle Thread wird nie blockiert.</span><span class="sxs-lookup"><span data-stu-id="39e32-341">This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread.</span></span> <span data-ttu-id="39e32-342">Wenn der Thread nicht ohne Blockierung eingegeben werden kann, wird das- `lockTaken` Argument auf festgelegt, `false` Wenn die Methode zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="39e32-342">If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-343">Verwenden <xref:System.Threading.Monitor> Sie, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren.</span><span class="sxs-lookup"><span data-stu-id="39e32-343">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="39e32-344">Weitere Informationen finden Sie im Artikel <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="39e32-344">For more information, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="39e32-345">Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Wert von überprüfen `lockTaken` und Code im kritischen Abschnitt nur dann ausführen, wenn sein Wert ist `true` .</span><span class="sxs-lookup"><span data-stu-id="39e32-345">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="39e32-346">Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-346">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="39e32-347">Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem- `finally` Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-347">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="39e32-348">Der folgende Code zeigt das grundlegende Muster für die Verwendung der- <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="39e32-348">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="39e32-349">Diese Überladung legt den Wert der Variablen fest, die an den- `ref` Parameter übergeben wird ( `ByRef` in Visual Basic) `lockTaken` . Dies gilt auch, wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Methode ist, um zu testen, ob die Sperre freigegeben werden muss.</span><span class="sxs-lookup"><span data-stu-id="39e32-349">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39e32-350">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-350">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-351">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-351">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-352">Das Objekt, für das die Sperre erhalten werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-352">The object on which to acquire the lock.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="39e32-353">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-353">The number of milliseconds to wait for the lock.</span></span></param>
        <summary><span data-ttu-id="39e32-354">Versucht über eine angegebene Anzahl von Millisekunden hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="39e32-354">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="39e32-355"><see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-355"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-356">Wenn der- `millisecondsTimeout` Parameter gleich ist <xref:System.Threading.Timeout.Infinite> , entspricht diese Methode <xref:System.Threading.Monitor.Enter%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-356">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="39e32-357">Wenn `millisecondsTimeout` gleich 0 ist, entspricht diese Methode <xref:System.Threading.Monitor.TryEnter%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-357">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-358">Verwenden <xref:System.Threading.Monitor> Sie, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren.</span><span class="sxs-lookup"><span data-stu-id="39e32-358">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="39e32-359">Weitere Informationen finden Sie im <xref:System.Threading.Monitor> Artikel.</span><span class="sxs-lookup"><span data-stu-id="39e32-359">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="39e32-360">Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Rückgabewert der Methode überprüfen und Code im kritischen Abschnitt nur dann ausführen, wenn der Rückgabewert ist `true` .</span><span class="sxs-lookup"><span data-stu-id="39e32-360">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="39e32-361">Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-361">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="39e32-362">Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem- `finally` Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-362">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-363">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-363">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39e32-364"><paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-364"><paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-365">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-365">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-366">Das Objekt, für das die Sperre erhalten werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-366">The object on which to acquire the lock.</span></span></param>
        <param name="timeout"><span data-ttu-id="39e32-367">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne darstellt, für die auf die Sperre gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-367">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait for the lock.</span></span> <span data-ttu-id="39e32-368">Ein Wert von –1 Millisekunde gibt eine unbegrenzte Wartezeit an.</span><span class="sxs-lookup"><span data-stu-id="39e32-368">A value of -1 millisecond specifies an infinite wait.</span></span></param>
        <summary><span data-ttu-id="39e32-369">Versucht über einen angegebenen Zeitraum hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="39e32-369">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="39e32-370"><see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-370"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-371">Wenn der Wert des `timeout` -Parameters, der in Millisekunden konvertiert wurde, gleich-1 ist, entspricht diese Methode <xref:System.Threading.Monitor.Enter%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-371">If the value of the `timeout` parameter converted to milliseconds equals -1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="39e32-372">Wenn der Wert von `timeout` gleich 0 ist, entspricht diese Methode <xref:System.Threading.Monitor.TryEnter%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-372">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-373">Verwenden <xref:System.Threading.Monitor> Sie, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren.</span><span class="sxs-lookup"><span data-stu-id="39e32-373">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="39e32-374">Weitere Informationen finden Sie im <xref:System.Threading.Monitor> Thema zur-Klasse.</span><span class="sxs-lookup"><span data-stu-id="39e32-374">For details, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="39e32-375">Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Rückgabewert der Methode überprüfen und Code im kritischen Abschnitt nur dann ausführen, wenn der Rückgabewert ist `true` .</span><span class="sxs-lookup"><span data-stu-id="39e32-375">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="39e32-376">Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-376">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="39e32-377">Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem- `finally` Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-377">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-378">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-378">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39e32-379">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-379">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-380">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-380">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-381">Das Objekt, für das die Sperre erhalten werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-381">The object on which to acquire the lock.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="39e32-382">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-382">The number of milliseconds to wait for the lock.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="39e32-383">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span><span class="sxs-lookup"><span data-stu-id="39e32-383">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="39e32-384">Die Eingabe muss <see langword="false" /> sein.</span><span class="sxs-lookup"><span data-stu-id="39e32-384">The input must be <see langword="false" />.</span></span> <span data-ttu-id="39e32-385">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-385">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="39e32-386">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-386">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="39e32-387">Versucht für die angegebene Anzahl von Millisekunden, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-387">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-388">Wenn der- `millisecondsTimeout` Parameter gleich ist <xref:System.Threading.Timeout.Infinite> , entspricht diese Methode <xref:System.Threading.Monitor.Enter%28System.Object%29> .</span><span class="sxs-lookup"><span data-stu-id="39e32-388">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="39e32-389">Wenn `millisecondsTimeout` gleich 0 ist, entspricht diese Methode <xref:System.Threading.Monitor.TryEnter%28System.Object%29> .</span><span class="sxs-lookup"><span data-stu-id="39e32-389">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="39e32-390">Wenn die Sperre nicht übernommen wurde, weil eine Ausnahme ausgelöst wurde, ist die für den-Parameter angegebene Variable, `lockTaken` `false` nachdem diese Methode beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-390">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="39e32-391">Dadurch kann das Programm in allen Fällen ermitteln, ob es erforderlich ist, die Sperre freizugeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-391">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-392">Verwenden <xref:System.Threading.Monitor> Sie, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren.</span><span class="sxs-lookup"><span data-stu-id="39e32-392">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="39e32-393">Weitere Informationen finden Sie im Thema zur- <xref:System.Threading.Monitor> Klasse.</span><span class="sxs-lookup"><span data-stu-id="39e32-393">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="39e32-394">Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Wert von überprüfen `lockTaken` und Code im kritischen Abschnitt nur dann ausführen, wenn sein Wert ist `true` .</span><span class="sxs-lookup"><span data-stu-id="39e32-394">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="39e32-395">Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-395">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="39e32-396">Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem- `finally` Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-396">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="39e32-397">Der folgende Code zeigt das grundlegende Muster für die Verwendung der- <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="39e32-397">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="39e32-398">Diese Überladung legt den Wert der Variablen fest, die an den- `ref` Parameter übergeben wird ( `ByRef` in Visual Basic) `lockTaken` . Dies gilt auch, wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Methode ist, um zu testen, ob die Sperre freigegeben werden muss.</span><span class="sxs-lookup"><span data-stu-id="39e32-398">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39e32-399">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-399">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-400">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-400">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39e32-401"><paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-401"><paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-402">Das Objekt, für das die Sperre erhalten werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-402">The object on which to acquire the lock.</span></span></param>
        <param name="timeout"><span data-ttu-id="39e32-403">Die Zeitspanne, für die auf die Sperre gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-403">The amount of time to wait for the lock.</span></span> <span data-ttu-id="39e32-404">Ein Wert von –1 Millisekunde gibt eine unbegrenzte Wartezeit an.</span><span class="sxs-lookup"><span data-stu-id="39e32-404">A value of -1 millisecond specifies an infinite wait.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="39e32-405">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis.</span><span class="sxs-lookup"><span data-stu-id="39e32-405">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="39e32-406">Die Eingabe muss <see langword="false" /> sein.</span><span class="sxs-lookup"><span data-stu-id="39e32-406">The input must be <see langword="false" />.</span></span> <span data-ttu-id="39e32-407">Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-407">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="39e32-408">Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-408">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="39e32-409">Versucht für die angegebene Dauer, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-409">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-410">Wenn der Wert des `timeout` -Parameters, der in Millisekunden konvertiert wurde, gleich-1 ist, entspricht diese Methode <xref:System.Threading.Monitor.Enter%28System.Object%29> .</span><span class="sxs-lookup"><span data-stu-id="39e32-410">If the value of the `timeout` parameter converted to milliseconds equals -1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="39e32-411">Wenn der Wert von `timeout` gleich 0 ist, entspricht diese Methode <xref:System.Threading.Monitor.TryEnter%28System.Object%29> .</span><span class="sxs-lookup"><span data-stu-id="39e32-411">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="39e32-412">Wenn die Sperre nicht übernommen wurde, weil eine Ausnahme ausgelöst wurde, ist die für den-Parameter angegebene Variable, `lockTaken` `false` nachdem diese Methode beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-412">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="39e32-413">Dadurch kann das Programm in allen Fällen ermitteln, ob es erforderlich ist, die Sperre freizugeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-413">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-414">Verwenden <xref:System.Threading.Monitor> Sie, um Objekte (d. h. Verweis Typen) und keine Werttypen zu sperren.</span><span class="sxs-lookup"><span data-stu-id="39e32-414">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="39e32-415">Weitere Informationen finden Sie im Thema zur- <xref:System.Threading.Monitor> Klasse.</span><span class="sxs-lookup"><span data-stu-id="39e32-415">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="39e32-416">Um sicherzustellen, dass der Thread nicht in den kritischen Abschnitt eintritt, sollten Sie den Wert von überprüfen `lockTaken` und Code im kritischen Abschnitt nur dann ausführen, wenn sein Wert ist `true` .</span><span class="sxs-lookup"><span data-stu-id="39e32-416">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="39e32-417">Das folgende Code Fragment zeigt das Muster, das zum Aufrufen dieser Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-417">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="39e32-418">Beachten Sie, dass Sie <xref:System.Threading.Monitor.Exit%2A> in einem- `finally` Block aufrufen müssen, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt freigibt, wenn eine Ausnahme auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-418">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39e32-419">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-419">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-420">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-420">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39e32-421">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-421">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-422">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-422">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="39e32-423">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-423">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-424">Das Objekt, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-424">The object on which to wait.</span></span></param>
        <summary><span data-ttu-id="39e32-425">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-425">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span></summary>
        <returns><span data-ttu-id="39e32-426"><see langword="true" />, wenn der Aufruf beendet wurde, weil der Aufrufer die Sperre für das angegebene Objekt erneut erhalten hat.</span><span class="sxs-lookup"><span data-stu-id="39e32-426"><see langword="true" /> if the call returned because the caller reacquired the lock for the specified object.</span></span> <span data-ttu-id="39e32-427">Diese Methode wird nicht beendet, wenn die Sperre nicht erneut erhalten wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-427">This method does not return if the lock is not reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-428">Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um das Objekt freizugeben, damit ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-428">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="39e32-429">Der Aufrufer ist blockiert, während er darauf wartet, die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-429">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="39e32-430">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten muss, die als Ergebnis der Vorgänge eines anderen Threads auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-430">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="39e32-431">Wenn ein Thread aufruft `Wait` , gibt er die Sperre für das Objekt frei und wechselt in die Warteschlange des Objekts.</span><span class="sxs-lookup"><span data-stu-id="39e32-431">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="39e32-432">Der nächste Thread in der Ready-Warteschlange des-Objekts (sofern vorhanden) erhält die Sperre und verfügt über eine exklusive Verwendung des-Objekts.</span><span class="sxs-lookup"><span data-stu-id="39e32-432">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="39e32-433">Alle Threads, die aufzurufen `Wait` , verbleiben in der Warteschlange, bis Sie ein Signal von <xref:System.Threading.Monitor.Pulse%2A> oder empfangen <xref:System.Threading.Monitor.PulseAll%2A> , das vom Besitzer der Sperre gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-433">All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock.</span></span> <span data-ttu-id="39e32-434">Wenn `Pulse` gesendet wird, ist nur der Thread an der Spitze der Warteschlange betroffen.</span><span class="sxs-lookup"><span data-stu-id="39e32-434">If `Pulse` is sent, only the thread at the head of the waiting queue is affected.</span></span> <span data-ttu-id="39e32-435">Wenn `PulseAll` gesendet wird, sind alle Threads betroffen, die auf das-Objekt warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-435">If `PulseAll` is sent, all threads that are waiting for the object are affected.</span></span> <span data-ttu-id="39e32-436">Wenn das Signal empfangen wird, verlässt mindestens ein Thread die Warteschlange, und die Warteschlange wird in die Warteschlange eingereiht.</span><span class="sxs-lookup"><span data-stu-id="39e32-436">When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</span></span> <span data-ttu-id="39e32-437">Ein Thread in der Warteschlange ist berechtigt, die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-437">A thread in the ready queue is permitted to reacquire the lock.</span></span>  
  
 <span data-ttu-id="39e32-438">Diese Methode gibt zurück, wenn der aufrufenden Thread die Sperre für das Objekt wieder erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-438">This method returns when the calling thread reacquires the lock on the object.</span></span> <span data-ttu-id="39e32-439">Beachten Sie, dass diese Methode unbegrenzt blockiert, wenn der Inhaber der Sperre nicht `Pulse` oder aufruft `PulseAll` .</span><span class="sxs-lookup"><span data-stu-id="39e32-439">Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.</span></span>  
  
 <span data-ttu-id="39e32-440">Der Aufrufer `Wait` wird einmal ausgeführt, unabhängig davon, <xref:System.Threading.Monitor.Enter%2A> wie oft für das angegebene Objekt aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-440">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="39e32-441">Konzeptionell speichert die-Methode die Anzahl der Aufrufe, die der Aufrufer `Wait` `Enter` für das Objekt aufgerufen hat, und ruft `Exit` so oft wie nötig auf, um das gesperrte Objekt vollständig freizugeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-441">Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="39e32-442">Der Aufrufer blockiert dann, während er darauf wartet, das Objekt erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-442">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="39e32-443">Wenn der Aufrufer die Sperre erneut erhält, ruft das System `Enter` so oft wie nötig auf, um die gespeicherte `Enter` Anzahl für den Aufrufer wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-443">When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller.</span></span> <span data-ttu-id="39e32-444">Beim Aufrufen `Wait` von wird nur die Sperre für das angegebene Objekt freigegeben. wenn der Aufrufer der Besitzer von Sperren für andere Objekte ist, werden diese Sperren nicht freigegeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-444">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
 <span data-ttu-id="39e32-445">Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise enthält, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die bereit sind, die Sperre abzurufen, und einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-445">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="39e32-446">Die <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> Methoden, und `Wait` müssen in einem synchronisierten Codeblock aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="39e32-446">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="39e32-447">Die Hinweise für die- <xref:System.Threading.Monitor.Pulse%2A> Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-447">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-448">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-448">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="39e32-449">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="39e32-449">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="39e32-450">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="39e32-450">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="39e32-451">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span><span class="sxs-lookup"><span data-stu-id="39e32-451">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-452">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-452">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-453">Das Objekt, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-453">The object on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="39e32-454">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-454">The number of milliseconds to wait before the thread enters the ready queue.</span></span></param>
        <summary><span data-ttu-id="39e32-455">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-455">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="39e32-456">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span><span class="sxs-lookup"><span data-stu-id="39e32-456">If the specified time-out interval elapses, the thread enters the ready queue.</span></span></summary>
        <returns><span data-ttu-id="39e32-457"><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span><span class="sxs-lookup"><span data-stu-id="39e32-457"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="39e32-458">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-458">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-459">Diese Methode gibt erst dann zurück, wenn Sie eine exklusive Sperre für den- `obj` Parameter erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-459">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="39e32-460">Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um das Objekt freizugeben, damit ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-460">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="39e32-461">Der Aufrufer ist blockiert, während er darauf wartet, die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-461">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="39e32-462">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten muss, die als Ergebnis der Vorgänge eines anderen Threads auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-462">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="39e32-463">Das Timeout stellt sicher, dass der aktuelle Thread nicht unbegrenzt blockiert wird, wenn ein anderer Thread die Sperre freigibt, ohne zuerst die-oder die-Methode aufrufen zu muss <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-463">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="39e32-464">Außerdem wird der Thread in die Warteschlange für die Warteschlange verschoben, sodass andere Threads vor ihm in der Warteschlange umgangen werden, damit die Sperre früher wieder hergestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-464">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="39e32-465">Der Thread kann den Rückgabewert der Methode testen <xref:System.Threading.Monitor.Wait%2A> , um zu bestimmen, ob die Sperre vor dem Timeout erneut abgerufen wurde. Der Thread kann die Bedingungen auswerten, die dazu geführt haben, dass er in den warte Vorgang gelangt, und die Methode gegebenenfalls erneut aufzurufen <xref:System.Threading.Monitor.Wait%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-465">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="39e32-466">Wenn ein Thread aufruft `Wait` , gibt er die Sperre für das Objekt frei und wechselt in die Warteschlange des Objekts.</span><span class="sxs-lookup"><span data-stu-id="39e32-466">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="39e32-467">Der nächste Thread in der Ready-Warteschlange des-Objekts (sofern vorhanden) erhält die Sperre und verfügt über eine exklusive Verwendung des-Objekts.</span><span class="sxs-lookup"><span data-stu-id="39e32-467">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="39e32-468">Der Thread, der aufgerufen hat `Wait` , verbleibt in der Warteschlange, bis entweder ein Thread, der die Sperre besitzt <xref:System.Threading.Monitor.PulseAll%2A> , oder der nächste in der Warteschlange ist, und ein Thread, der die Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-468">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="39e32-469">Wenn jedoch `millisecondsTimeout` abläuft, bevor ein anderer Thread die-Methode oder die-Methode dieses Objekts aufruft <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> , wird der ursprüngliche Thread in die bereite Warteschlange verschoben, um die Sperre wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-469">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-470">Wenn <xref:System.Threading.Timeout.Infinite> für den-Parameter angegeben wird `millisecondsTimeout` , blockiert diese Methode unbegrenzt, es sei denn, der Inhaber der Sperre ruft <xref:System.Threading.Monitor.Pulse%2A> oder auf <xref:System.Threading.Monitor.PulseAll%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-470">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="39e32-471">Wenn `millisecondsTimeout` gleich 0 ist, gibt der Thread, der aufruft, `Wait` die Sperre frei und wechselt dann sofort in die bereite Warteschlange, um die Sperre wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-471">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="39e32-472">Der Aufrufer `Wait` wird einmal ausgeführt, unabhängig davon, <xref:System.Threading.Monitor.Enter%2A> wie oft für das angegebene Objekt aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-472">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="39e32-473">Konzeptionell speichert die-Methode die Anzahl der Aufrufe, die der Aufrufer `Wait` <xref:System.Threading.Monitor.Enter%2A> für das Objekt aufgerufen hat, und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig auf, um das gesperrte Objekt vollständig freizugeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-473">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="39e32-474">Der Aufrufer blockiert dann, während er darauf wartet, das Objekt erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-474">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="39e32-475">Wenn der Aufrufer die Sperre erneut erhält, ruft das System <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig auf, um die gespeicherte <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-475">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="39e32-476">Beim Aufrufen `Wait` von wird nur die Sperre für das angegebene Objekt freigegeben. wenn der Aufrufer der Besitzer von Sperren für andere Objekte ist, werden diese Sperren nicht freigegeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-476">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-477">Ein synchronisiertes Objekt enthält mehrere Verweise, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die zum Abrufen der Sperre bereit sind, sowie einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-477">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="39e32-478">Die <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> Methoden, und `Wait` müssen in einem synchronisierten Codeblock aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="39e32-478">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="39e32-479">Die Hinweise für die- <xref:System.Threading.Monitor.Pulse%2A> Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-479">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-480">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-480">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="39e32-481">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="39e32-481">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="39e32-482">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="39e32-482">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="39e32-483">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span><span class="sxs-lookup"><span data-stu-id="39e32-483">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39e32-484">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-484">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-485">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-485">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-486">Das Objekt, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-486">The object on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="39e32-487">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-487">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span></span></param>
        <summary><span data-ttu-id="39e32-488">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-488">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="39e32-489">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span><span class="sxs-lookup"><span data-stu-id="39e32-489">If the specified time-out interval elapses, the thread enters the ready queue.</span></span></summary>
        <returns><span data-ttu-id="39e32-490"><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span><span class="sxs-lookup"><span data-stu-id="39e32-490"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="39e32-491">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-491">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-492">Diese Methode gibt erst dann zurück, wenn Sie eine exklusive Sperre für den- `obj` Parameter erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-492">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="39e32-493">Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um das Objekt freizugeben, damit ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-493">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="39e32-494">Der Aufrufer ist blockiert, während er darauf wartet, die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-494">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="39e32-495">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten muss, die als Ergebnis der Vorgänge eines anderen Threads auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-495">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="39e32-496">Das Timeout stellt sicher, dass der aktuelle Thread nicht unbegrenzt blockiert wird, wenn ein anderer Thread die Sperre freigibt, ohne zuerst die-oder die-Methode aufrufen zu muss <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-496">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="39e32-497">Außerdem wird der Thread in die Warteschlange für die Warteschlange verschoben, sodass andere Threads vor ihm in der Warteschlange umgangen werden, damit die Sperre früher wieder hergestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-497">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="39e32-498">Der Thread kann den Rückgabewert der Methode testen <xref:System.Threading.Monitor.Wait%2A> , um zu bestimmen, ob die Sperre vor dem Timeout erneut abgerufen wurde. Der Thread kann die Bedingungen auswerten, die dazu geführt haben, dass er in den warte Vorgang gelangt, und die Methode gegebenenfalls erneut aufzurufen <xref:System.Threading.Monitor.Wait%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-498">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="39e32-499">Wenn ein Thread aufruft `Wait` , gibt er die Sperre für das Objekt frei und wechselt in die Warteschlange des Objekts.</span><span class="sxs-lookup"><span data-stu-id="39e32-499">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="39e32-500">Der nächste Thread in der Ready-Warteschlange des-Objekts (sofern vorhanden) erhält die Sperre und verfügt über eine exklusive Verwendung des-Objekts.</span><span class="sxs-lookup"><span data-stu-id="39e32-500">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="39e32-501">Der Thread, der aufgerufen hat `Wait` , verbleibt in der Warteschlange, bis entweder ein Thread, der die Sperre besitzt <xref:System.Threading.Monitor.PulseAll%2A> , oder der nächste in der Warteschlange ist, und ein Thread, der die Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-501">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="39e32-502">Wenn jedoch `timeout` abläuft, bevor ein anderer Thread die-Methode oder die-Methode dieses Objekts aufruft <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> , wird der ursprüngliche Thread in die bereite Warteschlange verschoben, um die Sperre wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-502">However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-503">Wenn eine <xref:System.TimeSpan> -1 Millisekunde für den-Parameter angegeben wird `timeout` , blockiert diese Methode unbegrenzt, es sei denn, der Inhaber der Sperre ruft <xref:System.Threading.Monitor.Pulse%2A> oder auf <xref:System.Threading.Monitor.PulseAll%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-503">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="39e32-504">Wenn `timeout` 0 Millisekunden beträgt, gibt der Thread, `Wait` der aufruft, die Sperre frei und wechselt dann sofort in die bereite Warteschlange, um die Sperre wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-504">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="39e32-505">Der Aufrufer `Wait` wird einmal ausgeführt, unabhängig davon, <xref:System.Threading.Monitor.Enter%2A> wie oft für das angegebene Objekt aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-505">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="39e32-506">Konzeptionell speichert die-Methode die Anzahl der Aufrufe, die der Aufrufer `Wait` <xref:System.Threading.Monitor.Enter%2A> für das Objekt aufgerufen hat, und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig auf, um das gesperrte Objekt vollständig freizugeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-506">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="39e32-507">Der Aufrufer blockiert dann, während er darauf wartet, das Objekt erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-507">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="39e32-508">Wenn der Aufrufer die Sperre erneut erhält, ruft das System <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig auf, um die gespeicherte <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-508">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="39e32-509">Beim Aufrufen `Wait` von wird nur die Sperre für das angegebene Objekt freigegeben. wenn der Aufrufer der Besitzer von Sperren für andere Objekte ist, werden diese Sperren nicht freigegeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-509">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-510">Ein synchronisiertes Objekt enthält mehrere Verweise, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die zum Abrufen der Sperre bereit sind, sowie einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-510">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="39e32-511">Die <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> Methoden, und `Wait` müssen in einem synchronisierten Codeblock aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="39e32-511">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="39e32-512">Die Hinweise für die- <xref:System.Threading.Monitor.Pulse%2A> Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-512">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-513">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-513">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="39e32-514">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="39e32-514">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="39e32-515">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="39e32-515">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="39e32-516">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span><span class="sxs-lookup"><span data-stu-id="39e32-516">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39e32-517">Der Wert des <paramref name="timeout" />-Parameters in Millisekunden ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) dar, oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-517">The value of the <paramref name="timeout" /> parameter in milliseconds is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-518">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-518">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-519">Das Objekt, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-519">The object on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="39e32-520">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-520">The number of milliseconds to wait before the thread enters the ready queue.</span></span></param>
        <param name="exitContext"><span data-ttu-id="39e32-521"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-521"><see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="39e32-522">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-522">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="39e32-523">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span><span class="sxs-lookup"><span data-stu-id="39e32-523">If the specified time-out interval elapses, the thread enters the ready queue.</span></span> <span data-ttu-id="39e32-524">Diese Methode gibt außerdem an, ob die Synchronisierungsdomäne danach für den Kontext (wenn es sich um einen synchronisierten Kontext handelt) vor dem Warten und erneuten Erhalten verlassen wird.</span><span class="sxs-lookup"><span data-stu-id="39e32-524">This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</span></span></summary>
        <returns><span data-ttu-id="39e32-525"><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span><span class="sxs-lookup"><span data-stu-id="39e32-525"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="39e32-526">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-526">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-527">Diese Methode gibt erst dann zurück, wenn Sie eine exklusive Sperre für den- `obj` Parameter erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-527">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="39e32-528">Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um das Objekt freizugeben, damit ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-528">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="39e32-529">Der Aufrufer ist blockiert, während er darauf wartet, die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-529">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="39e32-530">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten muss, die als Ergebnis der Vorgänge eines anderen Threads auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-530">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="39e32-531">Das Timeout stellt sicher, dass der aktuelle Thread nicht unbegrenzt blockiert wird, wenn ein anderer Thread die Sperre freigibt, ohne zuerst die-oder die-Methode aufrufen zu muss <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-531">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="39e32-532">Außerdem wird der Thread in die Warteschlange für die Warteschlange verschoben, sodass andere Threads vor ihm in der Warteschlange umgangen werden, damit die Sperre früher wieder hergestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-532">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="39e32-533">Der Thread kann den Rückgabewert der Methode testen <xref:System.Threading.Monitor.Wait%2A> , um zu bestimmen, ob die Sperre vor dem Timeout erneut abgerufen wurde. Der Thread kann die Bedingungen auswerten, die dazu geführt haben, dass er in den warte Vorgang gelangt, und die Methode gegebenenfalls erneut aufzurufen <xref:System.Threading.Monitor.Wait%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-533">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="39e32-534">Wenn ein Thread aufruft `Wait` , gibt er die Sperre frei und wechselt in die Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="39e32-534">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="39e32-535">An diesem Punkt kann der nächste Thread in der Warteschlange (sofern vorhanden) die Kontrolle über die Sperre übernehmen.</span><span class="sxs-lookup"><span data-stu-id="39e32-535">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="39e32-536">Der Thread, der aufgerufen hat `Wait` , verbleibt in der Warteschlange, bis entweder ein Thread, der die Sperre besitzt <xref:System.Threading.Monitor.PulseAll%2A> , oder der nächste in der Warteschlange ist, und ein Thread, der die Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-536">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="39e32-537">Wenn jedoch `millisecondsTimeout` abläuft, bevor ein anderer Thread die-Methode oder die-Methode dieses Objekts aufruft <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> , wird der ursprüngliche Thread in die bereite Warteschlange verschoben, um die Sperre wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-537">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-538">Wenn <xref:System.Threading.Timeout.Infinite> für den-Parameter angegeben wird `millisecondsTimeout` , blockiert diese Methode unbegrenzt, es sei denn, der Inhaber der Sperre ruft <xref:System.Threading.Monitor.Pulse%2A> oder auf <xref:System.Threading.Monitor.PulseAll%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-538">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="39e32-539">Wenn `millisecondsTimeout` gleich 0 ist, gibt der Thread, der aufruft, `Wait` die Sperre frei und wechselt dann sofort in die bereite Warteschlange, um die Sperre wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-539">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="39e32-540">Der Aufrufer `Wait` wird einmal ausgeführt, unabhängig davon, <xref:System.Threading.Monitor.Enter%2A> wie oft für das angegebene Objekt aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-540">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="39e32-541">Konzeptionell speichert die-Methode die Anzahl der Aufrufe, die der Aufrufer `Wait` <xref:System.Threading.Monitor.Enter%2A> für das Objekt aufgerufen hat, und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig auf, um das gesperrte Objekt vollständig freizugeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-541">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="39e32-542">Der Aufrufer blockiert dann, während er darauf wartet, das Objekt erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-542">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="39e32-543">Wenn der Aufrufer die Sperre erneut erhält, ruft das System <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig auf, um die gespeicherte <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-543">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="39e32-544">Beim Aufrufen `Wait` von wird nur die Sperre für das angegebene Objekt freigegeben. wenn der Aufrufer der Besitzer von Sperren für andere Objekte ist, werden diese Sperren nicht freigegeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-544">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-545">Ein synchronisiertes Objekt enthält mehrere Verweise, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die zum Abrufen der Sperre bereit sind, sowie einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-545">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="39e32-546">Die <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> Methoden, und `Wait` müssen in einem synchronisierten Codeblock aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="39e32-546">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="39e32-547">Die Hinweise für die- <xref:System.Threading.Monitor.Pulse%2A> Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-547">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="39e32-548">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="39e32-548">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="39e32-549">Der- `exitContext` Parameter hat keine Auswirkung, es sei denn, die- <xref:System.Threading.Monitor.Wait%2A> Methode wird in einem nicht standardmäßigen verwalteten Kontext aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-549">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="39e32-550">Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer von abgeleiteten Klasse befindet <xref:System.ContextBoundObject> .</span><span class="sxs-lookup"><span data-stu-id="39e32-550">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="39e32-551">Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von abgeleitet ist <xref:System.ContextBoundObject> , <xref:System.String> können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn <xref:System.ContextBoundObject> sich ein auf dem Stapel in der aktuellen Anwendungsdomäne befindet.</span><span class="sxs-lookup"><span data-stu-id="39e32-551">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="39e32-552">Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` bewirkt die Angabe von for, `exitContext` dass der Thread den nicht standardmäßigen verwalteten Kontext verlässt (d. h., um zum Standardkontext zu wechseln), bevor die-Methode ausgeführt wird <xref:System.Threading.Monitor.Wait%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-552">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="39e32-553">Sie kehrt zum ursprünglichen, nicht standardmäßigen Kontext zurück, nachdem der-Vorgang <xref:System.Threading.Monitor.Wait%2A> abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-553">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="39e32-554">Dies kann hilfreich sein, wenn die Kontext gebundene Klasse über das- <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> Attribut verfügt.</span><span class="sxs-lookup"><span data-stu-id="39e32-554">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="39e32-555">In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse.</span><span class="sxs-lookup"><span data-stu-id="39e32-555">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="39e32-556">Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.Monitor.Wait%2A> -Methode aufruft und `true` für angibt `exitContext` , beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des-Objekts blockiert ist, fortgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-556">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="39e32-557">Wenn die- <xref:System.Threading.Monitor.Wait%2A> Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird</span><span class="sxs-lookup"><span data-stu-id="39e32-557">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-558">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-558">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="39e32-559"><see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-559"><see langword="Wait" /> is not invoked from within a synchronized block of code.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="39e32-560">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="39e32-560">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="39e32-561">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span><span class="sxs-lookup"><span data-stu-id="39e32-561">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39e32-562">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-562">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-563">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-563">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="39e32-564">Das Objekt, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="39e32-564">The object on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="39e32-565">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-565">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span></span></param>
        <param name="exitContext"><span data-ttu-id="39e32-566"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-566"><see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="39e32-567">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-567">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="39e32-568">Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</span><span class="sxs-lookup"><span data-stu-id="39e32-568">If the specified time-out interval elapses, the thread enters the ready queue.</span></span> <span data-ttu-id="39e32-569">Beendet vor dem Warten optional auch die Synchronisierungsdomäne für den synchronisierten Kontext und erhält die Domäne anschließend wieder.</span><span class="sxs-lookup"><span data-stu-id="39e32-569">Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</span></span></summary>
        <returns><span data-ttu-id="39e32-570"><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist.</span><span class="sxs-lookup"><span data-stu-id="39e32-570"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="39e32-571">Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-571">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39e32-572">Diese Methode gibt erst dann zurück, wenn Sie eine exklusive Sperre für den- `obj` Parameter erhält.</span><span class="sxs-lookup"><span data-stu-id="39e32-572">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="39e32-573">Der Thread, der die Sperre für das angegebene Objekt zurzeit besitzt, ruft diese Methode auf, um das Objekt freizugeben, damit ein anderer Thread darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-573">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="39e32-574">Der Aufrufer ist blockiert, während er darauf wartet, die Sperre erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-574">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="39e32-575">Diese Methode wird aufgerufen, wenn der Aufrufer auf eine Zustandsänderung warten muss, die als Ergebnis der Vorgänge eines anderen Threads auftritt.</span><span class="sxs-lookup"><span data-stu-id="39e32-575">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="39e32-576">Das Timeout stellt sicher, dass der aktuelle Thread nicht unbegrenzt blockiert wird, wenn ein anderer Thread die Sperre freigibt, ohne zuerst die-oder die-Methode aufrufen zu muss <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-576">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="39e32-577">Außerdem wird der Thread in die Warteschlange für die Warteschlange verschoben, sodass andere Threads vor ihm in der Warteschlange umgangen werden, damit die Sperre früher wieder hergestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-577">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="39e32-578">Der Thread kann den Rückgabewert der Methode testen <xref:System.Threading.Monitor.Wait%2A> , um zu bestimmen, ob die Sperre vor dem Timeout erneut abgerufen wurde. Der Thread kann die Bedingungen auswerten, die dazu geführt haben, dass er in den warte Vorgang gelangt, und die Methode gegebenenfalls erneut aufzurufen <xref:System.Threading.Monitor.Wait%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-578">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="39e32-579">Wenn ein Thread aufruft `Wait` , gibt er die Sperre frei und wechselt in die Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="39e32-579">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="39e32-580">An diesem Punkt kann der nächste Thread in der Warteschlange (sofern vorhanden) die Kontrolle über die Sperre übernehmen.</span><span class="sxs-lookup"><span data-stu-id="39e32-580">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="39e32-581">Der Thread, der aufgerufen hat `Wait` , verbleibt in der Warteschlange, bis entweder ein Thread, der die Sperre besitzt <xref:System.Threading.Monitor.PulseAll%2A> , oder der nächste in der Warteschlange ist, und ein Thread, der die Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-581">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="39e32-582">Wenn jedoch `timeout` Millisekunden vergehen, bevor ein anderer Thread die-oder-Methode dieses Objekts aufruft <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> , wird der ursprüngliche Thread in die bereite Warteschlange verschoben, um die Sperre wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-582">However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-583">Wenn eine <xref:System.TimeSpan> -1 Millisekunde für den-Parameter angegeben wird `timeout` , blockiert diese Methode unbegrenzt, es sei denn, der Inhaber der Sperre ruft <xref:System.Threading.Monitor.Pulse%2A> oder auf <xref:System.Threading.Monitor.PulseAll%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-583">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="39e32-584">Wenn `timeout` 0 Millisekunden beträgt, gibt der Thread, `Wait` der aufruft, die Sperre frei und wechselt dann sofort in die bereite Warteschlange, um die Sperre wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-584">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="39e32-585">Der Aufrufer `Wait` wird einmal ausgeführt, unabhängig davon, <xref:System.Threading.Monitor.Enter%2A> wie oft für das angegebene Objekt aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-585">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="39e32-586">Konzeptionell speichert die-Methode die Anzahl der Aufrufe, die der Aufrufer `Wait` <xref:System.Threading.Monitor.Enter%2A> für das Objekt aufgerufen hat, und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig auf, um das gesperrte Objekt vollständig freizugeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-586">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="39e32-587">Der Aufrufer blockiert dann, während er darauf wartet, das Objekt erneut abzurufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-587">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="39e32-588">Wenn der Aufrufer die Sperre erneut erhält, ruft das System <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig auf, um die gespeicherte <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="39e32-588">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="39e32-589">Beim Aufrufen `Wait` von wird nur die Sperre für das angegebene Objekt freigegeben. wenn der Aufrufer der Besitzer von Sperren für andere Objekte ist, werden diese Sperren nicht freigegeben.</span><span class="sxs-lookup"><span data-stu-id="39e32-589">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39e32-590">Ein synchronisiertes Objekt enthält mehrere Verweise, einschließlich eines Verweises auf den Thread, der derzeit die Sperre enthält, einen Verweis auf die bereite Warteschlange, die die Threads enthält, die zum Abrufen der Sperre bereit sind, sowie einen Verweis auf die Warteschlange, die die Threads enthält, die auf eine Änderung des Objekt Zustands warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-590">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="39e32-591">Die <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> Methoden, und `Wait` müssen in einem synchronisierten Codeblock aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="39e32-591">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="39e32-592">Die Hinweise für die- <xref:System.Threading.Monitor.Pulse%2A> Methode erläutern, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> aufgerufen wird, wenn keine Threads warten.</span><span class="sxs-lookup"><span data-stu-id="39e32-592">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="39e32-593">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="39e32-593">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="39e32-594">Der- `exitContext` Parameter hat keine Auswirkung, es sei denn, die- <xref:System.Threading.Monitor.Wait%2A> Methode wird in einem nicht standardmäßigen verwalteten Kontext aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-594">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="39e32-595">Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer von abgeleiteten Klasse befindet <xref:System.ContextBoundObject> .</span><span class="sxs-lookup"><span data-stu-id="39e32-595">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="39e32-596">Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von abgeleitet ist <xref:System.ContextBoundObject> , <xref:System.String> können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn <xref:System.ContextBoundObject> sich ein auf dem Stapel in der aktuellen Anwendungsdomäne befindet.</span><span class="sxs-lookup"><span data-stu-id="39e32-596">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="39e32-597">Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` bewirkt die Angabe von for, `exitContext` dass der Thread den nicht standardmäßigen verwalteten Kontext verlässt (d. h., um zum Standardkontext zu wechseln), bevor die-Methode ausgeführt wird <xref:System.Threading.Monitor.Wait%2A> .</span><span class="sxs-lookup"><span data-stu-id="39e32-597">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="39e32-598">Sie kehrt zum ursprünglichen, nicht standardmäßigen Kontext zurück, nachdem der-Vorgang <xref:System.Threading.Monitor.Wait%2A> abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39e32-598">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="39e32-599">Dies kann hilfreich sein, wenn die Kontext gebundene Klasse über das- <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> Attribut verfügt.</span><span class="sxs-lookup"><span data-stu-id="39e32-599">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="39e32-600">In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse.</span><span class="sxs-lookup"><span data-stu-id="39e32-600">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="39e32-601">Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.Monitor.Wait%2A> -Methode aufruft und `true` für angibt `exitContext` , beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des-Objekts blockiert ist, fortgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="39e32-601">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="39e32-602">Wenn die- <xref:System.Threading.Monitor.Wait%2A> Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird</span><span class="sxs-lookup"><span data-stu-id="39e32-602">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39e32-603">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-603">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="39e32-604"><see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="39e32-604"><see langword="Wait" /> is not invoked from within a synchronized block of code.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="39e32-605">Der Thread, der „Wait“ aufruft, wird später im Wartezustand unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="39e32-605">The thread that invokes Wait is later interrupted from the waiting state.</span></span> <span data-ttu-id="39e32-606">Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</span><span class="sxs-lookup"><span data-stu-id="39e32-606">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39e32-607">Der <paramref name="timeout" />-Parameter ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> dar (–1 Millisekunde), oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="39e32-607">The <paramref name="timeout" /> parameter is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="39e32-608">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="39e32-608">Managed Threading</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
