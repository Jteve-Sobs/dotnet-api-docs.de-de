<Type Name="SpinLock" FullName="System.Threading.SpinLock">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d373a195c71ced8f320e17f64505aaeb5b6c9601" /><Meta Name="ms.sourcegitcommit" Value="33529b5cc32683b91d3422992fb4dc422f85782b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/17/2020" /><Meta Name="ms.locfileid" Value="88265435" /></Metadata><TypeSignature Language="C#" Value="public struct SpinLock" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit SpinLock extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Threading.SpinLock" />
  <TypeSignature Language="VB.NET" Value="Public Structure SpinLock" />
  <TypeSignature Language="C++ CLI" Value="public value class SpinLock" />
  <TypeSignature Language="F#" Value="type SpinLock = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("IsHeld = {IsHeld}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("IsHeld = {IsHeld}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.SpinLock/SystemThreading_SpinLockDebugView))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.SpinLock/SystemThreading_SpinLockDebugView))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Mutex-Sperrprimitiven bereit, wobei ein Thread, der versucht, die Sperre abzurufen, in einer Schleife wartet, die laufend prüft, ob die Sperre verfügbar wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel für die Verwendung einer spinsperre finden Sie unter Gewusst [wie: Verwenden von Spinlock für die Synchronisierung auf niedriger Ebene](/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization).  
  
 Dreh Sperren können für Sperren auf Blatt Ebene verwendet werden, bei denen die Objekt Zuordnung, die durch die Verwendung eines <xref:System.Threading.Monitor> , in Größe oder aufgrund Garbage Collection Drucks impliziert wird, übermäßig teuer ist. Eine Drehsperre kann nützlich sein, um eine Blockierung zu vermeiden. Wenn Sie jedoch eine große Menge an Blockierung erwarten, sollten Sie aufgrund übermäßiger spinvorgänge wahrscheinlich keine Spin-Sperren verwenden. Das drehen kann nützlich sein, wenn Sperren differenzierte und große Zahlen (z. b. eine Sperre pro Knoten in einer verknüpften Liste) und auch dann, wenn Sperrzeiten immer sehr kurz sind. Im Allgemeinen sollte eine der folgenden Aktionen vermieden werden, während eine spinsperre aufrechterhalten wird:  
  
-   blockieren  
  
-   das Aufrufen von etwas, das sich selbst blockieren kann,  
  
-   gleichzeitige Speicherung von mehr als einer Drehsperre  
  
-   dynamisch verteilte Aufrufe (Schnittstelle und Virtuale)  
  
-   durch die statische Verteilung von Aufrufen an Code, den Sie nicht besitzen, oder  
  
-   belegen von Speicher.  
  
 <xref:System.Threading.SpinLock> sollte nur verwendet werden, nachdem Sie ermittelt haben, dass dadurch die Leistung einer Anwendung verbessert wird. Es ist auch wichtig zu beachten, dass <xref:System.Threading.SpinLock> aus Leistungsgründen ein Werttyp ist. Aus diesem Grund müssen Sie sehr vorsichtig sein, um eine-Instanz nicht versehentlich zu kopieren <xref:System.Threading.SpinLock> , da die beiden Instanzen (die ursprüngliche und die Kopie) dann vollständig voneinander unabhängig sind, was wahrscheinlich zu einem fehlerhaften Verhalten der Anwendung führen würde. Wenn eine- <xref:System.Threading.SpinLock> Instanz umgangen werden muss, sollte Sie als Verweis und nicht als Wert übermittelt werden.  
  
 Speichern Sie keine <xref:System.Threading.SpinLock> Instanzen in schreibgeschützten Feldern.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein verwendet wird <xref:System.Threading.SpinLock> :  
  
 [!code-csharp[System.Threading.SpinLock#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.spinlock/cs/spinlock.cs#01)]
 [!code-vb[System.Threading.SpinLock#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.spinlock/vb/spinlock.vb#01)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Elemente von <see cref="T:System.Threading.SpinLock" /> sind Thread sicher und können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
    <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
    <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Vorgehensweise: Synchronisierung auf niedriger Ebene mit SpinLock</related>
    <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SpinLock (bool enableThreadOwnerTracking);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool enableThreadOwnerTracking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (enableThreadOwnerTracking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SpinLock(bool enableThreadOwnerTracking);" />
      <MemberSignature Language="F#" Value="new System.Threading.SpinLock : bool -&gt; System.Threading.SpinLock" Usage="new System.Threading.SpinLock enableThreadOwnerTracking" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="enableThreadOwnerTracking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enableThreadOwnerTracking">Gibt an, ob Thread-IDs zu Debugzwecken erfasst und verwendet werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.SpinLock" />-Struktur mit der Option, Thread-IDs nachzuverfolgen, um das Debuggen zu vereinfachen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Parameter lose Konstruktor für <xref:System.Threading.SpinLock> verfolgt den Thread Besitz.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine SpinLock verwendet werden kann.  
  
```csharp  
// C#  
public class MyType  
{  
    private SpinLock _spinLock = new SpinLock();  
  
    public void DoWork()  
    {  
        bool lockTaken = false;   
        try  
        {  
           _spinLock.Enter(ref lockTaken);  
           // do work here protected by the lock  
        }  
        finally  
        {  
            if (lockTaken) _spinLock.Exit();  
        }  
    }  
}  
```  
  
```vb  
' Visual Basic  
  
Class MyType  
   Private _spinLock As New SpinLock()  
  
   Public Sub DoWork()  
      Dim lockTaken As Boolean = False  
      Try  
         _spinLock.Enter(lockTaken)  
         ' do work here protected by the lock  
      Finally  
         If lockTaken Then _spinLock.Exit()  
      End Try  
   End Sub  
End Class  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Gewusst wie: Synchronisierung auf niedriger Ebene mit SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public void Enter (ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Enter(bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Enter(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Enter (ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Enter(bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.Enter : bool -&gt; unit" Usage="spinLock.Enter lockTaken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockTaken">True, wenn die Sperre abgerufen wird, andernfalls false. <paramref name="lockTaken" /> muss vor dem Aufrufen dieser Methode mit false initialisiert werden.</param>
        <summary>Ruft die Sperre zuverlässig ab, sodass <paramref name="lockTaken" /> auch bei einer Ausnahme innerhalb des Methodenaufrufs zuverlässig untersucht werden kann, um zu bestimmen, ob die Sperre abgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.SpinLock> ist eine nicht wieder eintretende Sperre, d. h., wenn ein Thread die Sperre besitzt, ist es nicht zulässig, die Sperre erneut einzugeben. Wenn die Nachverfolgung von Thread Besitz aktiviert ist (unabhängig davon, ob Sie aktiviert ist <xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A> ), wird eine Ausnahme ausgelöst, wenn ein Thread versucht, erneut eine Sperre einzugeben, die er bereits enthält. Wenn die Nachverfolgung von Thread Besitz jedoch deaktiviert ist, führt der Versuch, eine Sperre einzugeben, zu einem Deadlock.  
  
 Wenn Sie aufrufen, <xref:System.Threading.SpinLock.Exit%2A> ohne zuerst <xref:System.Threading.SpinLock.Enter%2A> den internen Zustand von aufzurufen, <xref:System.Threading.SpinLock> kann beschädigt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das <paramref name="lockTaken" />-Argument muss vor dem Aufrufen von Enter mit false initialisiert werden.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread hat diese Sperre bereits abgerufen.</exception>
        <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Gewusst wie: Synchronisierung auf niedriger Ebene mit SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hebt die Sperre auf.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exit();" />
      <MemberSignature Language="F#" Value="member this.Exit : unit -&gt; unit" Usage="spinLock.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hebt die Sperre auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Überladung von <xref:System.Threading.SpinLock.Exit%2A> bietet das gleiche Verhalten wie beim Aufrufen von <xref:System.Threading.SpinLock.Exit%2A> mit true als Argument.  
  
 Wenn Sie aufrufen, <xref:System.Threading.SpinLock.Exit%2A> ohne zuerst <xref:System.Threading.SpinLock.Enter%2A> den internen Zustand von aufzurufen, <xref:System.Threading.SpinLock> kann beschädigt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread ist nicht Besitzer dieser Sperre.</exception>
        <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Gewusst wie: Synchronisierung auf niedriger Ebene mit SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public void Exit (bool useMemoryBarrier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exit(bool useMemoryBarrier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Exit(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exit (useMemoryBarrier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exit(bool useMemoryBarrier);" />
      <MemberSignature Language="F#" Value="member this.Exit : bool -&gt; unit" Usage="spinLock.Exit useMemoryBarrier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="useMemoryBarrier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="useMemoryBarrier">Ein boolescher Wert, der angibt, ob eine Arbeitsspeicherumgrenzung ausgegeben werden soll, um den Beendigungsvorgang sofort für andere Threads zu veröffentlichen.</param>
        <summary>Hebt die Sperre auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Threading.SpinLock.Exit%2A> Sie mit dem- `useMemoryBarrier` Argument aufrufen, das auf true festgelegt ist, wird die Fairness der Sperre auf Kosten der Leistung verbessert. Die Standard <xref:System.Threading.SpinLock.Exit%2A> Überladung verhält sich wie, wenn true für angegeben wird `useMemoryBarrier` .  
  
 Wenn Sie aufrufen, <xref:System.Threading.SpinLock.Exit%2A> ohne zuerst <xref:System.Threading.SpinLock.Enter%2A> den internen Zustand von aufzurufen, <xref:System.Threading.SpinLock> kann beschädigt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread ist nicht Besitzer dieser Sperre.</exception>
        <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Gewusst wie: Synchronisierung auf niedriger Ebene mit SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="IsHeld">
      <MemberSignature Language="C#" Value="public bool IsHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHeld : bool" Usage="System.Threading.SpinLock.IsHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Sperre zurzeit von einem Thread verwendet wird.</summary>
        <value>True, wenn die Sperre zurzeit von einem Thread verwendet wird, andernfalls false.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Gewusst wie: Synchronisierung auf niedriger Ebene mit SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="IsHeldByCurrentThread">
      <MemberSignature Language="C#" Value="public bool IsHeldByCurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHeldByCurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsHeldByCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHeldByCurrentThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHeldByCurrentThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHeldByCurrentThread : bool" Usage="System.Threading.SpinLock.IsHeldByCurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Sperre vom aktuellen Thread verwendet wird.</summary>
        <value>True, wenn die Sperre vom aktuellen Thread verwendet wird, andernfalls false.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Sperre für die Nachverfolgung von besitzerthreads initialisiert wurde, wird zurückgegeben, ob die Sperre vom aktuellen Thread abgerufen wird. Es ist ungültig, diese Eigenschaft zu verwenden, wenn die Sperre initialisiert wurde, um den Thread Besitz nicht zu verfolgen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Threadbesitznachverfolgung wird deaktiviert.</exception>
        <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Gewusst wie: Synchronisierung auf niedriger Ebene mit SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadOwnerTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool IsThreadOwnerTrackingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadOwnerTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadOwnerTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadOwnerTrackingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadOwnerTrackingEnabled : bool" Usage="System.Threading.SpinLock.IsThreadOwnerTrackingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Threadbesitznachverfolgung für diese Instanz aktiviert ist.</summary>
        <value>True, wenn die Threadbesitznachverfolgung für diese Instanz aktiviert ist, andernfalls false.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Gewusst wie: Synchronisierung auf niedriger Ebene mit SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, die Sperre zuverlässig abzurufen, sodass <paramref name="lockTaken" /> auch bei einer Ausnahme innerhalb des Methodenaufrufs zuverlässig untersucht werden kann, um zu bestimmen, ob die Sperre abgerufen wurde.</summary>
        <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Gewusst wie: Synchronisierung auf niedriger Ebene mit SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter : bool -&gt; unit" Usage="spinLock.TryEnter lockTaken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockTaken">True, wenn die Sperre abgerufen wird, andernfalls false. <paramref name="lockTaken" /> muss vor dem Aufrufen dieser Methode mit false initialisiert werden.</param>
        <summary>Versucht, die Sperre zuverlässig abzurufen, sodass <paramref name="lockTaken" /> auch bei einer Ausnahme innerhalb des Methodenaufrufs zuverlässig untersucht werden kann, um zu bestimmen, ob die Sperre abgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu <xref:System.Threading.SpinLock.Enter%2A> wird von TryEnter nicht blockiert, bis die Sperre verfügbar ist. Wenn die Sperre nicht verfügbar ist, wenn TryEnter aufgerufen wird, wird Sie sofort zurückgegeben, ohne dass weitere spinvorgänge durchlaufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das <paramref name="lockTaken" />-Argument muss vor dem Aufrufen von TryEnter mit false initialisiert werden.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread hat diese Sperre bereits abgerufen.</exception>
        <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Gewusst wie: Synchronisierung auf niedriger Ebene mit SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter : int * bool -&gt; unit" Usage="spinLock.TryEnter (millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="lockTaken">True, wenn die Sperre abgerufen wird, andernfalls false. <paramref name="lockTaken" /> muss vor dem Aufrufen dieser Methode mit false initialisiert werden.</param>
        <summary>Versucht, die Sperre zuverlässig abzurufen, sodass <paramref name="lockTaken" /> auch bei einer Ausnahme innerhalb des Methodenaufrufs zuverlässig untersucht werden kann, um zu bestimmen, ob die Sperre abgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu <xref:System.Threading.SpinLock.Enter%2A> wird TryEnter nicht unbegrenzt blockieren, bis die Sperre verfügbar ist. Sie wird blockiert, bis entweder die Sperre verfügbar ist oder bis `millisecondsTimeout` abgelaufen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="lockTaken" />-Argument muss vor dem Aufrufen von TryEnter mit false initialisiert werden.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread hat diese Sperre bereits abgerufen.</exception>
        <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Gewusst wie: Synchronisierung auf niedriger Ebene mit SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter : TimeSpan * bool -&gt; unit" Usage="spinLock.TryEnter (timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <param name="lockTaken">True, wenn die Sperre abgerufen wird, andernfalls false. <paramref name="lockTaken" /> muss vor dem Aufrufen dieser Methode mit false initialisiert werden.</param>
        <summary>Versucht, die Sperre zuverlässig abzurufen, sodass <paramref name="lockTaken" /> auch bei einer Ausnahme innerhalb des Methodenaufrufs zuverlässig untersucht werden kann, um zu bestimmen, ob die Sperre abgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu <xref:System.Threading.SpinLock.Enter%2A> wird TryEnter nicht unbegrenzt blockieren, bis die Sperre verfügbar ist. Sie wird blockiert, bis entweder die Sperre verfügbar ist oder bis `timeout` abgelaufen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt, - oder - Timeout ist größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="lockTaken" />-Argument muss vor dem Aufrufen von TryEnter mit false initialisiert werden.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread hat diese Sperre bereits abgerufen.</exception>
        <related type="Article" href="/dotnet/standard/threading/spinlock">SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-use-spinlock-for-low-level-synchronization">Gewusst wie: Synchronisierung auf niedriger Ebene mit SpinLock</related>
        <related type="Article" href="/dotnet/standard/threading/how-to-enable-thread-tracking-mode-in-spinlock">Gewusst wie: Aktivieren des Modus zum Nachverfolgen von Threads in SpinLock</related>
      </Docs>
    </Member>
  </Members>
</Type>
