<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Thread.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b857fe3" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2eccf4de-4b1c-4706-8cb3-f46682ccfb72f908dbd04f1ed17bee04e225536a93e5e092d9d1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f908dbd04f1ed17bee04e225536a93e5e092d9d1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b15b8cf0f6dbc1504057c88969d9ef4b790891fe</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/11/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Creates and controls a thread, sets its priority, and gets its status.</source>
          <target state="translated">Erstellt und steuert einen Thread, legt dessen Priorität fest und ruft den Status ab.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</source>
          <target state="translated">Beim Starten eines Prozesses erstellt die common Language Runtime automatisch einen einzelne Vordergrundthread um Anwendungscode auszuführen.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</source>
          <target state="translated">Zusammen mit diesem Hauptmenü Vordergrundthread kann ein Prozess einen oder mehrere Threads zum Ausführen eines Teils des Programmcodes, die dem Prozess zugeordnet erstellen.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>These threads can execute either in the foreground or in the background.</source>
          <target state="translated">Diese Threads können im Vordergrund oder im Hintergrund ausgeführt.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>In addition, you can use the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class to execute code on worker threads that are managed by the common language runtime.</source>
          <target state="translated">Darüber hinaus können Sie die <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> Klasse zum Ausführen von Code von Arbeitsthreads, die von der common Language Runtime verwaltet werden.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>In this section</source>
          <target state="translated">In diesem Abschnitt</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Starten eines Threads<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Retrieving Thread objects<ept id="p1">](#Retrieving)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Thread-Serverobjekte werden abgerufen<ept id="p1">](#Retrieving)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Vordergrund-und Hintergrundthreads<ept id="p1">](#Foreground)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Culture and threads<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Kultur und threads<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Getting information about and controlling threads<ept id="p1">](#Properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Abrufen von Informationen zu und Steuern von threads<ept id="p1">](#Properties)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Starting a thread</source>
          <target state="translated">Starten eines Threads</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</source>
          <target state="translated">Starten Sie einen Thread, indem ein Delegat, der die Methode darstellt, die der Thread zum Ausführen in den Klassenkonstruktor wird angeben.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You then call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method to begin execution.</source>
          <target state="translated">Rufen Sie dann die <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> Methode, um die Ausführung zu starten.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> Konstruktoren können eine der beiden Delegattypen, je nachdem, ob Sie ein Argument an die Methode ausgeführt werden weitergeben können:</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>If the method has no arguments, you pass a <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> delegate to  the constructor.</source>
          <target state="translated">Wenn die Methode keine Argumente verfügt, übergeben Sie eine <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> an den Konstruktor zu delegieren.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It has the signature:</source>
          <target state="translated">Es hat die Signatur:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example creates and starts a thread that executes the <ph id="ph1">`ExecuteInForeground`</ph> method.</source>
          <target state="translated">Das folgende Beispiel erstellt und startet einen Thread, der ausgeführt wird die <ph id="ph1">`ExecuteInForeground`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</source>
          <target state="translated">Die Methode zeigt Informationen zu einigen Threadeigenschaften, und führt eine Schleife in der für eine halbe Sekunde angehalten und zeigt die verstrichene Anzahl von Sekunden.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</source>
          <target state="translated">Wenn der Thread mindestens fünf Sekunden lang ausgeführt wurde, wird die Schleife beendet, und der Thread Ausführung beendet.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>If the method has an argument, you pass a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate to the constructor.</source>
          <target state="translated">Wenn die Methode ein Argument verfügt, übergeben Sie eine <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> an den Konstruktor zu delegieren.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It has the signature:</source>
          <target state="translated">Es hat die Signatur:</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</source>
          <target state="translated">Die Methode ausgeführt wird, durch den Delegaten kann dann umgewandelt (in c#) oder (in Visual Basic) die Parameter in den entsprechenden Typ konvertieren.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example is identical to the previous one, except that it calls the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor.</source>
          <target state="translated">Das folgende Beispiel ist identisch mit der vorherigen Abfrage, außer dass sie ruft die <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This version of the <ph id="ph1">`ExecuteInForeground`</ph> method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</source>
          <target state="translated">Diese Version von den <ph id="ph1">`ExecuteInForeground`</ph> Methode verfügt über einen einzelnen Parameter, der die ungefähre Anzahl von Millisekunden darstellt, die Schleife ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It is not necessary to retain a reference to a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> object once you have started the thread.</source>
          <target state="translated">Es ist nicht notwendig, behalten einen Verweis auf ein <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> -Objekt, sobald Sie den Thread gestartet haben.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The thread continues to execute until the thread procedure is complete.</source>
          <target state="translated">Der Thread weiterhin ausgeführt, bis die Threadprozedur abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Retrieving Thread objects</source>
          <target state="translated">Thread-Serverobjekte werden abgerufen</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can use the static (<ph id="ph1">`Shared`</ph> in Visual Basic)  <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</source>
          <target state="translated">Sie können die statische (<ph id="ph1">`Shared`</ph> in Visual Basic) <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> Eigenschaft um einen Verweis auf den gerade ausgeführten Thread aus dem Code abzurufen, die der Thread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> Eigenschaft zum Anzeigen von Informationen zum Thread der hauptanwendung, der eine andere Vordergrundthread, einen Hintergrundthread weitergeben und ein Thread des Threadpools.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Foreground and background threads</source>
          <target state="translated">Vordergrund-und Hintergrundthreads</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Instances of the <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class represent either foreground threads or background threads.</source>
          <target state="translated">Instanzen der <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> Vordergrundthreads oder Hintergrundthreads Klasse darstellen.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</source>
          <target state="translated">Hintergrundthreads sind identisch mit Vordergrundthreads mit einer Ausnahme: ein Hintergrundthread behält keinen laufenden Prozess aus, wenn alle Vordergrundthreads beendet haben.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</source>
          <target state="translated">Sobald alle Vordergrundthreads beendet wurden, wird die Common Language Runtime beendet alle Hintergrundthreads und heruntergefahren.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>By default, the following threads execute in the foreground:</source>
          <target state="translated">Standardmäßig werden die folgenden Threads im Vordergrund:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The main application thread.</source>
          <target state="translated">Der Thread der hauptanwendung.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>All threads created by calling a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class constructor.</source>
          <target state="translated">Alle Threads durch Aufruf erstellt einen <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> Klassenkonstruktor.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following threads execute in the background by default:</source>
          <target state="translated">Die folgenden Threads, die standardmäßig im Hintergrund ausgeführt werden:</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">Der Thread im Threadpool, die einen Pool von Arbeitsthreads, die von der Laufzeit verwaltet werden.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class.</source>
          <target state="translated">Sie können die Thread-Pool und den Zeitplan Arbeit auf Threads im Threadpool konfigurieren, mit der <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">Aufgabenbasierte asynchrone Vorgänge werden automatisch auf Threads im Threadpool ausgeführt.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Task-based asynchronous operations use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> classes to implement the <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept>.</source>
          <target state="translated">Aufgabenbasierte asynchrone Vorgänge verwenden die <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> Klassen zum Implementieren der <bpt id="p1">[</bpt>aufgabenbasierte asynchrone Muster<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">Alle Threads, die die verwaltete ausführungsumgebung von nicht verwaltetem Code eingeben.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can change a thread to execute in the background by setting the <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property at any time.</source>
          <target state="translated">Sie können ändern, einen Thread zum Ausführen im Hintergrund durch Festlegen der <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> Eigenschaft zu einem beliebigen Zeitpunkt.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</source>
          <target state="translated">Hintergrundthreads eignen sich für jeden Vorgang, der als eine Anwendung ausgeführt wird, jedoch verhindert nicht, die Anwendung beendet wird dass sollten, wie z. B. das Überwachen von dateisystemänderungen oder eingehenden Socketverbindungen fortgesetzt werden soll.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example illustrates the difference between foreground and background threads.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht den Unterschied zwischen Vordergrund-und Hintergrundthreads.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It is like the first example in the <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept> section, except that it sets the thread to execute in the background before starting it.</source>
          <target state="translated">Er ist wie im ersten Beispiel in der <bpt id="p1">[</bpt>Starten eines Threads<ept id="p1">](#Starting)</ept> Abschnitt Ausnahme, dass den Thread im Hintergrund ausgeführt werden soll, vor dem starten.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>As the output shows, the loop is interrupted before it executes for five seconds.</source>
          <target state="translated">Wie die Ausgabe zeigt, wird die Schleife unterbrochen, bevor er fünf Sekunden ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Culture and threads</source>
          <target state="translated">Kultur und threads</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Each thread has a culture, represented by the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property, and a UI culture, represented by the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;</ph> property.</source>
          <target state="translated">Jeder Thread verfügt über eine Kultur, dargestellt durch die <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> -Eigenschaft und eine UI-Kultur, dargestellt durch die <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</source>
          <target state="translated">Die aktuelle Kultur kulturabhängige Vorgänge wie das Analysieren und formatieren, Zeichenfolgenvergleich und-Sortierung unterstützt, und steuert auch, das Schriftsystem und Kalender, die von einem Thread verwendet.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The current UI culture provides for culture-sensitive retrieval of resources in resource files.</source>
          <target state="translated">Die aktuelle Benutzeroberflächenkultur bietet für kulturabhängige Abruf von Ressourcen in Ressourcendateien.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</source>
          <target state="translated">Wenn Sie ein neuer Thread instanziiert wird, werden seine Kultur und Benutzeroberflächenkultur definiert, durch die aktuelle Systemkultur und die Kultur der Benutzeroberfläche und nicht von der Kultur und Benutzeroberflächenkultur des Threads, die aus der neue Thread erstellt wird.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor from the primary thread is English (United States), and not French (France).</source>
          <target state="translated">Dies bedeutet beispielsweise, dass wenn die aktuelle Systemkultur Englisch (Vereinigte Staaten ist) und der primäre Thread der aktuellen Kultur Französisch (Frankreich), die Kultur eines neuen Threads durch Aufruf erstellt die <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> Konstruktor vom primären Thread ist Englisch (Vereinigte Staaten) und nicht Französisch (Frankreich).</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information, see the "Culture and threads" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Kultur und Threads" die <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> klassenthema.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This is not true of threads that execute asynchronous operations for apps that target the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</source>
          <target state="translated">Dies gilt nicht für Threads, die asynchrone Vorgänge für apps ausgeführt werden, die auf die <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> und höhere Versionen, In diesem Fall werden die Kultur und Benutzeroberflächenkultur ist Teil eines asynchronen Vorgangskontext; der Thread auf dem einen asynchronen Vorgang führt standardmäßig erbt, die Kultur und Benutzeroberflächenkultur des Threads, in dem der asynchrone Vorgang gestartet wurde.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information, see the "Culture and task-based asynchronous operations" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Kultur und aufgabenbasierte asynchrone Vorgänge" im Thema zur <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</source>
          <target state="translated">Führen Sie eine der folgenden Optionen, um sicherzustellen, dass alle Threads in einer Anwendung ausführen freigeben, das dieselbe Kultur und Benutzeroberflächenkultur:</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can pass a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents that culture to the <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate or the <ph id="ph3">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Können Sie übergeben ein <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> -Objekt, das diese Kultur entspricht der <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegieren oder <ph id="ph3">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For apps running on the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Für apps, die unter der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> und höheren Versionen können Sie definieren, die Kultur und Benutzeroberflächenkultur, die für alle Threads in einer Anwendungsdomäne erstellt, durch Festlegen des Werts der zugewiesen werden soll die <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Note that this is a per-application domain setting.</source>
          <target state="translated">Beachten Sie, dass dies eine pro-AppDomain-Einstellung ist.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information and examples, see the "Culture and threads" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
          <target state="translated">Weitere Informationen und Beispiele finden Sie im Abschnitt "Kultur und Threads" die <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> klassenthema.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Getting information about and controlling threads</source>
          <target state="translated">Abrufen von Informationen zu und Steuern von threads</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can retrieve a number of property values that provide information about a thread.</source>
          <target state="translated">Sie können eine Anzahl an Eigenschaftenwerten abrufen, die Informationen über einen Thread bereitstellen.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>In some cases, you can also set these property values to control the operation of the thread.</source>
          <target state="translated">In einigen Fällen können Sie auch diese Eigenschaftswerte die Ausführung des Threads steuern festlegen.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>These thread properties include:</source>
          <target state="translated">Zu diesen Threadeigenschaften zählen:</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A name.</source>
          <target state="translated">Einen Namen.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> is a write-once property that you can use to identify a thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> ist ein Schreibvorgang-einmal-Eigenschaft, die Sie verwenden können, um einen Thread zu identifizieren.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Its default value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A hash code, which you can retrieve by calling the <ph id="ph1">&lt;xref:System.Threading.Thread.GetHashCode%2A&gt;</ph> method.</source>
          <target state="translated">Ein Hashcode, d. h. Sie, durch Aufrufen abrufen können der <ph id="ph1">&lt;xref:System.Threading.Thread.GetHashCode%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</source>
          <target state="translated">Der Hashcode kann zur eindeutigen Identifizierung von einem Thread verwendet werden. für die Lebensdauer des Threads wird dessen Hashcode nicht mit dem Wert eines anderen Threads, unabhängig von der Anwendungsdomäne Konflikte zwischen von dem Sie den Wert abrufen.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A thread ID.</source>
          <target state="translated">Ein Thread-ID.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The value of the read-only <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property is assigned by the runtime and uniquely identifies a thread within its process.</source>
          <target state="translated">Der Wert der Read-only <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> Eigenschaft wird von der Laufzeit zugewiesen und einen Thread in einem Prozess eindeutig identifiziert.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>An operating-system <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</source>
          <target state="translated">Eine Betriebssystem-<bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> hat keine feste Beziehung zu einem verwalteten Thread, da ein nicht verwalteter Host die Beziehung zwischen verwalteten und nicht verwalteten Threads steuern kann.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Specifically, a sophisticated host can use the <bpt id="p1">[</bpt>CLR Hosting API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</source>
          <target state="translated">Insbesondere können ein komplexer Host die <bpt id="p1">[</bpt>CLR Hosting-API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> um viele verwaltete Threads mit demselben Betriebssystemthread zu planen oder einen verwalteten Thread zwischen verschiedenen Betriebssystemthreads zu verschieben.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The thread's current state.</source>
          <target state="translated">Aktueller Status für den Thread.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For the duration of its existence, a thread is always in one or more of the states defined by the <ph id="ph1">&lt;xref:System.Threading.ThreadState&gt;</ph> property.</source>
          <target state="translated">Für die Dauer des sein Vorhandensein überprüft werden soll, ein Thread ist immer in einem oder mehreren der Zustände definiert, indem Sie die <ph id="ph1">&lt;xref:System.Threading.ThreadState&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A scheduling priority level, which is defined by the <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> property.</source>
          <target state="translated">Eine Prioritätsstufe planen, die durch festgelegt sind die <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</source>
          <target state="translated">Obwohl Sie diesen Wert zum Anfordern der Priorität des Threads festlegen können, ist es nicht garantiert, die vom Betriebssystem berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The read-only <ph id="ph1">&lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</ph> property, which indicates whether a thread is  a thread pool thread.</source>
          <target state="translated">Die schreibgeschützte <ph id="ph1">&lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</ph> -Eigenschaft, die angibt, ob ein Thread ein Thread des Threadpools ist.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph>-Eigenschaft</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information, see the <bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept> section.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <bpt id="p1">[</bpt>Vordergrund-und Hintergrundthreads<ept id="p1">](#Foreground)</ept> Abschnitt.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example demonstrates simple threading functionality.</source>
          <target state="translated">Das folgende Beispiel zeigt einfachen threading-Funktionen.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This code produces output similar to the following:</source>
          <target state="translated">Dieser Code erzeugt eine Ausgabe ähnlich der folgenden:</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This type is thread safe.</source>
          <target state="translated">Dieser Typ ist threadsicher.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>A delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Ein Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>-Klasse und gibt dabei einen Delegaten an, der das Übergeben eines Objekts an den Thread bei dessen Start ermöglicht.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Ein Thread ausgeführt wird, während der Erstellung nicht gestartet.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>To schedule the thread for execution, call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method.</source>
          <target state="translated">Wenn den Thread für die Ausführung planen möchten, rufen Sie die <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>To pass a data object to the thread, use the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;</ph> method overload.</source>
          <target state="translated">Um ein Datenobjekt an den Thread übergeben, verwenden die <ph id="ph1">&lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Visual Basic users can omit the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor when creating a thread.</source>
          <target state="translated">Visual Basic-Benutzer können weglassen der <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> Konstruktor beim Erstellen eines Threads.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method, for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">`AddressOf`</ph> Operator, wenn die Methode übergeben, z. B. <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Visual Basic automatically calls the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor.</source>
          <target state="translated">Visual Basic ruft automatisch den <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>The following example shows the syntax for creating and using a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate with a static method and an instance method.</source>
          <target state="translated">Das folgende Beispiel zeigt die Syntax zum Erstellen und Verwenden einer <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> Delegaten mit einer statischen Methode und eine Instanzenmethode.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph>-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Ein Thread ausgeführt wird, während der Erstellung nicht gestartet.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>To schedule the thread for execution, call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method.</source>
          <target state="translated">Wenn den Thread für die Ausführung planen möchten, rufen Sie die <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Visual Basic users can omit the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor when creating a thread.</source>
          <target state="translated">Visual Basic-Benutzer können weglassen der <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> Konstruktor beim Erstellen eines Threads.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">`AddressOf`</ph> Operator, wenn die Methode übergeben, z. B. <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Visual Basic automatically calls the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor.</source>
          <target state="translated">Visual Basic ruft automatisch den <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>The following code example shows how to create a thread that executes a static method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie einen Thread zu erstellen, der eine statische Methode ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>The following code example shows how to create a thread that executes an instance method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie einen Thread zu erstellen, der eine Instanzmethode ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>The <ph id="ph1">&lt;paramref name="start" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="start" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph>-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">Die maximale Stapelgröße, in Bytes, für den Thread, oder 0 (null), wenn die angegebene maximale Standardstapelgröße aus dem Header der ausführbaren Datei verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Important   For partially trusted code, <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Wichtig   Für teilweise vertrauenswürdigen Code wird <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> ignoriert, wenn sie größer als die Standardstapelgröße ist.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>-Klasse und gibt dabei einen Delegaten, der das Übergeben eines Objekts an den Thread bei dessen Start ermöglicht, sowie eine maximale Stapelgröße für den Thread an.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Vermeiden Sie die Verwendung dieser Überladung des Konstruktors.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>The default stack size used by the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor overload is the recommended stack size for threads.</source>
          <target state="translated">Die Standardgröße des Stapel verwendet werden, indem die <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> Konstruktorüberladung ist die empfohlene Stapelgröße für Threads.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Wenn ein Thread Arbeitsspeicherprobleme hat, ist die wahrscheinlichste Ursache, z. B. eine unbegrenzte Rekursion Programmierfehler.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph2">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, nur für vollständig vertrauenswürdige Code festlegen kann <ph id="ph2">`maxStackSize`</ph> auf einen Wert, der größer als die Standardstapelgröße (1 MB).</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Wenn ein größerer Wert, für angegeben wird <ph id="ph1">`maxStackSize`</ph> Code mit teilweiser Vertrauenswürdigkeit ausgeführt wird <ph id="ph2">`maxStackSize`</ph> wird ignoriert, und die Standardgröße des Stapel verwendet wird.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Auf jeder Ebene der Vertrauenswürdigkeit können zeichencodesatz-ID <ph id="ph1">`maxStackSize`</ph> auf einen Wert, der kleiner als die Standardstapelgröße ist.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">Wenn Sie entwickeln eine voll vertrauenswürdige Bibliothek, die von teilweise vertrauenswürdigem Code verwendet werden, und Sie Starten eines Threads müssen erfordert, dass eine große Stack, Sie müssen volle Vertrauenswürdigkeit zusichern, vor dem Erstellen des Threads oder die standardmäßige Stapelgröße verwendet werden.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Tun Sie dies, wenn Sie den Code vollständig steuern, der auf dem Thread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Wenn <ph id="ph1">`maxStackSize`</ph> ist kleiner als die minimale Stapelgröße, wird die minimale Stapelgröße verwendet.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Wenn <ph id="ph1">`maxStackSize`</ph> ist kein Vielfaches der Seitengröße, gerundet auf das nächste größere Vielfache der Seitengröße.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Bei Verwendung von .NET Framework, Version 2.0 unter Windows Vista 256KB (262.144 Bytes) ist die minimale Stapelgröße ein, und das Seitenformat beträgt 64KB (65.536 Byte).</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">In Versionen von Microsoft Windows vor Windows XP und Windows Server 2003 <ph id="ph1">`maxStackSize`</ph> ignoriert, und die Größe des Stapels im Header ausführbaren Datei angegeben werden.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Wenn Sie eine sehr kleine Stapelgröße angeben, müssen Sie u. u. Stapelüberlaufs deaktivieren.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Wenn der Stapel stark eingeschränkt ist, kann, auf dem selbst einen Stapelüberlauf verursachen die Überprüfung.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Fügen Sie folgenden in der Anwendungskonfigurationsdatei, um Stapelüberlaufs zu deaktivieren.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph>-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">Die maximale Stapelgröße, in Bytes, für den Thread, oder 0 (null), wenn die angegebene maximale Standardstapelgröße aus dem Header der ausführbaren Datei verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Important   For partially trusted code, <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Wichtig   Für teilweise vertrauenswürdigen Code wird <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> ignoriert, wenn sie größer als die Standardstapelgröße ist.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class, specifying the maximum stack size for the thread.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>-Klasse und gibt die maximale Stapelgröße für den Thread an.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Vermeiden Sie die Verwendung dieser Überladung des Konstruktors.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>The default stack size used by the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</ph> constructor overload is the recommended stack size for threads.</source>
          <target state="translated">Die Standardgröße des Stapel verwendet werden, indem die <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</ph> Konstruktorüberladung ist die empfohlene Stapelgröße für Threads.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Wenn ein Thread Arbeitsspeicherprobleme hat, ist die wahrscheinlichste Ursache, z. B. eine unbegrenzte Rekursion Programmierfehler.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph2">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, nur für vollständig vertrauenswürdige Code festlegen kann <ph id="ph2">`maxStackSize`</ph> auf einen Wert, der größer als die Standardstapelgröße (1 MB).</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Wenn ein größerer Wert, für angegeben wird <ph id="ph1">`maxStackSize`</ph> Code mit teilweiser Vertrauenswürdigkeit ausgeführt wird <ph id="ph2">`maxStackSize`</ph> wird ignoriert, und die Standardgröße des Stapel verwendet wird.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Auf jeder Ebene der Vertrauenswürdigkeit können zeichencodesatz-ID <ph id="ph1">`maxStackSize`</ph> auf einen Wert, der kleiner als die Standardstapelgröße ist.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">Wenn Sie entwickeln eine voll vertrauenswürdige Bibliothek, die von teilweise vertrauenswürdigem Code verwendet werden, und Sie Starten eines Threads müssen erfordert, dass eine große Stack, Sie müssen volle Vertrauenswürdigkeit zusichern, vor dem Erstellen des Threads oder die standardmäßige Stapelgröße verwendet werden.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Tun Sie dies, wenn Sie den Code vollständig steuern, der auf dem Thread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Wenn <ph id="ph1">`maxStackSize`</ph> ist kleiner als die minimale Stapelgröße, wird die minimale Stapelgröße verwendet.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Wenn <ph id="ph1">`maxStackSize`</ph> ist kein Vielfaches der Seitengröße, gerundet auf das nächste größere Vielfache der Seitengröße.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Bei Verwendung von .NET Framework, Version 2.0 unter Windows Vista 256KB (262.144 Bytes) ist die minimale Stapelgröße ein, und das Seitenformat beträgt 64KB (65.536 Byte).</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">In Versionen von Microsoft Windows vor Windows XP und Windows Server 2003 <ph id="ph1">`maxStackSize`</ph> ignoriert, und die Größe des Stapels im Header ausführbaren Datei angegeben werden.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Wenn Sie eine sehr kleine Stapelgröße angeben, müssen Sie u. u. Stapelüberlaufs deaktivieren.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Wenn der Stapel stark eingeschränkt ist, kann, auf dem selbst einen Stapelüberlauf verursachen die Überprüfung.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Fügen Sie folgenden in der Anwendungskonfigurationsdatei, um Stapelüberlaufs zu deaktivieren.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Raises a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">Löst eine <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>Raises a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">Löst eine <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>When this method is invoked on a thread, the system throws a <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> in the thread to abort it.</source>
          <target state="translated">Wenn diese Methode in einem Thread aufgerufen wird, löst das System eine <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> im Thread aus, um ihn abzubrechen.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph> ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch wird erneut ausgelöst, am Ende der <ph id="ph2">`catch`</ph> blockieren, es sei denn, <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph> Bricht die Anforderung zum Abbrechen und verhindert, dass die <ph id="ph2">`ThreadAbortException`</ph> aus Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Nicht ausgeführte <ph id="ph1">`finally`</ph> Blöcke werden ausgeführt, bevor der Thread abgebrochen wird.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>When a thread calls <ph id="ph1">`Abort`</ph> on itself, the effect is similar to throwing an exception; the <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> happens immediately, and the result is predictable.</source>
          <target state="translated">Wenn ein Thread aufruft, <ph id="ph1">`Abort`</ph> auf sich selbst, die Wirkung gleicht dem Auslösen einer Ausnahme; die <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> wird sofort ausgeführt, und das Ergebnis ist eine vorhersehbare.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">Jedoch, wenn ein Thread ruft <ph id="ph1">`Abort`</ph> in einem anderen Thread, unterbricht der Abbruch der Code ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>There is also a chance that a static constructor could be aborted.</source>
          <target state="translated">Es ist auch möglich, dass ein statischer Konstruktor abgebrochen werden konnte.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">In seltenen Fällen kann dadurch verhindert, dass Instanzen dieser Klasse in der Anwendungsdomäne erstellt wird.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">In der .NET Framework-Versionen 1.0 und 1.1, besteht die Möglichkeit der Thread während einer <ph id="ph1">`finally`</ph> Block ausgeführt wird, in diesem Fall die <ph id="ph2">`finally`</ph> Block wird abgebrochen.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">Der Thread wird nicht unbedingt sofort oder überhaupt abgebrochen.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Diese Situation kann auftreten, wenn ein Thread eine unbegrenzte Berechnung in der Fall ist die <ph id="ph1">`finally`</ph> Blöcke, die im Rahmen des Abbruchvorgangs, wodurch unbegrenzt der Abbruch verzögert aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>To wait until a thread has aborted, you can call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method on the thread after calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> method, but there is no guarantee the wait will end.</source>
          <target state="translated">Warten, bis ein Thread abgebrochen wurde, rufen Sie die <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> Methode für den Thread nach dem Aufruf der <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> -Methode, aber es gibt keine Garantie der Wartevorgang wird beendet.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>The thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">Der aufrufende Thread <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> möglicherweise blockiert, wenn der Thread, die abgebrochen wird in einen geschützten Codebereich, wie eine <ph id="ph2">`catch`</ph> Block <ph id="ph3">`finally`</ph> Block oder eingeschränkten Ausführungsbereich.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If the thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Wenn der Thread aufruft <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> eine Sperre, die der abgebrochene Thread erforderlich ist, kann ein Deadlock auftreten, enthält.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> is called.</source>
          <target state="translated">Wenn <ph id="ph1">`Abort`</ph> wird aufgerufen, auf einen Thread, der nicht gestartet wurde, wird der Thread abgebrochen Wenn <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Wenn <ph id="ph1">`Abort`</ph> wird aufgerufen, auf einen Thread, der blockiert ist oder im Ruhezustand ist, wird der Thread unterbrochen und dann abgebrochen.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> is thrown in the thread that called <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> is added to the <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property of the thread being aborted.</source>
          <target state="translated">Wenn <ph id="ph1">`Abort`</ph> aufgerufen wird, auf einen Thread, der angehalten wurde, eine <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> wird ausgelöst, in dem Thread, <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> hinzugefügt wird die <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> Eigenschaft des abgebrochenen Thread.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> is not thrown in the suspended thread until <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> is called.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> wird nicht ausgelöst, in den angehaltenen Thread, bis <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Wenn <ph id="ph1">`Abort`</ph> für einen verwalteten Thread aufgerufen wird, während der Ausführung von nicht verwalteten Codes wird eine <ph id="ph2">`ThreadAbortException`</ph> nicht ausgelöst, bis der Thread zu verwaltetem Code zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Wenn zwei Aufrufe <ph id="ph1">`Abort`</ph> stammen zur gleichen Zeit ist es möglich, dass ein Aufruf zum Festlegen der Informationen über den Zustand und der andere Aufruf zum Ausführen der <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">Eine Anwendung kann nicht jedoch diese Situation erkennen.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</source>
          <target state="translated">Nach dem <ph id="ph1">`Abort`</ph> wird aufgerufen, in einem Thread der Zustand des Threads enthält <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</source>
          <target state="translated">Nachdem der Thread, als Ergebnis einer erfolgreichen Aufruf beendet wurde <ph id="ph1">`Abort`</ph>, der Status des Threads wird geändert, um <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Ein Thread, der ist mit ausreichenden Berechtigungen das Ziel einer <ph id="ph1">`Abort`</ph> "Abbrechen" können diesen Vorgang unter Verwendung der <ph id="ph2">`ResetAbort`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Ein Beispiel für die Aufrufen der <ph id="ph1">`ResetAbort`</ph> -Methode finden Sie unter der <ph id="ph2">`ThreadAbortException`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">Nur .NET Core: Dieser Member wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">Der abgebrochene Thread ist derzeit angehalten.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>for advanced operations on threads.</source>
          <target state="translated">für erweiterte Vorgänge für Threads.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>An object that contains application-specific information, such as state, which can be used by the thread being aborted.</source>
          <target state="translated">Ein Objekt, das anwendungsspezifische Informationen enthält (z. B. über den Zustand), die vom abgebrochenen Thread verwendet werden können.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Raises a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</source>
          <target state="translated">Löst eine <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen. Gleichzeitig werden Ausnahmeinformationen über das Beenden des Threads bereitgestellt.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>When this method is invoked on a thread, the system throws a <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> in the thread to abort it.</source>
          <target state="translated">Wenn diese Methode in einem Thread aufgerufen wird, löst das System eine <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> im Thread aus, um ihn abzubrechen.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph> ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch wird erneut ausgelöst, am Ende der <ph id="ph2">`catch`</ph> blockieren, es sei denn, <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph> Bricht die Anforderung zum Abbrechen und verhindert, dass die <ph id="ph2">`ThreadAbortException`</ph> aus Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Nicht ausgeführte <ph id="ph1">`finally`</ph> Blöcke werden ausgeführt, bevor der Thread abgebrochen wird.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>When a thread calls <ph id="ph1">`Abort`</ph> on itself, the effect is similar to throwing an exception; the <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> happens immediately, and the result is predictable.</source>
          <target state="translated">Wenn ein Thread aufruft, <ph id="ph1">`Abort`</ph> auf sich selbst, die Wirkung gleicht dem Auslösen einer Ausnahme; die <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> wird sofort ausgeführt, und das Ergebnis ist eine vorhersehbare.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">Jedoch, wenn ein Thread ruft <ph id="ph1">`Abort`</ph> in einem anderen Thread, unterbricht der Abbruch der Code ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>There is a chance that a static constructor could be aborted.</source>
          <target state="translated">Es besteht die Möglichkeit, dass ein statischer Konstruktor abgebrochen werden konnte.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">In seltenen Fällen kann dadurch verhindert, dass Instanzen dieser Klasse in der Anwendungsdomäne erstellt wird.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">In der .NET Framework-Versionen 1.0 und 1.1, besteht die Möglichkeit der Thread während einer <ph id="ph1">`finally`</ph> Block ausgeführt wird, in diesem Fall die <ph id="ph2">`finally`</ph> Block wird abgebrochen.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">Der Thread wird nicht unbedingt sofort oder überhaupt abgebrochen.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Diese Situation kann auftreten, wenn ein Thread eine unbegrenzte Berechnung in der Fall ist die <ph id="ph1">`finally`</ph> Blöcke, die im Rahmen des Abbruchvorgangs, wodurch unbegrenzt der Abbruch verzögert aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>To wait until a thread has aborted, you can call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method on the thread after calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> method, but there is no guarantee that the wait will end.</source>
          <target state="translated">Warten, bis ein Thread abgebrochen wurde, rufen Sie die <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> Methode für den Thread nach dem Aufruf der <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> -Methode, aber es gibt keine Garantie, die der Wartevorgang beendet wird.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">Der aufrufende Thread <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> möglicherweise blockiert, wenn der Thread, die abgebrochen wird in einen geschützten Codebereich, wie eine <ph id="ph2">`catch`</ph> Block <ph id="ph3">`finally`</ph> Block oder eingeschränkten Ausführungsbereich.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If the thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Wenn der Thread aufruft <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> eine Sperre, die der abgebrochene Thread erforderlich ist, kann ein Deadlock auftreten, enthält.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> is called.</source>
          <target state="translated">Wenn <ph id="ph1">`Abort`</ph> wird aufgerufen, auf einen Thread, der nicht gestartet wurde, wird der Thread abgebrochen Wenn <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Wenn <ph id="ph1">`Abort`</ph> wird aufgerufen, auf einen Thread, der blockiert ist oder im Ruhezustand ist, wird der Thread unterbrochen und dann abgebrochen.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> is thrown in the thread that called <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> is added to the <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property of the thread being aborted.</source>
          <target state="translated">Wenn <ph id="ph1">`Abort`</ph> aufgerufen wird, auf einen Thread, der angehalten wurde, eine <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> wird ausgelöst, in dem Thread, <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> hinzugefügt wird die <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> Eigenschaft des abgebrochenen Thread.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> is not thrown in the suspended thread until <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> is called.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> wird nicht ausgelöst, in den angehaltenen Thread, bis <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Wenn <ph id="ph1">`Abort`</ph> für einen verwalteten Thread aufgerufen wird, während der Ausführung von nicht verwalteten Codes wird eine <ph id="ph2">`ThreadAbortException`</ph> nicht ausgelöst, bis der Thread zu verwaltetem Code zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Wenn zwei Aufrufe <ph id="ph1">`Abort`</ph> stammen zur gleichen Zeit ist es möglich, dass ein Aufruf zum Festlegen der Informationen über den Zustand und der andere Aufruf zum Ausführen der <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">Eine Anwendung kann nicht jedoch diese Situation erkennen.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</source>
          <target state="translated">Nach dem <ph id="ph1">`Abort`</ph> wird aufgerufen, in einem Thread der Zustand des Threads enthält <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</source>
          <target state="translated">Nachdem der Thread, als Ergebnis einer erfolgreichen Aufruf beendet wurde <ph id="ph1">`Abort`</ph>, der Status des Threads wird geändert, um <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Ein Thread, der ist mit ausreichenden Berechtigungen das Ziel einer <ph id="ph1">`Abort`</ph> "Abbrechen" können diesen Vorgang unter Verwendung der <ph id="ph2">`ResetAbort`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Ein Beispiel für die Aufrufen der <ph id="ph1">`ResetAbort`</ph> -Methode finden Sie unter der <ph id="ph2">`ThreadAbortException`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The following code example shows how to pass information to a thread that is being aborted.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie Informationen an einen Thread übergeben, die abgebrochen wird.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">Nur .NET Core: Dieser Member wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">Der abgebrochene Thread ist derzeit angehalten.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>for advanced operations on threads.</source>
          <target state="translated">für erweiterte Vorgänge für Threads.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Allocates an unnamed data slot on all the threads.</source>
          <target state="translated">Reserviert einen unbenannten Datenslot für alle Threads.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>-Attribut markiert sind.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">Der reservierte benannte Datenslot für alle Threads.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut) und Datenslots.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Weitere Informationen zur Verwendung von TLS finden Sie unter <bpt id="p1">[</bpt>lokaler Threadspeicher: threadbezogene statische Felder und Datenslots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The slot is allocated on all threads.</source>
          <target state="translated">Der Slot wird für alle Threads zugeordnet.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen von Daten Wert im Slot des Slots für die Wiederverwendung freizugeben, nach Ablauf des Threads.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Datenslots sind pro Thread eindeutig.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>This section contains two code examples.</source>
          <target state="translated">Dieser Abschnitt enthält zwei Codebeispiele.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut, um die Thread-spezifische Informationen zu halten.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Erste Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> , Thread-spezifische Informationen aufnimmt.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Zweite Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The following code example demonstrates how to use a data slot to store thread-specific information.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie auf einen Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The name of the data slot to be allocated.</source>
          <target state="translated">Der Name des zu reservierenden Datenslots.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Allocates a named data slot on all threads.</source>
          <target state="translated">Reserviert einen benannten Datenslot für alle Threads.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>-Attribut markiert sind.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">Der reservierte benannte Datenslot für alle Threads.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut) und Datenslots.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Weitere Informationen zur Verwendung von TLS finden Sie unter <bpt id="p1">[</bpt>lokaler Threadspeicher: threadbezogene statische Felder und Datenslots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen von Daten Wert im Slot des Slots für die Wiederverwendung freizugeben, nach Ablauf des Threads.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Datenslots sind pro Thread eindeutig.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>It is not necessary to use the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method to allocate a named data slot, because the <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> method allocates the slot if it has not already been allocated.</source>
          <target state="translated">Es ist nicht notwendig, verwenden Sie die <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> Methode, um einen benannten Datenslot reserviert werden, da die <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> -Methode den Slot zuweist, wenn er noch nicht zugeordnet wurde.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> Methode wird verwendet, es sollte im Hauptthread bei Programmstart aufgerufen werden, da es eine Ausnahme auslöst, wenn ein Slot mit dem angegebenen Namen bereits zugeordnet wurde.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>There is no way to test whether a slot has already been allocated.</source>
          <target state="translated">Es gibt keine Möglichkeit zum Überprüfen, ob ein Slot bereits zugeordnet wurde.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Slots allocated with this method must be freed with <ph id="ph1">&lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</ph>.</source>
          <target state="translated">Mit dieser Methode reservierten Slots müssen mit freigegeben werden <ph id="ph1">&lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>This section contains two code examples.</source>
          <target state="translated">Dieser Abschnitt enthält zwei Codebeispiele.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut, um die Thread-spezifische Informationen zu halten.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Erste Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> , Thread-spezifische Informationen aufnimmt.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Zweite Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie auf einen benannten Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The example code does not use the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method, because the <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> method allocates the slot if it has not already been allocated.</source>
          <target state="translated">Der Beispielcode verwendet nicht die <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> -Methode, da der <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> -Methode den Slot zuweist, wenn er noch nicht zugeordnet wurde.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method is used, it should be called in the main thread at program startup.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> Methode verwendet wird, sollte im Hauptthread beim Programmstart aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>A named data slot with the specified name already exists.</source>
          <target state="translated">Es ist bereits ein benannter Datenslot mit dem angegebenen Namen vorhanden.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ApartmentState">
          <source>Gets or sets the apartment state of this thread.</source>
          <target state="translated">Ruft den Apartmentzustand dieses Threads ab oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The initial value is <ph id="ph1">&lt;see langword="Unknown" /&gt;</ph>.</source>
          <target state="translated">Der Anfangswert ist <ph id="ph1">&lt;see langword="Unknown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source><bpt id="p1">**</bpt>The <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property is obsolete.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Die <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> Eigenschaft ist veraltet.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The non-obsolete alternatives are the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method to retrieve the apartment state and the   <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method to set the apartment state.</source>
          <target state="translated">Die nicht veraltete alternativen lauten die <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> Methode, um den Apartmentzustand abzurufen und die <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> Methode, um der Apartmentzustand festgelegt.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>In the .NET Framework versions 1.0 and 1.1, the <ph id="ph1">`ApartmentState`</ph> property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</source>
          <target state="translated">In der .NET Framework-Versionen 1.0 und 1.1 kann die <ph id="ph1">`ApartmentState`</ph> Eigenschaft kennzeichnet einen Thread, um anzugeben, dass er in einem Singlethread-Apartment oder einem Multithread-Apartment ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>This property can be set when the thread is in the <ph id="ph1">`Unstarted`</ph> or <ph id="ph2">`Running`</ph> thread state; however, it can be set only once for a thread.</source>
          <target state="translated">Diese Eigenschaft kann festgelegt werden, wenn der Thread die <ph id="ph1">`Unstarted`</ph> oder <ph id="ph2">`Running`</ph> Threadzustand befindet; allerdings es kann nur einmal festgelegt werden für einen Thread.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>If the property has not been set, it returns <ph id="ph1">`Unknown`</ph>.</source>
          <target state="translated">Wenn die Eigenschaft nicht festgelegt wurde, gibt es <ph id="ph1">`Unknown`</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>An attempt to use the <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property to set the apartment state of a thread whose apartment state has already been set is ignored.</source>
          <target state="translated">Versuch, verwenden die <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> Eigenschaft, um den Apartmentzustand eines Threads festzulegen, dessen Apartmentzustand bereits festgelegt wurde wurde, wird ignoriert.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>However, the <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> in this case.</source>
          <target state="translated">Allerdings die <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> -Methode löst eine <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> in diesem Fall.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>In the .NET Framework version 2.0, new threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> if their apartment state has not been set before they are started.</source>
          <target state="translated">In .NET Framework, Version 2.0, werden neue Threads als initialisiert <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> Wenn ihre Apartmentzustand nicht festgelegt wurde, bevor sie gestartet wurden.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> by default.</source>
          <target state="translated">Thread der hauptanwendung wird initialisiert, um <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> standardmäßig.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>You can no longer set the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> by setting the <ph id="ph2">&lt;xref:System.Threading.ApartmentState?displayProperty=nameWithType&gt;</ph> property on the first line of code.</source>
          <target state="translated">Thread der hauptanwendung können nicht mehr festgelegt werden, um <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> durch Festlegen der <ph id="ph2">&lt;xref:System.Threading.ApartmentState?displayProperty=nameWithType&gt;</ph> Eigenschaft auf die erste Zeile des Codes.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>Use the <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph> instead.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph> stattdessen.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)</ept> linker option.</source>
          <target state="translated">In .NET Framework, Version 2.0, können Sie angeben, die COM-Threadingmodell für eine C++-Anwendung mithilfe der <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (festlegen CLR-Thread-Attribut)<ept id="p1">](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)</ept> (Linkeroption).</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The following code example demonstrates how to set the apartment state of a thread.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie den Apartmentzustand eines Threads fest.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ApartmentState">
          <source>An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<ph id="ph1">&lt;see langword="STA" /&gt;</ph>) or multithreaded apartment (<ph id="ph2">&lt;see langword="MTA" /&gt;</ph>)).</source>
          <target state="translated">Es wird versucht, diese Eigenschaft in einen Zustand zu versetzen, der kein gültiger Apartmentzustand ist, d. h. in einen anderen Zustand als Singlethread-Apartment (<ph id="ph1">&lt;see langword="STA" /&gt;</ph>) oder Multithread-Apartment (<ph id="ph2">&lt;see langword="MTA" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</source>
          <target state="translated">Benachrichtigt einen Host, dass die Ausführung im Begriff ist, zu einem Codebereich überzugehen, in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme andere Aufgaben in der Anwendungsdomäne gefährden könnten.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Hosts, der die common Language Runtime (CLR), z. B. Microsoft SQL Server 2005 können unterschiedliche Richtlinien für Fehler in kritischen und nicht kritischen Bereiche des Codes eingerichtet.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Ein kritischen Bereich ist in dem die Auswirkungen eines Threadabbruchs oder einer unbehandelten Ausnahme möglicherweise nicht auf die aktuelle Aufgabe beschränkt werden.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Im Gegensatz dazu, wirkt sich auf einen Abbruch oder ein Fehler in einem unkritische Codebereich nur auf den Task, in dem der Fehler auftritt.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Betrachten Sie beispielsweise eine Aufgabe, die versucht, die beim Sperren Arbeitsspeicher belegt werden.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Wenn die speicherbelegung fehlschlägt, Abbrechen der aktuellen Aufgabe ist nicht ausreichend, um die Stabilität des gewährleisten die <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, da möglicherweise andere Aufgaben in der Domäne, die die gleiche Sperre warten.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Wenn die aktuelle Aufgabe beendet wird, können andere Tasks blockiert.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">Tritt ein Fehler in einer kritischen Bereichs, kann der Host die gesamte entladen <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> statt nehmen das Risiko, dass das Fortsetzen der Ausführung in einem potenziell instabilen Zustand.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>To inform the host that your code is entering a critical region, call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</source>
          <target state="translated">Aufrufen, um dem Host darüber zu informieren, dass Code in einen kritischen Bereich eintritt, <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> when execution returns to a non-critical region of code.</source>
          <target state="translated">Rufen Sie <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> Ausführung in einem unkritische Codebereich zurück.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Verwenden diese Methode im Code, die unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> methods to divide a block of code into critical and non-critical regions.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> Methoden, um einen Codeblock in kritische und nicht kritische Bereiche zu unterteilen.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Benachrichtigt einen Host, dass verwalteter Code im Begriff ist, Anweisungen auszuführen, die von der Identität des aktuellen physischen Betriebssystemthreads abhängen.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Einige Hosts von der common Language Runtime, z. B. Microsoft SQL Server 2005, geben Sie ihre eigenen Threadverwaltung.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Ein Host, der eine eigene Threadverwaltung bereitstellt, kann eine derzeit ausgeführte Aufgabe jederzeit von einem physischen Betriebssystemthreads in eine andere verschieben.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">Die meisten Aufgaben sind von diesem Wechsel nicht betroffen.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">Jedoch einige Aufgaben Threadaffinität - d. h., sie von der Identität des physischen Betriebssystemthreads abhängig sind.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Diese Aufgaben müssen den Host informieren, wenn sie Code ausführen, der nicht umgeschaltet werden soll.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> before acquiring the lock, and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> after releasing the lock.</source>
          <target state="translated">Sie müssen z. B., wenn Ihre Anwendung ein System-API aufruft, erwerben Sie ein älteres Betriebssystem sperren, die Threadaffinität, z. B. eine Win32-CRITICAL_SECTION Aufrufen <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> vor dem Abrufen der Sperre und <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> nach der Freigabe der Sperre.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Verwenden diese Methode im Code, die unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> Methoden, um einen Host zu benachrichtigen, die ein Codeblock auf die Identität des physischen Betriebssystemthreads abhängen.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentContext">
          <source>Gets the current context in which the thread is executing.</source>
          <target state="translated">Ruft den aktuellen Kontext ab, in dem der Thread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Contexts.Context" /&gt;</ph> representing the current thread context.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Contexts.Context" /&gt;</ph> der den aktuellen Kontext des Threads darstellt.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentContext">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentContext">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentContext">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Gets or sets the culture for the current thread.</source>
          <target state="translated">Ruft die Kultur für den aktuellen Thread ab oder legt diese fest.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>An object that represents the culture for the current thread.</source>
          <target state="translated">Ein Objekt, das die Kultur für den aktuellen Thread darstellt.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> -Objekt, das von dieser Eigenschaft zusammen mit der ihr zugeordneten Objekte zurückgegeben wird, bestimmen das Standardformat für Datumsangaben, Uhrzeiten, Zahlen, Currency-Werte, die Sortierreihenfolge des Texts, Groß-/ Kleinschreibungskonventionen und Zeichenfolgenvergleiche.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> Klasse, um weitere Informationen zu Kulturnamen und Bezeichnern, die Unterschiede zwischen invariante, neutrale und spezifische Kulturen und die Möglichkeit kulturinformationen wirkt sich auf Threads und Anwendungsdomänen.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um zu erfahren, wie die Standardkultur des Threads bestimmt wird, und wie Benutzer die kulturinformationen für ihre Computer festlegen.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, you can set the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property to a neutral culture.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, Sie können festlegen, die <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> Eigenschaft, um eine neutrale Kultur.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>This is because the behavior of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class has changed: When it represents a neutral culture, its property values (in particular, the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;</ph>, and <ph id="ph6">&lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;</ph> properties) now reflect the specific culture that is associated with the neutral culture.</source>
          <target state="translated">Grund hierfür ist das Verhalten von der <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> Klasse hat sich geändert: Wenn es eine neutrale Kultur, die Eigenschaftswerte darstellt (insbesondere der <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;</ph>, und <ph id="ph6">&lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;</ph> Eigenschaften) jetzt wider, die bestimmte Kultur, die die neutrale Kultur zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>In earlier versions of the .NET Framework, the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property threw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> exception when a neutral culture was assigned.</source>
          <target state="translated">In früheren Versionen von .NET Framework die <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> Eigenschaft ausgelöst hat eine <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> -Ausnahme aus, wenn eine neutrale Kultur zugewiesen wurde.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</source>
          <target state="translated">Das folgende Codebeispiel zeigt die threading-Anweisung, die ermöglicht der Benutzeroberfläche von Windows Forms in der Kultur angezeigt, die in der Systemsteuerung festgelegt ist.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Additional code is needed.</source>
          <target state="translated">Es ist kein zusätzlicher Code erforderlich.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentCulture">
          <source>The property is set to <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die Eigenschaft ist auf <ph id="ph1">&lt;see langword="null" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>for setting the property.</source>
          <target state="translated">für die Eigenschaft festlegen.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>Gets or sets the thread's current principal (for role-based security).</source>
          <target state="translated">Ruft den aktuellen Prinzipal des Threads (für rollenbasierte Sicherheit) ab oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.Principal.IPrincipal" /&gt;</ph> value representing the security context.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Security.Principal.IPrincipal" /&gt;</ph>-Wert, der den Sicherheitskontext darstellt.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>The following code example shows how to set and retrieve the principal of a thread.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht das Festlegen und Abrufen des Prinzipals eines Threads.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>The caller does not have the permission required to set the principal.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderliche Berechtigung zum Festlegen des Prinzipals.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>to manipulate the principal object.</source>
          <target state="translated">Bearbeiten Sie das principal-Objekt.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentThread">
          <source>Gets the currently running thread.</source>
          <target state="translated">Ruft den derzeit ausgeführten Thread ab.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> that is the representation of the currently running thread.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>, der den derzeit ausgeführten Thread darstellt.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>The following example creates a task that in turn creates 20 child tasks.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Aufgabe, die wiederum 20 untergeordneten Aufgaben erstellt.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>The application itself, as well as each task, calls the <ph id="ph1">`ShowThreadInformation`</ph> method, which uses the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> property  to display information about the thread on which it is running.</source>
          <target state="translated">Ruft die Anwendung selbst, als auch jede Aufgabe, die <ph id="ph1">`ShowThreadInformation`</ph> Methode, die verwendet die <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> Eigenschaft, um Informationen zum Thread anzuzeigen, auf dem er ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</source>
          <target state="translated">Jede untergeordnete Aufgabe 1 Million Zufallszahlen zwischen 1 und 1 Million generiert und gibt zurück, deren Mittelwert.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>The parent task calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</source>
          <target state="translated">Die Aufrufe der übergeordneten Aufgabe der <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> Methode, um sicherzustellen, dass die untergeordneten Aufgaben abgeschlossen haben, ehe den Mittelwert zurückgegeben, die für jede Aufgabe und das Berechnen der Mittelwert der bedeutet.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</source>
          <target state="translated">Beachten Sie, dass während die Anwendung auf einen Vordergrundthread ausgeführt wird, jede Aufgabe in einem Threadpoolthread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</source>
          <target state="translated">Ruft die aktuelle Kultur ab, mit deren Hilfe der Ressourcen-Manager zur Laufzeit kulturabhängige Ressourcen sucht, oder legt diese fest.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>An object that represents the current culture.</source>
          <target state="translated">Ein Objekt, das die aktuelle Kultur darstellt.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</source>
          <target state="translated">Die Benutzeroberflächenkultur gibt die Ressourcen, die eine Anwendung muss Benutzer ein- und Ausgaben unterstützen, die und in der Standardeinstellung ist identisch mit dem Betriebssystem-Kultur, an.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> Klasse, um weitere Informationen zu Kulturnamen und Bezeichnern, die Unterschiede zwischen invariante, neutrale und spezifische Kulturen und die Möglichkeit kulturinformationen wirkt sich auf Threads und Anwendungsdomänen.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> property to learn how a thread's default UI culture is determined.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um zu erfahren, wie die Standard-UI-Kultur des Threads bestimmt wird.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> returned by this property can be a neutral culture.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> von dieser Eigenschaft zurückgegebene kann eine neutrale Kultur.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Neutral cultures should not be used with formatting methods such as <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Neutrale Kulturen sollte nicht verwendet werden, z. B. Formatierungsmethoden <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> method to get a specific culture, or use the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property.</source>
          <target state="translated">Verwenden Sie die <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> Methode, um eine bestimmte Kultur abrufen oder verwenden Sie die <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> method throws <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> -Methode löst <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> für die neutralen Kulturen "Zh-Hant" ("Zh-CHT") und "Zh-Hans" ("Zh-CHS").</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The following example determines whether the language of the current thread's UI culture is French.</source>
          <target state="translated">Im folgenden Beispiel wird bestimmt, ob die Sprache des UI-Kultur des aktuellen Threads Französisch.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>If it is not, it sets the UI culture of the current thread to English (United States).</source>
          <target state="translated">Wenn sie nicht der Fall ist, wird der UI-Kultur des aktuellen Threads auf Englisch (Vereinigte Staaten) festgelegt.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</source>
          <target state="translated">Das folgende Codebeispiel zeigt die threading-Anweisung, die ermöglicht der Benutzeroberfläche von Windows Forms in der Kultur angezeigt, die in der Systemsteuerung festgelegt ist.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Additional code is needed.</source>
          <target state="translated">Es ist kein zusätzlicher Code erforderlich.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The property is set to <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die Eigenschaft ist auf <ph id="ph1">&lt;see langword="null" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The property is set to a culture name that cannot be used to locate a resource file.</source>
          <target state="translated">Die Eigenschaft ist auf einen Kulturnamen festgelegt, der nicht zum Suchen einer Ressourcendatei verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Resource filenames must include only letters, numbers, hyphens or underscores.</source>
          <target state="translated">Ressourcendateinamen dürfen nur Buchstaben, Zahlen, Bindestriche oder Unterstriche enthalten.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</source>
          <target state="translated">Deaktiviert die automatische Bereinigung von Runtime Callable Wrappern (RCW) für den aktuellen Thread.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</source>
          <target state="translated">Standardmäßig bereinigt die common Language Runtime (CLR) Runtime callable Wrappern automatisch.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</source>
          <target state="translated">Die CLR Pumps Nachrichten während der Bereinigung aus, die für einige Anwendungen Reentranz-Probleme verursachen können, die die folgenden ungewöhnlichen Kriterien erfüllen:</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>The application does its own message pumping.</source>
          <target state="translated">Die Anwendung führt einen eigenen meldungsweiterleitung.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>The application needs to control precisely when message pumping occurs.</source>
          <target state="translated">Die Anwendung muss genau, wann meldungsweiterleitung tritt auf, zu steuern.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Such applications can use the <ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A&gt;</ph> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</source>
          <target state="translated">Solche Anwendungen können die <ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A&gt;</ph> Methode, um zu verhindern, dass die CLR auf diese Weise Automatische Freigabe von Runtime callable Wrapper.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</source>
          <target state="translated">Beim Aufrufen dieser Methode in einem Thread darf nicht die automatische Bereinigung aktiviert werden, damit diesem Thread sein.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>When your application is ready to clean up runtime callable wrappers, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType&gt;</ph> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</source>
          <target state="translated">Wenn Ihre Anwendung zum Bereinigen von Runtime callable Wrapper bereit ist, verwenden die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType&gt;</ph> Methode, um die Laufzeitkomponente anzuweisen, bereinigen alle Runtime callable Wrapper im aktuellen Kontext.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Message pumping occurs while the method executes.</source>
          <target state="translated">Meldungsweiterleitung tritt auf, während die Methode ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</source>
          <target state="translated">Benachrichtigt einen Host, dass die Ausführung im Begriff ist, zu einem Codebereich überzugehen, in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme auf die aktuelle Aufgabe beschränkt sind.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Hosts, der die common Language Runtime (CLR), z. B. Microsoft SQL Server 2005 können unterschiedliche Richtlinien für Fehler in kritischen und nicht kritischen Bereiche des Codes eingerichtet.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Ein kritischen Bereich ist in dem die Auswirkungen eines Threadabbruchs oder einer unbehandelten Ausnahme möglicherweise nicht auf die aktuelle Aufgabe beschränkt werden.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Im Gegensatz dazu, wirkt sich auf einen Abbruch oder ein Fehler in einem unkritische Codebereich nur auf den Task, in dem der Fehler auftritt.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Betrachten Sie beispielsweise eine Aufgabe, die versucht, die beim Sperren Arbeitsspeicher belegt werden.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Wenn die speicherbelegung fehlschlägt, Abbrechen der aktuellen Aufgabe ist nicht ausreichend, um die Stabilität des gewährleisten die <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, da möglicherweise andere Aufgaben in der Domäne, die die gleiche Sperre warten.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Wenn die aktuelle Aufgabe beendet wird, können andere Tasks blockiert.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">Tritt ein Fehler in einer kritischen Bereichs, kann der Host die gesamte entladen <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> statt nehmen das Risiko, dass das Fortsetzen der Ausführung in einem potenziell instabilen Zustand.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>To inform the host that your code is entering a critical region, call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</source>
          <target state="translated">Aufrufen, um dem Host darüber zu informieren, dass Code in einen kritischen Bereich eintritt, <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> when execution returns to a non-critical region of code.</source>
          <target state="translated">Rufen Sie <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> Ausführung in einem unkritische Codebereich zurück.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Verwenden diese Methode im Code, die unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> methods to divide a block of code into critical and non-critical regions.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> Methoden, um einen Codeblock in kritische und nicht kritische Bereiche zu unterteilen.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Benachrichtigt einen Host, dass verwalteter Code die Ausführung von Anweisungen beendet hat, die von der Identität des aktuellen physischen Betriebssystemthreads abhängen.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Einige Hosts von der common Language Runtime, z. B. Microsoft SQL Server 2005, geben Sie ihre eigenen Threadverwaltung.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Ein Host, der eine eigene Threadverwaltung bereitstellt, kann eine derzeit ausgeführte Aufgabe jederzeit von einem physischen Betriebssystemthreads in eine andere verschieben.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">Die meisten Aufgaben sind von diesem Wechsel nicht betroffen.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">Jedoch einige Aufgaben Threadaffinität - d. h., sie von der Identität des physischen Betriebssystemthreads abhängig sind.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Diese Aufgaben müssen den Host informieren, wenn sie Code ausführen, der nicht umgeschaltet werden soll.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> before acquiring the lock, and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> after releasing the lock.</source>
          <target state="translated">Sie müssen z. B., wenn Ihre Anwendung ein System-API aufruft, erwerben Sie ein älteres Betriebssystem sperren, die Threadaffinität, z. B. eine Win32-CRITICAL_SECTION Aufrufen <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> vor dem Abrufen der Sperre und <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> nach der Freigabe der Sperre.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Verwenden diese Methode im Code, die unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> Methoden, um einen Host zu benachrichtigen, die ein Codeblock auf die Identität des physischen Betriebssystemthreads abhängen.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ExecutionContext">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph> object that contains information about the various contexts of the current thread.</source>
          <target state="translated">Ruft ein <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph>-Objekt ab, das Informationen zu den verschiedenen Kontexten des aktuellen Threads enthält.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ExecutionContext">
          <source>An <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph> object that consolidates context information for the current thread.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph>-Objekt, das Kontextinformationen für den aktuellen Thread konsolidiert.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ExecutionContext">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ExecutionContext&gt;</ph> class provides a single container for all information relevant to a logical thread of execution.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.ExecutionContext&gt;</ph> Klasse stellt einen einzelnen Container für alle Informationen über einen logischen Thread der Ausführung.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ExecutionContext">
          <source>This includes security context, call context, synchronization context, localization context, and transaction context.</source>
          <target state="translated">Dies schließt Sicherheitskontext, Aufrufkontext, Synchronisierungskontext, Lokalisierungskontext und bereits verwendeten Transaktionskontext.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Finalize">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> object.</source>
          <target state="translated">Stellt das Freigeben von Ressourcen und das Ausführen anderer Garbage Collector-Vorgänge sicher, wenn der Garbage Collector das <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>-Objekt verarbeitet.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Finalize">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Threading.Thread.Finalize%2A&gt;</ph> when the current object is ready to be finalized.</source>
          <target state="translated">Der Garbage Collector ruft <ph id="ph1">&lt;xref:System.Threading.Thread.Finalize%2A&gt;</ph> Wenn das aktuelle Objekt wird finalisiert werden.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The name of the data slot to be freed.</source>
          <target state="translated">Der Name des freizugebenden Datenslots.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Eliminates the association between a name and a slot, for all threads in the process.</source>
          <target state="translated">Entfernt die Zuordnung zwischen einem Namen und einem Slot für alle Threads in dem Prozess.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>-Attribut markiert sind.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut) und Datenslots.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Weitere Informationen zur Verwendung von TLS finden Sie unter <bpt id="p1">[</bpt>lokaler Threadspeicher: threadbezogene statische Felder und Datenslots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>After any thread calls <ph id="ph1">`FreeNamedDataSlot`</ph>, any other thread that calls <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> with the same name will allocate a new slot associated with the name.</source>
          <target state="translated">Nach dem Aufrufen <ph id="ph1">`FreeNamedDataSlot`</ph>, eines anderen Threads, die Aufrufe <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> mit dem gleichen Namen wird einen neuen Slot verknüpft sind, mit dem Namen zuweisen.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Subsequent calls to <ph id="ph1">`GetNamedDataSlot`</ph> by any thread will return the new slot.</source>
          <target state="translated">Nachfolgende Aufrufe <ph id="ph1">`GetNamedDataSlot`</ph> durch einen beliebigen Thread des neuen Slots zurück.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>However, any thread that still has a <ph id="ph1">&lt;xref:System.LocalDataStoreSlot?displayProperty=nameWithType&gt;</ph> returned by an earlier call to <ph id="ph2">`GetNamedDataSlot`</ph> can continue to use the old slot.</source>
          <target state="translated">Jedoch einen beliebigen Thread, die immer noch eine <ph id="ph1">&lt;xref:System.LocalDataStoreSlot?displayProperty=nameWithType&gt;</ph> durch einen früheren Aufruf zurückgegebene <ph id="ph2">`GetNamedDataSlot`</ph> können weiterhin den alten Slot verwenden.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>A slot that has been associated with a name is released only when every <ph id="ph1">`LocalDataStoreSlot`</ph> that was obtained prior to the call to <ph id="ph2">`FreeNamedDataSlot`</ph> has been released and garbage-collected.</source>
          <target state="translated">Ein Slot, die mit einem Namen zugeordnet wurde freigegeben ist nur, wenn alle <ph id="ph1">`LocalDataStoreSlot`</ph> , die vor dem Aufruf von abgerufen wurde <ph id="ph2">`FreeNamedDataSlot`</ph> freigegeben und Garbage Collection durchgeführt wurde.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen von Daten Wert im Slot des Slots für die Wiederverwendung freizugeben, nach Ablauf des Threads.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Datenslots sind pro Thread eindeutig.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>This section contains two code examples.</source>
          <target state="translated">Dieser Abschnitt enthält zwei Codebeispiele.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut, um die Thread-spezifische Informationen zu halten.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Erste Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> , Thread-spezifische Informationen aufnimmt.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Zweite Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie auf einen benannten Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetApartmentState">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> value indicating the apartment state.</source>
          <target state="translated">Gibt einen <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph>-Wert zurück, der den Apartmentzustand angibt.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetApartmentState">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> values indicating the apartment state of the managed thread.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph>-Werte, der den Apartmentzustand des verwalteten Threads angibt.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The default is <ph id="ph1">&lt;see cref="F:System.Threading.ApartmentState.Unknown" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see cref="F:System.Threading.ApartmentState.Unknown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>This method, along with the <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph3">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
          <target state="translated">Diese Methode zusammen mit der <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> Methode und die <ph id="ph2">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> Methode ersetzt die <ph id="ph3">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> methods.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The code example creates a thread.</source>
          <target state="translated">Das Codebeispiel erstellt einen Thread.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>Before the thread is started, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> displays the initial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> state and <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> changes the state to <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Bevor der Thread gestartet wird, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> zeigt den ersten <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> Zustand und <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> ändert den Zustand in <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method then returns <ph id="ph2">`false`</ph> when attempting to change the state to <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> because the apartment state is already set.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> dann Methodenrückgabe <ph id="ph2">`false`</ph> beim Versuch, den Status zu ändern <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> da bereits der Apartmentzustand festgelegt ist.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>If the same operation had been attempted with <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> would have been thrown.</source>
          <target state="translated">Mit der gleiche Vorgang versucht wurde, hatte <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> würde ausgelöst wurden.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>After the thread is started, the <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method is used again.</source>
          <target state="translated">Nachdem der Thread gestartet wird, die <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> Methode erneut verwendet wird.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>This time it throws <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> because the thread has already been started.</source>
          <target state="translated">Sie löst dieses Mal <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> , weil der Thread bereits gestartet wurde.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> object that can be used to capture the stack for the current thread.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph>-Objekt zurück, mit dem der Stapel für den aktuellen Thread erfasst werden kann.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>None.</source>
          <target state="translated">Keine</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>This method is no longer supported.</source>
          <target state="translated">Diese Methode wird nicht mehr unterstützt.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>In all cases.</source>
          <target state="translated">In allen Fällen.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> from which to get the value.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph>, aus dem der Wert abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</source>
          <target state="translated">Ruft in der aktuellen Domäne des aktuellen Threads den Wert aus dem angegebenen Slot für den aktuellen Thread ab.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>-Attribut markiert sind.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The retrieved value.</source>
          <target state="translated">Der abgerufene Wert.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut) und Datenslots.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Weitere Informationen zur Verwendung von TLS finden Sie unter <bpt id="p1">[</bpt>lokaler Threadspeicher: threadbezogene statische Felder und Datenslots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen von Daten Wert im Slot des Slots für die Wiederverwendung freizugeben, nach Ablauf des Threads.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Datenslots sind pro Thread eindeutig.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.GetData%2A&gt;</ph> is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.GetData%2A&gt;</ph> ist eine <ph id="ph2">`Shared`</ph> Methode, die immer auf den gerade ausgeführten Thread angewendet wird, auch wenn Sie mit einer Variablen, die auf einem anderen Thread aufgerufen.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</source>
          <target state="translated">Um Verwirrung zu vermeiden, verwenden Sie den Klassennamen beim Aufrufen von <ph id="ph1">`Shared`</ph> Methoden: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>This section contains two code examples.</source>
          <target state="translated">Dieser Abschnitt enthält zwei Codebeispiele.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut, um die Thread-spezifische Informationen zu halten.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Erste Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> , Thread-spezifische Informationen aufnimmt.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Zweite Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The following example demonstrates how to use a data slot to store thread-specific information.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht einen Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomain">
          <source>Returns the current domain in which the current thread is running.</source>
          <target state="translated">Gibt die aktuelle Domäne zurück, in der der aktuelle Thread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomain">
          <source>An <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> representing the current application domain of the running thread.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph>, die die aktuelle Anwendungsdomäne des ausgeführten Threads darstellt.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetDomain">
          <source>The following code example shows how to retrieve the name and ID of the <ph id="ph1">`AppDomain`</ph> in which the thread is running.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie die Namen und die ID des abzurufenden der <ph id="ph1">`AppDomain`</ph> in der der Thread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomainID">
          <source>Returns a unique application domain identifier.</source>
          <target state="translated">Gibt einen eindeutigen Bezeichner der Anwendungsdomäne zurück.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomainID">
          <source>A 32-bit signed integer uniquely identifying the application domain.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, mit der die Anwendungsdomäne eindeutig bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetDomainID">
          <source>The following code example shows how to retrieve the name and ID of the <ph id="ph1">`AppDomain`</ph> in which the thread is running.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie die Namen und die ID des abzurufenden der <ph id="ph1">`AppDomain`</ph> in der der Thread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetHashCode">
          <source>Returns a hash code for the current thread.</source>
          <target state="translated">Gibt einen Hashcode für den aktuellen Thread zurück.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetHashCode">
          <source>An integer hash code value.</source>
          <target state="translated">Ein ganzzahliger Hashcodewert.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetHashCode">
          <source>The hash code is not guaranteed to be unique.</source>
          <target state="translated">Der Hashcode ist nicht unbedingt eindeutig sein.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetHashCode">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property if you need a unique identifier for a managed thread.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> Eigenschaft, wenn Sie einen eindeutigen Bezeichner für einen verwalteten Thread benötigen.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The name of the local data slot.</source>
          <target state="translated">Der Name des lokalen Datenslots.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Looks up a named data slot.</source>
          <target state="translated">Sucht einen benannten Datenslot.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>-Attribut markiert sind.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> allocated for this thread.</source>
          <target state="translated">Ein für diesen Thread reservierter <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut) und Datenslots.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Weitere Informationen zur Verwendung von TLS finden Sie unter <bpt id="p1">[</bpt>lokaler Threadspeicher: threadbezogene statische Felder und Datenslots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen von Daten Wert im Slot des Slots für die Wiederverwendung freizugeben, nach Ablauf des Threads.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Datenslots sind pro Thread eindeutig.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>If the named slot does not exist, a new slot is allocated.</source>
          <target state="translated">Wenn der benannte Datenslot nicht vorhanden ist, wird ein neuer Slot zugeordnet.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Named data slots are public and can be manipulated by anyone.</source>
          <target state="translated">Benannte Datenslots sind öffentlich und können von einem Benutzer bearbeitet werden.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>This section contains two code examples.</source>
          <target state="translated">Dieser Abschnitt enthält zwei Codebeispiele.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut, um die Thread-spezifische Informationen zu halten.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Erste Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> , Thread-spezifische Informationen aufnimmt.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Zweite Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie auf einen benannten Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Interrupt">
          <source>Interrupts a thread that is in the <ph id="ph1">&lt;see langword="WaitSleepJoin" /&gt;</ph> thread state.</source>
          <target state="translated">Unterbricht einen Thread, der sich im <ph id="ph1">&lt;see langword="WaitSleepJoin" /&gt;</ph>-Threadzustand befindet.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</source>
          <target state="translated">Dieser Thread in einer warten, Standby- oder Verknüpfungszustand derzeit nicht gesperrt ist, ist unterbrochen, bei Beginn des nächsten blockiert.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source><ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> is thrown in the interrupted thread, but not until the thread blocks.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> in den unterbrochenen THEAD, jedoch erst, nachdem der Thread blockiert wird ausgelöst werden.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</source>
          <target state="translated">Wenn der Thread nie blockiert wird, die Ausnahme wird nie ausgelöst und daher kann der Thread ohne jegliche Unterbrechung wird abgeschlossen.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Verhalten der einen laufenden Thread auf, wenn er unterbrochen und anschließend gesperrt wird.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Interrupt">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderliche <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>for advanced operations on threads.</source>
          <target state="translated">für erweiterte Vorgänge für Threads.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsAlive">
          <source>Gets a value indicating the execution status of the current thread.</source>
          <target state="translated">Ruft einen Wert ab, der den Ausführungsstatus des aktuellen Threads angibt.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsAlive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this thread has been started and has not terminated normally or aborted; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn dieser Thread gestartet und ordnungsgemäß beendet bzw. abgebrochen wurde, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsBackground">
          <source>Gets or sets a value indicating whether or not a thread is a background thread.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob es sich bei einem Thread um einen Hintergrundthread handelt, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this thread is or is to become a background thread; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn dieser Thread ein Hintergrundthread ist oder zu einem solchen wird, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>A thread is either a background thread or a foreground thread.</source>
          <target state="translated">Ein Thread ist ein Hintergrundthread oder ein Vordergrundthread.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</source>
          <target state="translated">Hintergrundthreads sind mit Vordergrundthreads identisch, außer dass Hintergrundthreads verhindert nicht, einen Prozess beendet ist.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</source>
          <target state="translated">Sobald alle zu einem Prozess gehörenden Vordergrundthreads beendet wurden, beendet die common Language Runtime den Prozess an.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Any remaining background threads are stopped and do not complete.</source>
          <target state="translated">Alle verbleibenden Hintergrundthreads werden beendet und nicht abgeschlossen.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>By default, the following threads execute in the foreground (that is, their <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>):</source>
          <target state="translated">Wird standardmäßig die folgenden Threads, die im Vordergrund ausgeführt (d. h. deren <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`false`</ph>):</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>The primary thread (or main application thread).</source>
          <target state="translated">Der primäre Thread (oder den Hauptthread der Anwendung).</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>All threads created by calling a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class constructor.</source>
          <target state="translated">Alle Threads durch Aufruf erstellt einen <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> Klassenkonstruktor.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>By default, the following threads execute in the background  (that is, their <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>):</source>
          <target state="translated">Standardmäßig werden die folgenden Threads im Hintergrund ausgeführt (d. h. ihre <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`true`</ph>):</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">Der Thread im Threadpool, die einen Pool von Arbeitsthreads, die von der Laufzeit verwaltet werden.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class.</source>
          <target state="translated">Sie können die Thread-Pool und den Zeitplan Arbeit auf Threads im Threadpool konfigurieren, mit der <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">Aufgabenbasierte asynchrone Vorgänge werden automatisch auf Threads im Threadpool ausgeführt.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">Alle Threads, die die verwaltete ausführungsumgebung von nicht verwaltetem Code eingeben.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>The following example contrasts the behavior of foreground and background threads.</source>
          <target state="translated">Im folgende Beispiel werden die Unterschiede zwischen des Verhaltens von Vordergrund-und Hintergrundthreads.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>It creates a foreground thread and a background thread.</source>
          <target state="translated">Erstellt einen Vordergrundthread und einen Hintergrundthread weitergeben.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>The foreground thread keeps the process running until completes its <ph id="ph1">`for`</ph> loop and terminates.</source>
          <target state="translated">Der Vordergrundthread erhält den Prozess ausgeführt wird, bis Abschluss seine <ph id="ph1">`for`</ph> Schleife und beendet.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</source>
          <target state="translated">Jedoch, wie die Ausgabe des Beispiels zeigt, da der Vordergrundthread Ausführung abgeschlossen ist, wird der Prozess beendet, bevor der Hintergrundthread Ausführung abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsBackground">
          <source>The thread is dead.</source>
          <target state="translated">Der Thread ist deaktiviert.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source>Gets a value indicating whether or not a thread belongs to the managed thread pool.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob ein Thread zu dem verwalteten Threadpool gehört.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this thread belongs to the managed thread pool; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Thread zu dem verwalteten Threadpool gehört, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source>For more information see <bpt id="p1">[</bpt>The Managed Thread Pool<ept id="p1">](~/docs/standard/threading/the-managed-thread-pool.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>die verwalteter Thread Pool<ept id="p1">](~/docs/standard/threading/the-managed-thread-pool.md)</ept>.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source>The following code example shows how to determine whether a thread is from the thread pool.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zu bestimmen, ob ein Thread aus dem Threadpool ist.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Blocks the calling thread until the thread represented by this instance terminates.</source>
          <target state="translated">Blockiert den aufrufenden Thread, bis der durch diese Instanz dargestellte Thread beendet wird.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join">
          <source>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <ph id="ph1">&lt;see langword="SendMessage" /&gt;</ph> pumping.</source>
          <target state="translated">Blockiert den aufrufenden Thread, bis der durch diese Instanz dargestellte Thread beendet wird, während das Standard-COM- und das <ph id="ph1">&lt;see langword="SendMessage" /&gt;</ph>-Pumping fortgesetzt werden.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. der Thread, der die Methode aufruft) blockiert, bis der Thread, dessen <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> Methode wird aufgerufen, abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>Use this method to ensure that a thread has been terminated.</source>
          <target state="translated">Verwenden Sie diese Methode, um sicherzustellen, dass ein Thread beendet wurde.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>The caller will block indefinitely if the thread does not terminate.</source>
          <target state="translated">Der Aufrufer wird unendlich lang blockiert, wenn der Thread nicht beendet wird.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block until <ph id="ph5">`Thread2`</ph> has completed.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">`Thread1`</ph> thread Aufrufen der <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> Methode <ph id="ph3">`Thread2`</ph>, wodurch <ph id="ph4">`Thread1`</ph> zu blockieren, bis <ph id="ph5">`Thread2`</ph> wurde abgeschlossen.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
          <target state="translated">Wenn der Thread bereits beendet wurde <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> aufgerufen wird, gibt die Methode sofort zurück.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>You should never call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> object that represents the current thread from the current thread.</source>
          <target state="translated">Sie sollten niemals aufrufen, die <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> Objekt, das den aktuellen Thread aus dem aktuellen Thread darstellt.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>This causes your app to hang because the current thread waits upon itself indefinitely,</source>
          <target state="translated">Dies bewirkt, dass Ihre app nicht mehr reagiert, da der aktuelle Thread auf sich selbst unbegrenzt wartet,</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>This method changes the state of the calling thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Diese Methode ändert den Zustand des aufrufenden Threads enthalten <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> state.</source>
          <target state="translated">Sie können nicht aufgerufen werden <ph id="ph1">`Join`</ph> auf einen Thread, in dem <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> Zustand.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join">
          <source>The caller attempted to join a thread that is in the <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph> state.</source>
          <target state="translated">Der Aufrufer hat versucht, mit einem Thread zu verknüpfen, der den Zustand <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph> hat.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join">
          <source>The thread is interrupted while waiting.</source>
          <target state="translated">Der Thread wird beim Warten unterbrochen.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>The number of milliseconds to wait for the thread to terminate.</source>
          <target state="translated">Die Anzahl der Millisekunden, die auf das Beenden des Threads gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Blockiert den aufrufenden Thread, bis der von dieser Instanz dargestellte Thread beendet wird, oder die festgelegte Zeit verstreicht, während das Standard-COM- und das SendMessage-Pumping fortgesetzt werden.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the thread has terminated; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the thread has not terminated after the amount of time specified by the <ph id="ph3">&lt;paramref name="millisecondsTimeout" /&gt;</ph> parameter has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Thread beendet wurde. <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn der Thread nach Ablauf des vom <ph id="ph3">&lt;paramref name="millisecondsTimeout" /&gt;</ph>-Parameter angegebenen Zeitraums nicht beendet wurde.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.Int32%29&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.Int32%29&gt;</ph> ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. der Thread, der die Methode aufruft) blockiert, bis entweder der Thread, dessen <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> Methode wird aufgerufen, abgeschlossen wurde oder das Timeoutintervall abgelaufen.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block either until <ph id="ph5">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">`Thread1`</ph> thread Aufrufen der <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> Methode <ph id="ph3">`Thread2`</ph>, wodurch <ph id="ph4">`Thread1`</ph> entweder bis zum Blockieren <ph id="ph5">`Thread2`</ph> abgeschlossen wurde oder 2 Sekunden verstrichen sind.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> is specified for the <ph id="ph2">`millisecondsTimeout`</ph> parameter, this method behaves identically to the <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> method overload, except for the return value.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> wird angegeben, für die <ph id="ph2">`millisecondsTimeout`</ph> Parameter, diese Methode verhält sich genauso wie die <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> methodenüberladung, mit Ausnahme der Rückgabewert.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
          <target state="translated">Wenn der Thread bereits beendet wurde <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> aufgerufen wird, gibt die Methode sofort zurück.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>This method changes the state of the calling thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Diese Methode ändert den Zustand des aufrufenden Threads enthalten <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> state.</source>
          <target state="translated">Sie können nicht aufgerufen werden <ph id="ph1">`Join`</ph> auf einen Thread, in dem <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> Zustand.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in milliseconds.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> ist negativ und nicht gleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in Millisekunden.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>The thread has not been started.</source>
          <target state="translated">Der Thread wurde nicht gestartet.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> set to the amount of time to wait for the thread to terminate.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph>-Wert, der auf den Zeitraum festgelegt ist, während dessen auf das Beenden des Threads gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Blockiert den aufrufenden Thread, bis der von dieser Instanz dargestellte Thread beendet wird, oder die festgelegte Zeit verstreicht, während das Standard-COM- und das SendMessage-Pumping fortgesetzt werden.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the thread terminated; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the thread has not terminated after the amount of time specified by the <ph id="ph3">&lt;paramref name="timeout" /&gt;</ph> parameter has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Thread beendet wurde. <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn der Thread nach Ablauf des vom <ph id="ph3">&lt;paramref name="timeout" /&gt;</ph>-Parameter angegebenen Zeitraums nicht beendet wurde.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.TimeSpan%29&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.TimeSpan%29&gt;</ph> ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. der Thread, der die Methode aufruft) blockiert, bis entweder der Thread, dessen <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> Methode wird aufgerufen, abgeschlossen wurde oder das Timeoutintervall abgelaufen.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block either until <ph id="ph5">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">`Thread1`</ph> thread Aufrufen der <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> Methode <ph id="ph3">`Thread2`</ph>, wodurch <ph id="ph4">`Thread1`</ph> entweder bis zum Blockieren <ph id="ph5">`Thread2`</ph> abgeschlossen wurde oder 2 Sekunden verstrichen sind.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> is specified for <ph id="ph2">`timeout`</ph>, this method behaves identically to the <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> method overload, except for the return value.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> für angegeben <ph id="ph2">`timeout`</ph>, diese Methode verhält sich genauso wie die <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> methodenüberladung, mit Ausnahme der Rückgabewert.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
          <target state="translated">Wenn der Thread bereits beendet wurde <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> aufgerufen wird, gibt die Methode sofort zurück.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>This method changes the state of the current thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
          <target state="translated">Diese Methode ändert den Zustand des aktuellen Threads enthalten <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> state.</source>
          <target state="translated">Sie können nicht aufgerufen werden <ph id="ph1">`Join`</ph> auf einen Thread, in dem <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> Zustand.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>The following code example demonstrates how to use a <ph id="ph1">`TimeSpan`</ph> value with the <ph id="ph2">`Join`</ph> method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie eine <ph id="ph1">`TimeSpan`</ph> Wert mit der <ph id="ph2">`Join`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in milliseconds, or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> ist negativ und nicht gleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in Millisekunden oder größer als <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> Millisekunden.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>The caller attempted to join a thread that is in the <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph> state.</source>
          <target state="translated">Der Aufrufer hat versucht, mit einem Thread zu verknüpfen, der den Zustand <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph> hat.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>Gets a unique identifier for the current managed thread.</source>
          <target state="translated">Ruft einen eindeutigen Bezeichner für den aktuellen verwalteten Thread ab.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>An integer that represents a unique identifier for this managed thread.</source>
          <target state="translated">Eine Ganzzahl, die einen eindeutigen Bezeichner für diesen verwalteten Thread darstellt.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>A thread's <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property value serves to uniquely identify that thread within its process.</source>
          <target state="translated">Eines Threads <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> Eigenschaftswert dient zur eindeutigen Identifizierung von diesem Thread in einem Prozess.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>The value of the <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</source>
          <target state="translated">Der Wert, der die <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> variiert Eigenschaft nicht im Laufe der Zeit, auch wenn nicht verwalteter Code, der die common Language Runtime hostet, den Thread als Fiber implementiert.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.MemoryBarrier">
          <source>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <ph id="ph1">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph> execute after memory accesses that follow the call to <ph id="ph2">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph>.</source>
          <target state="translated">Der Prozessor, der den aktuellen Thread ausführt, kann Anweisungen nicht so neu anordnen, dass Speicherzugriffe vor dem Aufruf von <ph id="ph1">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph> nach Speicherzugriffen ausgeführt werden, die nach dem Aufruf von <ph id="ph2">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph> erfolgen.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.MemoryBarrier">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.MemoryBarrier%2A&gt;</ph> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.MemoryBarrier%2A&gt;</ph> ist nur auf Systemen mit mehreren Prozessoren mit schwachen Sortierung (z. B. ein System mit mehreren Prozessoren der Intel Itanium) Arbeitsspeicher erforderlich.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.MemoryBarrier">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier ways to synchronize data.</source>
          <target state="translated">Für die Mehrzahl der Fälle, die C#- <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung oder der <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere Möglichkeiten zur Synchronisierung von Daten.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Name">
          <source>Gets or sets the name of the thread.</source>
          <target state="translated">Ruft den Namen des Threads ab oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>A string containing the name of the thread, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no name was set.</source>
          <target state="translated">Eine Zeichenfolge mit dem Namen des Threads, oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn kein Name festgelegt wurde.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>This property is write-once.</source>
          <target state="translated">Diese Eigenschaft ist für Write-sobald.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>Because the default value of a thread's <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> property is <ph id="ph2">`null`</ph>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Da der Standardwert eines Threads <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> Eigenschaft <ph id="ph2">`null`</ph>, können Sie bestimmen, ob ein Name bereits explizit an den Thread zugewiesen wurde durch einen Vergleich mit <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>The string assigned to the <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> property can include any Unicode character.</source>
          <target state="translated">Die zugewiesene Zeichenfolge die <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> -Eigenschaft kann beliebige Unicode-Zeichen enthalten.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>The following example shows how to name a thread.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie einen Thread zu benennen.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Name">
          <source>A set operation was requested, but the <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property has already been set.</source>
          <target state="translated">Ein SET-Vorgang wurde angefordert, aber die <ph id="ph1">&lt;see langword="Name" /&gt;</ph>-Eigenschaft wurde bereits festgelegt.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Priority">
          <source>Gets or sets a value indicating the scheduling priority of a thread.</source>
          <target state="translated">Ruft einen Wert ab, der die Planungspriorität eines Threads angibt, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.Threading.ThreadPriority.Normal" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see cref="F:System.Threading.ThreadPriority.Normal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>A thread can be assigned any one of the following priority <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> values:</source>
          <target state="translated">Ein Thread kann eines der folgenden Priorität zugewiesen werden <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> Werte:</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>Operating systems are not required to honor the priority of a thread.</source>
          <target state="translated">Betriebssysteme sind nicht erforderlich, die Priorität eines Threads beachten müssen.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>The following example shows the result of changing the priority of a thread.</source>
          <target state="translated">Das folgende Beispiel zeigt das Ergebnis einer Änderung der Priorität eines Threads.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>Three threads are created, the priority of one thread is set to <ph id="ph1">&lt;xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType&gt;</ph>, and the priority of a second is set to <ph id="ph2">&lt;xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Drei Threads erstellt, die Priorität eines Threads wird festgelegt, um <ph id="ph1">&lt;xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType&gt;</ph>, und die Priorität eines zweiten wird festgelegt, um <ph id="ph2">&lt;xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>Each thread increments a variable in a <ph id="ph1">`while`</ph> loop and runs for a set time.</source>
          <target state="translated">Jeder Thread inkrementiert den Wert einer Variablen in einem <ph id="ph1">`while`</ph> Schleife und Testläufe für einen festgelegten Zeitraum.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Priority">
          <source>The thread has reached a final state, such as <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Aborted" /&gt;</ph>.</source>
          <target state="translated">Der Thread hat einen Endzustand erreicht, z. B. <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Aborted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Priority">
          <source>The value specified for a set operation is not a valid <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph> value.</source>
          <target state="translated">Der für eine Set-Operation angegebene Wert ist kein gültiger <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source>Cancels an <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Abort(System.Object)" /&gt;</ph> requested for the current thread.</source>
          <target state="translated">Bricht ein <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Abort(System.Object)" /&gt;</ph> ab, das für den aktuellen Thread angefordert wurde.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>This method can only be called by code with the proper permissions.</source>
          <target state="translated">Diese Methode kann nur von Code mit den entsprechenden Berechtigungen aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>When a call is made to <ph id="ph1">`Abort`</ph> to terminate a thread, the system throws a <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph>.</source>
          <target state="translated">Wenn ein Aufruf ausgelöst wird, um <ph id="ph1">`Abort`</ph> um einen Thread zu beenden, löst das System eine <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless <ph id="ph2">`ResetAbort`</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph> ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, aber am Ende des Catch-Blocks erneut ausgelöst wird, wenn <ph id="ph2">`ResetAbort`</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph> Bricht die Anforderung zum Abbrechen und verhindert, dass die <ph id="ph2">`ThreadAbortException`</ph> aus Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>See <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> for an example that demonstrates calling the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Finden Sie unter <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> ein Beispiel für die Aufrufen der <ph id="ph2">`ResetAbort`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">Nur .NET Core: Dieser Member wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source><ph id="ph1">&lt;see langword="Abort" /&gt;</ph> was not invoked on the current thread.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Abort" /&gt;</ph> wurde für den aktuellen Thread nicht aufgerufen.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source>The caller does not have the required security permission for the current thread.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Sicherheitsberechtigungen für den aktuellen Thread.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>for advanced operations on threads.</source>
          <target state="translated">für erweiterte Vorgänge für Threads.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>Resumes a thread that has been suspended.</source>
          <target state="translated">Nimmt die Ausführung eines angehaltenen Threads wieder auf.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>Do not use the <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> methods to synchronize the activities of threads.</source>
          <target state="translated">Verwenden Sie nicht die <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> Methoden zum Synchronisieren der Aktivitäten von Threads.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">Sie haben keine Möglichkeit, zu wissen, welcher Code ein Thread ausgeführt wird, wenn Sie ihn anhalten.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> might be blocked.</source>
          <target state="translated">Wenn Sie einen Thread anhalten, während sie Sperren während der Auswertung von Sicherheitsberechtigungen enthält, andere threads in der <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> blockiert werden.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> that attempt to use that class are blocked.</source>
          <target state="translated">Wenn Sie einen Thread anhalten, während der Konstruktor einer Klasse ausgeführt wird, andere threads in der <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> , die versuchen, verwenden Sie, dass die Klasse werden blockiert.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">Deadlocks können leicht auftreten.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">Nur .NET Core: Dieser Member wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>The thread has not been started, is dead, or is not in the suspended state.</source>
          <target state="translated">Der Thread wurde nicht gestartet, ist deaktiviert oder befindet sich nicht im angehaltenen Zustand.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderliche <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>for advanced operations on threads.</source>
          <target state="translated">für erweiterte Vorgänge für Threads.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The new apartment state.</source>
          <target state="translated">Der neue Apartmentzustand.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Legt den Apartmentzustand eines Threads fest, bevor dieser gestartet wird.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>New threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> if their apartment state has not been set before they are started.</source>
          <target state="translated">Neue Threads werden als initialisiert <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> Wenn ihre Apartmentzustand nicht festgelegt wurde, bevor sie gestartet wurden.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Apartmentzustand muss festgelegt werden, bevor ein Thread gestartet wird.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> by default.</source>
          <target state="translated">Thread der hauptanwendung wird initialisiert, um <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> standardmäßig.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The only way to set the apartment state of the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> is to apply the <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> attribute to the entry point method.</source>
          <target state="translated">Die einzige Möglichkeit zum Festlegen des Status Apartment des Threads hauptanwendung, <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> angewendet wird die <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> -Attribut auf die Einstiegspunktmethode.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method, along with the <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method and the <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> -Methode, zusammen mit den <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> Methode und die <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> Methode ersetzt die <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> methods.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The code example creates a thread.</source>
          <target state="translated">Das Codebeispiel erstellt einen Thread.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>Before the thread is started, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> displays the initial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> state and <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> changes the state to <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Bevor der Thread gestartet wird, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> zeigt den ersten <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> Zustand und <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> ändert den Zustand in <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method then returns <ph id="ph2">`false`</ph> when attempting to change the state to <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> because the apartment state is already set.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> dann Methodenrückgabe <ph id="ph2">`false`</ph> beim Versuch, den Status zu ändern <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> da bereits der Apartmentzustand festgelegt ist.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>If the same operation had been attempted with <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> would have been thrown.</source>
          <target state="translated">Mit der gleiche Vorgang versucht wurde, hatte <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> würde ausgelöst wurden.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>After the thread is started, the <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method is used again.</source>
          <target state="translated">Nachdem der Thread gestartet wird, die <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> Methode erneut verwendet wird.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>This time it throws <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> because the thread has already been started.</source>
          <target state="translated">Sie löst dieses Mal <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> , weil der Thread bereits gestartet wurde.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>.NET Core only: This member is not supported on the macOS and Linux platforms.</source>
          <target state="translated">Nur .NET Core: Dieser Member wird auf den Plattformen macOS und Linux nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source><ph id="ph1">&lt;paramref name="state" /&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="state" /&gt;</ph> ist kein gültiger Apartmentzustand.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The thread has already been started.</source>
          <target state="translated">Der Thread wurde bereits gestartet.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The apartment state has already been initialized.</source>
          <target state="translated">Der Apartmentzustand wurde bereits initialisiert.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> object to be applied to the current thread.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph>-Objekt, das für den aktuellen Thread übernommen werden soll.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>Applies a captured <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> to the current thread.</source>
          <target state="translated">Übernimmt einen erfassten <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> für den aktuellen Thread.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>This method is no longer supported.</source>
          <target state="translated">Diese Methode wird nicht mehr unterstützt.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>In all cases.</source>
          <target state="translated">In allen Fällen.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> in which to set the value.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph>, in dem der Wert festgelegt werden soll.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The value to be set.</source>
          <target state="translated">Der festzulegende Wert.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Sets the data in the specified slot on the currently running thread, for that thread's current domain.</source>
          <target state="translated">Legt die Daten im angegebenen Slot auf den derzeit ausgeführten Thread und für die aktuelle Domäne des betreffenden Threads fest.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>For better performance, use fields marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>-Attribut markiert sind.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut) und Datenslots.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Weitere Informationen zur Verwendung von TLS finden Sie unter <bpt id="p1">[</bpt>lokaler Threadspeicher: threadbezogene statische Felder und Datenslots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> object has been reclaimed by garbage collection.</source>
          <target state="translated">Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen eines Wert im Slot und der Slot für die Wiederverwendung freigeben, nachdem die Threadprozedur beendet und die <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> Objekt von der Garbagecollection zurückgefordert wurde.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Datenslots sind pro Thread eindeutig.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SetData%2A&gt;</ph> is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.SetData%2A&gt;</ph> ist eine <ph id="ph2">`Shared`</ph> Methode, die immer auf den gerade ausgeführten Thread angewendet wird, auch wenn Sie mit einer Variablen, die auf einem anderen Thread aufgerufen.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</source>
          <target state="translated">Um Verwirrung zu vermeiden, verwenden Sie den Klassennamen beim Aufrufen von <ph id="ph1">`Shared`</ph> Methoden: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>This section contains two code examples.</source>
          <target state="translated">Dieser Abschnitt enthält zwei Codebeispiele.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut, um die Thread-spezifische Informationen zu halten.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Erste Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> , Thread-spezifische Informationen aufnimmt.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Zweite Beispiel<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie auf einen benannten Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">Hält den aktuellen Thread während des angegebenen Zeitraums an.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The number of milliseconds for which the thread is suspended.</source>
          <target state="translated">Die Anzahl von Millisekunden, die der Thread angehalten wird.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>If the value of the <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Wenn der Wert des <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept>-Arguments 0 (null) lautet, gibt der Thread den Rest seines Zeitanteils an einen beliebigen Thread mit gleicher Priorität ab, der für die Ausführung bereit ist.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Sind keine anderen Threads mit gleicher Priorität vorhanden, die ausgeführt werden können, wird die Ausführung des aktuellen Threads nicht angehalten.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>Suspends the current thread for the specified number of milliseconds.</source>
          <target state="translated">Hält den aktuellen Thread für die angegebene Anzahl von Millisekunden an.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">Der Thread wird nicht vom Betriebssystem für den angegebenen Zeitraum für die Ausführung geplant.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>This method changes the state of the thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
          <target state="translated">Diese Methode ändert den Zustand des Threads enthalten <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>You can specify <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> for the <ph id="ph2">`millisecondsTimeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Sie können angeben, <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> für die <ph id="ph2">`millisecondsTimeout`</ph> Parameter auf unbestimmte Zeit Anhalten des Threads vor.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>However, we recommend that you use other <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> classes such as <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> instead to sychronize threads or manage resources.</source>
          <target state="translated">Allerdings wird empfohlen, dass Sie andere verwenden <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> Klassen wie <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> stattdessen für Threads synchronisieren oder Ressourcen zu verwalten.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The system clock ticks at a specific rate called the clock resolution.</source>
          <target state="translated">Das System Zeiteinheiten in einer bestimmten Rate wird aufgerufen, die Auflösung der Uhr.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</source>
          <target state="translated">Die tatsächliche timeoutsekunden möglicherweise nicht genau das festgelegte Timeout, da das festgelegte Timeout mit Teilstrichen zur berichtsausführung die Verarbeitung angepasst wird.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>For more information on clock resolution and the waiting time, see the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> topic.</source>
          <target state="translated">Weitere Informationen zur Auflösung der Uhr und die Wartezeit finden Sie unter der <bpt id="p1">[</bpt>Standbymodus Funktion<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> Thema.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>This method calls the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> from the Windows system APIs.</source>
          <target state="translated">Diese Methode ruft die <bpt id="p1">[</bpt>Standbymodus Funktion<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> aus der Windows-Dateisystem-APIs.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Diese Methode führt keine standard COM- und das SendMessage-Pumping fortgesetzt werden.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>If you need to sleep on a thread that has <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method that specifies a timeout interval.</source>
          <target state="translated">Wenn Sie in einem Thread im Ruhezustand verbleiben, die aufweist, müssen <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, aber Sie verwenden möchten, führen Sie standard COM- und das SendMessage-Pumping fortgesetzt werden, sollten eine der Überladungen der die <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> Methode, die ein Timeoutintervall angibt.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method to block the application's main thread.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> Methode, um den Hauptthread der Anwendung blockiert.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The time-out value is negative and is not equal to <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">Der Timeoutwert ist negativ und ungleich <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The amount of time for which the thread is suspended.</source>
          <target state="translated">Der Zeitraum, während dessen der Thread angehalten wird.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>If the value of the <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept> argument is <ph id="ph1">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Wenn der Wert des <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept>-Arguments <ph id="ph1">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> lautet, gibt der Thread den Rest seines Zeitanteils an einen beliebigen Thread mit gleicher Priorität ab, der für die Ausführung bereit ist.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Sind keine anderen Threads mit gleicher Priorität vorhanden, die ausgeführt werden können, wird die Ausführung des aktuellen Threads nicht angehalten.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">Hält den aktuellen Thread während des angegebenen Zeitraums an.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">Der Thread wird nicht vom Betriebssystem für den angegebenen Zeitraum für die Ausführung geplant.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>This method changes the state of the thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
          <target state="translated">Diese Methode ändert den Zustand des Threads enthalten <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>You can specify <ph id="ph1">&lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Sie können angeben, <ph id="ph1">&lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType&gt;</ph> für die <ph id="ph2">`timeout`</ph> Parameter auf unbestimmte Zeit Anhalten des Threads vor.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>However, we recommend that you use other <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> classes such as <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> instead to sychronize threads or manage resources.</source>
          <target state="translated">Allerdings wird empfohlen, dass Sie andere verwenden <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> Klassen wie <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> stattdessen für Threads synchronisieren oder Ressourcen zu verwalten.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>This overload of <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> uses the total number of whole milliseconds in <ph id="ph2">`timeout`</ph>.</source>
          <target state="translated">Diese Überladung der <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> verwendet die Gesamtanzahl von ganzen Millisekunden in <ph id="ph2">`timeout`</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>Fractional milliseconds are discarded.</source>
          <target state="translated">Bruchteile von Millisekunden werden verworfen.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Diese Methode führt keine standard COM- und das SendMessage-Pumping fortgesetzt werden.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>If you need to sleep on a thread that has <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method that specifies a timeout interval.</source>
          <target state="translated">Wenn Sie in einem Thread im Ruhezustand verbleiben, die aufweist, müssen <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, aber Sie verwenden möchten, führen Sie standard COM- und das SendMessage-Pumping fortgesetzt werden, sollten eine der Überladungen der die <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> Methode, die ein Timeoutintervall angibt.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%28System.TimeSpan%29&gt;</ph> method overload to block the application's main thread five times, for two seconds each time.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%28System.TimeSpan%29&gt;</ph> methodenüberladung Hauptthread der Anwendung zwei Sekunden jedes Mal fünf Mal blockieren.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in milliseconds, or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> ist negativ und nicht gleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in Millisekunden oder größer als <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> Millisekunden.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>A 32-bit signed integer that defines how long a thread is to wait.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die den Zeitraum definiert, den ein Thread warten soll.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Causes a thread to wait the number of times defined by the <ph id="ph1">&lt;paramref name="iterations" /&gt;</ph> parameter.</source>
          <target state="translated">Veranlasst, dass ein Thread so oft wartet, wie vom <ph id="ph1">&lt;paramref name="iterations" /&gt;</ph>-Parameter definiert.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> method is useful for implementing locks.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> Methode eignet sich zum Implementieren von Sperren.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Classes in the .NET Framework, such as <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, use this method internally.</source>
          <target state="translated">Klassen in .NET Framework, z. B. <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, verwenden Sie diese Methode intern.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> essentially puts the processor into a very tight loop, with the loop count specified by the <ph id="ph2">`iterations`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> setzt im Wesentlichen den Prozessor in eine sehr enge Schleife mit der Schleifenanzahl gemäß der <ph id="ph2">`iterations`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>The duration of the wait therefore depends on the speed of the processor.</source>
          <target state="translated">Die Dauer des Wartevorgangs hängt daher von der Geschwindigkeit des Prozessors.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Contrast this with the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method.</source>
          <target state="translated">Vergleichen Sie dies mit der <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>A thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> yields the rest of its current slice of processor time, even if the specified interval is zero.</source>
          <target state="translated">Ein Thread, der Aufrufe <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> ergibt den Rest des aktuellen Zeitanteils, selbst wenn das angegebene Intervall 0 (null) ist.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Specifying a non-zero interval for <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</source>
          <target state="translated">Angeben eines Intervalls ungleich NULL für <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> entfernt den Thread aus der Threadplanung, bis das angegebene Zeitintervall abgelaufen ist.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> is not generally useful for ordinary applications.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> ist nicht für gewöhnliche Anwendungen in der Regel sinnvoll.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> or a statement that wraps <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">`lock`</ph> in C# or <ph id="ph4">`SyncLock`</ph> in Visual Basic).</source>
          <target state="translated">In den meisten Fällen sollten Sie von .NET Framework bereitgestellten Synchronisierungsklassen verwenden. Rufen Sie z. B. <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> oder eine Anweisung, die umschließt <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">`lock`</ph> in c# oder <ph id="ph4">`SyncLock`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> method in your loop.</source>
          <target state="translated">Stellen Sie in den seltenen Fällen, in denen ist es vorteilhaft sein, einen Kontextwechsel, z. B. Wenn Sie wissen, dass eine Zustandsänderung bevorsteht, vermeiden Sie, einen Aufruf der <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> -Methode in der Schleife.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>The code <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> executes is designed to prevent problems that can occur on computers with multiple processors.</source>
          <target state="translated">Der Code <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> führt wurde entwickelt, um Probleme zu vermeiden, die auf Computern mit mehreren Prozessoren auftreten können.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>For example, on computers with multiple Intel processors employing Hyper-Threading technology, <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> prevents processor starvation in certain situations.</source>
          <target state="translated">Auf Computern mit mehreren Intel-Prozessoren mit Hyperthreading-Technologie, beispielsweise <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> Prozessor verhungern in bestimmten Situationen verhindert.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Causes a thread to be scheduled for execution.</source>
          <target state="translated">Bewirkt, dass die Ausführung eines Threads geplant wird.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start">
          <source>Causes the operating system to change the state of the current instance to <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph>.</source>
          <target state="translated">Weist das Betriebssystem an, den Zustand der aktuellen Instanz in <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph> zu ändern.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>Once a thread is in the <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> state, the operating system can schedule it for execution.</source>
          <target state="translated">Sobald ein Thread die <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> Zustand befindet, wird das Betriebssystem für die Ausführung planen.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>The thread begins executing at the first line of the method represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate supplied to the thread constructor.</source>
          <target state="translated">Der Thread beginnt mit der Ausführung in der ersten Zeile der Methode, dargestellt durch die <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> -Delegaten an den Threadkonstruktor.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>Note that the call to <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> does not block the calling thread.</source>
          <target state="translated">Beachten Sie, dass der Aufruf von <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> den aufrufenden Thread nicht blockiert.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>If this overload is used with a thread created using a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate, <ph id="ph2">`null`</ph> is passed to the method executed by the thread.</source>
          <target state="translated">Wenn diese Überladung mit einem Thread mit erstellt verwendet wird eine <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> zu delegieren, <ph id="ph2">`null`</ph> an die vom Thread ausgeführte Methode übergeben wird.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Sobald der Thread beendet wird, er kann nicht neu gestartet werden mit einem weiteren Aufruf von <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>The following example creates and starts a thread.</source>
          <target state="translated">Das folgende Beispiel erstellt und startet einen Thread.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start">
          <source>The thread has already been started.</source>
          <target state="translated">Der Thread wurde bereits gestartet.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">Es ist nicht genügend Speicher zum Starten dieses Threads verfügbar.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>An object that contains data to be used by the method the thread executes.</source>
          <target state="translated">Ein Objekt mit Daten, die von der vom Thread ausgeführten Methode verwendet werden sollen.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Causes the operating system to change the state of the current instance to <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph>, and optionally supplies an object containing data to be used by the method the thread executes.</source>
          <target state="translated">Bewirkt, dass das Betriebssystem den Zustand der aktuellen Instanz in <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph> ändert, und stellt optional ein Objekt mit Daten bereit, die von der vom Thread ausgeführten Methode verwendet werden sollen.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Once a thread is in the <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> state, the operating system can schedule it for execution.</source>
          <target state="translated">Sobald ein Thread die <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> Zustand befindet, wird das Betriebssystem für die Ausführung planen.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>The thread begins executing at the first line of the method represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate supplied to the thread constructor.</source>
          <target state="translated">Der Thread beginnt mit der Ausführung in der ersten Zeile der Methode, dargestellt durch die <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> -Delegaten an den Threadkonstruktor.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Note that the call to <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> does not block the calling thread.</source>
          <target state="translated">Beachten Sie, dass der Aufruf von <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> den aufrufenden Thread nicht blockiert.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Sobald der Thread beendet wird, er kann nicht neu gestartet werden mit einem weiteren Aufruf von <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>This overload and the <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</source>
          <target state="translated">Diese Überladung und <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> Delegaten erleichtern die Daten an eine Threadprozedur übergeben, aber das Verfahren ist nicht typsicher, da ein Objekt für diese Überladung übergeben werden kann.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</source>
          <target state="translated">Eine robustere Möglichkeit, Daten an eine Threadprozedur übergeben wird, die Threadprozedur und Datenfelder zu einem Worker-Objekt eingefügt werden soll.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Threads and Passing Data at Start Time<ept id="p1">](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Threads erstellen und übergeben von Daten zur Startzeit<ept id="p1">](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)</ept>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate with a static method and an instance method.</source>
          <target state="translated">Das folgende Beispiel erstellt eine <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> Delegaten mit einer statischen Methode und eine Instanzenmethode.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>The thread has already been started.</source>
          <target state="translated">Der Thread wurde bereits gestartet.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">Es ist nicht genügend Speicher zum Starten dieses Threads verfügbar.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>This thread was created using a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> delegate instead of a <ph id="ph2">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph> delegate.</source>
          <target state="translated">Dieser Thread wurde mithilfe eines <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph>-Delegaten anstelle eines <ph id="ph2">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph>-Delegaten erstellt.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>Either suspends the thread, or if the thread is already suspended, has no effect.</source>
          <target state="translated">Hält den Thread an. Hat keine Auswirkungen, wenn der Thread bereits angehalten ist.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>If the thread is already suspended, this method has no effect.</source>
          <target state="translated">Wenn der Thread bereits angehalten ist, hat diese Methode keine Auswirkung.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>Do not use the <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> methods to synchronize the activities of threads.</source>
          <target state="translated">Verwenden Sie nicht die <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> Methoden zum Synchronisieren der Aktivitäten von Threads.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">Sie haben keine Möglichkeit, zu wissen, welcher Code ein Thread ausgeführt wird, wenn Sie ihn anhalten.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> might be blocked.</source>
          <target state="translated">Wenn Sie einen Thread anhalten, während sie Sperren während der Auswertung von Sicherheitsberechtigungen enthält, andere threads in der <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> blockiert werden.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> that attempt to use that class are blocked.</source>
          <target state="translated">Wenn Sie einen Thread anhalten, während der Konstruktor einer Klasse ausgeführt wird, andere threads in der <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> , die versuchen, verwenden Sie, dass die Klasse werden blockiert.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">Deadlocks können leicht auftreten.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">Nur .NET Core: Dieser Member wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>The thread has not been started or is dead.</source>
          <target state="translated">Der Thread wurde nicht gestartet oder reagiert nicht.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderliche <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>for advanced operations on threads.</source>
          <target state="translated">für erweiterte Vorgänge für Threads.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Für zukünftige Verwendung reserviert.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Muss IID_NULL sein.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Das übergebene Array von zuzuordnenden Namen.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Die Anzahl der zuzuordnenden Namen.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Die zurückzugebenden Typinformationen.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Der Gebietsschemabezeichner für die Typinformationen.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Bezeichnet den Member.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Für zukünftige Verwendung reserviert.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Muss IID_NULL sein.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Flags, die den Kontext des Aufrufs beschreiben.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Der Index des ersten Arguments mit einem Fehler.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::Invoke`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ThreadState">
          <source>Gets a value containing the states of the current thread.</source>
          <target state="translated">Ruft einen Wert ab, der die Zustände des aktuellen Threads enthält.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ThreadState" /&gt;</ph> values indicating the state of the current thread.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Threading.ThreadState" /&gt;</ph>-Werte, der den Zustand des aktuellen Threads angibt.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>The initial value is <ph id="ph1">&lt;see langword="Unstarted" /&gt;</ph>.</source>
          <target state="translated">Der Anfangswert ist <ph id="ph1">&lt;see langword="Unstarted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property provides more specific information than the <ph id="ph2">&lt;xref:System.Threading.Thread.IsAlive%2A&gt;</ph> property.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> Eigenschaft erhalten Sie genauere Informationen als die <ph id="ph2">&lt;xref:System.Threading.Thread.IsAlive%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>Thread state is only of interest in debugging scenarios.</source>
          <target state="translated">Threadzustand ist nur in Debugszenarien von Interesse.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>Your code should never use thread state to synchronize the activities of threads.</source>
          <target state="translated">Sie sollten den Threadzustand niemals verwenden, um die Aktivitäten von Threads zu synchronisieren.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>The following code example demonstrates accessing the <ph id="ph1">`ThreadState`</ph> of a thread.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht den Zugriff auf die <ph id="ph1">`ThreadState`</ph> eines Threads.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The new apartment state.</source>
          <target state="translated">Der neue Apartmentzustand.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Legt den Apartmentzustand eines Threads fest, bevor dieser gestartet wird.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the apartment state is set; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Apartmentzustand festgelegt wurde, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>New threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> if their apartment state has not been set before they are started.</source>
          <target state="translated">Neue Threads werden als initialisiert <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> Wenn ihre Apartmentzustand nicht festgelegt wurde, bevor sie gestartet wurden.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Apartmentzustand muss festgelegt werden, bevor ein Thread gestartet wird.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> by default.</source>
          <target state="translated">Thread der hauptanwendung wird initialisiert, um <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> standardmäßig.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The only way to set the apartment state of the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> is to apply the <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> attribute to the entry point method.</source>
          <target state="translated">Die einzige Möglichkeit zum Festlegen des Status Apartment des Threads hauptanwendung, <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> angewendet wird die <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> -Attribut auf die Einstiegspunktmethode.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, along with the <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method and the <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> -Methode, zusammen mit den <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> Methode und die <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> Methode ersetzt die <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> methods.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The code example creates a thread.</source>
          <target state="translated">Das Codebeispiel erstellt einen Thread.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>Before the thread is started, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> displays the initial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> state and <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> changes the state to <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Bevor der Thread gestartet wird, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> zeigt den ersten <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> Zustand und <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> ändert den Zustand in <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method then returns <ph id="ph2">`false`</ph> when attempting to change the state to <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> because the apartment state is already set.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> dann Methodenrückgabe <ph id="ph2">`false`</ph> beim Versuch, den Status zu ändern <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> da bereits der Apartmentzustand festgelegt ist.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>If the same operation had been attempted with <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> would have been thrown.</source>
          <target state="translated">Mit der gleiche Vorgang versucht wurde, hatte <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> würde ausgelöst wurden.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>After the thread is started, the <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method is used again.</source>
          <target state="translated">Nachdem der Thread gestartet wird, die <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> Methode erneut verwendet wird.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>This time it throws <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> because the thread has already been started.</source>
          <target state="translated">Sie löst dieses Mal <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> , weil der Thread bereits gestartet wurde.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source><ph id="ph1">&lt;paramref name="state" /&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="state" /&gt;</ph> ist kein gültiger Apartmentzustand.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The thread has already been started.</source>
          <target state="translated">Der Thread wurde bereits gestartet.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>The field to be read.</source>
          <target state="translated">Das zu lesende Feld.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Liest den Wert eines Felds.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Der letzte von einem Prozessor in das Feld geschriebene Wert.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Das Feld, in das der Wert geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>The value to be written.</source>
          <target state="translated">Der zu schreibende Wert.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sind für Sonderfälle der Synchronisierung.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Unter normalen Umständen c# <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung und die <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere alternativen.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Auf einem Multiprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Dies könnte Prozessorcache geleert werden.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Auch bei einem Einprozessorsystem <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">In c# mithilfe der <ph id="ph1">`volatile`</ph> Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Yield">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
          <target state="translated">Bewirkt, dass der aufrufende Thread die Ausführung an einen anderen Thread übergibt, der auf dem aktuellen Prozessor ausgeführt werden kann.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Yield">
          <source>The operating system selects the thread to yield to.</source>
          <target state="translated">Das Betriebssystem wählt den Thread für die Übergabe aus.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Yield">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system switched execution to another thread; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das Betriebssystem die Ausführung an einen anderen Thread übergeben hat, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>If this method succeeds, the rest of the thread's current time slice is yielded.</source>
          <target state="translated">Wenn diese Methode erfolgreich ist, wird der Rest der aktuellen Zeitscheibe des Threads zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</source>
          <target state="translated">Das Betriebssystem plant den aufrufenden Thread für eine andere Zeitscheibe nach seiner Priorität und den Status von anderen Threads, die zum Ausführen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>Yielding is limited to the processor that is executing the calling thread.</source>
          <target state="translated">Gewinnung ist beschränkt, für den Prozessor an, der den aufrufenden Thread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</source>
          <target state="translated">Das Betriebssystem wird nicht mit einem anderen Prozessor Ausführung wechseln, selbst wenn der Prozessor im Leerlauf befindet oder einen Thread mit geringerer Priorität ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Wenn es sind keine anderen Threads, die auf dem aktuellen Prozessor ausgeführt werden und das Betriebssystem keine Arbeitsvorgänge von Ausführung zugunsten dieser Methode <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>This method is equivalent to using platform invoke to call the native Win32 <ph id="ph1">`SwitchToThread`</ph> function.</source>
          <target state="translated">Diese Methode ist gleichbedeutend mit Plattformaufruf zum Aufrufen von systemeigenen Win32 <ph id="ph1">`SwitchToThread`</ph> Funktion.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>You should call the <ph id="ph1">&lt;xref:System.Threading.Thread.Yield%2A&gt;</ph> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Threading.Thread.Yield%2A&gt;</ph> Methode anstelle der Plattform aufrufen, da ein Plattformaufruf umgeht alle benutzerdefiniertes threading Verhalten der Host angefordert hat.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>