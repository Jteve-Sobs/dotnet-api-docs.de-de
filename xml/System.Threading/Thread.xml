<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="28940d1ccf8cfc682bfdfb25e8a009feb7873360" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83536244" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="C#" Value="public sealed class Thread" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Thread extends System.Object" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="F#" Value="type Thread = class" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.InteropServices._Thread" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Thread extends System.Object implements class System.Runtime.InteropServices._Thread" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Implements _Thread" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::InteropServices::_Thread" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    interface _Thread" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" FrameworkAlternate="xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading.Thread" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Erstellt und steuert einen Thread, legt dessen Priorität fest und ruft den Status ab.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Prozess gestartet wird, erstellt der Common Language Runtime automatisch einen einzelnen Vordergrund Thread, um Anwendungscode auszuführen. Zusammen mit diesem Haupt Vordergrund Thread kann ein Prozess einen oder mehrere Threads erstellen, um einen Teil des Programmcodes auszuführen, der dem Prozess zugeordnet ist. Diese Threads können entweder im Vordergrund oder im Hintergrund ausgeführt werden. Außerdem können Sie die <xref:System.Threading.ThreadPool>-Klasse verwenden, um Code für Arbeitsthreads auszuführen, die vom Common Language Runtime verwaltet werden.  
  
 In diesem Abschnitt  
  
 [Starten eines Thread](#Starting)   
 [Abrufen von Thread Objekten](#Retrieving)   
 [Vordergrund-und Hintergrundthreads](#Foreground)   
 [Kultur und Threads](#Culture)   
 [Erhalten von Informationen über und Steuern von Threads](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>Starten eines Threads  
 Sie starten einen Thread, indem Sie einen Delegaten bereitstellen, der die Methode darstellt, die der Thread in seinem Klassenkonstruktor ausführen soll. Anschließend wird die <xref:System.Threading.Thread.Start%2A>-Methode aufgerufen, um die Ausführung zu starten.  
  
 Die <xref:System.Threading.Thread>-Konstruktoren können einen von zwei Delegattypen annehmen, je nachdem, ob Sie ein Argument an die auszuführende Methode übergeben können:  
  
-   Wenn die Methode über keine Argumente verfügt, übergeben Sie einen <xref:System.Threading.ThreadStart>-Delegaten an den Konstruktor. Sie hat die folgende Signatur:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     Im folgenden Beispiel wird ein Thread erstellt und gestartet, der die `ExecuteInForeground`-Methode ausführt. Die-Methode zeigt Informationen zu einigen Thread Eigenschaften an und führt dann eine Schleife aus, in der Sie für eine halbe Sekunde angehalten wird, und zeigt die verstrichene Anzahl von Sekunden an. Wenn der Thread mindestens fünf Sekunden lang ausgeführt wurde, wird die-Schleife beendet, und der Thread beendet die Ausführung.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   Wenn die Methode über ein Argument verfügt, übergeben Sie einen <xref:System.Threading.ParameterizedThreadStart>-Delegaten an den Konstruktor. Sie hat die folgende Signatur:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     Die vom Delegaten ausgeführte Methode kann dann den- C#Parameter in den entsprechenden Typ umwandeln (in) oder (in Visual Basic).  
  
     Das folgende Beispiel ist mit dem vorherigen identisch, mit der Ausnahme, dass der <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>-Konstruktor aufgerufen wird. Diese Version der `ExecuteInForeground`-Methode verfügt über einen einzelnen Parameter, der die ungefähre Anzahl von Millisekunden darstellt, die die Schleife ausgeführt werden soll.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 Es ist nicht erforderlich, einen Verweis auf ein <xref:System.Threading.Thread> Objekt beizubehalten, nachdem Sie den Thread gestartet haben. Der Thread wird weiter ausgeführt, bis die Thread Prozedur vollständig ist.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>Abrufen von Thread Objekten  
 Sie können die statische (`Shared` in Visual Basic)-<xref:System.Threading.Thread.CurrentThread%2A> Eigenschaft verwenden, um einen Verweis auf den aktuell ausgeführten Thread aus dem Code abzurufen, den der Thread ausführt. Im folgenden Beispiel wird die <xref:System.Threading.Thread.CurrentThread%2A>-Eigenschaft verwendet, um Informationen zum Hauptanwendungs Thread, einen weiteren Vordergrund Thread, einen Hintergrund Thread und einen Thread Pool Thread anzuzeigen.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>Vordergrund-und Hintergrundthreads  
 Instanzen der <xref:System.Threading.Thread>-Klasse stellen entweder Vordergrundthreads oder Hintergrundthreads dar. Hintergrundthreads sind mit einer Ausnahme mit den Vordergrundthreads identisch: ein Hintergrund Thread führt keinen Prozess aus, wenn alle Vordergrundthreads beendet wurden. Nachdem alle Vordergrundthreads beendet wurden, beendet die Common Language Runtime alle Hintergrundthreads und wird heruntergefahren.  
  
 Standardmäßig werden die folgenden Threads im Vordergrund ausgeführt:  
  
-   Der Hauptanwendungs Thread.  
  
-   Alle Threads, die durch Aufrufen eines <xref:System.Threading.Thread>-Klassenkonstruktors erstellt werden.  
  
 Die folgenden Threads werden standardmäßig im Hintergrund ausgeführt:  
  
-   Thread Poolthreads, bei denen es sich um einen Pool von Arbeitsthreads handelt, die von der Laufzeit verwaltet werden.  Sie können den Thread Pool konfigurieren und Arbeitsaufgaben in Thread Pool-Threads planen, indem Sie die <xref:System.Threading.ThreadPool>-Klasse verwenden.  
  
    > [!NOTE]
    >  Aufgabenbasierte asynchrone Vorgänge werden automatisch in Thread Pool-Threads ausgeführt. Aufgabenbasierte asynchrone Vorgänge verwenden die Klassen <xref:System.Threading.Tasks.Task> und <xref:System.Threading.Tasks.Task%601>, um das [aufgabenbasierte asynchrone Muster](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)zu implementieren.  
  
-   Alle Threads, die aus nicht verwaltetem Code in die verwaltete Ausführungsumgebung eintreten.  
  
 Sie können einen Thread so ändern, dass er im Hintergrund ausgeführt wird, indem Sie die <xref:System.Threading.Thread.IsBackground%2A>-Eigenschaft jederzeit festlegen.  Hintergrundthreads sind für jeden Vorgang nützlich, der fortgesetzt werden sollte, wenn eine Anwendung ausgeführt wird, aber nicht verhindern soll, dass die Anwendung beendet wird, z. b. das Überwachen von Dateisystem Änderungen oder eingehenden Socketverbindungen  
  
 Das folgende Beispiel veranschaulicht den Unterschied zwischen Vordergrund-und Hintergrundthreads. Dies entspricht dem ersten Beispiel im Abschnitt " [Starten eines Threads](#Starting) ", mit dem Unterschied, dass der Thread vor dem Starten im Hintergrund ausgeführt wird. Wie die Ausgabe zeigt, wird die Schleife unterbrochen, bevor Sie fünf Sekunden lang ausgeführt wird.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>Kultur und Threads  
 Jeder Thread verfügt über eine Kultur, die durch die <xref:System.Threading.Thread.CurrentCulture%2A>-Eigenschaft dargestellt wird, und eine Benutzeroberflächen Kultur, die durch die <xref:System.Threading.Thread.CurrentUICulture%2A>-Eigenschaft dargestellt wird.  Die aktuelle Kultur unterstützt solche Kultur abhängigen Vorgänge wie das durcharbeiten und formatieren, den Zeichen folgen Vergleich und die Sortierung sowie das von einem Thread verwendete Schriftsystem und den von einem Thread verwendeten Kalender. Die aktuelle Benutzeroberflächen Kultur ermöglicht das Kultur abhängige Abrufen von Ressourcen in Ressourcen Dateien.  

> [!IMPORTANT]
> Die Eigenschaften "<xref:System.Threading.Thread.CurrentCulture>" und "<xref:System.Threading.Thread.CurrentUICulture>" funktionieren nicht zuverlässig, wenn Sie mit einem anderen Thread als dem aktuellen Thread verwendet werden. In .NET Framework ist das Lesen dieser Eigenschaften zuverlässig, auch wenn diese Eigenschaften für einen anderen Thread als den aktuellen Thread festgelegt werden. Unter .net Core wird eine <xref:System.InvalidOperationException> ausgelöst, wenn ein Thread versucht, diese Eigenschaften in einem anderen Thread zu lesen oder zu schreiben.
> Es wird empfohlen, die Eigenschaften "<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType>" und "<xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType>" zum Abrufen und Festlegen der aktuellen Kultur zu verwenden.

 Wenn ein neuer Thread instanziiert wird, werden seine Kultur und Benutzeroberflächen Kultur von der aktuellen System Kultur und Benutzeroberflächen Kultur definiert, nicht von der Kultur und Benutzeroberflächen Kultur des Threads, von dem aus der neue Thread erstellt wird. Dies bedeutet beispielsweise Folgendes: Wenn die aktuelle System Kultur Englisch (USA) und die aktuelle Kultur des primären Anwendungs Threads Französisch (Frankreich) ist, ist die Kultur eines neuen Threads, der durch Aufrufen des <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Konstruktors vom primären Thread erstellt wird, Englisch (USA) und nicht Französisch (Frankreich). Weitere Informationen finden Sie im Abschnitt "Kultur und Threads" im Thema <xref:System.Globalization.CultureInfo>-Klasse.  
  
> [!IMPORTANT]
>  Dies gilt nicht für Threads, die asynchrone Vorgänge für apps ausführen, die auf [!INCLUDE[net_v46](~/includes/net-v46-md.md)] und spätere Versionen abzielen. in diesem Fall ist die Kultur und die UI-Kultur Teil eines asynchronen Vorgangs Kontexts. der Thread, für den ein asynchroner Vorgang standardmäßig ausgeführt wird, erbt die Kultur und die UI-Kultur des Threads, von dem der asynchrone Vorgang gestartet wurde. Weitere Informationen finden Sie im Abschnitt "Kultur und aufgabenbasierte asynchrone Vorgänge" im Thema zur <xref:System.Globalization.CultureInfo>-Klasse.  
  
 Sie können eine der folgenden Aktionen durchführen, um sicherzustellen, dass alle in einer Anwendung ausgeführten Threads dieselbe Kultur und Benutzeroberflächen Kultur gemeinsam nutzen:  
  
-   Sie können ein <xref:System.Globalization.CultureInfo> Objekt, das diese Kultur darstellt, an den <xref:System.Threading.ParameterizedThreadStart>-Delegaten oder die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType>-Methode übergeben.  
  
-   Für apps, die auf dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] und höheren Versionen ausgeführt werden, können Sie die Kultur und die UI-Kultur definieren, die allen in einer Anwendungsdomäne erstellten Threads zugewiesen werden soll, indem Sie den Wert der Eigenschaften <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> und <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> festlegen. Beachten Sie, dass es sich hierbei um eine Domänen Einstellung pro Anwendung handelt.  

 Weitere Informationen und Beispiele finden Sie im Abschnitt "Kultur und Threads" im Thema <xref:System.Globalization.CultureInfo>-Klasse.

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>Erhalten von Informationen über und Steuern von Threads  
 Sie können eine Reihe von Eigenschafts Werten abrufen, die Informationen zu einem Thread bereitstellen. In einigen Fällen können Sie auch diese Eigenschaftswerte festlegen, um den Thread Vorgang zu steuern. Zu diesen Thread Eigenschaften gehören:  
  
-   Einen Namen <xref:System.Threading.Thread.Name%2A> ist eine Write-Once-Eigenschaft, mit der Sie einen Thread identifizieren können.  Der Standardwert lautet `null`.  
  
-   Ein Hashcode, den Sie abrufen können, indem Sie die <xref:System.Threading.Thread.GetHashCode%2A>-Methode aufrufen. Der Hashcode kann verwendet werden, um einen Thread eindeutig zu identifizieren. der Hashcode für die Lebensdauer des Threads findet nicht mit dem Wert eines anderen Threads in Konflikt, unabhängig von der Anwendungsdomäne, aus der der Wert abgerufen wird.  
  
-   Eine Thread-ID. Der Wert der schreibgeschützten <xref:System.Threading.Thread.ManagedThreadId%2A>-Eigenschaft wird von der Common Language Runtime zugewiesen und identifiziert einen Thread innerhalb des Prozesses eindeutig.  
  
    > [!NOTE]
    >  Eine Betriebssystem- [ThreadId](/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadid) hat keine feste Beziehung zu einem verwalteten Thread, da ein nicht verwalteter Host die Beziehung zwischen verwalteten und nicht verwalteten Threads steuern kann. Insbesondere kann ein hoch entwickelter Host die [CLR-Hosting-API](~/docs/framework/unmanaged-api/hosting/index.md) verwenden, um viele verwaltete Threads mit demselben Betriebssystem Thread zu planen oder einen verwalteten Thread zwischen verschiedenen Betriebssystemthreads zu verschieben.  
  
-   Der aktuelle Zustand des Threads. Für die Dauer des Vorhandenseins befindet sich ein Thread immer in einem oder mehreren der Zustände, die durch die <xref:System.Threading.ThreadState>-Eigenschaft definiert sind.  
  
-   Eine Prioritätsstufe für die Planung, die durch die <xref:System.Threading.ThreadPriority>-Eigenschaft definiert wird. Obwohl Sie diesen Wert festlegen können, um die Priorität eines Threads anzufordern, ist es nicht gewährleistet, dass er vom Betriebssystem berücksichtigt wird.  
  
-   Die schreibgeschützte <xref:System.Threading.Thread.IsThreadPoolThread%2A>-Eigenschaft, die angibt, ob es sich bei einem Thread um einen Thread Pool Thread handelt.  
  
-   Die Eigenschaft <xref:System.Threading.Thread.IsBackground%2A>. Weitere Informationen finden Sie im Abschnitt [Vordergrund-und Hintergrundthreads](#Foreground) .  
  
## Examples  
 Im folgenden Beispiel werden einfache Threading Funktionen veranschaulicht.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 Dieser Code erzeugt eine Ausgabe ähnlich der folgenden:  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads und Threading</related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Verwenden von Threads und Threading</related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96">Verweis Quelle für die Thread-Klasse</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start">Ein Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt dabei einen Delegaten an, der das Übergeben eines Objekts an den Thread bei dessen Start ermöglicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread beginnt nicht mit der Ausführung, wenn er erstellt wird. Um den Thread für die Ausführung zu planen, müssen Sie die <xref:System.Threading.Thread.Start%2A>-Methode aufzurufen. Um ein Datenobjekt an den Thread zu übergeben, verwenden Sie die <xref:System.Threading.Thread.Start%28System.Object%29>-Methoden Überladung.  
  
> [!NOTE]
>  Visual Basic Benutzer können den <xref:System.Threading.ThreadStart>-Konstruktor weglassen, wenn ein Thread erstellt wird. Verwenden Sie den `AddressOf`-Operator, wenn Sie die Methode übergeben, z. b. `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic ruft automatisch den <xref:System.Threading.ThreadStart>-Konstruktor auf.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Syntax zum Erstellen und Verwenden eines <xref:System.Threading.ParameterizedThreadStart> Delegaten mit einer statischen-Methode und einer Instanzmethode.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Erstellen von Threads</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Ein <see cref="T:System.Threading.ThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread beginnt nicht mit der Ausführung, wenn er erstellt wird. Um den Thread für die Ausführung zu planen, müssen Sie die <xref:System.Threading.Thread.Start%2A>-Methode aufzurufen.  
  
> [!NOTE]
>  Visual Basic Benutzer können den <xref:System.Threading.ThreadStart>-Konstruktor weglassen, wenn ein Thread erstellt wird. Verwenden Sie den `AddressOf`-Operator, wenn Sie die Methode beispielsweise `Dim t As New Thread(AddressOf ThreadProc)`übergeben. Visual Basic ruft automatisch den <xref:System.Threading.ThreadStart>-Konstruktor auf.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein Thread erstellt wird, der eine statische Methode ausführt.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird gezeigt, wie ein Thread erstellt wird, der eine Instanzmethode ausführt.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="start" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Erstellen von Threads</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start">Ein <see cref="T:System.Threading.ParameterizedThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <param name="maxStackSize">Die maximale Stapelgröße, in Bytes, für den Thread, oder 0 (null), wenn die angegebene maximale Standardstapelgröße aus dem Header der ausführbaren Datei verwendet werden soll.  
  
Wichtig: Für teilweise vertrauenswürdigen Code wird <paramref name="maxStackSize" /> ignoriert, wenn sie größer als die Standardstapelgröße ist. Es werden keine Ausnahmen ausgelöst.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt dabei einen Delegaten, der das Übergeben eines Objekts an den Thread bei dessen Start ermöglicht, sowie eine maximale Stapelgröße für den Thread an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vermeiden Sie die Verwendung dieser Konstruktorüberladung. Die Standard Stapelgröße, die von der <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>-Konstruktorüberladung verwendet wird, ist die empfohlene Stapelgröße für Threads. Wenn ein Thread Arbeitsspeicher Probleme aufweist, ist der Programmierfehler wahrscheinlich, wie z. b. eine unendliche Rekursion.  
  
> [!IMPORTANT]
>  Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]kann nur voll vertrauenswürdiger Code `maxStackSize` auf einen Wert festlegen, der größer ist als die Standard Stapelgröße (1 Megabyte). Wenn ein größerer Wert für `maxStackSize` angegeben wird, wenn Code mit teilweiser Vertrauenswürdigkeit ausgeführt wird, wird `maxStackSize` ignoriert und die Standard Stapelgröße verwendet. Es werden keine Ausnahmen ausgelöst. Code auf jeder Vertrauens Ebene kann `maxStackSize` auf einen Wert festlegen, der kleiner als die Standard Stapelgröße ist.  
  
> [!NOTE]
>  Wenn Sie eine voll vertrauenswürdige Bibliothek entwickeln, die von teilweise vertrauenswürdigem Code verwendet wird, und einen Thread starten müssen, der einen großen Stapel erfordert, müssen Sie vor dem Erstellen des Threads die volle Vertrauenswürdigkeit bestätigen, oder es wird die Standard Stapelgröße verwendet. Führen Sie diese Schritte nur aus, wenn Sie den Code, der auf dem Thread ausgeführt wird, vollständig steuern.  
  
 Wenn `maxStackSize` kleiner als die minimale Stapelgröße ist, wird die minimale Stapelgröße verwendet. Wenn `maxStackSize` kein Vielfaches der Seitengröße ist, wird es auf das nächste größere Vielfache der Seitengröße gerundet. Wenn Sie z. b. die .NET Framework Version 2,0 unter Windows Vista verwenden, ist 256 KB (262.144 Bytes) die minimale Stapelgröße, und die Seitengröße beträgt 64 KB (65.536 Bytes).  
  
> [!NOTE]
>  In Versionen von Microsoft Windows vor Windows XP und Windows Server 2003 wird `maxStackSize` ignoriert und die im ausführbaren Header angegebene Stapelgröße verwendet.  
  
 Wenn Sie eine sehr kleine Stapelgröße angeben, müssen Sie möglicherweise die Stapelüberlauf Prüfung deaktivieren. Wenn der Stapel stark eingeschränkt ist, kann die Überprüfung selbst zu einem Stapelüberlauf führen. Fügen Sie der Anwendungs Konfigurationsdatei Folgendes hinzu, um die Stapelüberlauf Prüfung zu deaktivieren.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStackSize" /> ist kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start">Ein <see cref="T:System.Threading.ThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <param name="maxStackSize">Die maximale Stapelgröße, in Bytes, für den Thread, oder 0 (null), wenn die angegebene maximale Standardstapelgröße aus dem Header der ausführbaren Datei verwendet werden soll.  
  
Wichtig: Für teilweise vertrauenswürdigen Code wird <paramref name="maxStackSize" /> ignoriert, wenn sie größer als die Standardstapelgröße ist. Es werden keine Ausnahmen ausgelöst.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt die maximale Stapelgröße für den Thread an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vermeiden Sie die Verwendung dieser Konstruktorüberladung. Die Standard Stapelgröße, die von der <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>-Konstruktorüberladung verwendet wird, ist die empfohlene Stapelgröße für Threads. Wenn ein Thread Arbeitsspeicher Probleme aufweist, ist der Programmierfehler wahrscheinlich, wie z. b. eine unendliche Rekursion.  
  
> [!IMPORTANT]
>  Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]kann nur voll vertrauenswürdiger Code `maxStackSize` auf einen Wert festlegen, der größer ist als die Standard Stapelgröße (1 Megabyte). Wenn ein größerer Wert für `maxStackSize` angegeben wird, wenn Code mit teilweiser Vertrauenswürdigkeit ausgeführt wird, wird `maxStackSize` ignoriert und die Standard Stapelgröße verwendet. Es werden keine Ausnahmen ausgelöst. Code auf jeder Vertrauens Ebene kann `maxStackSize` auf einen Wert festlegen, der kleiner als die Standard Stapelgröße ist.  
  
> [!NOTE]
>  Wenn Sie eine voll vertrauenswürdige Bibliothek entwickeln, die von teilweise vertrauenswürdigem Code verwendet wird, und einen Thread starten müssen, der einen großen Stapel erfordert, müssen Sie vor dem Erstellen des Threads die volle Vertrauenswürdigkeit bestätigen, oder es wird die Standard Stapelgröße verwendet. Führen Sie diese Schritte nur aus, wenn Sie den Code, der auf dem Thread ausgeführt wird, vollständig steuern.  
  
 Wenn `maxStackSize` kleiner als die minimale Stapelgröße ist, wird die minimale Stapelgröße verwendet. Wenn `maxStackSize` kein Vielfaches der Seitengröße ist, wird es auf das nächste größere Vielfache der Seitengröße gerundet. Wenn Sie z. b. die .NET Framework Version 2,0 unter Windows Vista verwenden, ist 256 KB (262.144 Bytes) die minimale Stapelgröße, und die Seitengröße beträgt 64 KB (65.536 Bytes).  
  
> [!NOTE]
>  In Versionen von Microsoft Windows vor Windows XP und Windows Server 2003 wird `maxStackSize` ignoriert und die im ausführbaren Header angegebene Stapelgröße verwendet.  
  
 Wenn Sie eine sehr kleine Stapelgröße angeben, müssen Sie möglicherweise die Stapelüberlauf Prüfung deaktivieren. Wenn der Stapel stark eingeschränkt ist, kann die Überprüfung selbst zu einem Stapelüberlauf führen. Fügen Sie der Anwendungs Konfigurationsdatei Folgendes hinzu, um die Stapelüberlauf Prüfung zu deaktivieren.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStackSize" /> ist kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löst eine <see cref="T:System.Threading.ThreadAbortException" /> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen. Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> Die `Thread.Abort`-Methode sollte mit Bedacht verwendet werden. Vor allem, wenn Sie einen anderen Thread als den aktuellen Thread abbrechen, wissen Sie nicht, welcher Code ausgeführt wurde oder nicht ausgeführt werden konnte, wenn die <xref:System.Threading.ThreadAbortException> ausgelöst wird. Sie können auch nicht sicher sein, dass der Zustand der Anwendung oder der Anwendungs-und Benutzer Zustand, der für die Beibehaltung verantwortlich ist, aufgetreten ist. Beispielsweise kann das Aufrufen von `Thread.Abort` verhindern, dass statische Konstruktoren ausgeführt werden, oder es wird verhindert, dass nicht verwaltete Ressourcen freigegeben werden.

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst eine <see cref="T:System.Threading.ThreadAbortException" /> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen. Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode in einem Thread aufgerufen wird, löst das System eine <xref:System.Threading.ThreadAbortException> im Thread aus, um Sie abzubrechen. `ThreadAbortException` ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch am Ende des `catch` Blocks erneut ausgelöst wird, es sei denn, <xref:System.Threading.Thread.ResetAbort%2A> aufgerufen wird. `ResetAbort` bricht die Abbruch Anforderung ab und verhindert, dass der `ThreadAbortException` den Thread beendet. Nicht ausgeführte `finally` Blöcke werden ausgeführt, bevor der Thread abgebrochen wird.  
  
> [!NOTE]
>  Wenn ein Thread `Abort` auf sich selbst aufruft, ähnelt der Effekt dem Auslösen einer Ausnahme. der <xref:System.Threading.ThreadAbortException> erfolgt sofort, und das Ergebnis ist vorhersagbar. Wenn jedoch ein Thread `Abort` in einem anderen Thread aufruft, unterbricht der Abbruch den Code, der ausgeführt wird. Außerdem besteht die Möglichkeit, dass ein statischer Konstruktor abgebrochen werden kann. In seltenen Fällen kann dies verhindern, dass Instanzen dieser Klasse in dieser Anwendungsdomäne erstellt werden. In den .NET Framework Versionen 1,0 und 1,1 besteht die Möglichkeit, dass der Thread abgebrochen wird, während ein `finally` Block ausgeführt wird. in diesem Fall wird der `finally` Block abgebrochen.  
  
 Es ist nicht garantiert, dass der Thread sofort oder überhaupt abgebrochen wird. Diese Situation kann eintreten, wenn ein Thread eine unbegrenzte Menge an Berechnung in den `finally` Blöcken ausführt, die im Rahmen der Abbruch Prozedur aufgerufen werden, wodurch der Abbruch unbegrenzt verzögert wird. Um zu warten, bis ein Thread abgebrochen wurde, können Sie die <xref:System.Threading.Thread.Join%2A>-Methode für den Thread aufrufen, nachdem Sie die <xref:System.Threading.Thread.Abort%2A>-Methode aufgerufen haben. es gibt jedoch keine Garantie, dass der Warte Vorgang beendet wird.  
  
> [!NOTE]
>  Der Thread, der <xref:System.Threading.Thread.Abort%2A> aufruft, kann blockieren, wenn sich der abgebrochene Thread in einem geschützten Bereich von Code befindet, z. b. einem `catch` Block, einem `finally` Block oder einem eingeschränkten Ausführungs Bereich. Wenn der Thread, der <xref:System.Threading.Thread.Abort%2A> aufruft, eine Sperre besitzt, die der abgebrochene Thread erfordert, kann ein Deadlock auftreten.  
  
 Wenn `Abort` für einen Thread aufgerufen wird, der noch nicht gestartet wurde, wird der Thread abgebrochen, wenn <xref:System.Threading.Thread.Start%2A> aufgerufen wird. Wenn `Abort` für einen Thread aufgerufen wird, der blockiert ist oder sich im Ruhezustand befindet, wird der Thread unterbrochen und dann abgebrochen.  
  
 Wenn `Abort` für einen Thread aufgerufen wird, der angehalten wurde, wird ein <xref:System.Threading.ThreadStateException> in dem Thread ausgelöst, der <xref:System.Threading.Thread.Abort%2A>aufgerufen hat, und <xref:System.Threading.ThreadState.AbortRequested> der <xref:System.Threading.Thread.ThreadState%2A>-Eigenschaft des abzugebrochenen Threads hinzugefügt. Eine <xref:System.Threading.ThreadAbortException> wird nicht im angehaltenen Thread ausgelöst, bis <xref:System.Threading.Thread.Resume%2A> aufgerufen wird.  
  
 Wenn `Abort` für einen verwalteten Thread aufgerufen wird, während er nicht verwalteten Code ausführt, wird ein `ThreadAbortException` erst ausgelöst, wenn der Thread an verwalteten Code zurückgegeben wird.  
  
 Wenn zwei Aufrufe von `Abort` gleichzeitig erfolgen, ist es möglich, dass ein Aufruf die Zustandsinformationen und den anderen Aufruf zum Ausführen des `Abort`einrichtet. Diese Situation kann jedoch von einer Anwendung nicht erkannt werden.  
  
 Nachdem `Abort` in einem Thread aufgerufen wurde, enthält der Thread Zustand <xref:System.Threading.ThreadState.AbortRequested>. Nachdem der Thread aufgrund eines erfolgreichen Aufrufes `Abort`beendet wurde, wird der Status des Threads in <xref:System.Threading.ThreadState.Stopped>geändert. Mit ausreichenden Berechtigungen kann ein Thread, der das Ziel eines `Abort` ist, den Abbruch mithilfe der `ResetAbort`-Methode abbrechen. Ein Beispiel für das Aufrufen der `ResetAbort`-Methode finden Sie in der `ThreadAbortException`-Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der abgebrochene Thread ist derzeit angehalten.</exception>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads und Threading</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Verwenden von Threads und Threading</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Zerstören von Threads</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stateInfo">Ein Objekt, das anwendungsspezifische Informationen enthält (z. B. über den Zustand), die vom abgebrochenen Thread verwendet werden können.</param>
        <summary>Löst eine <see cref="T:System.Threading.ThreadAbortException" /> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen. Gleichzeitig werden Ausnahmeinformationen über das Beenden des Threads bereitgestellt. Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode in einem Thread aufgerufen wird, löst das System eine <xref:System.Threading.ThreadAbortException> im Thread aus, um Sie abzubrechen. `ThreadAbortException` ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch am Ende des `catch` Blocks erneut ausgelöst wird, es sei denn, <xref:System.Threading.Thread.ResetAbort%2A> aufgerufen wird. `ResetAbort` bricht die Abbruch Anforderung ab und verhindert, dass der `ThreadAbortException` den Thread beendet. Nicht ausgeführte `finally` Blöcke werden ausgeführt, bevor der Thread abgebrochen wird.  
  
> [!NOTE]
>  Wenn ein Thread `Abort` auf sich selbst aufruft, ähnelt der Effekt dem Auslösen einer Ausnahme. der <xref:System.Threading.ThreadAbortException> erfolgt sofort, und das Ergebnis ist vorhersagbar. Wenn jedoch ein Thread `Abort` in einem anderen Thread aufruft, unterbricht der Abbruch den Code, der ausgeführt wird. Es besteht die Möglichkeit, dass ein statischer Konstruktor abgebrochen werden kann. In seltenen Fällen kann dies verhindern, dass Instanzen dieser Klasse in dieser Anwendungsdomäne erstellt werden. In den .NET Framework Versionen 1,0 und 1,1 besteht die Möglichkeit, dass der Thread abgebrochen wird, während ein `finally` Block ausgeführt wird. in diesem Fall wird der `finally` Block abgebrochen.  
  
 Es ist nicht garantiert, dass der Thread sofort oder überhaupt abgebrochen wird. Diese Situation kann eintreten, wenn ein Thread eine unbegrenzte Menge an Berechnung in den `finally` Blöcken ausführt, die im Rahmen der Abbruch Prozedur aufgerufen werden, wodurch der Abbruch unbegrenzt verzögert wird. Um zu warten, bis ein Thread abgebrochen wurde, können Sie die <xref:System.Threading.Thread.Join%2A>-Methode für den Thread aufrufen, nachdem Sie die <xref:System.Threading.Thread.Abort%2A>-Methode aufgerufen haben. es gibt jedoch keine Garantie, dass der Warte Vorgang beendet wird.  
  
> [!NOTE]
>  Der Thread, der <xref:System.Threading.Thread.Abort%2A> aufruft, kann blockieren, wenn sich der abgebrochene Thread in einem geschützten Bereich von Code befindet, z. b. einem `catch` Block, einem `finally` Block oder einem eingeschränkten Ausführungs Bereich. Wenn der Thread, der <xref:System.Threading.Thread.Abort%2A> aufruft, eine Sperre besitzt, die der abgebrochene Thread erfordert, kann ein Deadlock auftreten.  
  
 Wenn `Abort` für einen Thread aufgerufen wird, der noch nicht gestartet wurde, wird der Thread abgebrochen, wenn <xref:System.Threading.Thread.Start%2A> aufgerufen wird. Wenn `Abort` für einen Thread aufgerufen wird, der blockiert ist oder sich im Ruhezustand befindet, wird der Thread unterbrochen und dann abgebrochen.  
  
 Wenn `Abort` für einen Thread aufgerufen wird, der angehalten wurde, wird ein <xref:System.Threading.ThreadStateException> in dem Thread ausgelöst, der <xref:System.Threading.Thread.Abort%2A>aufgerufen hat, und <xref:System.Threading.ThreadState.AbortRequested> der <xref:System.Threading.Thread.ThreadState%2A>-Eigenschaft des abzugebrochenen Threads hinzugefügt. Eine <xref:System.Threading.ThreadAbortException> wird nicht im angehaltenen Thread ausgelöst, bis <xref:System.Threading.Thread.Resume%2A> aufgerufen wird.  
  
 Wenn `Abort` für einen verwalteten Thread aufgerufen wird, während er nicht verwalteten Code ausführt, wird ein `ThreadAbortException` erst ausgelöst, wenn der Thread an verwalteten Code zurückgegeben wird.  
  
 Wenn zwei Aufrufe von `Abort` gleichzeitig erfolgen, ist es möglich, dass ein Aufruf die Zustandsinformationen und den anderen Aufruf zum Ausführen des `Abort`einrichtet. Diese Situation kann jedoch von einer Anwendung nicht erkannt werden.  
  
 Nachdem `Abort` in einem Thread aufgerufen wurde, enthält der Thread Zustand <xref:System.Threading.ThreadState.AbortRequested>. Nachdem der Thread aufgrund eines erfolgreichen Aufrufes `Abort`beendet wurde, wird der Status des Threads in <xref:System.Threading.ThreadState.Stopped>geändert. Mit ausreichenden Berechtigungen kann ein Thread, der das Ziel eines `Abort` ist, den Abbruch mithilfe der `ResetAbort`-Methode abbrechen. Ein Beispiel für das Aufrufen der `ResetAbort`-Methode finden Sie in der `ThreadAbortException`-Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Informationen an einen Thread übergeben werden, der abgebrochen wird.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der abgebrochene Thread ist derzeit angehalten.</exception>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads und Threading</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Verwenden von Threads und Threading</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Zerstören von Threads</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reserviert einen unbenannten Datenslot für alle Threads. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Der reservierte benannte Datenslot für alle Threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots. Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Der Slot wird allen Threads zugeordnet.  
  
 Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten. Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu. Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot wieder verwenden, nachdem der Thread abläuft. Daten Slots sind pro Thread eindeutig. Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern. Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.  
  
 **Erstes Beispiel**  
  
 Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können. Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweites Beispiel**  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie einen Datenslot zum Speichern Thread spezifischer Informationen verwenden.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads und Threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu reservierenden Datenslots.</param>
        <summary>Reserviert einen benannten Datenslot für alle Threads. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Der reservierte benannte Datenslot für alle Threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots. Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten. Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu. Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot wieder verwenden, nachdem der Thread abläuft. Daten Slots sind pro Thread eindeutig. Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.  
  
 Es ist nicht erforderlich, die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A>-Methode zu verwenden, um einen benannten Datenslot zuzuordnen, da die <xref:System.Threading.Thread.GetNamedDataSlot%2A>-Methode den Slot zuordnet, wenn er noch nicht zugeordnet wurde.  
  
> [!NOTE]
>  Wenn die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A>-Methode verwendet wird, sollte Sie im Haupt Thread beim Programmstart aufgerufen werden, da Sie eine Ausnahme auslöst, wenn bereits ein Slot mit dem angegebenen Namen zugewiesen wurde. Es gibt keine Möglichkeit, zu testen, ob ein Slot bereits zugeordnet wurde.  
  
 Mit dieser Methode zugeordnete Slots müssen mit <xref:System.Threading.Thread.FreeNamedDataSlot%2A>freigegeben werden.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern. Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.  
  
 **Erstes Beispiel**  
  
 Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können. Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweites Beispiel**  
  
 Im folgenden Beispiel wird veranschaulicht, wie ein benannter Datenslot verwendet wird, um Thread spezifische Informationen zu speichern.  
  
> [!NOTE]
>  Der Beispielcode verwendet nicht die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A>-Methode, da die <xref:System.Threading.Thread.GetNamedDataSlot%2A>-Methode den Slot zuordnet, wenn er noch nicht zugeordnet wurde. Wenn die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A>-Methode verwendet wird, sollte Sie im Haupt Thread beim Programmstart aufgerufen werden.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es ist bereits ein benannter Datenslot mit dem angegebenen Namen vorhanden.</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads und Threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Apartmentzustand dieses Threads ab oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Threading.ApartmentState" />-Werte. Der Anfangswert ist <see langword="Unknown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Die <xref:System.Threading.Thread.ApartmentState%2A>-Eigenschaft ist veraltet.**  Die nicht veralteten Alternativen sind die <xref:System.Threading.Thread.GetApartmentState%2A> Methode zum Abrufen des Apartment Zustands und die <xref:System.Threading.Thread.SetApartmentState%2A>-Methode, um den Apartment Zustand festzulegen.  
  
 In den .NET Framework Versionen 1,0 und 1,1 markiert die `ApartmentState`-Eigenschaft einen Thread, um anzugeben, dass er in einem Single Thread-oder Multithread-Apartment ausgeführt wird. Diese Eigenschaft kann festgelegt werden, wenn sich der Thread im `Unstarted` oder `Running` Thread Zustand befindet. Sie kann jedoch nur einmal für einen Thread festgelegt werden. Wenn die Eigenschaft nicht festgelegt wurde, wird `Unknown`zurückgegeben.  
  
 Der Versuch, die <xref:System.Threading.Thread.ApartmentState%2A>-Eigenschaft zu verwenden, um den Apartment Zustand eines Threads festzulegen, dessen Apartment Zustand bereits festgelegt wurde, wird ignoriert. Die <xref:System.Threading.Thread.SetApartmentState%2A>-Methode löst in diesem Fall jedoch eine <xref:System.InvalidOperationException> aus.  
  
> [!IMPORTANT]
>  In der .NET Framework Version 2,0 werden neue Threads als <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> initialisiert, wenn der Apartment Zustand nicht festgelegt wurde, bevor Sie gestartet werden. Der Haupt Anwendungs Thread wird initialisiert, um standardmäßig <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>. Der Hauptanwendungs Thread kann nicht mehr auf <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> festgelegt werden, indem die <xref:System.Threading.ApartmentState?displayProperty=nameWithType>-Eigenschaft in der ersten Codezeile festgelegt wird. Verwenden Sie stattdessen die-<xref:System.STAThreadAttribute>.  
  
 In der .NET Framework Version 2,0 können Sie das COM-Threading Modell für eine C++ Anwendung mithilfe der [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](/cpp/build/reference/clrthreadattribute-set-clr-thread-attribute) -Linkeroption angeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie der Apartment Zustand eines Threads festgelegt wird.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wird versucht, diese Eigenschaft in einen Zustand zu versetzen, der kein gültiger Apartmentzustand ist, d. h. in einen anderen Zustand als Singlethread-Apartment (<see langword="STA" />) oder Multithread-Apartment (<see langword="MTA" />).</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass die Ausführung im Begriff ist, zu einem Codebereich überzugehen, in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme andere Aufgaben in der Anwendungsdomäne gefährden könnten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosts des Common Language Runtime (CLR), z. b. Microsoft SQL Server 2005, können unterschiedliche Richtlinien für Fehler in kritischen und nicht kritischen Codebereichen einrichten. Eine kritische Region ist eine Region, in der die Auswirkungen eines Thread Abbruchs oder einer nicht behandelten Ausnahme möglicherweise nicht auf die aktuelle Aufgabe beschränkt sind. Im Gegensatz dazu wirkt sich ein Abbruch oder Fehler in einem nicht kritischen Code Bereich nur auf die Aufgabe aus, in der der Fehler auftritt.  
  
 Stellen Sie sich z. b. einen Task vor, der versucht, während einer Sperre Speicher zuzuweisen. Wenn die Speicher Belegung fehlschlägt, reicht das Abbrechen der aktuellen Aufgabe nicht aus, um die Stabilität des <xref:System.AppDomain>zu gewährleisten, weil in der Domäne andere Tasks vorhanden sein können, die auf die gleiche Sperre warten. Wenn die aktuelle Aufgabe beendet wird, können andere Aufgaben blockiert werden.  
  
 Wenn ein Fehler in einer kritischen Region auftritt, kann der Host die gesamte <xref:System.AppDomain> entladen, anstatt das Risiko der Fortsetzung der Ausführung in einem potenziell instabilen Zustand zu nehmen. Um den Host zu informieren, dass der Code in einen kritischen Bereich wechselt, wenden Sie <xref:System.Threading.Thread.BeginCriticalRegion%2A>an. Ruft <xref:System.Threading.Thread.EndCriticalRegion%2A> auf, wenn die Ausführung in einen nicht kritischen Code Bereich zurückkehrt.  
  
 Wenn Sie diese Methode in Code verwenden, der unter SQL Server 2005 ausgeführt wird, muss der Code auf der höchsten Host Schutz Ebene ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Methoden <xref:System.Threading.Thread.BeginCriticalRegion%2A> und <xref:System.Threading.Thread.EndCriticalRegion%2A> verwendet werden, um einen Codeblock in kritische und nicht kritische Bereiche aufzuteilen.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass verwalteter Code im Begriff ist, Anweisungen auszuführen, die von der Identität des aktuellen physischen Betriebssystemthreads abhängen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Hosts der Common Language Runtime, z. b. Microsoft SQL Server 2005, stellen eine eigene Thread Verwaltung bereit. Ein Host, der die eigene Thread Verwaltung bereitstellt, kann eine ausgeführte Aufgabe jederzeit von einem physischen Betriebssystem Thread zu einem anderen verschieben. Die meisten Aufgaben sind von diesem Wechsel nicht betroffen. Einige Tasks verfügen jedoch über Thread Affinität, d. h., Sie hängen von der Identität eines physischen Betriebssystemthreads ab. Diese Tasks müssen den Host benachrichtigen, wenn Sie Code ausführen, der nicht gewechselt werden soll.  
  
 Wenn Ihre Anwendung z. b. eine System-API aufruft, um eine Betriebssystem Sperre mit Thread Affinität (z. b. eine Win32-CRITICAL_SECTION abzurufen), müssen Sie <xref:System.Threading.Thread.BeginThreadAffinity%2A> vor dem Erwerb der Sperre aufrufen und <xref:System.Threading.Thread.EndThreadAffinity%2A>, nachdem die Sperre freigegeben wurde.  
  
 Wenn Sie diese Methode in Code verwenden, der unter SQL Server 2005 ausgeführt wird, muss der Code auf der höchsten Host Schutz Ebene ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Methoden <xref:System.Threading.Thread.BeginThreadAffinity%2A> und <xref:System.Threading.Thread.EndThreadAffinity%2A> verwendet werden, um einen Host zu benachrichtigen, dass ein Codeblock von der Identität eines physischen Betriebssystemthreads abhängig ist.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktuellen Kontext ab, in dem der Thread ausgeführt wird.</summary>
        <value>Ein <see cref="T:System.Runtime.Remoting.Contexts.Context" /> der den aktuellen Kontext des Threads darstellt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kultur für den aktuellen Thread ab oder legt diese fest.</summary>
        <value>Ein Objekt, das die Kultur für den aktuellen Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Globalization.CultureInfo> Objekt, das von dieser Eigenschaft zusammen mit den zugeordneten Objekten zurückgegeben wird, bestimmt das Standardformat für Datumsangaben, Uhrzeiten, Ziffern, Währungswerte, Sortierreihenfolge von Text, Schreib Konventionen und Zeichen folgen Vergleiche. Sehen Sie sich die <xref:System.Globalization.CultureInfo>-Klasse an, um mehr über Kultur Namen und Bezeichner zu erfahren, die Unterschiede zwischen invarianten, neutralen und bestimmten Kulturen und die Art und Weise, wie Kultur Informationen Auswirkungen auf Threads und Anwendungs Domänen Sehen Sie sich die <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>-Eigenschaft an, um zu erfahren, wie die Standard Kultur eines Threads bestimmt wird und wie Benutzer Kultur Informationen für Ihre Computer festlegen.  

> [!IMPORTANT]
> Die <xref:System.Threading.Thread.CurrentCulture>-Eigenschaft funktioniert nicht zuverlässig, wenn Sie mit einem anderen Thread als dem aktuellen Thread verwendet wird. In .NET Framework ist das Lesen der Eigenschaft zuverlässig, auch wenn Sie für einen anderen Thread als den aktuellen Thread festgelegt wird. Unter .net Core wird eine <xref:System.InvalidOperationException> ausgelöst, wenn ein Thread versucht, die <xref:System.Threading.Thread.CurrentCulture>-Eigenschaft in einem anderen Thread zu lesen oder zu schreiben.
> Es wird empfohlen, dass Sie die <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType>-Eigenschaft verwenden, um die aktuelle Kultur abzurufen und festzulegen.

 Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]können Sie die <xref:System.Threading.Thread.CurrentCulture%2A>-Eigenschaft auf eine neutrale Kultur festlegen. Dies liegt daran, dass sich das Verhalten der <xref:System.Globalization.CultureInfo> Klasse geändert hat: Wenn es sich um eine neutrale Kultur handelt, entsprechen seine Eigenschaftswerte (insbesondere die Eigenschaften <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>und <xref:System.Globalization.CultureInfo.TextInfo%2A>) jetzt der spezifischen Kultur, die der neutralen Kultur zugeordnet ist. In früheren Versionen des .NET Framework hat die <xref:System.Threading.Thread.CurrentCulture%2A>-Eigenschaft eine <xref:System.NotSupportedException> Ausnahme ausgelöst, als eine neutrale Kultur zugewiesen wurde.  
  
## Examples  
 Das folgende Beispiel zeigt die Threading-Anweisung, mit der die Benutzeroberfläche einer Windows Forms Anwendung in der in der Systemsteuerung festgelegten Kultur angezeigt werden kann. Zusätzlicher Code ist erforderlich.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Eigenschaft ist auf <see langword="null" /> festgelegt.</exception>
        <exception cref="T:System.InvalidOperationException">Nur .NET Core: Das Lesen oder Schreiben der Kultur eines Threads aus einem anderen Thread wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktuellen Prinzipal des Threads (für rollenbasierte Sicherheit) ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Security.Principal.IPrincipal" />-Wert, der den Sicherheitskontext darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Prinzipal eines Threads festgelegt und abgerufen wird.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung zum Festlegen des Prinzipals.</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den derzeit ausgeführten Thread ab.</summary>
        <value>Ein <see cref="T:System.Threading.Thread" />, der den derzeit ausgeführten Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine Aufgabe erstellt, die wiederum 20 untergeordnete Aufgaben erstellt. Die Anwendung selbst und jede Aufgabe ruft die `ShowThreadInformation`-Methode auf, die die <xref:System.Threading.Thread.CurrentThread%2A>-Eigenschaft verwendet, um Informationen über den Thread anzuzeigen, in dem Sie ausgeführt wird.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Jede untergeordnete Aufgabe generiert 1 Million Zufallszahlen zwischen 1 und 1 Million und gibt ihren Mittelwert zurück. Die übergeordnete Aufgabe ruft die <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>-Methode auf, um sicherzustellen, dass die untergeordneten Aufgaben abgeschlossen wurden, bevor der von den einzelnen Aufgaben zurückgegebene Mittelwert und der Mittelwert der Mittelwert  
  
 Beachten Sie, dass die Anwendung in einem Thread Pool Thread ausgeführt wird, während die Anwendung auf einem Vordergrund Thread ausgeführt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Kultur ab, mit deren Hilfe der Ressourcen-Manager zur Laufzeit kulturabhängige Ressourcen sucht, oder legt diese fest.</summary>
        <value>Ein Objekt, das die aktuelle Kultur darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Benutzeroberflächen Kultur gibt die Ressourcen an, die eine Anwendung benötigt, um Benutzereingaben und-Ausgaben zu unterstützen, und ist standardmäßig identisch mit der Kultur des Betriebssystems. Sehen Sie sich die <xref:System.Globalization.CultureInfo>-Klasse an, um mehr über Kultur Namen und Bezeichner zu erfahren, die Unterschiede zwischen invarianten, neutralen und bestimmten Kulturen und die Art und Weise, wie Kultur Informationen Auswirkungen auf Threads und Anwendungs Domänen Informationen dazu, wie die Standardbenutzer Oberflächen Kultur eines Threads bestimmt wird, finden Sie unter der <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>-Eigenschaft.  

> [!IMPORTANT]
> Die <xref:System.Threading.Thread.CurrentUICulture>-Eigenschaft funktioniert nicht zuverlässig, wenn Sie mit einem anderen Thread als dem aktuellen Thread verwendet wird. In .NET Framework ist das Lesen der Eigenschaft zuverlässig, auch wenn Sie für einen anderen Thread als den aktuellen Thread festgelegt wird. Unter .net Core wird eine <xref:System.InvalidOperationException> ausgelöst, wenn ein Thread versucht, die <xref:System.Threading.Thread.CurrentUICulture>-Eigenschaft in einem anderen Thread zu lesen oder zu schreiben.
> Es wird empfohlen, dass Sie die <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType>-Eigenschaft verwenden, um die aktuelle Kultur abzurufen und festzulegen.

 Die von dieser Eigenschaft zurückgegebene <xref:System.Globalization.CultureInfo> kann eine neutrale Kultur sein. Neutrale Kulturen sollten nicht mit Formatierungs Methoden wie <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>und <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>verwendet werden. Verwenden Sie die <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>-Methode, um eine bestimmte Kultur zu erhalten, oder verwenden Sie die <xref:System.Threading.Thread.CurrentCulture%2A>-Eigenschaft.  
  
> [!NOTE]
>  Die <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>-Methode löst <xref:System.ArgumentException> für die neutralen Kulturen "zh-Hant" ("zh-CHT") und "zh-Hans" ("zh-CHS") aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob die Sprache der Benutzeroberflächen Kultur des aktuellen Threads Französisch ist. Wenn dies nicht der Fall ist, wird die Benutzeroberflächen Kultur des aktuellen Threads auf Englisch (USA) festgelegt.  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 Das folgende Codebeispiel zeigt die Threading-Anweisung, mit der die Benutzeroberfläche einer Windows Forms in der in der Systemsteuerung festgelegten Kultur angezeigt werden kann. Zusätzlicher Code ist erforderlich.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Eigenschaft ist auf <see langword="null" /> festgelegt.</exception>
        <exception cref="T:System.ArgumentException">Die Eigenschaft ist auf einen Kulturnamen festgelegt, der nicht zum Suchen einer Ressourcendatei verwendet werden kann. Ressourcendateinamen dürfen nur Buchstaben, Zahlen, Bindestriche oder Unterstriche enthalten.</exception>
        <exception cref="T:System.InvalidOperationException">Nur .NET Core: Das Lesen oder Schreiben der Kultur eines Threads aus einem anderen Thread wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deaktiviert die automatische Bereinigung von Runtime Callable Wrappern (RCW) für den aktuellen Thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig bereinigt der Common Language Runtime (CLR) automatisch aufrufbare Wrapper für die Laufzeit. Die CLR bereinigt Nachrichten während der Bereinigung, was zu Problemen bei einigen Anwendungen führen kann, die die folgenden ungewöhnlichen Kriterien erfüllen:  
  
-   Die Anwendung führt eine eigene Nachrichten Pumpe aus.  
  
-   Die Anwendung muss genau steuern, wann das Senden von Nachrichten erfolgt.  
  
 Solche Anwendungen können die <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A>-Methode verwenden, um zu verhindern, dass die CLR automatische Wiederherstellung von Runtime Callable Wrappern durchführen kann.  
  
 Wenn diese Methode für einen Thread aufgerufen wurde, kann der automatische Bereinigung für diesen Thread nicht erneut aktiviert werden. Wenn Ihre Anwendung für die Bereinigung von Runtime Callable Wrapper bereit ist, verwenden Sie die <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType>-Methode, um die Laufzeit anzuweisen, alle Runtime Callable Wrapper im aktuellen Kontext zu bereinigen. Das Senden von Nachrichten erfolgt während der Ausführung der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass die Ausführung im Begriff ist, zu einem Codebereich überzugehen, in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme auf die aktuelle Aufgabe beschränkt sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosts des Common Language Runtime (CLR), z. b. Microsoft SQL Server 2005, können unterschiedliche Richtlinien für Fehler in kritischen und nicht kritischen Codebereichen einrichten. Eine kritische Region ist eine Region, in der die Auswirkungen eines Thread Abbruchs oder einer nicht behandelten Ausnahme möglicherweise nicht auf die aktuelle Aufgabe beschränkt sind. Im Gegensatz dazu wirkt sich ein Abbruch oder Fehler in einem nicht kritischen Code Bereich nur auf die Aufgabe aus, in der der Fehler auftritt.  
  
 Stellen Sie sich z. b. einen Task vor, der versucht, während einer Sperre Speicher zuzuweisen. Wenn die Speicher Belegung fehlschlägt, reicht das Abbrechen der aktuellen Aufgabe nicht aus, um die Stabilität des <xref:System.AppDomain>zu gewährleisten, weil in der Domäne andere Tasks vorhanden sein können, die auf die gleiche Sperre warten. Wenn die aktuelle Aufgabe beendet wird, können andere Aufgaben blockiert werden.  
  
 Wenn ein Fehler in einer kritischen Region auftritt, kann der Host die gesamte <xref:System.AppDomain> entladen, anstatt das Risiko der Fortsetzung der Ausführung in einem potenziell instabilen Zustand zu nehmen. Um den Host zu informieren, dass der Code in einen kritischen Bereich wechselt, wenden Sie <xref:System.Threading.Thread.BeginCriticalRegion%2A>an. Ruft <xref:System.Threading.Thread.EndCriticalRegion%2A> auf, wenn die Ausführung in einen nicht kritischen Code Bereich zurückkehrt.  
  
 Wenn Sie diese Methode in Code verwenden, der unter SQL Server 2005 ausgeführt wird, muss der Code auf der höchsten Host Schutz Ebene ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Methoden <xref:System.Threading.Thread.BeginCriticalRegion%2A> und <xref:System.Threading.Thread.EndCriticalRegion%2A> verwendet werden, um einen Codeblock in kritische und nicht kritische Bereiche aufzuteilen.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass verwalteter Code die Ausführung von Anweisungen beendet hat, die von der Identität des aktuellen physischen Betriebssystemthreads abhängen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Hosts der Common Language Runtime, z. b. Microsoft SQL Server 2005, stellen eine eigene Thread Verwaltung bereit. Ein Host, der die eigene Thread Verwaltung bereitstellt, kann eine ausgeführte Aufgabe jederzeit von einem physischen Betriebssystem Thread zu einem anderen verschieben. Die meisten Aufgaben sind von diesem Wechsel nicht betroffen. Einige Tasks verfügen jedoch über Thread Affinität, d. h., Sie hängen von der Identität eines physischen Betriebssystemthreads ab. Diese Tasks müssen den Host benachrichtigen, wenn Sie Code ausführen, der nicht gewechselt werden soll.  
  
 Wenn Ihre Anwendung z. b. eine System-API aufruft, um eine Betriebssystem Sperre mit Thread Affinität (z. b. eine Win32-CRITICAL_SECTION abzurufen), müssen Sie <xref:System.Threading.Thread.BeginThreadAffinity%2A> vor dem Erwerb der Sperre aufrufen und <xref:System.Threading.Thread.EndThreadAffinity%2A>, nachdem die Sperre freigegeben wurde.  
  
 Wenn Sie diese Methode in Code verwenden, der unter SQL Server 2005 ausgeführt wird, muss der Code auf der höchsten Host Schutz Ebene ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Methoden <xref:System.Threading.Thread.BeginThreadAffinity%2A> und <xref:System.Threading.Thread.EndThreadAffinity%2A> verwendet werden, um einen Host zu benachrichtigen, dass ein Codeblock von der Identität eines physischen Betriebssystemthreads abhängig ist.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.ExecutionContext" />-Objekt ab, das Informationen zu den verschiedenen Kontexten des aktuellen Threads enthält.</summary>
        <value>Ein <see cref="T:System.Threading.ExecutionContext" />-Objekt, das Kontextinformationen für den aktuellen Thread konsolidiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.ExecutionContext>-Klasse stellt einen einzelnen Container für alle Informationen bereit, die für einen logischen Ausführungs Thread relevant sind. Dies schließt den Sicherheitskontext, den Rückruf Kontext, den Synchronisierungs Kontext, den Lokalisierungs Kontext und den Transaktionskontext ein.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt das Freigeben von Ressourcen und das Ausführen anderer Garbage Collector-Vorgänge sicher, wenn der Garbage Collector das <see cref="T:System.Threading.Thread" />-Objekt verarbeitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Garbage Collector ruft <xref:System.Threading.Thread.Finalize%2A> auf, wenn das aktuelle-Objekt für die Fertigstellung bereit ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des freizugebenden Datenslots.</param>
        <summary>Entfernt die Zuordnung zwischen einem Namen und einem Slot für alle Threads in dem Prozess. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots. Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Nachdem ein Thread `FreeNamedDataSlot`aufgerufen hat, weist jeder andere Thread, der <xref:System.Threading.Thread.GetNamedDataSlot%2A> mit demselben Namen aufruft, einen neuen Slot zu, der mit dem Namen verknüpft ist. Nachfolgende Aufrufe von, die von einem beliebigen Thread `GetNamedDataSlot` werden, geben den neuen Slot zurück. Allerdings kann jeder Thread, der noch über einen <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> verfügt, der von einem früheren `GetNamedDataSlot` zurückgegeben wurde, weiterhin den alten Slot verwenden.  
  
 Ein Slot, dem ein Name zugeordnet ist, wird nur freigegeben, wenn jede `LocalDataStoreSlot`, die vor dem `FreeNamedDataSlot` aufgerufen wurde, freigegeben wurde und eine Garbage Collection durchgeführt wurde.  
  
 Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten. Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu. Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot wieder verwenden, nachdem der Thread abläuft. Daten Slots sind pro Thread eindeutig. Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern. Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.  
  
 **Erstes Beispiel**  
  
 Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können. Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweites Beispiel**  
  
 Im folgenden Beispiel wird veranschaulicht, wie ein benannter Datenslot verwendet wird, um Thread spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads und Threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Threading.ApartmentState" />-Wert zurück, der den Apartmentzustand angibt.</summary>
        <returns>Einer der <see cref="T:System.Threading.ApartmentState" />-Werte, der den Apartmentzustand des verwalteten Threads angibt. Der Standardwert lautet <see cref="F:System.Threading.ApartmentState.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ersetzt zusammen mit der <xref:System.Threading.Thread.SetApartmentState%2A>-Methode und der <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode die <xref:System.Threading.Thread.ApartmentState%2A>-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Methoden <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>und <xref:System.Threading.Thread.TrySetApartmentState%2A> veranschaulicht. Im Codebeispiel wird ein Thread erstellt. Bevor der Thread gestartet wird, zeigt <xref:System.Threading.Thread.GetApartmentState%2A> den anfänglichen <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> Status an, und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Status in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode gibt dann `false` zurück, wenn versucht wird, den Zustand in <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> zu ändern, da der Apartment Zustand bereits festgelegt ist. Wenn der gleiche Vorgang mit <xref:System.Threading.Thread.SetApartmentState%2A>versucht wurde, wurde <xref:System.InvalidOperationException> ausgelöst.  
  
 Nachdem der Thread gestartet wurde, wird die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode erneut verwendet. Dieses Mal wird <xref:System.Threading.ThreadStateException> ausgelöst, da der Thread bereits gestartet wurde.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Threading.CompressedStack" />-Objekt zurück, mit dem der Stapel für den aktuellen Thread erfasst werden kann.</summary>
        <returns>None.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird nicht mehr unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine ID ab, mit der angegeben wird, mit welchem Prozessor der aktuelle Thread ausgeführt wird.</summary>
        <returns>Ein Integerwert, der die zwischengespeicherte Prozessor-ID darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Dieser Wert wird zwischengespeichert und regelmäßig aktualisiert. Sie ist möglicherweise veraltet, wenn Sie verwendet wird: das Verarbeiten von Code darf sich nicht auf seine Richtigkeit der Richtigkeit verlassen.

Es ist nicht garantiert, dass der Wert eine Null basierte Prozessornummer ist.

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="slot">Der <see cref="T:System.LocalDataStoreSlot" />, aus dem der Wert abgerufen werden soll.</param>
        <summary>Ruft in der aktuellen Domäne des aktuellen Threads den Wert aus dem angegebenen Slot für den aktuellen Thread ab. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Der abgerufene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots. Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten. Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu. Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot wieder verwenden, nachdem der Thread abläuft. Daten Slots sind pro Thread eindeutig. Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> ist eine `Shared` Methode, die immer auf den derzeit ausgeführten Thread angewendet wird, auch wenn Sie ihn mit einer Variablen, die auf einen anderen Thread verweist, aufruft. Um Verwirrung zu vermeiden, verwenden Sie den Klassennamen, wenn Sie `Shared` Methoden aufrufen: `Dim test As Object = Thread.GetData(testSlot)`.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern. Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.  
  
 **Erstes Beispiel**  
  
 Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können. Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweites Beispiel**  
  
 Im folgenden Beispiel wird veranschaulicht, wie ein Daten Slot zum Speichern Thread spezifischer Informationen verwendet wird.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads und Threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die aktuelle Domäne zurück, in der der aktuelle Thread ausgeführt wird.</summary>
        <returns>Eine <see cref="T:System.AppDomain" />, die die aktuelle Anwendungsdomäne des ausgeführten Threads darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Name und die ID des `AppDomain` abgerufen werden, in dem der Thread ausgeführt wird.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen eindeutigen Bezeichner der Anwendungsdomäne zurück.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, mit der die Anwendungsdomäne eindeutig bezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Name und die ID des `AppDomain` abgerufen werden, in dem der Thread ausgeführt wird.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashcode für den aktuellen Thread zurück.</summary>
        <returns>Ein ganzzahliger Hashcodewert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Hashcode ist nicht garantiert eindeutig. Verwenden Sie die <xref:System.Threading.Thread.ManagedThreadId%2A>-Eigenschaft, wenn Sie einen eindeutigen Bezeichner für einen verwalteten Thread benötigen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des lokalen Datenslots.</param>
        <summary>Sucht einen benannten Datenslot. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Ein für diesen Thread reservierter <see cref="T:System.LocalDataStoreSlot" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots. Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten. Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu. Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot wieder verwenden, nachdem der Thread abläuft. Daten Slots sind pro Thread eindeutig. Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.  
  
 Wenn der benannte Slot nicht vorhanden ist, wird ein neuer Slot zugeordnet. Benannte Daten Slots sind öffentlich und können von beliebigen Personen bearbeitet werden.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern. Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.  
  
 **Erstes Beispiel**  
  
 Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können. Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweites Beispiel**  
  
 Im folgenden Beispiel wird veranschaulicht, wie ein benannter Datenslot verwendet wird, um Thread spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads und Threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterbricht einen Thread, der sich im <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />-Threadzustand befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser Thread momentan nicht in einem Wartezustand, Standbymodus oder joinzustand blockiert ist, wird er beim nächsten Block Vorgang unterbrochen.  
  
 <xref:System.Threading.ThreadInterruptedException> wird im unterbrochenen Thread ausgelöst, jedoch nicht, bis der Thread blockiert wird. Wenn der Thread nie blockiert wird, wird die Ausnahme nie ausgelöst, und der Thread wird daher möglicherweise beendet, ohne jemals unterbrochen zu werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Verhalten eines ausgelaufenden Threads veranschaulicht, wenn er unterbrochen und anschließend blockiert wird.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die geeignete <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Anhalten und Unterbrechen von Threads</related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den Ausführungsstatus des aktuellen Threads angibt.</summary>
        <value><see langword="true" />, wenn dieser Thread gestartet und ordnungsgemäß beendet bzw. abgebrochen wurde, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob es sich bei einem Thread um einen Hintergrundthread handelt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn dieser Thread ein Hintergrundthread ist oder zu einem solchen wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread ist entweder ein Hintergrund Thread oder ein Vordergrund Thread. Hintergrundthreads sind mit Vorder grundthreads identisch, mit der Ausnahme, dass Hintergrundthreads nicht verhindern, dass ein Prozess beendet wird. Nachdem alle für einen Prozess gehörenden Vordergrundthreads beendet wurden, beendet der Common Language Runtime den Prozess. Alle verbleibenden Hintergrundthreads werden beendet und werden nicht beendet.  
  
 Standardmäßig werden die folgenden Threads im Vordergrund ausgeführt (d. h., ihre <xref:System.Threading.Thread.IsBackground%2A>-Eigenschaft gibt `false`zurück):  
  
-   Der primäre Thread (oder Hauptanwendungs Thread).  
  
-   Alle Threads, die durch Aufrufen eines <xref:System.Threading.Thread>-Klassenkonstruktors erstellt werden.  
  
 Standardmäßig werden die folgenden Threads im Hintergrund ausgeführt (d. h., ihre <xref:System.Threading.Thread.IsBackground%2A>-Eigenschaft gibt `true`zurück):  
  
-   Thread Poolthreads, bei denen es sich um einen Pool von Arbeitsthreads handelt, die von der Laufzeit verwaltet werden. Sie können den Thread Pool konfigurieren und Arbeitsaufgaben in Thread Pool-Threads planen, indem Sie die <xref:System.Threading.ThreadPool>-Klasse verwenden.  
  
    > [!NOTE]
    >  Aufgabenbasierte asynchrone Vorgänge werden automatisch in Thread Pool-Threads ausgeführt.  
  
-   Alle Threads, die aus nicht verwaltetem Code in die verwaltete Ausführungsumgebung eintreten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Verhalten von Vordergrund-und Hintergrundthreads gegenüberstellen. Er erstellt einen Vordergrund Thread und einen Hintergrund Thread. Der Vordergrund Thread sorgt dafür, dass der Prozess ausgeführt wird, bis die `for` Schleife abgeschlossen und beendet wird. Wie die Ausgabe aus dem Beispiel zeigt, wird der Prozess beendet, bevor der Hintergrund Thread die Ausführung abgeschlossen hat, da der Vordergrund Thread die Ausführung abgeschlossen hat.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread ist deaktiviert.</exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md">Vordergrund- und Hintergrundthreads</related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Thread zu dem verwalteten Threadpool gehört.</summary>
        <value><see langword="true" />, wenn der Thread zu dem verwalteten Threadpool gehört, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie [unter Managed Thread Pool](~/docs/standard/threading/the-managed-thread-pool.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ermittelt wird, ob ein Thread aus dem Thread Pool besteht.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blockiert den aufrufenden Thread, bis der durch diese Instanz dargestellte Thread beendet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blockiert den aufrufenden Thread, bis der durch diese Instanz dargestellte Thread beendet wird, während das Standard-COM- und das <see langword="SendMessage" />-Pumping fortgesetzt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. den Thread, der die-Methode aufruft) blockiert, bis der Thread, dessen <xref:System.Threading.Thread.Join%2A>-Methode aufgerufen wird, abgeschlossen ist. Verwenden Sie diese Methode, um sicherzustellen, dass ein Thread beendet wurde. Der Aufrufer blockiert unbegrenzt, wenn der Thread nicht beendet wird. Im folgenden Beispiel ruft der `Thread1` Thread die <xref:System.Threading.Thread.Join>-Methode von `Thread2`auf, die bewirkt, dass `Thread1` blockiert wird, bis `Thread2` abgeschlossen ist.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 Wenn der Thread bereits beendet wurde, wenn <xref:System.Threading.Thread.Join%2A> aufgerufen wird, wird die Methode sofort zurückgegeben.  
  
> [!WARNING]
>  Die <xref:System.Threading.Thread.Join%2A>-Methode des <xref:System.Threading.Thread> Objekts, das den aktuellen Thread darstellt, sollte nie aus dem aktuellen Thread aufgerufen werden. Dies bewirkt, dass Ihre APP nicht mehr reagiert, da der aktuelle Thread unbegrenzt auf sich selbst wartet,  
  
 Diese Methode ändert den Status des aufrufenden Threads, sodass er <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>einschließt. Sie können `Join` in einem Thread, der sich im <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> Zustand befindet, nicht aufrufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Aufrufer hat versucht, mit einem Thread zu verknüpfen, der den Zustand <see cref="F:System.Threading.ThreadState.Unstarted" /> hat.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread wird beim Warten unterbrochen.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl der Millisekunden, die auf das Beenden des Threads gewartet werden soll.</param>
        <summary>Blockiert den aufrufenden Thread, bis der von dieser Instanz dargestellte Thread beendet wird, oder die festgelegte Zeit verstreicht, während das Standard-COM- und das SendMessage-Pumping fortgesetzt werden.</summary>
        <returns><see langword="true" />, wenn der Thread beendet wurde. <see langword="false" />, wenn der Thread nach Ablauf des vom <paramref name="millisecondsTimeout" />-Parameter angegebenen Zeitraums nicht beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. den Thread, der die-Methode aufruft) blockiert, bis entweder der Thread, dessen <xref:System.Threading.Thread.Join%2A>-Methode aufgerufen wird, abgeschlossen ist oder das Timeout Intervall abgelaufen ist. Im folgenden Beispiel ruft der `Thread1` Thread die <xref:System.Threading.Thread.Join>-Methode von `Thread2`auf, wodurch `Thread1` blockiert wird, bis `Thread2` abgeschlossen ist oder 2 Sekunden abgelaufen sind.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 Wenn <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für den `millisecondsTimeout`-Parameter angegeben wird, verhält sich diese Methode identisch mit der <xref:System.Threading.Thread.Join>-Methoden Überladung, mit Ausnahme des Rückgabewerts.  
  
 Wenn der Thread bereits beendet wurde, wenn <xref:System.Threading.Thread.Join%2A> aufgerufen wird, wird die Methode sofort zurückgegeben.  
  
 Diese Methode ändert den Status des aufrufenden Threads, sodass er <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>einschließt. Sie können `Join` in einem Thread, der sich im <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> Zustand befindet, nicht aufrufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde nicht gestartet.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <exception cref="T:System.ArgumentException"><paramref name="millisecondsTimeout" /> ist kleiner als -1 (Timeout.Infinite).</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread wurde beim Warten unterbrochen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" />-Wert, der auf den Zeitraum festgelegt ist, während dessen auf das Beenden des Threads gewartet werden soll.</param>
        <summary>Blockiert den aufrufenden Thread, bis der von dieser Instanz dargestellte Thread beendet wird, oder die festgelegte Zeit verstreicht, während das Standard-COM- und das SendMessage-Pumping fortgesetzt werden.</summary>
        <returns><see langword="true" />, wenn der Thread beendet wurde. <see langword="false" />, wenn der Thread nach Ablauf des vom <paramref name="timeout" />-Parameter angegebenen Zeitraums nicht beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. den Thread, der die-Methode aufruft) blockiert, bis entweder der Thread, dessen <xref:System.Threading.Thread.Join%2A>-Methode aufgerufen wird, abgeschlossen ist oder das Timeout Intervall abgelaufen ist. Im folgenden Beispiel ruft der `Thread1` Thread die <xref:System.Threading.Thread.Join>-Methode von `Thread2`auf, wodurch `Thread1` blockiert wird, bis `Thread2` abgeschlossen ist oder 2 Sekunden abgelaufen sind.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 Wenn <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für `timeout`angegeben wird, verhält sich diese Methode identisch mit der <xref:System.Threading.Thread.Join>-Methoden Überladung, mit Ausnahme des Rückgabewerts.  
  
 Wenn der Thread bereits beendet wurde, wenn <xref:System.Threading.Thread.Join%2A> aufgerufen wird, wird die Methode sofort zurückgegeben.  
  
 Diese Methode ändert den Zustand des aktuellen Threads, sodass er <xref:System.Threading.ThreadState.WaitSleepJoin>enthält. Sie können `Join` in einem Thread, der sich im <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> Zustand befindet, nicht aufrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein `TimeSpan` Wert mit der `Join`-Methode verwendet wird.  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden oder größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Aufrufer hat versucht, mit einem Thread zu verknüpfen, der den Zustand <see cref="F:System.Threading.ThreadState.Unstarted" /> hat.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen eindeutigen Bezeichner für den aktuellen verwalteten Thread ab.</summary>
        <value>Eine Ganzzahl, die einen eindeutigen Bezeichner für diesen verwalteten Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Threading.Thread.ManagedThreadId%2A>-Eigenschafts Wert eines Threads dient zur eindeutigen Identifizierung des Threads innerhalb des Prozesses.  
  
 Der Wert der <xref:System.Threading.Thread.ManagedThreadId%2A>-Eigenschaft variiert nicht im Laufe der Zeit, auch wenn nicht verwalteter Code, der die Common Language Runtime hostet, den Thread als Fiber implementiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Der Prozessor, der den aktuellen Thread ausführt, kann Anweisungen nicht so neu anordnen, dass Speicherzugriffe vor dem Aufruf von <see cref="M:System.Threading.Thread.MemoryBarrier" /> nach Speicherzugriffen ausgeführt werden, die nach dem Aufruf von <see cref="M:System.Threading.Thread.MemoryBarrier" /> erfolgen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> ist nur auf Multiprozessorsystemen mit schwacher Arbeitsspeicher Anordnung erforderlich (z. b. ein System, das mehrere Intel Itanium-Prozessoren verwendet).  
  
 In den meisten Fällen bieten C# die `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung oder die <xref:System.Threading.Monitor>-Klasse einfachere Möglichkeiten zum Synchronisieren von Daten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Threads ab oder legt diesen fest.</summary>
        <value>Eine Zeichenfolge mit dem Namen des Threads, oder <see langword="null" />, wenn kein Name festgelegt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist "Write-Once". Da der Standardwert der <xref:System.Threading.Thread.Name%2A>-Eigenschaft eines Threads `null`ist, können Sie bestimmen, ob dem Thread bereits explizit ein Name zugewiesen wurde, indem Sie ihn mit `null`vergleichen.  
  
 Die der <xref:System.Threading.Thread.Name%2A>-Eigenschaft zugewiesene Zeichenfolge kann ein beliebiges Unicode-Zeichen enthalten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Thread benennen kann.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ein SET-Vorgang wurde angefordert, aber die <see langword="Name" />-Eigenschaft wurde bereits festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Planungspriorität eines Threads angibt, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Threading.ThreadPriority" />-Werte. Standardwert: <see cref="F:System.Threading.ThreadPriority.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einem Thread kann eine der folgenden Prioritäts <xref:System.Threading.ThreadPriority> Werte zugewiesen werden:  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 Betriebssysteme müssen nicht die Priorität eines Threads berücksichtigen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Ergebnis der Änderung der Priorität eines Threads. Es werden drei Threads erstellt, die Priorität eines Threads auf <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>festgelegt, und die Priorität einer Sekunde ist auf <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>festgelegt. Jeder Thread erhöht eine Variable in einer `while` Schleife und wird für eine festgelegte Zeit ausgeführt.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread hat einen Endzustand erreicht, z. B. <see cref="F:System.Threading.ThreadState.Aborted" />.</exception>
        <exception cref="T:System.ArgumentException">Der für einen SET-Vorgang festgelegte Wert ist kein gültiger <see cref="T:System.Threading.ThreadPriority" />-Wert.</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md">Scheduling von Threads</related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht ein <see cref="M:System.Threading.Thread.Abort(System.Object)" /> ab, das für den aktuellen Thread angefordert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nur von Code mit den entsprechenden Berechtigungen aufgerufen werden.  
  
 Wenn `Abort` aufgerufen wird, um einen Thread zu beenden, löst das System eine <xref:System.Threading.ThreadAbortException>aus. `ThreadAbortException` ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch am Ende des catch-Blocks erneut ausgelöst wird, es sei denn, `ResetAbort` aufgerufen wird. `ResetAbort` bricht die Abbruch Anforderung ab und verhindert, dass der `ThreadAbortException` den Thread beendet.  
  
 Ein Beispiel für das Aufrufen der `ResetAbort`-Methode finden Sie unter <xref:System.Threading.ThreadAbortException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
        <exception cref="T:System.Threading.ThreadStateException"><see langword="Abort" /> wurde für den aktuellen Thread nicht aufgerufen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Sicherheitsberechtigungen für den aktuellen Thread.</exception>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Zerstören von Threads</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt die Ausführung eines angehaltenen Threads wieder auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Verwenden Sie die Methoden <xref:System.Threading.Thread.Suspend%2A> und <xref:System.Threading.Thread.Resume%2A> nicht, um die Aktivitäten von Threads zu synchronisieren. Sie haben keine Möglichkeit, zu wissen, welcher Code von einem Thread ausgeführt wird, wenn Sie ihn aussetzen. Wenn Sie einen Thread aussetzen, während er während einer Bewertung der Sicherheits Berechtigung Sperren enthält, werden möglicherweise andere Threads in der <xref:System.AppDomain> blockiert. Wenn Sie einen Thread beim Ausführen eines Klassenkonstruktors aussetzen, werden andere Threads in der <xref:System.AppDomain>, die versuchen, diese Klasse zu verwenden, blockiert. Deadlocks können sehr einfach auftreten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde nicht gestartet, ist deaktiviert oder befindet sich nicht im angehaltenen Zustand.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die geeignete <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Anhalten und Unterbrechen von Threads</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="state">Der neue Apartmentzustand.</param>
        <summary>Legt den Apartmentzustand eines Threads fest, bevor dieser gestartet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Neue Threads werden als <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> initialisiert, wenn der Apartment Zustand nicht festgelegt wurde, bevor Sie gestartet werden. Der Apartment Zustand muss festgelegt werden, bevor ein Thread gestartet wird.  
  
> [!NOTE]
>  Der Haupt Anwendungs Thread wird initialisiert, um standardmäßig <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>. Der Apartment Zustand des Hauptanwendungs Threads kann nur auf <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> festgelegt werden, indem das <xref:System.STAThreadAttribute>-Attribut auf die Einstiegspunkt Methode angewendet wird.  
  
 Die <xref:System.Threading.Thread.SetApartmentState%2A>-Methode, zusammen mit der <xref:System.Threading.Thread.GetApartmentState%2A>-Methode und der <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode, ersetzt die <xref:System.Threading.Thread.ApartmentState%2A>-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Methoden <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>und <xref:System.Threading.Thread.TrySetApartmentState%2A> veranschaulicht. Im Codebeispiel wird ein Thread erstellt. Bevor der Thread gestartet wird, zeigt <xref:System.Threading.Thread.GetApartmentState%2A> den anfänglichen <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> Status an, und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Status in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode gibt dann `false` zurück, wenn versucht wird, den Zustand in <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> zu ändern, da der Apartment Zustand bereits festgelegt ist. Wenn der gleiche Vorgang mit <xref:System.Threading.Thread.SetApartmentState%2A>versucht wurde, wurde <xref:System.InvalidOperationException> ausgelöst.  
  
 Nachdem der Thread gestartet wurde, wird die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode erneut verwendet. Dieses Mal wird <xref:System.Threading.ThreadStateException> ausgelöst, da der Thread bereits gestartet wurde.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird auf den Plattformen macOS und Linux nicht unterstützt.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="state" /> ist kein gültiger Apartmentzustand.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde bereits gestartet.</exception>
        <exception cref="T:System.InvalidOperationException">Der Apartmentzustand wurde bereits initialisiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stack">Das <see cref="T:System.Threading.CompressedStack" />-Objekt, das für den aktuellen Thread übernommen werden soll.</param>
        <summary>Übernimmt einen erfassten <see cref="T:System.Threading.CompressedStack" /> für den aktuellen Thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird nicht mehr unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="slot">Der <see cref="T:System.LocalDataStoreSlot" />, in dem der Wert festgelegt werden soll.</param>
        <param name="data">Der festzulegende Wert.</param>
        <summary>Legt die Daten im angegebenen Slot auf den derzeit ausgeführten Thread und für die aktuelle Domäne des betreffenden Threads fest. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots. Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten. Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu. Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot zur Wiederverwendung freigeben, nachdem die Thread Prozedur beendet wurde und das <xref:System.Threading.Thread> Objekt von Garbage Collection freigegeben wurde. Daten Slots sind pro Thread eindeutig. Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> ist eine `Shared` Methode, die immer auf den derzeit ausgeführten Thread angewendet wird, auch wenn Sie ihn mit einer Variablen, die auf einen anderen Thread verweist, aufruft. Um Verwirrung zu vermeiden, verwenden Sie den Klassennamen, wenn Sie `Shared` Methoden aufrufen: `Thread.SetData(testSlot, "test data")`.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern. Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.  
  
 **Erstes Beispiel**  
  
 Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können. Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweites Beispiel**  
  
 Im folgenden Beispiel wird veranschaulicht, wie ein benannter Datenslot verwendet wird, um Thread spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads und Threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hält den aktuellen Thread während des angegebenen Zeitraums an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die der Thread angehalten wird. Wenn der Wert des <paramref name="millisecondsTimeout" />-Arguments 0 (null) lautet, gibt der Thread den Rest seines Zeitanteils an einen beliebigen Thread mit gleicher Priorität ab, der für die Ausführung bereit ist. Sind keine anderen Threads mit gleicher Priorität vorhanden, die ausgeführt werden können, wird die Ausführung des aktuellen Threads nicht angehalten.</param>
        <summary>Hält den aktuellen Thread für die angegebene Anzahl von Millisekunden an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread wird für die angegebene Zeitspanne nicht für die Ausführung durch das Betriebssystem geplant. Diese Methode ändert den Status des Threads, sodass er <xref:System.Threading.ThreadState.WaitSleepJoin>enthält.  
  
 Sie können <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für den Parameter `millisecondsTimeout` angeben, um den Thread unbegrenzt anzuhalten. Es wird jedoch empfohlen, stattdessen andere <xref:System.Threading?displayProperty=nameWithType> Klassen, z. b. <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>oder <xref:System.Threading.Semaphore>, zu verwenden, um Threads zu synchronisieren oder Ressourcen zu verwalten.  
  
 Die Systemuhr wird mit einer bestimmten Rate, die als Takt Auflösung bezeichnet wird, Ticks. Der tatsächliche Timeout Wert ist möglicherweise nicht genau das angegebene Timeout, da das angegebene Timeout an Zeiteinheiten angepasst wird. Weitere Informationen zur Takt Auflösung und zur Wartezeit finden Sie in der Windows-System-APIs unter Standby- [Funktion](/windows/win32/api/synchapi/nf-synchapi-sleep) .  
  
 Diese Methode führt keine Standard-com-und SendMessage-Pump durch.  
  
> [!NOTE]
>  Wenn Sie sich in einem Thread befinden müssen, der über <xref:System.STAThreadAttribute>verfügt, Sie jedoch das Standard-com-und SendMessage-Pump ausführen möchten, sollten Sie eine der über Ladungen der <xref:System.Threading.Thread.Join%2A>-Methode verwenden, die ein Timeout Intervall angibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Thread.Sleep%2A>-Methode verwendet, um den Haupt Thread der Anwendung zu blockieren.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Timeoutwert ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Der Zeitraum, während dessen der Thread angehalten wird. Wenn der Wert des <paramref name="millisecondsTimeout" />-Arguments <see cref="F:System.TimeSpan.Zero" /> lautet, gibt der Thread den Rest seines Zeitanteils an einen beliebigen Thread mit gleicher Priorität ab, der für die Ausführung bereit ist. Sind keine anderen Threads mit gleicher Priorität vorhanden, die ausgeführt werden können, wird die Ausführung des aktuellen Threads nicht angehalten.</param>
        <summary>Hält den aktuellen Thread während des angegebenen Zeitraums an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread wird für die angegebene Zeitspanne nicht für die Ausführung durch das Betriebssystem geplant. Diese Methode ändert den Status des Threads, sodass er <xref:System.Threading.ThreadState.WaitSleepJoin>enthält.  
  
 Sie können <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> für den Parameter `timeout` angeben, um den Thread unbegrenzt anzuhalten. Es wird jedoch empfohlen, stattdessen andere <xref:System.Threading?displayProperty=nameWithType> Klassen, z. b. <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>oder <xref:System.Threading.Semaphore>, zu verwenden, um Threads zu synchronisieren oder Ressourcen zu verwalten.  
  
 Diese Überladung von <xref:System.Threading.Thread.Sleep%2A> verwendet die Gesamtzahl ganzer Millisekunden in `timeout`. Bruchteile der Millisekunden werden verworfen.  
  
 Diese Methode führt keine Standard-com-und SendMessage-Pump durch.  
  
> [!NOTE]
>  Wenn Sie sich in einem Thread befinden müssen, der über <xref:System.STAThreadAttribute>verfügt, Sie jedoch das Standard-com-und SendMessage-Pump ausführen möchten, sollten Sie eine der über Ladungen der <xref:System.Threading.Thread.Join%2A>-Methode verwenden, die ein Timeout Intervall angibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29>-Methoden Überladung verwendet, um den Haupt Thread der Anwendung fünfmal zu blockieren, zwei Sekunden lang jedes Mal.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden oder größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iterations">Eine 32-Bit-Ganzzahl mit Vorzeichen, die den Zeitraum definiert, den ein Thread warten soll.</param>
        <summary>Veranlasst, dass ein Thread so oft wartet, wie vom <paramref name="iterations" />-Parameter definiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Thread.SpinWait%2A>-Methode eignet sich für die Implementierung von Sperren. Klassen im .NET Framework, z. b. <xref:System.Threading.Monitor> und <xref:System.Threading.ReaderWriterLock>, verwenden diese Methode intern. <xref:System.Threading.Thread.SpinWait%2A> stellt den Prozessor im Wesentlichen in eine sehr enge Schleife ein, wobei die Schleifen Anzahl durch den `iterations`-Parameter angegeben wird. Die Dauer der Wartezeit hängt daher von der Geschwindigkeit des Prozessors ab.  
  
 Vergleichen Sie dies mit der <xref:System.Threading.Thread.Sleep%2A>-Methode. Ein Thread, der <xref:System.Threading.Thread.Sleep%2A> aufruft, liefert den Rest seines aktuellen Slice der Prozessorzeit, auch wenn das angegebene Intervall 0 (null) ist. Wenn Sie ein Intervall ungleich 0 (null) für <xref:System.Threading.Thread.Sleep%2A> angeben, wird der Thread vom Thread Planer bis zum Ablauf des Zeitintervalls von der Überlegung entfernt.  
  
 <xref:System.Threading.Thread.SpinWait%2A> ist im Allgemeinen nicht für normale Anwendungen nützlich. In den meisten Fällen sollten Sie die Synchronisierungs Klassen verwenden, die vom .NET Framework bereitgestellt werden. Beispielsweise wird <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> oder eine-Anweisung aufgerufen, die <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> umschließt C# (`lock` in oder `SyncLock` in Visual Basic).  
  
> [!CAUTION]
>  In den seltenen Fällen, in denen es vorteilhaft ist, einen Kontextwechsel zu vermeiden, z. b. Wenn Sie wissen, dass eine Zustandsänderung bevorstehend ist, führen Sie in ihrer Schleife einen aufzurufenden <xref:System.Threading.Thread.SpinWait%2A>-Methode aus. Der Code <xref:System.Threading.Thread.SpinWait%2A> ausgeführt wird, um Probleme zu vermeiden, die auf Computern mit mehreren Prozessoren auftreten können. Beispielsweise verhindert <xref:System.Threading.Thread.SpinWait%2A> auf Computern mit mehreren Intel-Prozessoren, die Hyperthreading Technologie verwenden, in bestimmten Situationen den Prozessor Hunger.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bewirkt, dass die Ausführung eines Threads geplant wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Weist das Betriebssystem an, den Zustand der aktuellen Instanz in <see cref="F:System.Threading.ThreadState.Running" /> zu ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sobald sich ein Thread im <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> Zustand befindet, kann er vom Betriebssystem für die Ausführung geplant werden. Der Thread beginnt mit der Ausführung in der ersten Zeile der Methode, die durch den <xref:System.Threading.ThreadStart> oder <xref:System.Threading.ParameterizedThreadStart> Delegaten, der für den Thread-Konstruktor bereitgestellt wird, repräsentiert Beachten Sie, dass der Aufruf von <xref:System.Threading.Thread.Start%2A> den aufrufenden Thread nicht blockiert.  
  
> [!NOTE]
>  Wenn diese Überladung mit einem Thread verwendet wird, der mit einem <xref:System.Threading.ParameterizedThreadStart> Delegaten erstellt wurde, wird `null` an die vom Thread ausgeführte Methode übermittelt.  
  
 Nachdem der Thread beendet wurde, kann er nicht mehr mit einem weiteren `Start`aufgerufen werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Thread erstellt und gestartet.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde bereits gestartet.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Speicher zum Starten dieses Threads verfügbar.</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads und Threading</related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Erstellen von Threads und Übergeben von Daten zur Startzeit</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="parameter">Ein Objekt mit Daten, die von der vom Thread ausgeführten Methode verwendet werden sollen.</param>
        <summary>Bewirkt, dass das Betriebssystem den Zustand der aktuellen Instanz in <see cref="F:System.Threading.ThreadState.Running" /> ändert, und stellt optional ein Objekt mit Daten bereit, die von der vom Thread ausgeführten Methode verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sobald sich ein Thread im <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> Zustand befindet, kann er vom Betriebssystem für die Ausführung geplant werden. Der Thread beginnt mit der Ausführung in der ersten Zeile der Methode, die durch den <xref:System.Threading.ThreadStart> oder <xref:System.Threading.ParameterizedThreadStart> Delegaten, der für den Thread-Konstruktor bereitgestellt wird, repräsentiert Beachten Sie, dass der Aufruf von <xref:System.Threading.Thread.Start%2A> den aufrufenden Thread nicht blockiert.  
  
 Nachdem der Thread beendet wurde, kann er nicht mehr mit einem weiteren `Start`aufgerufen werden.  
  
 Diese Überladung und der <xref:System.Threading.ParameterizedThreadStart>-Delegat erleichtern das Übergeben von Daten an eine Thread Prozedur, aber die Technik ist nicht typsicher, da jedes Objekt an diese Überladung übergeben werden kann. Eine stabilere Methode zum Übergeben von Daten an eine Thread Prozedur besteht darin, die Thread Prozedur und die Datenfelder in ein Workerobjekt einzufügen. Weitere Informationen finden Sie [unter Erstellen von Threads und übergeben von Daten zur Startzeit](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Threading.ParameterizedThreadStart> Delegaten mit einer statischen-Methode und einer Instanzmethode erstellt.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde bereits gestartet.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Speicher zum Starten dieses Threads verfügbar.</exception>
        <exception cref="T:System.InvalidOperationException">Dieser Thread wurde mithilfe eines <see cref="T:System.Threading.ThreadStart" />-Delegaten anstelle eines <see cref="T:System.Threading.ParameterizedThreadStart" />-Delegaten erstellt.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Erstellen von Threads</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hält den Thread an. Hat keine Auswirkungen, wenn der Thread bereits angehalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Thread bereits angehalten wurde, hat diese Methode keine Auswirkungen.  
  
> [!CAUTION]
> Verwenden Sie die Methoden <xref:System.Threading.Thread.Suspend%2A> und <xref:System.Threading.Thread.Resume%2A> nicht, um die Aktivitäten von Threads zu synchronisieren. Sie haben keine Möglichkeit, zu wissen, welcher Code von einem Thread ausgeführt wird, wenn Sie ihn aussetzen. Wenn Sie einen Thread aussetzen, während er während einer Bewertung der Sicherheits Berechtigung Sperren enthält, werden möglicherweise andere Threads in der <xref:System.AppDomain> blockiert. Wenn Sie einen Thread beim Ausführen eines Klassenkonstruktors aussetzen, werden andere Threads in der <xref:System.AppDomain>, die versuchen, diese Klasse zu verwenden, blockiert. Deadlocks können sehr einfach auftreten.

Wenn Sie die `Suspend`-Methode für einen Thread aufzurufen, erkennt das System, dass ein Thread angehalten wurde, und ermöglicht die Ausführung des Threads, bis er einen sicheren Punkt erreicht, bevor der Thread tatsächlich angehalten wird. Ein sicherer Punkt für einen Thread ist ein Punkt in seiner Ausführung, an dem eine Garbage Collection durchgeführt werden kann. Sobald ein sicherer Punkt erreicht ist, garantiert die Runtime, dass der unterbrochene Thread in verwaltetem Code nicht weiter fortgesetzt wird. Ein außerhalb von verwaltetem Code ausgeführter Thread ist stets sicher für die Garbage Collection, und dessen Ausführung wird fortgeführt, bis er versucht, die Ausführung von verwaltetem Code fortzusetzen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde nicht gestartet oder reagiert nicht.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die geeignete <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Anhalten und Unterbrechen von Threads</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Thread.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._Thread.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit" Usage="thread.System.Runtime.InteropServices._Thread.GetIDsOfNames (riid, rgszNames, cNames, lcid, rgDispId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array von zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</param>
        <summary>Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden. Weitere Informationen finden Sie unter [IDispatch:: GetIDsOfNames](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Thread.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._Thread.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit" Usage="thread.System.Runtime.InteropServices._Thread.GetTypeInfo (iTInfo, lcid, ppTInfo)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</param>
        <summary>Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden. Weitere Informationen finden Sie unter [IDispatch:: GetTypeInfo](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Thread.GetTypeInfoCount : uint32 -&gt; unit&#xA;override this.System.Runtime.InteropServices._Thread.GetTypeInfoCount : uint32 -&gt; unit" Usage="thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount pcTInfo" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</param>
        <summary>Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden. Weitere Informationen finden Sie unter [IDispatch:: GetTypeInfoCount](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfocount).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Thread.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._Thread.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit" Usage="thread.System.Runtime.InteropServices._Thread.Invoke (dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Bezeichnet den Member.</param>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden. Weitere Informationen finden Sie unter [IDispatch:: Aufrufen](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zustände des aktuellen Threads enthält.</summary>
        <value>Einer der <see cref="T:System.Threading.ThreadState" />-Werte, der den Zustand des aktuellen Threads angibt. Der Anfangswert ist <see cref="F:System.Threading.ThreadState.Unstarted" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Thread.ThreadState%2A>-Eigenschaft bietet spezifischere Informationen als die <xref:System.Threading.Thread.IsAlive%2A>-Eigenschaft.  
  
> [!IMPORTANT]
>  Der Thread Zustand ist nur in Debugszenarien von Interesse. Sie sollten den Threadzustand niemals verwenden, um die Aktivitäten von Threads zu synchronisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zugriff auf die `ThreadState` eines Threads veranschaulicht.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="state">Der neue Apartmentzustand.</param>
        <summary>Legt den Apartmentzustand eines Threads fest, bevor dieser gestartet wird.</summary>
        <returns><see langword="true" />, wenn der Apartmentzustand festgelegt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Neue Threads werden als <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> initialisiert, wenn der Apartment Zustand nicht festgelegt wurde, bevor Sie gestartet werden. Der Apartment Zustand muss festgelegt werden, bevor ein Thread gestartet wird.  
  
> [!NOTE]
>  Der Haupt Anwendungs Thread wird initialisiert, um standardmäßig <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>. Der Apartment Zustand des Hauptanwendungs Threads kann nur auf <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> festgelegt werden, indem das <xref:System.STAThreadAttribute>-Attribut auf die Einstiegspunkt Methode angewendet wird.  
  
 Die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode, zusammen mit der <xref:System.Threading.Thread.GetApartmentState%2A>-Methode und der <xref:System.Threading.Thread.SetApartmentState%2A>-Methode, ersetzt die <xref:System.Threading.Thread.ApartmentState%2A>-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Methoden <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>und <xref:System.Threading.Thread.TrySetApartmentState%2A> veranschaulicht. Im Codebeispiel wird ein Thread erstellt. Bevor der Thread gestartet wird, zeigt <xref:System.Threading.Thread.GetApartmentState%2A> den anfänglichen <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> Status an, und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Status in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode gibt dann `false` zurück, wenn versucht wird, den Zustand in <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> zu ändern, da der Apartment Zustand bereits festgelegt ist. Wenn der gleiche Vorgang mit <xref:System.Threading.Thread.SetApartmentState%2A>versucht wurde, wurde <xref:System.InvalidOperationException> ausgelöst.  
  
 Nachdem der Thread gestartet wurde, wird die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode erneut verwendet. Dieses Mal wird <xref:System.Threading.ThreadStateException> ausgelöst, da der Thread bereits gestartet wurde.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird auf den Plattformen macOS und Linux nicht unterstützt.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="state" /> ist kein gültiger Apartmentzustand.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde gestartet und beendet, oder der Aufruf erfolgt nicht aus dem Kontext des Threads, während der Thread ausgeführt wird.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : byte -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : double -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int16 -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int64 -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : nativeint -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : obj -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : sbyte -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : single -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint16 -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint32 -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint64 -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : unativeint -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : byte * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : double * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int16 * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int16" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int64 * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : nativeint * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : obj * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.Diagnostics.CodeAnalysis.NotNullIfNotNull("value")</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : sbyte * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.SByte" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : single * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint16 * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.UInt16" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint32 * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint64 * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : unativeint * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle. Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.  
  
 Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise das Leeren von Prozessor Caches.  
  
 Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register). Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.  
  
 Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus. Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.  
  
> [!NOTE]
>  In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass der aufrufende Thread die Ausführung an einen anderen Thread übergibt, der auf dem aktuellen Prozessor ausgeführt werden kann. Das Betriebssystem wählt den Thread für die Übergabe aus.</summary>
        <returns><see langword="true" />, wenn das Betriebssystem die Ausführung an einen anderen Thread übergeben hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode erfolgreich ausgeführt wird, wird der Rest des aktuellen Zeitabschnitts des Threads zurückgegeben. Das Betriebssystem plant den aufrufenden Thread für einen anderen Zeit Slice entsprechend seiner Priorität und des Status anderer Threads, die zur Ausführung verfügbar sind.  
  
 Das Ergebnis ist auf den Prozessor beschränkt, der den aufrufenden Thread ausführt. Das Betriebssystem wechselt nicht zu einem anderen Prozessor, auch wenn sich der Prozessor im Leerlauf befindet oder ein Thread mit niedrigerer Priorität ausgeführt wird. Wenn keine anderen Threads vorhanden sind, die auf dem aktuellen Prozessor ausgeführt werden können, führt das Betriebssystem keine Ausführung aus, und diese Methode gibt `false`zurück.  
  
 Diese Methode entspricht der Verwendung eines Platt Form Aufrufs zum Aufrufen der systemeigenen Win32-`SwitchToThread` Funktion. Sie sollten die <xref:System.Threading.Thread.Yield%2A>-Methode anstelle des Platt Form Aufrufs aufrufen, da der Platt Form Aufruf das von dem Host angeforderte benutzerdefinierte Threading Verhalten umgeht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
