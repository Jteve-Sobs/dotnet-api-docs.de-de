<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3af9eb192475880cbd2d24c8fc9868ef626b28cb" /><Meta Name="ms.sourcegitcommit" Value="8b09499854b5b7b909802126edc1f1fca0054c10" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/01/2020" /><Meta Name="ms.locfileid" Value="76942826" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="4b18f-101">Erstellt und steuert einen Thread, legt dessen Priorität fest und ruft den Status ab.</span><span class="sxs-lookup"><span data-stu-id="4b18f-101">Creates and controls a thread, sets its priority, and gets its status.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-102">Wenn ein Prozess gestartet wird, erstellt der Common Language Runtime automatisch einen einzelnen Vordergrund Thread, um Anwendungscode auszuführen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="4b18f-103">Zusammen mit diesem Haupt Vordergrund Thread kann ein Prozess einen oder mehrere Threads erstellen, um einen Teil des Programmcodes auszuführen, der dem Prozess zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="4b18f-104">Diese Threads können entweder im Vordergrund oder im Hintergrund ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="4b18f-105">Außerdem können Sie die <xref:System.Threading.ThreadPool>-Klasse verwenden, um Code für Arbeitsthreads auszuführen, die vom Common Language Runtime verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="4b18f-106">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="4b18f-106">In this section</span></span>  
  
 <span data-ttu-id="4b18f-107">[Starten eines Thread](#Starting) </span><span class="sxs-lookup"><span data-stu-id="4b18f-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="4b18f-108">[Abrufen von Thread Objekten](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="4b18f-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="4b18f-109">[Vordergrund-und Hintergrundthreads](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="4b18f-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="4b18f-110">[Kultur und Threads](#Culture) </span><span class="sxs-lookup"><span data-stu-id="4b18f-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="4b18f-111">Erhalten von Informationen über und Steuern von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="4b18f-112">Starten eines Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-112">Starting a thread</span></span>  
 <span data-ttu-id="4b18f-113">Sie starten einen Thread, indem Sie einen Delegaten bereitstellen, der die Methode darstellt, die der Thread in seinem Klassenkonstruktor ausführen soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="4b18f-114">Anschließend wird die <xref:System.Threading.Thread.Start%2A>-Methode aufgerufen, um die Ausführung zu starten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="4b18f-115">Die <xref:System.Threading.Thread>-Konstruktoren können einen von zwei Delegattypen annehmen, je nachdem, ob Sie ein Argument an die auszuführende Methode übergeben können:</span><span class="sxs-lookup"><span data-stu-id="4b18f-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="4b18f-116">Wenn die Methode über keine Argumente verfügt, übergeben Sie einen <xref:System.Threading.ThreadStart>-Delegaten an den Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="4b18f-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="4b18f-117">Sie hat die folgende Signatur:</span><span class="sxs-lookup"><span data-stu-id="4b18f-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="4b18f-118">Im folgenden Beispiel wird ein Thread erstellt und gestartet, der die `ExecuteInForeground`-Methode ausführt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="4b18f-119">Die-Methode zeigt Informationen zu einigen Thread Eigenschaften an und führt dann eine Schleife aus, in der Sie für eine halbe Sekunde angehalten wird, und zeigt die verstrichene Anzahl von Sekunden an.</span><span class="sxs-lookup"><span data-stu-id="4b18f-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="4b18f-120">Wenn der Thread mindestens fünf Sekunden lang ausgeführt wurde, wird die-Schleife beendet, und der Thread beendet die Ausführung.</span><span class="sxs-lookup"><span data-stu-id="4b18f-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="4b18f-121">Wenn die Methode über ein Argument verfügt, übergeben Sie einen <xref:System.Threading.ParameterizedThreadStart>-Delegaten an den Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="4b18f-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="4b18f-122">Sie hat die folgende Signatur:</span><span class="sxs-lookup"><span data-stu-id="4b18f-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="4b18f-123">Die vom Delegaten ausgeführte Methode kann dann den- C#Parameter in den entsprechenden Typ umwandeln (in) oder (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4b18f-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="4b18f-124">Das folgende Beispiel ist mit dem vorherigen identisch, mit der Ausnahme, dass der <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>-Konstruktor aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="4b18f-125">Diese Version der `ExecuteInForeground`-Methode verfügt über einen einzelnen Parameter, der die ungefähre Anzahl von Millisekunden darstellt, die die Schleife ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="4b18f-126">Es ist nicht erforderlich, einen Verweis auf ein <xref:System.Threading.Thread> Objekt beizubehalten, nachdem Sie den Thread gestartet haben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="4b18f-127">Der Thread wird weiter ausgeführt, bis die Thread Prozedur vollständig ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="4b18f-128">Abrufen von Thread Objekten</span><span class="sxs-lookup"><span data-stu-id="4b18f-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="4b18f-129">Sie können die statische (`Shared` in Visual Basic)-<xref:System.Threading.Thread.CurrentThread%2A> Eigenschaft verwenden, um einen Verweis auf den aktuell ausgeführten Thread aus dem Code abzurufen, den der Thread ausführt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="4b18f-130">Im folgenden Beispiel wird die <xref:System.Threading.Thread.CurrentThread%2A>-Eigenschaft verwendet, um Informationen zum Hauptanwendungs Thread, einen weiteren Vordergrund Thread, einen Hintergrund Thread und einen Thread Pool Thread anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="4b18f-131">Vordergrund-und Hintergrundthreads</span><span class="sxs-lookup"><span data-stu-id="4b18f-131">Foreground and background threads</span></span>  
 <span data-ttu-id="4b18f-132">Instanzen der <xref:System.Threading.Thread>-Klasse stellen entweder Vordergrundthreads oder Hintergrundthreads dar.</span><span class="sxs-lookup"><span data-stu-id="4b18f-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="4b18f-133">Hintergrundthreads sind mit einer Ausnahme mit den Vordergrundthreads identisch: ein Hintergrund Thread führt keinen Prozess aus, wenn alle Vordergrundthreads beendet wurden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="4b18f-134">Nachdem alle Vordergrundthreads beendet wurden, beendet die Common Language Runtime alle Hintergrundthreads und wird heruntergefahren.</span><span class="sxs-lookup"><span data-stu-id="4b18f-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="4b18f-135">Standardmäßig werden die folgenden Threads im Vordergrund ausgeführt:</span><span class="sxs-lookup"><span data-stu-id="4b18f-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="4b18f-136">Der Hauptanwendungs Thread.</span><span class="sxs-lookup"><span data-stu-id="4b18f-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="4b18f-137">Alle Threads, die durch Aufrufen eines <xref:System.Threading.Thread>-Klassenkonstruktors erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="4b18f-138">Die folgenden Threads werden standardmäßig im Hintergrund ausgeführt:</span><span class="sxs-lookup"><span data-stu-id="4b18f-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="4b18f-139">Thread Poolthreads, bei denen es sich um einen Pool von Arbeitsthreads handelt, die von der Laufzeit verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="4b18f-140">Sie können den Thread Pool konfigurieren und Arbeitsaufgaben in Thread Pool-Threads planen, indem Sie die <xref:System.Threading.ThreadPool>-Klasse verwenden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="4b18f-141">Aufgabenbasierte asynchrone Vorgänge werden automatisch in Thread Pool-Threads ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="4b18f-142">Aufgabenbasierte asynchrone Vorgänge verwenden die Klassen <xref:System.Threading.Tasks.Task> und <xref:System.Threading.Tasks.Task%601>, um das [aufgabenbasierte asynchrone Muster](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="4b18f-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="4b18f-143">Alle Threads, die aus nicht verwaltetem Code in die verwaltete Ausführungsumgebung eintreten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="4b18f-144">Sie können einen Thread so ändern, dass er im Hintergrund ausgeführt wird, indem Sie die <xref:System.Threading.Thread.IsBackground%2A>-Eigenschaft jederzeit festlegen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="4b18f-145">Hintergrundthreads sind für jeden Vorgang nützlich, der fortgesetzt werden sollte, wenn eine Anwendung ausgeführt wird, aber nicht verhindern soll, dass die Anwendung beendet wird, z. b. das Überwachen von Dateisystem Änderungen oder eingehenden Socketverbindungen</span><span class="sxs-lookup"><span data-stu-id="4b18f-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="4b18f-146">Das folgende Beispiel veranschaulicht den Unterschied zwischen Vordergrund-und Hintergrundthreads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="4b18f-147">Dies entspricht dem ersten Beispiel im Abschnitt " [Starten eines Threads](#Starting) ", mit dem Unterschied, dass der Thread vor dem Starten im Hintergrund ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="4b18f-148">Wie die Ausgabe zeigt, wird die Schleife unterbrochen, bevor Sie fünf Sekunden lang ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="4b18f-149">Kultur und Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-149">Culture and threads</span></span>  
 <span data-ttu-id="4b18f-150">Jeder Thread verfügt über eine Kultur, die durch die <xref:System.Threading.Thread.CurrentCulture%2A>-Eigenschaft dargestellt wird, und eine Benutzeroberflächen Kultur, die durch die <xref:System.Threading.Thread.CurrentUICulture%2A>-Eigenschaft dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="4b18f-151">Die aktuelle Kultur unterstützt solche Kultur abhängigen Vorgänge wie das durcharbeiten und formatieren, den Zeichen folgen Vergleich und die Sortierung sowie das von einem Thread verwendete Schriftsystem und den von einem Thread verwendeten Kalender.</span><span class="sxs-lookup"><span data-stu-id="4b18f-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="4b18f-152">Die aktuelle Benutzeroberflächen Kultur ermöglicht das Kultur abhängige Abrufen von Ressourcen in Ressourcen Dateien.</span><span class="sxs-lookup"><span data-stu-id="4b18f-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="4b18f-153">Die Eigenschaften "<xref:System.Threading.Thread.CurrentCulture>" und "<xref:System.Threading.Thread.CurrentUICulture>" funktionieren nicht zuverlässig, wenn Sie mit einem anderen Thread als dem aktuellen Thread verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-153">The <xref:System.Threading.Thread.CurrentCulture> and <xref:System.Threading.Thread.CurrentUICulture> properties don't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="4b18f-154">In .NET Framework ist das Lesen dieser Eigenschaften zuverlässig, auch wenn diese Eigenschaften für einen anderen Thread als den aktuellen Thread festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-154">In .NET Framework, reading these properties is reliable, although setting these properties for a thread other than the current thread is not.</span></span> <span data-ttu-id="4b18f-155">Unter .net Core wird eine <xref:System.InvalidOperationException> ausgelöst, wenn ein Thread versucht, diese Eigenschaften in einem anderen Thread zu lesen oder zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-155">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write these properties on a different thread.</span></span>
> <span data-ttu-id="4b18f-156">Es wird empfohlen, die Eigenschaften "<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType>" und "<xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType>" zum Abrufen und Festlegen der aktuellen Kultur zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-156">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> properties to retrieve and set the current culture.</span></span>

 <span data-ttu-id="4b18f-157">Wenn ein neuer Thread instanziiert wird, werden seine Kultur und Benutzeroberflächen Kultur von der aktuellen System Kultur und Benutzeroberflächen Kultur definiert, nicht von der Kultur und Benutzeroberflächen Kultur des Threads, von dem aus der neue Thread erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-157">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="4b18f-158">Dies bedeutet beispielsweise Folgendes: Wenn die aktuelle System Kultur Englisch (USA) und die aktuelle Kultur des primären Anwendungs Threads Französisch (Frankreich) ist, ist die Kultur eines neuen Threads, der durch Aufrufen des <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Konstruktors vom primären Thread erstellt wird, Englisch (USA) und nicht Französisch (Frankreich).</span><span class="sxs-lookup"><span data-stu-id="4b18f-158">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="4b18f-159">Weitere Informationen finden Sie im Abschnitt "Kultur und Threads" im Thema <xref:System.Globalization.CultureInfo>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="4b18f-159">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4b18f-160">Dies gilt nicht für Threads, die asynchrone Vorgänge für apps ausführen, die auf [!INCLUDE[net_v46](~/includes/net-v46-md.md)] und spätere Versionen abzielen. in diesem Fall ist die Kultur und die UI-Kultur Teil eines asynchronen Vorgangs Kontexts. der Thread, für den ein asynchroner Vorgang standardmäßig ausgeführt wird, erbt die Kultur und die UI-Kultur des Threads, von dem der asynchrone Vorgang gestartet wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-160">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="4b18f-161">Weitere Informationen finden Sie im Abschnitt "Kultur und aufgabenbasierte asynchrone Vorgänge" im Thema zur <xref:System.Globalization.CultureInfo>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="4b18f-161">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="4b18f-162">Sie können eine der folgenden Aktionen durchführen, um sicherzustellen, dass alle in einer Anwendung ausgeführten Threads dieselbe Kultur und Benutzeroberflächen Kultur gemeinsam nutzen:</span><span class="sxs-lookup"><span data-stu-id="4b18f-162">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="4b18f-163">Sie können ein <xref:System.Globalization.CultureInfo> Objekt, das diese Kultur darstellt, an den <xref:System.Threading.ParameterizedThreadStart>-Delegaten oder die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType>-Methode übergeben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-163">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="4b18f-164">Für apps, die auf dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] und höheren Versionen ausgeführt werden, können Sie die Kultur und die UI-Kultur definieren, die allen in einer Anwendungsdomäne erstellten Threads zugewiesen werden soll, indem Sie den Wert der Eigenschaften <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> und <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> festlegen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-164">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="4b18f-165">Beachten Sie, dass es sich hierbei um eine Domänen Einstellung pro Anwendung handelt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-165">Note that this is a per-application domain setting.</span></span>  

 <span data-ttu-id="4b18f-166">Weitere Informationen und Beispiele finden Sie im Abschnitt "Kultur und Threads" im Thema <xref:System.Globalization.CultureInfo>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="4b18f-166">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="4b18f-167">Erhalten von Informationen über und Steuern von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-167">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="4b18f-168">Sie können eine Reihe von Eigenschafts Werten abrufen, die Informationen zu einem Thread bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-168">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="4b18f-169">In einigen Fällen können Sie auch diese Eigenschaftswerte festlegen, um den Thread Vorgang zu steuern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-169">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="4b18f-170">Zu diesen Thread Eigenschaften gehören:</span><span class="sxs-lookup"><span data-stu-id="4b18f-170">These thread properties include:</span></span>  
  
-   <span data-ttu-id="4b18f-171">Einen Namen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-171">A name.</span></span> <span data-ttu-id="4b18f-172"><xref:System.Threading.Thread.Name%2A> ist eine Write-Once-Eigenschaft, mit der Sie einen Thread identifizieren können.</span><span class="sxs-lookup"><span data-stu-id="4b18f-172"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="4b18f-173">Der Standardwert lautet `null`.</span><span class="sxs-lookup"><span data-stu-id="4b18f-173">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="4b18f-174">Ein Hashcode, den Sie abrufen können, indem Sie die <xref:System.Threading.Thread.GetHashCode%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-174">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="4b18f-175">Der Hashcode kann verwendet werden, um einen Thread eindeutig zu identifizieren. der Hashcode für die Lebensdauer des Threads findet nicht mit dem Wert eines anderen Threads in Konflikt, unabhängig von der Anwendungsdomäne, aus der der Wert abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-175">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="4b18f-176">Eine Thread-ID.</span><span class="sxs-lookup"><span data-stu-id="4b18f-176">A thread ID.</span></span> <span data-ttu-id="4b18f-177">Der Wert der schreibgeschützten <xref:System.Threading.Thread.ManagedThreadId%2A>-Eigenschaft wird von der Common Language Runtime zugewiesen und identifiziert einen Thread innerhalb des Prozesses eindeutig.</span><span class="sxs-lookup"><span data-stu-id="4b18f-177">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="4b18f-178">Eine Betriebssystem- [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) hat keine feste Beziehung zu einem verwalteten Thread, da ein nicht verwalteter Host die Beziehung zwischen verwalteten und nicht verwalteten Threads steuern kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-178">An operating-system [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="4b18f-179">Insbesondere kann ein hoch entwickelter Host die [CLR-Hosting-API](https://msdn.microsoft.com/library/ms404385.aspx) verwenden, um viele verwaltete Threads mit demselben Betriebssystem Thread zu planen oder einen verwalteten Thread zwischen verschiedenen Betriebssystemthreads zu verschieben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-179">Specifically, a sophisticated host can use the [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="4b18f-180">Der aktuelle Zustand des Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-180">The thread's current state.</span></span> <span data-ttu-id="4b18f-181">Für die Dauer des Vorhandenseins befindet sich ein Thread immer in einem oder mehreren der Zustände, die durch die <xref:System.Threading.ThreadState>-Eigenschaft definiert sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-181">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="4b18f-182">Eine Prioritätsstufe für die Planung, die durch die <xref:System.Threading.ThreadPriority>-Eigenschaft definiert wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-182">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="4b18f-183">Obwohl Sie diesen Wert festlegen können, um die Priorität eines Threads anzufordern, ist es nicht gewährleistet, dass er vom Betriebssystem berücksichtigt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-183">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="4b18f-184">Die schreibgeschützte <xref:System.Threading.Thread.IsThreadPoolThread%2A>-Eigenschaft, die angibt, ob es sich bei einem Thread um einen Thread Pool Thread handelt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-184">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="4b18f-185">Die Eigenschaft <xref:System.Threading.Thread.IsBackground%2A>.</span><span class="sxs-lookup"><span data-stu-id="4b18f-185">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="4b18f-186">Weitere Informationen finden Sie im Abschnitt [Vordergrund-und Hintergrundthreads](#Foreground) .</span><span class="sxs-lookup"><span data-stu-id="4b18f-186">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="4b18f-187">Im folgenden Beispiel werden einfache Threading Funktionen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="4b18f-187">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="4b18f-188">Dieser Code erzeugt eine Ausgabe ähnlich der folgenden:</span><span class="sxs-lookup"><span data-stu-id="4b18f-188">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="4b18f-189">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="4b18f-189">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="4b18f-190">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-190">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="4b18f-191">Verwenden von Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-191">Using Threads and Threading</span></span></related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96"><span data-ttu-id="4b18f-192">Verweis Quelle für die Thread-Klasse</span><span class="sxs-lookup"><span data-stu-id="4b18f-192">Reference Source for the Thread Class</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4b18f-193">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="4b18f-193">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="4b18f-194">Ein Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-194">A delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="4b18f-195">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt dabei einen Delegaten an, der das Übergeben eines Objekts an den Thread bei dessen Start ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="4b18f-195">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-196">Ein Thread beginnt nicht mit der Ausführung, wenn er erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-196">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="4b18f-197">Um den Thread für die Ausführung zu planen, müssen Sie die <xref:System.Threading.Thread.Start%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-197">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="4b18f-198">Um ein Datenobjekt an den Thread zu übergeben, verwenden Sie die <xref:System.Threading.Thread.Start%28System.Object%29>-Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="4b18f-198">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-199">Visual Basic Benutzer können den <xref:System.Threading.ThreadStart>-Konstruktor weglassen, wenn ein Thread erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-199">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="4b18f-200">Verwenden Sie den `AddressOf`-Operator, wenn Sie die Methode übergeben, z. b. `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="4b18f-200">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="4b18f-201">Visual Basic ruft automatisch den <xref:System.Threading.ThreadStart>-Konstruktor auf.</span><span class="sxs-lookup"><span data-stu-id="4b18f-201">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-202">Das folgende Beispiel zeigt die Syntax zum Erstellen und Verwenden eines <xref:System.Threading.ParameterizedThreadStart> Delegaten mit einer statischen-Methode und einer Instanzmethode.</span><span class="sxs-lookup"><span data-stu-id="4b18f-202">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4b18f-203"><paramref name="start" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-203"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="4b18f-204">Erstellen von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-204">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="4b18f-205">Ein <see cref="T:System.Threading.ThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-205">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="4b18f-206">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="4b18f-206">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-207">Ein Thread beginnt nicht mit der Ausführung, wenn er erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-207">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="4b18f-208">Um den Thread für die Ausführung zu planen, müssen Sie die <xref:System.Threading.Thread.Start%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-208">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-209">Visual Basic Benutzer können den <xref:System.Threading.ThreadStart>-Konstruktor weglassen, wenn ein Thread erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-209">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="4b18f-210">Verwenden Sie den `AddressOf`-Operator, wenn Sie die Methode beispielsweise `Dim t As New Thread(AddressOf ThreadProc)`übergeben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-210">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="4b18f-211">Visual Basic ruft automatisch den <xref:System.Threading.ThreadStart>-Konstruktor auf.</span><span class="sxs-lookup"><span data-stu-id="4b18f-211">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-212">Im folgenden Codebeispiel wird gezeigt, wie ein Thread erstellt wird, der eine statische Methode ausführt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-212">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="4b18f-213">Im folgenden Codebeispiel wird gezeigt, wie ein Thread erstellt wird, der eine Instanzmethode ausführt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-213">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4b18f-214">Der Parameter <paramref name="start" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-214">The <paramref name="start" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="4b18f-215">Erstellen von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-215">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="4b18f-216">Ein <see cref="T:System.Threading.ParameterizedThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-216">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="4b18f-217">Die maximale Stapelgröße, in Bytes, für den Thread, oder 0 (null), wenn die angegebene maximale Standardstapelgröße aus dem Header der ausführbaren Datei verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-217">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="4b18f-218">Wichtig: Für teilweise vertrauenswürdigen Code wird <paramref name="maxStackSize" /> ignoriert, wenn sie größer als die Standardstapelgröße ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-218">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="4b18f-219">Es werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="4b18f-219">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="4b18f-220">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt dabei einen Delegaten, der das Übergeben eines Objekts an den Thread bei dessen Start ermöglicht, sowie eine maximale Stapelgröße für den Thread an.</span><span class="sxs-lookup"><span data-stu-id="4b18f-220">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-221">Vermeiden Sie die Verwendung dieser Konstruktorüberladung.</span><span class="sxs-lookup"><span data-stu-id="4b18f-221">Avoid using this constructor overload.</span></span> <span data-ttu-id="4b18f-222">Die Standard Stapelgröße, die von der <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>-Konstruktorüberladung verwendet wird, ist die empfohlene Stapelgröße für Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-222">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="4b18f-223">Wenn ein Thread Arbeitsspeicher Probleme aufweist, ist der Programmierfehler wahrscheinlich, wie z. b. eine unendliche Rekursion.</span><span class="sxs-lookup"><span data-stu-id="4b18f-223">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4b18f-224">Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]kann nur voll vertrauenswürdiger Code `maxStackSize` auf einen Wert festlegen, der größer ist als die Standard Stapelgröße (1 Megabyte).</span><span class="sxs-lookup"><span data-stu-id="4b18f-224">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="4b18f-225">Wenn ein größerer Wert für `maxStackSize` angegeben wird, wenn Code mit teilweiser Vertrauenswürdigkeit ausgeführt wird, wird `maxStackSize` ignoriert und die Standard Stapelgröße verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-225">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="4b18f-226">Es werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="4b18f-226">No exception is thrown.</span></span> <span data-ttu-id="4b18f-227">Code auf jeder Vertrauens Ebene kann `maxStackSize` auf einen Wert festlegen, der kleiner als die Standard Stapelgröße ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-227">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-228">Wenn Sie eine voll vertrauenswürdige Bibliothek entwickeln, die von teilweise vertrauenswürdigem Code verwendet wird, und einen Thread starten müssen, der einen großen Stapel erfordert, müssen Sie vor dem Erstellen des Threads die volle Vertrauenswürdigkeit bestätigen, oder es wird die Standard Stapelgröße verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-228">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="4b18f-229">Führen Sie diese Schritte nur aus, wenn Sie den Code, der auf dem Thread ausgeführt wird, vollständig steuern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-229">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="4b18f-230">Wenn `maxStackSize` kleiner als die minimale Stapelgröße ist, wird die minimale Stapelgröße verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-230">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="4b18f-231">Wenn `maxStackSize` kein Vielfaches der Seitengröße ist, wird es auf das nächste größere Vielfache der Seitengröße gerundet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-231">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="4b18f-232">Wenn Sie z. b. die .NET Framework Version 2,0 unter Windows Vista verwenden, ist 256 KB (262.144 Bytes) die minimale Stapelgröße, und die Seitengröße beträgt 64 KB (65.536 Bytes).</span><span class="sxs-lookup"><span data-stu-id="4b18f-232">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-233">In Versionen von Microsoft Windows vor Windows XP und Windows Server 2003 wird `maxStackSize` ignoriert und die im ausführbaren Header angegebene Stapelgröße verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-233">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="4b18f-234">Wenn Sie eine sehr kleine Stapelgröße angeben, müssen Sie möglicherweise die Stapelüberlauf Prüfung deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="4b18f-234">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="4b18f-235">Wenn der Stapel stark eingeschränkt ist, kann die Überprüfung selbst zu einem Stapelüberlauf führen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-235">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="4b18f-236">Fügen Sie der Anwendungs Konfigurationsdatei Folgendes hinzu, um die Stapelüberlauf Prüfung zu deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="4b18f-236">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4b18f-237"><paramref name="start" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-237"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4b18f-238"><paramref name="maxStackSize" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="4b18f-238"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="4b18f-239">Ein <see cref="T:System.Threading.ThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-239">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="4b18f-240">Die maximale Stapelgröße, in Bytes, für den Thread, oder 0 (null), wenn die angegebene maximale Standardstapelgröße aus dem Header der ausführbaren Datei verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-240">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="4b18f-241">Wichtig: Für teilweise vertrauenswürdigen Code wird <paramref name="maxStackSize" /> ignoriert, wenn sie größer als die Standardstapelgröße ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-241">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="4b18f-242">Es werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="4b18f-242">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="4b18f-243">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt die maximale Stapelgröße für den Thread an.</span><span class="sxs-lookup"><span data-stu-id="4b18f-243">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-244">Vermeiden Sie die Verwendung dieser Konstruktorüberladung.</span><span class="sxs-lookup"><span data-stu-id="4b18f-244">Avoid using this constructor overload.</span></span> <span data-ttu-id="4b18f-245">Die Standard Stapelgröße, die von der <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>-Konstruktorüberladung verwendet wird, ist die empfohlene Stapelgröße für Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-245">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="4b18f-246">Wenn ein Thread Arbeitsspeicher Probleme aufweist, ist der Programmierfehler wahrscheinlich, wie z. b. eine unendliche Rekursion.</span><span class="sxs-lookup"><span data-stu-id="4b18f-246">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4b18f-247">Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]kann nur voll vertrauenswürdiger Code `maxStackSize` auf einen Wert festlegen, der größer ist als die Standard Stapelgröße (1 Megabyte).</span><span class="sxs-lookup"><span data-stu-id="4b18f-247">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="4b18f-248">Wenn ein größerer Wert für `maxStackSize` angegeben wird, wenn Code mit teilweiser Vertrauenswürdigkeit ausgeführt wird, wird `maxStackSize` ignoriert und die Standard Stapelgröße verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-248">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="4b18f-249">Es werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="4b18f-249">No exception is thrown.</span></span> <span data-ttu-id="4b18f-250">Code auf jeder Vertrauens Ebene kann `maxStackSize` auf einen Wert festlegen, der kleiner als die Standard Stapelgröße ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-250">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-251">Wenn Sie eine voll vertrauenswürdige Bibliothek entwickeln, die von teilweise vertrauenswürdigem Code verwendet wird, und einen Thread starten müssen, der einen großen Stapel erfordert, müssen Sie vor dem Erstellen des Threads die volle Vertrauenswürdigkeit bestätigen, oder es wird die Standard Stapelgröße verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-251">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="4b18f-252">Führen Sie diese Schritte nur aus, wenn Sie den Code, der auf dem Thread ausgeführt wird, vollständig steuern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-252">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="4b18f-253">Wenn `maxStackSize` kleiner als die minimale Stapelgröße ist, wird die minimale Stapelgröße verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-253">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="4b18f-254">Wenn `maxStackSize` kein Vielfaches der Seitengröße ist, wird es auf das nächste größere Vielfache der Seitengröße gerundet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-254">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="4b18f-255">Wenn Sie z. b. die .NET Framework Version 2,0 unter Windows Vista verwenden, ist 256 KB (262.144 Bytes) die minimale Stapelgröße, und die Seitengröße beträgt 64 KB (65.536 Bytes).</span><span class="sxs-lookup"><span data-stu-id="4b18f-255">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-256">In Versionen von Microsoft Windows vor Windows XP und Windows Server 2003 wird `maxStackSize` ignoriert und die im ausführbaren Header angegebene Stapelgröße verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-256">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="4b18f-257">Wenn Sie eine sehr kleine Stapelgröße angeben, müssen Sie möglicherweise die Stapelüberlauf Prüfung deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="4b18f-257">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="4b18f-258">Wenn der Stapel stark eingeschränkt ist, kann die Überprüfung selbst zu einem Stapelüberlauf führen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-258">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="4b18f-259">Fügen Sie der Anwendungs Konfigurationsdatei Folgendes hinzu, um die Stapelüberlauf Prüfung zu deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="4b18f-259">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4b18f-260"><paramref name="start" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-260"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4b18f-261"><paramref name="maxStackSize" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="4b18f-261"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4b18f-262">Löst eine <see cref="T:System.Threading.ThreadAbortException" /> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-262">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="4b18f-263">Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-263">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="4b18f-264">Die `Thread.Abort`-Methode sollte mit Bedacht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-264">The `Thread.Abort` method should be used with caution.</span></span> <span data-ttu-id="4b18f-265">Vor allem, wenn Sie einen anderen Thread als den aktuellen Thread abbrechen, wissen Sie nicht, welcher Code ausgeführt wurde oder nicht ausgeführt werden konnte, wenn die <xref:System.Threading.ThreadAbortException> ausgelöst wird. Sie können auch nicht sicher sein, dass der Zustand der Anwendung oder der Anwendungs-und Benutzer Zustand, der für die Beibehaltung verantwortlich ist, aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-265">Particularly when you call it to abort a thread other than the current thread, you do not know what code has executed or failed to execute when the <xref:System.Threading.ThreadAbortException> is thrown, nor can you be certain of the state of your application or any application and user state that it is responsible for preserving.</span></span> <span data-ttu-id="4b18f-266">Beispielsweise kann durch das Aufrufen von `Thread.Abort` verhindert werden, dass statische Konstruktoren ausgeführt werden, oder die Freigabe nicht verwalteter Ressourcen wird verhindert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-266">For example, calling `Thread.Abort` may prevent static constructors from executing or prevent the release of unmanaged resources</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-267">Löst eine <see cref="T:System.Threading.ThreadAbortException" /> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-267">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="4b18f-268">Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-268">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-269">Wenn diese Methode in einem Thread aufgerufen wird, löst das System eine <xref:System.Threading.ThreadAbortException> im Thread aus, um Sie abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-269">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="4b18f-270">`ThreadAbortException` ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch am Ende des `catch` Blocks erneut ausgelöst wird, es sei denn, <xref:System.Threading.Thread.ResetAbort%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-270">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="4b18f-271">`ResetAbort` bricht die Abbruch Anforderung ab und verhindert, dass der `ThreadAbortException` den Thread beendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-271">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="4b18f-272">Nicht ausgeführte `finally` Blöcke werden ausgeführt, bevor der Thread abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-272">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-273">Wenn ein Thread `Abort` auf sich selbst aufruft, ähnelt der Effekt dem Auslösen einer Ausnahme. der <xref:System.Threading.ThreadAbortException> erfolgt sofort, und das Ergebnis ist vorhersagbar.</span><span class="sxs-lookup"><span data-stu-id="4b18f-273">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="4b18f-274">Wenn jedoch ein Thread `Abort` in einem anderen Thread aufruft, unterbricht der Abbruch den Code, der ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-274">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="4b18f-275">Außerdem besteht die Möglichkeit, dass ein statischer Konstruktor abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-275">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="4b18f-276">In seltenen Fällen kann dies verhindern, dass Instanzen dieser Klasse in dieser Anwendungsdomäne erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-276">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="4b18f-277">In den .NET Framework Versionen 1,0 und 1,1 besteht die Möglichkeit, dass der Thread abgebrochen wird, während ein `finally` Block ausgeführt wird. in diesem Fall wird der `finally` Block abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-277">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="4b18f-278">Es ist nicht garantiert, dass der Thread sofort oder überhaupt abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-278">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="4b18f-279">Diese Situation kann eintreten, wenn ein Thread eine unbegrenzte Menge an Berechnung in den `finally` Blöcken ausführt, die im Rahmen der Abbruch Prozedur aufgerufen werden, wodurch der Abbruch unbegrenzt verzögert wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-279">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="4b18f-280">Um zu warten, bis ein Thread abgebrochen wurde, können Sie die <xref:System.Threading.Thread.Join%2A>-Methode für den Thread aufrufen, nachdem Sie die <xref:System.Threading.Thread.Abort%2A>-Methode aufgerufen haben. es gibt jedoch keine Garantie, dass der Warte Vorgang beendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-280">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-281">Der Thread, der <xref:System.Threading.Thread.Abort%2A> aufruft, kann blockieren, wenn sich der abgebrochene Thread in einem geschützten Bereich von Code befindet, z. b. einem `catch` Block, einem `finally` Block oder einem eingeschränkten Ausführungs Bereich.</span><span class="sxs-lookup"><span data-stu-id="4b18f-281">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="4b18f-282">Wenn der Thread, der <xref:System.Threading.Thread.Abort%2A> aufruft, eine Sperre besitzt, die der abgebrochene Thread erfordert, kann ein Deadlock auftreten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-282">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="4b18f-283">Wenn `Abort` für einen Thread aufgerufen wird, der noch nicht gestartet wurde, wird der Thread abgebrochen, wenn <xref:System.Threading.Thread.Start%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-283">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="4b18f-284">Wenn `Abort` für einen Thread aufgerufen wird, der blockiert ist oder sich im Ruhezustand befindet, wird der Thread unterbrochen und dann abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-284">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="4b18f-285">Wenn `Abort` für einen Thread aufgerufen wird, der angehalten wurde, wird ein <xref:System.Threading.ThreadStateException> in dem Thread ausgelöst, der <xref:System.Threading.Thread.Abort%2A>aufgerufen hat, und <xref:System.Threading.ThreadState.AbortRequested> der <xref:System.Threading.Thread.ThreadState%2A>-Eigenschaft des abzugebrochenen Threads hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-285">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="4b18f-286">Eine <xref:System.Threading.ThreadAbortException> wird nicht im angehaltenen Thread ausgelöst, bis <xref:System.Threading.Thread.Resume%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-286">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="4b18f-287">Wenn `Abort` für einen verwalteten Thread aufgerufen wird, während er nicht verwalteten Code ausführt, wird ein `ThreadAbortException` erst ausgelöst, wenn der Thread an verwalteten Code zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-287">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="4b18f-288">Wenn zwei Aufrufe von `Abort` gleichzeitig erfolgen, ist es möglich, dass ein Aufruf die Zustandsinformationen und den anderen Aufruf zum Ausführen des `Abort`einrichtet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-288">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="4b18f-289">Diese Situation kann jedoch von einer Anwendung nicht erkannt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-289">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="4b18f-290">Nachdem `Abort` in einem Thread aufgerufen wurde, enthält der Thread Zustand <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="4b18f-290">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="4b18f-291">Nachdem der Thread aufgrund eines erfolgreichen Aufrufes `Abort`beendet wurde, wird der Status des Threads in <xref:System.Threading.ThreadState.Stopped>geändert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-291">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="4b18f-292">Mit ausreichenden Berechtigungen kann ein Thread, der das Ziel eines `Abort` ist, den Abbruch mithilfe der `ResetAbort`-Methode abbrechen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-292">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="4b18f-293">Ein Beispiel für das Aufrufen der `ResetAbort`-Methode finden Sie in der `ThreadAbortException`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="4b18f-293">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4b18f-294">Nur .NET Core: Dieser Member wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-294">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4b18f-295">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="4b18f-295">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-296">Der abgebrochene Thread ist derzeit angehalten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-296">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4b18f-297">für erweiterte Vorgänge für Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-297">for advanced operations on threads.</span></span> <span data-ttu-id="4b18f-298">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="4b18f-298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="4b18f-299">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-299">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="4b18f-300">Verwenden von Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-300">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="4b18f-301">Zerstören von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-301">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="stateInfo"><span data-ttu-id="4b18f-302">Ein Objekt, das anwendungsspezifische Informationen enthält (z. B. über den Zustand), die vom abgebrochenen Thread verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="4b18f-302">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span></span></param>
        <summary><span data-ttu-id="4b18f-303">Löst eine <see cref="T:System.Threading.ThreadAbortException" /> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen. Gleichzeitig werden Ausnahmeinformationen über das Beenden des Threads bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-303">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span></span> <span data-ttu-id="4b18f-304">Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-304">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-305">Wenn diese Methode in einem Thread aufgerufen wird, löst das System eine <xref:System.Threading.ThreadAbortException> im Thread aus, um Sie abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-305">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="4b18f-306">`ThreadAbortException` ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch am Ende des `catch` Blocks erneut ausgelöst wird, es sei denn, <xref:System.Threading.Thread.ResetAbort%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-306">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="4b18f-307">`ResetAbort` bricht die Abbruch Anforderung ab und verhindert, dass der `ThreadAbortException` den Thread beendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-307">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="4b18f-308">Nicht ausgeführte `finally` Blöcke werden ausgeführt, bevor der Thread abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-308">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-309">Wenn ein Thread `Abort` auf sich selbst aufruft, ähnelt der Effekt dem Auslösen einer Ausnahme. der <xref:System.Threading.ThreadAbortException> erfolgt sofort, und das Ergebnis ist vorhersagbar.</span><span class="sxs-lookup"><span data-stu-id="4b18f-309">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="4b18f-310">Wenn jedoch ein Thread `Abort` in einem anderen Thread aufruft, unterbricht der Abbruch den Code, der ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-310">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="4b18f-311">Es besteht die Möglichkeit, dass ein statischer Konstruktor abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-311">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="4b18f-312">In seltenen Fällen kann dies verhindern, dass Instanzen dieser Klasse in dieser Anwendungsdomäne erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-312">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="4b18f-313">In den .NET Framework Versionen 1,0 und 1,1 besteht die Möglichkeit, dass der Thread abgebrochen wird, während ein `finally` Block ausgeführt wird. in diesem Fall wird der `finally` Block abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-313">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="4b18f-314">Es ist nicht garantiert, dass der Thread sofort oder überhaupt abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-314">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="4b18f-315">Diese Situation kann eintreten, wenn ein Thread eine unbegrenzte Menge an Berechnung in den `finally` Blöcken ausführt, die im Rahmen der Abbruch Prozedur aufgerufen werden, wodurch der Abbruch unbegrenzt verzögert wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-315">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="4b18f-316">Um zu warten, bis ein Thread abgebrochen wurde, können Sie die <xref:System.Threading.Thread.Join%2A>-Methode für den Thread aufrufen, nachdem Sie die <xref:System.Threading.Thread.Abort%2A>-Methode aufgerufen haben. es gibt jedoch keine Garantie, dass der Warte Vorgang beendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-316">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-317">Der Thread, der <xref:System.Threading.Thread.Abort%2A> aufruft, kann blockieren, wenn sich der abgebrochene Thread in einem geschützten Bereich von Code befindet, z. b. einem `catch` Block, einem `finally` Block oder einem eingeschränkten Ausführungs Bereich.</span><span class="sxs-lookup"><span data-stu-id="4b18f-317">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="4b18f-318">Wenn der Thread, der <xref:System.Threading.Thread.Abort%2A> aufruft, eine Sperre besitzt, die der abgebrochene Thread erfordert, kann ein Deadlock auftreten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-318">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="4b18f-319">Wenn `Abort` für einen Thread aufgerufen wird, der noch nicht gestartet wurde, wird der Thread abgebrochen, wenn <xref:System.Threading.Thread.Start%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-319">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="4b18f-320">Wenn `Abort` für einen Thread aufgerufen wird, der blockiert ist oder sich im Ruhezustand befindet, wird der Thread unterbrochen und dann abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-320">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="4b18f-321">Wenn `Abort` für einen Thread aufgerufen wird, der angehalten wurde, wird ein <xref:System.Threading.ThreadStateException> in dem Thread ausgelöst, der <xref:System.Threading.Thread.Abort%2A>aufgerufen hat, und <xref:System.Threading.ThreadState.AbortRequested> der <xref:System.Threading.Thread.ThreadState%2A>-Eigenschaft des abzugebrochenen Threads hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-321">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="4b18f-322">Eine <xref:System.Threading.ThreadAbortException> wird nicht im angehaltenen Thread ausgelöst, bis <xref:System.Threading.Thread.Resume%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-322">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="4b18f-323">Wenn `Abort` für einen verwalteten Thread aufgerufen wird, während er nicht verwalteten Code ausführt, wird ein `ThreadAbortException` erst ausgelöst, wenn der Thread an verwalteten Code zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-323">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="4b18f-324">Wenn zwei Aufrufe von `Abort` gleichzeitig erfolgen, ist es möglich, dass ein Aufruf die Zustandsinformationen und den anderen Aufruf zum Ausführen des `Abort`einrichtet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-324">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="4b18f-325">Diese Situation kann jedoch von einer Anwendung nicht erkannt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-325">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="4b18f-326">Nachdem `Abort` in einem Thread aufgerufen wurde, enthält der Thread Zustand <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="4b18f-326">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="4b18f-327">Nachdem der Thread aufgrund eines erfolgreichen Aufrufes `Abort`beendet wurde, wird der Status des Threads in <xref:System.Threading.ThreadState.Stopped>geändert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-327">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="4b18f-328">Mit ausreichenden Berechtigungen kann ein Thread, der das Ziel eines `Abort` ist, den Abbruch mithilfe der `ResetAbort`-Methode abbrechen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-328">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="4b18f-329">Ein Beispiel für das Aufrufen der `ResetAbort`-Methode finden Sie in der `ThreadAbortException`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="4b18f-329">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-330">Im folgenden Codebeispiel wird gezeigt, wie Informationen an einen Thread übergeben werden, der abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-330">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4b18f-331">Nur .NET Core: Dieser Member wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-331">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4b18f-332">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="4b18f-332">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-333">Der abgebrochene Thread ist derzeit angehalten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-333">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4b18f-334">für erweiterte Vorgänge für Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-334">for advanced operations on threads.</span></span> <span data-ttu-id="4b18f-335">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="4b18f-335">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="4b18f-336">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-336">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="4b18f-337">Verwenden von Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-337">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="4b18f-338">Zerstören von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-338">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-339">Reserviert einen unbenannten Datenslot für alle Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-339">Allocates an unnamed data slot on all the threads.</span></span> <span data-ttu-id="4b18f-340">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-340">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="4b18f-341">Der reservierte benannte Datenslot für alle Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-341">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4b18f-342">Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots.</span><span class="sxs-lookup"><span data-stu-id="4b18f-342">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4b18f-343">Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit.</span><span class="sxs-lookup"><span data-stu-id="4b18f-343">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4b18f-344">Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4b18f-344">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4b18f-345">Der Slot wird allen Threads zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-345">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="4b18f-346">Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-346">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4b18f-347">Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu.</span><span class="sxs-lookup"><span data-stu-id="4b18f-347">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4b18f-348">Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot wieder verwenden, nachdem der Thread abläuft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-348">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="4b18f-349">Daten Slots sind pro Thread eindeutig.</span><span class="sxs-lookup"><span data-stu-id="4b18f-349">Data slots are unique per thread.</span></span> <span data-ttu-id="4b18f-350">Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-350">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-351">Dieser Abschnitt enthält zwei Codebeispiele.</span><span class="sxs-lookup"><span data-stu-id="4b18f-351">This section contains two code examples.</span></span> <span data-ttu-id="4b18f-352">Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-352">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-353">Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.</span><span class="sxs-lookup"><span data-stu-id="4b18f-353">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4b18f-354">**Erstes Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-354">**First Example**</span></span>  
  
 <span data-ttu-id="4b18f-355">Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="4b18f-355">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-356">Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.</span><span class="sxs-lookup"><span data-stu-id="4b18f-356">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4b18f-357">**Zweites Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-357">**Second Example**</span></span>  
  
 <span data-ttu-id="4b18f-358">Im folgenden Codebeispiel wird veranschaulicht, wie Sie einen Datenslot zum Speichern Thread spezifischer Informationen verwenden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-358">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="4b18f-359">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-359">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="4b18f-360">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</span><span class="sxs-lookup"><span data-stu-id="4b18f-360">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="4b18f-361">Der Name des zu reservierenden Datenslots.</span><span class="sxs-lookup"><span data-stu-id="4b18f-361">The name of the data slot to be allocated.</span></span></param>
        <summary><span data-ttu-id="4b18f-362">Reserviert einen benannten Datenslot für alle Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-362">Allocates a named data slot on all threads.</span></span> <span data-ttu-id="4b18f-363">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-363">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="4b18f-364">Der reservierte benannte Datenslot für alle Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-364">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4b18f-365">Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots.</span><span class="sxs-lookup"><span data-stu-id="4b18f-365">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4b18f-366">Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit.</span><span class="sxs-lookup"><span data-stu-id="4b18f-366">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4b18f-367">Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4b18f-367">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4b18f-368">Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-368">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4b18f-369">Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu.</span><span class="sxs-lookup"><span data-stu-id="4b18f-369">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4b18f-370">Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot wieder verwenden, nachdem der Thread abläuft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-370">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="4b18f-371">Daten Slots sind pro Thread eindeutig.</span><span class="sxs-lookup"><span data-stu-id="4b18f-371">Data slots are unique per thread.</span></span> <span data-ttu-id="4b18f-372">Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-372">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="4b18f-373">Es ist nicht erforderlich, die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A>-Methode zu verwenden, um einen benannten Datenslot zuzuordnen, da die <xref:System.Threading.Thread.GetNamedDataSlot%2A>-Methode den Slot zuordnet, wenn er noch nicht zugeordnet wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-373">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-374">Wenn die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A>-Methode verwendet wird, sollte Sie im Haupt Thread beim Programmstart aufgerufen werden, da Sie eine Ausnahme auslöst, wenn bereits ein Slot mit dem angegebenen Namen zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-374">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="4b18f-375">Es gibt keine Möglichkeit, zu testen, ob ein Slot bereits zugeordnet wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-375">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="4b18f-376">Mit dieser Methode zugeordnete Slots müssen mit <xref:System.Threading.Thread.FreeNamedDataSlot%2A>freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-376">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-377">Dieser Abschnitt enthält zwei Codebeispiele.</span><span class="sxs-lookup"><span data-stu-id="4b18f-377">This section contains two code examples.</span></span> <span data-ttu-id="4b18f-378">Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-378">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-379">Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.</span><span class="sxs-lookup"><span data-stu-id="4b18f-379">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4b18f-380">**Erstes Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-380">**First Example**</span></span>  
  
 <span data-ttu-id="4b18f-381">Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="4b18f-381">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-382">Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.</span><span class="sxs-lookup"><span data-stu-id="4b18f-382">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4b18f-383">**Zweites Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-383">**Second Example**</span></span>  
  
 <span data-ttu-id="4b18f-384">Im folgenden Beispiel wird veranschaulicht, wie ein benannter Datenslot verwendet wird, um Thread spezifische Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-384">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-385">Der Beispielcode verwendet nicht die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A>-Methode, da die <xref:System.Threading.Thread.GetNamedDataSlot%2A>-Methode den Slot zuordnet, wenn er noch nicht zugeordnet wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-385">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="4b18f-386">Wenn die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A>-Methode verwendet wird, sollte Sie im Haupt Thread beim Programmstart aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-386">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4b18f-387">Es ist bereits ein benannter Datenslot mit dem angegebenen Namen vorhanden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-387">A named data slot with the specified name already exists.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="4b18f-388">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-388">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="4b18f-389">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</span><span class="sxs-lookup"><span data-stu-id="4b18f-389">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-390">Ruft den Apartmentzustand dieses Threads ab oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="4b18f-390">Gets or sets the apartment state of this thread.</span></span></summary>
        <value><span data-ttu-id="4b18f-391">Einer der <see cref="T:System.Threading.ApartmentState" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="4b18f-391">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span></span> <span data-ttu-id="4b18f-392">Der Anfangswert ist <see langword="Unknown" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-392">The initial value is <see langword="Unknown" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-393">**Die <xref:System.Threading.Thread.ApartmentState%2A>-Eigenschaft ist veraltet.**</span><span class="sxs-lookup"><span data-stu-id="4b18f-393">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="4b18f-394">Die nicht veralteten Alternativen sind die <xref:System.Threading.Thread.GetApartmentState%2A> Methode zum Abrufen des Apartment Zustands und die <xref:System.Threading.Thread.SetApartmentState%2A>-Methode, um den Apartment Zustand festzulegen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-394">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="4b18f-395">In den .NET Framework Versionen 1,0 und 1,1 markiert die `ApartmentState`-Eigenschaft einen Thread, um anzugeben, dass er in einem Single Thread-oder Multithread-Apartment ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-395">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="4b18f-396">Diese Eigenschaft kann festgelegt werden, wenn sich der Thread im `Unstarted` oder `Running` Thread Zustand befindet. Sie kann jedoch nur einmal für einen Thread festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-396">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="4b18f-397">Wenn die Eigenschaft nicht festgelegt wurde, wird `Unknown`zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-397">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="4b18f-398">Der Versuch, die <xref:System.Threading.Thread.ApartmentState%2A>-Eigenschaft zu verwenden, um den Apartment Zustand eines Threads festzulegen, dessen Apartment Zustand bereits festgelegt wurde, wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-398">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="4b18f-399">Die <xref:System.Threading.Thread.SetApartmentState%2A>-Methode löst in diesem Fall jedoch eine <xref:System.InvalidOperationException> aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-399">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4b18f-400">In der .NET Framework Version 2,0 werden neue Threads als <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> initialisiert, wenn der Apartment Zustand nicht festgelegt wurde, bevor Sie gestartet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-400">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="4b18f-401">Der Haupt Anwendungs Thread wird initialisiert, um standardmäßig <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4b18f-401">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="4b18f-402">Der Hauptanwendungs Thread kann nicht mehr auf <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> festgelegt werden, indem die <xref:System.Threading.ApartmentState?displayProperty=nameWithType>-Eigenschaft in der ersten Codezeile festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-402">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="4b18f-403">Verwenden Sie stattdessen die-<xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="4b18f-403">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="4b18f-404">In der .NET Framework Version 2,0 können Sie das COM-Threading Modell für eine C++ Anwendung mithilfe der [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) -Linkeroption angeben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-404">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-405">Im folgenden Codebeispiel wird veranschaulicht, wie der Apartment Zustand eines Threads festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-405">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4b18f-406">Es wird versucht, diese Eigenschaft in einen Zustand zu versetzen, der kein gültiger Apartmentzustand ist, d. h. in einen anderen Zustand als Singlethread-Apartment (<see langword="STA" />) oder Multithread-Apartment (<see langword="MTA" />).</span><span class="sxs-lookup"><span data-stu-id="4b18f-406">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-407">Benachrichtigt einen Host, dass die Ausführung im Begriff ist, zu einem Codebereich überzugehen, in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme andere Aufgaben in der Anwendungsdomäne gefährden könnten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-407">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-408">Hosts des Common Language Runtime (CLR), z. b. Microsoft SQL Server 2005, können unterschiedliche Richtlinien für Fehler in kritischen und nicht kritischen Codebereichen einrichten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-408">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="4b18f-409">Eine kritische Region ist eine Region, in der die Auswirkungen eines Thread Abbruchs oder einer nicht behandelten Ausnahme möglicherweise nicht auf die aktuelle Aufgabe beschränkt sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-409">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="4b18f-410">Im Gegensatz dazu wirkt sich ein Abbruch oder Fehler in einem nicht kritischen Code Bereich nur auf die Aufgabe aus, in der der Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-410">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="4b18f-411">Stellen Sie sich z. b. einen Task vor, der versucht, während einer Sperre Speicher zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-411">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="4b18f-412">Wenn die Speicher Belegung fehlschlägt, reicht das Abbrechen der aktuellen Aufgabe nicht aus, um die Stabilität des <xref:System.AppDomain>zu gewährleisten, weil in der Domäne andere Tasks vorhanden sein können, die auf die gleiche Sperre warten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-412">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="4b18f-413">Wenn die aktuelle Aufgabe beendet wird, können andere Aufgaben blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-413">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="4b18f-414">Wenn ein Fehler in einer kritischen Region auftritt, kann der Host die gesamte <xref:System.AppDomain> entladen, anstatt das Risiko der Fortsetzung der Ausführung in einem potenziell instabilen Zustand zu nehmen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-414">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="4b18f-415">Um den Host zu informieren, dass der Code in einen kritischen Bereich wechselt, wenden Sie <xref:System.Threading.Thread.BeginCriticalRegion%2A>an.</span><span class="sxs-lookup"><span data-stu-id="4b18f-415">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="4b18f-416">Ruft <xref:System.Threading.Thread.EndCriticalRegion%2A> auf, wenn die Ausführung in einen nicht kritischen Code Bereich zurückkehrt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-416">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="4b18f-417">Wenn Sie diese Methode in Code verwenden, der unter SQL Server 2005 ausgeführt wird, muss der Code auf der höchsten Host Schutz Ebene ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-417">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-418">Im folgenden Beispiel wird veranschaulicht, wie die Methoden <xref:System.Threading.Thread.BeginCriticalRegion%2A> und <xref:System.Threading.Thread.EndCriticalRegion%2A> verwendet werden, um einen Codeblock in kritische und nicht kritische Bereiche aufzuteilen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-418">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-419">Benachrichtigt einen Host, dass verwalteter Code im Begriff ist, Anweisungen auszuführen, die von der Identität des aktuellen physischen Betriebssystemthreads abhängen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-419">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-420">Einige Hosts der Common Language Runtime, z. b. Microsoft SQL Server 2005, stellen eine eigene Thread Verwaltung bereit.</span><span class="sxs-lookup"><span data-stu-id="4b18f-420">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="4b18f-421">Ein Host, der die eigene Thread Verwaltung bereitstellt, kann eine ausgeführte Aufgabe jederzeit von einem physischen Betriebssystem Thread zu einem anderen verschieben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-421">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="4b18f-422">Die meisten Aufgaben sind von diesem Wechsel nicht betroffen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-422">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="4b18f-423">Einige Tasks verfügen jedoch über Thread Affinität, d. h., Sie hängen von der Identität eines physischen Betriebssystemthreads ab.</span><span class="sxs-lookup"><span data-stu-id="4b18f-423">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="4b18f-424">Diese Tasks müssen den Host benachrichtigen, wenn Sie Code ausführen, der nicht gewechselt werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-424">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="4b18f-425">Wenn Ihre Anwendung z. b. eine System-API aufruft, um eine Betriebssystem Sperre mit Thread Affinität (z. b. eine Win32-CRITICAL_SECTION abzurufen), müssen Sie <xref:System.Threading.Thread.BeginThreadAffinity%2A> vor dem Erwerb der Sperre aufrufen und <xref:System.Threading.Thread.EndThreadAffinity%2A>, nachdem die Sperre freigegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-425">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="4b18f-426">Wenn Sie diese Methode in Code verwenden, der unter SQL Server 2005 ausgeführt wird, muss der Code auf der höchsten Host Schutz Ebene ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-426">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-427">Im folgenden Beispiel wird veranschaulicht, wie die Methoden <xref:System.Threading.Thread.BeginThreadAffinity%2A> und <xref:System.Threading.Thread.EndThreadAffinity%2A> verwendet werden, um einen Host zu benachrichtigen, dass ein Codeblock von der Identität eines physischen Betriebssystemthreads abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-427">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4b18f-428">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="4b18f-428">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4b18f-429">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="4b18f-429">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4b18f-430">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-430">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-431">Ruft den aktuellen Kontext ab, in dem der Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-431">Gets the current context in which the thread is executing.</span></span></summary>
        <value><span data-ttu-id="4b18f-432">Ein <see cref="T:System.Runtime.Remoting.Contexts.Context" /> der den aktuellen Kontext des Threads darstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-432">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4b18f-433">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="4b18f-433">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4b18f-434">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="4b18f-434">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4b18f-435">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-435">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-436">Ruft die Kultur für den aktuellen Thread ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="4b18f-436">Gets or sets the culture for the current thread.</span></span></summary>
        <value><span data-ttu-id="4b18f-437">Ein Objekt, das die Kultur für den aktuellen Thread darstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-437">An object that represents the culture for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-438">Das <xref:System.Globalization.CultureInfo> Objekt, das von dieser Eigenschaft zusammen mit den zugeordneten Objekten zurückgegeben wird, bestimmt das Standardformat für Datumsangaben, Uhrzeiten, Ziffern, Währungswerte, Sortierreihenfolge von Text, Schreib Konventionen und Zeichen folgen Vergleiche.</span><span class="sxs-lookup"><span data-stu-id="4b18f-438">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="4b18f-439">Sehen Sie sich die <xref:System.Globalization.CultureInfo>-Klasse an, um mehr über Kultur Namen und Bezeichner zu erfahren, die Unterschiede zwischen invarianten, neutralen und bestimmten Kulturen und die Art und Weise, wie Kultur Informationen Auswirkungen auf Threads und Anwendungs Domänen</span><span class="sxs-lookup"><span data-stu-id="4b18f-439">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="4b18f-440">Sehen Sie sich die <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>-Eigenschaft an, um zu erfahren, wie die Standard Kultur eines Threads bestimmt wird und wie Benutzer Kultur Informationen für Ihre Computer festlegen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-440">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="4b18f-441">Die <xref:System.Threading.Thread.CurrentCulture>-Eigenschaft funktioniert nicht zuverlässig, wenn Sie mit einem anderen Thread als dem aktuellen Thread verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-441">The <xref:System.Threading.Thread.CurrentCulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="4b18f-442">In .NET Framework ist das Lesen der Eigenschaft zuverlässig, auch wenn Sie für einen anderen Thread als den aktuellen Thread festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-442">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="4b18f-443">Unter .net Core wird eine <xref:System.InvalidOperationException> ausgelöst, wenn ein Thread versucht, die <xref:System.Threading.Thread.CurrentCulture>-Eigenschaft in einem anderen Thread zu lesen oder zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-443">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentCulture> property on a different thread.</span></span>
> <span data-ttu-id="4b18f-444">Es wird empfohlen, dass Sie die <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType>-Eigenschaft verwenden, um die aktuelle Kultur abzurufen und festzulegen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-444">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="4b18f-445">Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]können Sie die <xref:System.Threading.Thread.CurrentCulture%2A>-Eigenschaft auf eine neutrale Kultur festlegen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-445">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="4b18f-446">Dies liegt daran, dass sich das Verhalten der <xref:System.Globalization.CultureInfo> Klasse geändert hat: Wenn es sich um eine neutrale Kultur handelt, entsprechen seine Eigenschaftswerte (insbesondere die Eigenschaften <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>und <xref:System.Globalization.CultureInfo.TextInfo%2A>) jetzt der spezifischen Kultur, die der neutralen Kultur zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-446">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="4b18f-447">In früheren Versionen des .NET Framework hat die <xref:System.Threading.Thread.CurrentCulture%2A>-Eigenschaft eine <xref:System.NotSupportedException> Ausnahme ausgelöst, als eine neutrale Kultur zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-447">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
## Examples  
 <span data-ttu-id="4b18f-448">Das folgende Beispiel zeigt die Threading-Anweisung, mit der die Benutzeroberfläche einer Windows Forms Anwendung in der in der Systemsteuerung festgelegten Kultur angezeigt werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-448">The following example shows the threading statement that allows the user interface of a Windows Forms application to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="4b18f-449">Zusätzlicher Code ist erforderlich.</span><span class="sxs-lookup"><span data-stu-id="4b18f-449">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4b18f-450">Die Eigenschaft ist auf <see langword="null" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-450">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4b18f-451">Nur .NET Core: Das Lesen oder Schreiben der Kultur eines Threads aus einem anderen Thread wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-451">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4b18f-452">zum Festlegen der-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-452">for setting the property.</span></span> <span data-ttu-id="4b18f-453">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="4b18f-453">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-454">Ruft den aktuellen Prinzipal des Threads (für rollenbasierte Sicherheit) ab oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="4b18f-454">Gets or sets the thread's current principal (for role-based security).</span></span></summary>
        <value><span data-ttu-id="4b18f-455">Ein <see cref="T:System.Security.Principal.IPrincipal" />-Wert, der den Sicherheitskontext darstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-455">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4b18f-456">Im folgenden Codebeispiel wird gezeigt, wie der Prinzipal eines Threads festgelegt und abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-456">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4b18f-457">Der Aufrufer verfügt nicht über die erforderliche Berechtigung zum Festlegen des Prinzipals.</span><span class="sxs-lookup"><span data-stu-id="4b18f-457">The caller does not have the permission required to set the principal.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4b18f-458">, um das Prinzipal Objekt zu bearbeiten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-458">to manipulate the principal object.</span></span> <span data-ttu-id="4b18f-459">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></span><span class="sxs-lookup"><span data-stu-id="4b18f-459">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-460">Ruft den derzeit ausgeführten Thread ab.</span><span class="sxs-lookup"><span data-stu-id="4b18f-460">Gets the currently running thread.</span></span></summary>
        <value><span data-ttu-id="4b18f-461">Ein <see cref="T:System.Threading.Thread" />, der den derzeit ausgeführten Thread darstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-461">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4b18f-462">Im folgenden Beispiel wird eine Aufgabe erstellt, die wiederum 20 untergeordnete Aufgaben erstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-462">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="4b18f-463">Die Anwendung selbst und jede Aufgabe ruft die `ShowThreadInformation`-Methode auf, die die <xref:System.Threading.Thread.CurrentThread%2A>-Eigenschaft verwendet, um Informationen über den Thread anzuzeigen, in dem Sie ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-463">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="4b18f-464">Jede untergeordnete Aufgabe generiert 1 Million Zufallszahlen zwischen 1 und 1 Million und gibt ihren Mittelwert zurück.</span><span class="sxs-lookup"><span data-stu-id="4b18f-464">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="4b18f-465">Die übergeordnete Aufgabe ruft die <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>-Methode auf, um sicherzustellen, dass die untergeordneten Aufgaben abgeschlossen wurden, bevor der von den einzelnen Aufgaben zurückgegebene Mittelwert und der Mittelwert der Mittelwert</span><span class="sxs-lookup"><span data-stu-id="4b18f-465">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="4b18f-466">Beachten Sie, dass die Anwendung in einem Thread Pool Thread ausgeführt wird, während die Anwendung auf einem Vordergrund Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-466">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-467">Ruft die aktuelle Kultur ab, mit deren Hilfe der Ressourcen-Manager zur Laufzeit kulturabhängige Ressourcen sucht, oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="4b18f-467">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span></span></summary>
        <value><span data-ttu-id="4b18f-468">Ein Objekt, das die aktuelle Kultur darstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-468">An object that represents the current culture.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-469">Die Benutzeroberflächen Kultur gibt die Ressourcen an, die eine Anwendung benötigt, um Benutzereingaben und-Ausgaben zu unterstützen, und ist standardmäßig identisch mit der Kultur des Betriebssystems.</span><span class="sxs-lookup"><span data-stu-id="4b18f-469">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="4b18f-470">Sehen Sie sich die <xref:System.Globalization.CultureInfo>-Klasse an, um mehr über Kultur Namen und Bezeichner zu erfahren, die Unterschiede zwischen invarianten, neutralen und bestimmten Kulturen und die Art und Weise, wie Kultur Informationen Auswirkungen auf Threads und Anwendungs Domänen</span><span class="sxs-lookup"><span data-stu-id="4b18f-470">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="4b18f-471">Informationen dazu, wie die Standardbenutzer Oberflächen Kultur eines Threads bestimmt wird, finden Sie unter der <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-471">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="4b18f-472">Die <xref:System.Threading.Thread.CurrentUICulture>-Eigenschaft funktioniert nicht zuverlässig, wenn Sie mit einem anderen Thread als dem aktuellen Thread verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-472">The <xref:System.Threading.Thread.CurrentUICulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="4b18f-473">In .NET Framework ist das Lesen der Eigenschaft zuverlässig, auch wenn Sie für einen anderen Thread als den aktuellen Thread festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-473">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="4b18f-474">Unter .net Core wird eine <xref:System.InvalidOperationException> ausgelöst, wenn ein Thread versucht, die <xref:System.Threading.Thread.CurrentUICulture>-Eigenschaft in einem anderen Thread zu lesen oder zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-474">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentUICulture> property on a different thread.</span></span>
> <span data-ttu-id="4b18f-475">Es wird empfohlen, dass Sie die <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType>-Eigenschaft verwenden, um die aktuelle Kultur abzurufen und festzulegen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-475">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="4b18f-476">Die von dieser Eigenschaft zurückgegebene <xref:System.Globalization.CultureInfo> kann eine neutrale Kultur sein.</span><span class="sxs-lookup"><span data-stu-id="4b18f-476">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="4b18f-477">Neutrale Kulturen sollten nicht mit Formatierungs Methoden wie <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>und <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-477">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b18f-478">Verwenden Sie die <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>-Methode, um eine bestimmte Kultur zu erhalten, oder verwenden Sie die <xref:System.Threading.Thread.CurrentCulture%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-478">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-479">Die <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>-Methode löst <xref:System.ArgumentException> für die neutralen Kulturen "zh-Hant" ("zh-CHT") und "zh-Hans" ("zh-CHS") aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-479">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-480">Im folgenden Beispiel wird bestimmt, ob die Sprache der Benutzeroberflächen Kultur des aktuellen Threads Französisch ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-480">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="4b18f-481">Wenn dies nicht der Fall ist, wird die Benutzeroberflächen Kultur des aktuellen Threads auf Englisch (USA) festgelegt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-481">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="4b18f-482">Das folgende Codebeispiel zeigt die Threading-Anweisung, mit der die Benutzeroberfläche einer Windows Forms in der in der Systemsteuerung festgelegten Kultur angezeigt werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-482">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="4b18f-483">Zusätzlicher Code ist erforderlich.</span><span class="sxs-lookup"><span data-stu-id="4b18f-483">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4b18f-484">Die Eigenschaft ist auf <see langword="null" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-484">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4b18f-485">Die Eigenschaft ist auf einen Kulturnamen festgelegt, der nicht zum Suchen einer Ressourcendatei verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-485">The property is set to a culture name that cannot be used to locate a resource file.</span></span> <span data-ttu-id="4b18f-486">Ressourcendateinamen dürfen nur Buchstaben, Zahlen, Bindestriche oder Unterstriche enthalten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-486">Resource filenames must include only letters, numbers, hyphens or underscores.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4b18f-487">Nur .NET Core: Das Lesen oder Schreiben der Kultur eines Threads aus einem anderen Thread wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-487">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-488">Deaktiviert die automatische Bereinigung von Runtime Callable Wrappern (RCW) für den aktuellen Thread.</span><span class="sxs-lookup"><span data-stu-id="4b18f-488">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-489">Standardmäßig bereinigt der Common Language Runtime (CLR) automatisch aufrufbare Wrapper für die Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="4b18f-489">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="4b18f-490">Die CLR bereinigt Nachrichten während der Bereinigung, was zu Problemen bei einigen Anwendungen führen kann, die die folgenden ungewöhnlichen Kriterien erfüllen:</span><span class="sxs-lookup"><span data-stu-id="4b18f-490">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="4b18f-491">Die Anwendung führt eine eigene Nachrichten Pumpe aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-491">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="4b18f-492">Die Anwendung muss genau steuern, wann das Senden von Nachrichten erfolgt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-492">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="4b18f-493">Solche Anwendungen können die <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A>-Methode verwenden, um zu verhindern, dass die CLR automatische Wiederherstellung von Runtime Callable Wrappern durchführen kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-493">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="4b18f-494">Wenn diese Methode für einen Thread aufgerufen wurde, kann der automatische Bereinigung für diesen Thread nicht erneut aktiviert werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-494">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="4b18f-495">Wenn Ihre Anwendung für die Bereinigung von Runtime Callable Wrapper bereit ist, verwenden Sie die <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType>-Methode, um die Laufzeit anzuweisen, alle Runtime Callable Wrapper im aktuellen Kontext zu bereinigen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-495">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="4b18f-496">Das Senden von Nachrichten erfolgt während der Ausführung der Methode.</span><span class="sxs-lookup"><span data-stu-id="4b18f-496">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4b18f-497">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="4b18f-497">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4b18f-498">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-498">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-499">Benachrichtigt einen Host, dass die Ausführung im Begriff ist, zu einem Codebereich überzugehen, in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme auf die aktuelle Aufgabe beschränkt sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-499">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-500">Hosts des Common Language Runtime (CLR), z. b. Microsoft SQL Server 2005, können unterschiedliche Richtlinien für Fehler in kritischen und nicht kritischen Codebereichen einrichten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-500">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="4b18f-501">Eine kritische Region ist eine Region, in der die Auswirkungen eines Thread Abbruchs oder einer nicht behandelten Ausnahme möglicherweise nicht auf die aktuelle Aufgabe beschränkt sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-501">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="4b18f-502">Im Gegensatz dazu wirkt sich ein Abbruch oder Fehler in einem nicht kritischen Code Bereich nur auf die Aufgabe aus, in der der Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-502">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="4b18f-503">Stellen Sie sich z. b. einen Task vor, der versucht, während einer Sperre Speicher zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-503">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="4b18f-504">Wenn die Speicher Belegung fehlschlägt, reicht das Abbrechen der aktuellen Aufgabe nicht aus, um die Stabilität des <xref:System.AppDomain>zu gewährleisten, weil in der Domäne andere Tasks vorhanden sein können, die auf die gleiche Sperre warten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-504">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="4b18f-505">Wenn die aktuelle Aufgabe beendet wird, können andere Aufgaben blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-505">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="4b18f-506">Wenn ein Fehler in einer kritischen Region auftritt, kann der Host die gesamte <xref:System.AppDomain> entladen, anstatt das Risiko der Fortsetzung der Ausführung in einem potenziell instabilen Zustand zu nehmen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-506">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="4b18f-507">Um den Host zu informieren, dass der Code in einen kritischen Bereich wechselt, wenden Sie <xref:System.Threading.Thread.BeginCriticalRegion%2A>an.</span><span class="sxs-lookup"><span data-stu-id="4b18f-507">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="4b18f-508">Ruft <xref:System.Threading.Thread.EndCriticalRegion%2A> auf, wenn die Ausführung in einen nicht kritischen Code Bereich zurückkehrt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-508">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="4b18f-509">Wenn Sie diese Methode in Code verwenden, der unter SQL Server 2005 ausgeführt wird, muss der Code auf der höchsten Host Schutz Ebene ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-509">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-510">Im folgenden Beispiel wird veranschaulicht, wie die Methoden <xref:System.Threading.Thread.BeginCriticalRegion%2A> und <xref:System.Threading.Thread.EndCriticalRegion%2A> verwendet werden, um einen Codeblock in kritische und nicht kritische Bereiche aufzuteilen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-510">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-511">Benachrichtigt einen Host, dass verwalteter Code die Ausführung von Anweisungen beendet hat, die von der Identität des aktuellen physischen Betriebssystemthreads abhängen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-511">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-512">Einige Hosts der Common Language Runtime, z. b. Microsoft SQL Server 2005, stellen eine eigene Thread Verwaltung bereit.</span><span class="sxs-lookup"><span data-stu-id="4b18f-512">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="4b18f-513">Ein Host, der die eigene Thread Verwaltung bereitstellt, kann eine ausgeführte Aufgabe jederzeit von einem physischen Betriebssystem Thread zu einem anderen verschieben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-513">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="4b18f-514">Die meisten Aufgaben sind von diesem Wechsel nicht betroffen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-514">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="4b18f-515">Einige Tasks verfügen jedoch über Thread Affinität, d. h., Sie hängen von der Identität eines physischen Betriebssystemthreads ab.</span><span class="sxs-lookup"><span data-stu-id="4b18f-515">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="4b18f-516">Diese Tasks müssen den Host benachrichtigen, wenn Sie Code ausführen, der nicht gewechselt werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-516">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="4b18f-517">Wenn Ihre Anwendung z. b. eine System-API aufruft, um eine Betriebssystem Sperre mit Thread Affinität (z. b. eine Win32-CRITICAL_SECTION abzurufen), müssen Sie <xref:System.Threading.Thread.BeginThreadAffinity%2A> vor dem Erwerb der Sperre aufrufen und <xref:System.Threading.Thread.EndThreadAffinity%2A>, nachdem die Sperre freigegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-517">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="4b18f-518">Wenn Sie diese Methode in Code verwenden, der unter SQL Server 2005 ausgeführt wird, muss der Code auf der höchsten Host Schutz Ebene ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-518">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-519">Im folgenden Beispiel wird veranschaulicht, wie die Methoden <xref:System.Threading.Thread.BeginThreadAffinity%2A> und <xref:System.Threading.Thread.EndThreadAffinity%2A> verwendet werden, um einen Host zu benachrichtigen, dass ein Codeblock von der Identität eines physischen Betriebssystemthreads abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-519">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4b18f-520">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="4b18f-520">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4b18f-521">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="4b18f-521">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4b18f-522">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-522">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-523">Ruft ein <see cref="T:System.Threading.ExecutionContext" />-Objekt ab, das Informationen zu den verschiedenen Kontexten des aktuellen Threads enthält.</span><span class="sxs-lookup"><span data-stu-id="4b18f-523">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span></span></summary>
        <value><span data-ttu-id="4b18f-524">Ein <see cref="T:System.Threading.ExecutionContext" />-Objekt, das Kontextinformationen für den aktuellen Thread konsolidiert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-524">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-525">Die <xref:System.Threading.ExecutionContext>-Klasse stellt einen einzelnen Container für alle Informationen bereit, die für einen logischen Ausführungs Thread relevant sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-525">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="4b18f-526">Dies schließt den Sicherheitskontext, den Rückruf Kontext, den Synchronisierungs Kontext, den Lokalisierungs Kontext und den Transaktionskontext ein.</span><span class="sxs-lookup"><span data-stu-id="4b18f-526">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-527">Stellt das Freigeben von Ressourcen und das Ausführen anderer Garbage Collector-Vorgänge sicher, wenn der Garbage Collector das <see cref="T:System.Threading.Thread" />-Objekt verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-527">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-528">Der Garbage Collector ruft <xref:System.Threading.Thread.Finalize%2A> auf, wenn das aktuelle-Objekt für die Fertigstellung bereit ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-528">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="4b18f-529">Der Name des freizugebenden Datenslots.</span><span class="sxs-lookup"><span data-stu-id="4b18f-529">The name of the data slot to be freed.</span></span></param>
        <summary><span data-ttu-id="4b18f-530">Entfernt die Zuordnung zwischen einem Namen und einem Slot für alle Threads in dem Prozess.</span><span class="sxs-lookup"><span data-stu-id="4b18f-530">Eliminates the association between a name and a slot, for all threads in the process.</span></span> <span data-ttu-id="4b18f-531">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-531">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4b18f-532">Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots.</span><span class="sxs-lookup"><span data-stu-id="4b18f-532">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4b18f-533">Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit.</span><span class="sxs-lookup"><span data-stu-id="4b18f-533">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4b18f-534">Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4b18f-534">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4b18f-535">Nachdem ein Thread `FreeNamedDataSlot`aufgerufen hat, weist jeder andere Thread, der <xref:System.Threading.Thread.GetNamedDataSlot%2A> mit demselben Namen aufruft, einen neuen Slot zu, der mit dem Namen verknüpft ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-535">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="4b18f-536">Nachfolgende Aufrufe von, die von einem beliebigen Thread `GetNamedDataSlot` werden, geben den neuen Slot zurück.</span><span class="sxs-lookup"><span data-stu-id="4b18f-536">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="4b18f-537">Allerdings kann jeder Thread, der noch über einen <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> verfügt, der von einem früheren `GetNamedDataSlot` zurückgegeben wurde, weiterhin den alten Slot verwenden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-537">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="4b18f-538">Ein Slot, dem ein Name zugeordnet ist, wird nur freigegeben, wenn jede `LocalDataStoreSlot`, die vor dem `FreeNamedDataSlot` aufgerufen wurde, freigegeben wurde und eine Garbage Collection durchgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-538">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="4b18f-539">Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-539">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4b18f-540">Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu.</span><span class="sxs-lookup"><span data-stu-id="4b18f-540">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4b18f-541">Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot wieder verwenden, nachdem der Thread abläuft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-541">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="4b18f-542">Daten Slots sind pro Thread eindeutig.</span><span class="sxs-lookup"><span data-stu-id="4b18f-542">Data slots are unique per thread.</span></span> <span data-ttu-id="4b18f-543">Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-543">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-544">Dieser Abschnitt enthält zwei Codebeispiele.</span><span class="sxs-lookup"><span data-stu-id="4b18f-544">This section contains two code examples.</span></span> <span data-ttu-id="4b18f-545">Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-545">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-546">Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.</span><span class="sxs-lookup"><span data-stu-id="4b18f-546">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4b18f-547">**Erstes Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-547">**First Example**</span></span>  
  
 <span data-ttu-id="4b18f-548">Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="4b18f-548">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-549">Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.</span><span class="sxs-lookup"><span data-stu-id="4b18f-549">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4b18f-550">**Zweites Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-550">**Second Example**</span></span>  
  
 <span data-ttu-id="4b18f-551">Im folgenden Beispiel wird veranschaulicht, wie ein benannter Datenslot verwendet wird, um Thread spezifische Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-551">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="4b18f-552">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-552">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="4b18f-553">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</span><span class="sxs-lookup"><span data-stu-id="4b18f-553">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-554">Gibt einen <see cref="T:System.Threading.ApartmentState" />-Wert zurück, der den Apartmentzustand angibt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-554">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span></span></summary>
        <returns><span data-ttu-id="4b18f-555">Einer der <see cref="T:System.Threading.ApartmentState" />-Werte, der den Apartmentzustand des verwalteten Threads angibt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-555">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span></span> <span data-ttu-id="4b18f-556">Der Standardwert ist <see cref="F:System.Threading.ApartmentState.Unknown" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-556">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-557">Diese Methode ersetzt zusammen mit der <xref:System.Threading.Thread.SetApartmentState%2A>-Methode und der <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode die <xref:System.Threading.Thread.ApartmentState%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-557">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-558">Im folgenden Codebeispiel werden die Methoden <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>und <xref:System.Threading.Thread.TrySetApartmentState%2A> veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="4b18f-558">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="4b18f-559">Im Codebeispiel wird ein Thread erstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-559">The code example creates a thread.</span></span> <span data-ttu-id="4b18f-560">Bevor der Thread gestartet wird, zeigt <xref:System.Threading.Thread.GetApartmentState%2A> den anfänglichen <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> Status an, und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Status in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4b18f-560">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b18f-561">Die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode gibt dann `false` zurück, wenn versucht wird, den Zustand in <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> zu ändern, da der Apartment Zustand bereits festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-561">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="4b18f-562">Wenn der gleiche Vorgang mit <xref:System.Threading.Thread.SetApartmentState%2A>versucht wurde, wurde <xref:System.InvalidOperationException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="4b18f-562">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="4b18f-563">Nachdem der Thread gestartet wurde, wird die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode erneut verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-563">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="4b18f-564">Dieses Mal wird <xref:System.Threading.ThreadStateException> ausgelöst, da der Thread bereits gestartet wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-564">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-565">Gibt ein <see cref="T:System.Threading.CompressedStack" />-Objekt zurück, mit dem der Stapel für den aktuellen Thread erfasst werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-565">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span></span></summary>
        <returns><span data-ttu-id="4b18f-566">None.</span><span class="sxs-lookup"><span data-stu-id="4b18f-566">None.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-567">Diese Methode wird nicht mehr unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-567">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4b18f-568">In allen Fällen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-568">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4b18f-569">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="4b18f-569">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4b18f-570">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-570">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-571">Ruft eine ID ab, mit der angegeben wird, mit welchem Prozessor der aktuelle Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-571">Gets an ID used to indicate on which processor the current thread is executing.</span></span></summary>
        <returns><span data-ttu-id="4b18f-572">Ein Integerwert, der die zwischengespeicherte Prozessor-ID darstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-572">An integer representing the cached processor ID.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="4b18f-573">Dieser Wert wird zwischengespeichert und regelmäßig aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-573">This value is cached and periodically refreshed.</span></span> <span data-ttu-id="4b18f-574">Sie ist möglicherweise veraltet, wenn Sie verwendet wird: das Verarbeiten von Code darf sich nicht auf seine Richtigkeit der Richtigkeit verlassen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-574">It may be stale by the time it's used: consuming code must not rely on its accuracy for correctness.</span></span>

<span data-ttu-id="4b18f-575">Es ist nicht garantiert, dass der Wert eine Null basierte Prozessornummer ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-575">The value is not guaranteed to be a zero-based processor number.</span></span>

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="4b18f-576">Der <see cref="T:System.LocalDataStoreSlot" />, aus dem der Wert abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-576">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span></span></param>
        <summary><span data-ttu-id="4b18f-577">Ruft in der aktuellen Domäne des aktuellen Threads den Wert aus dem angegebenen Slot für den aktuellen Thread ab.</span><span class="sxs-lookup"><span data-stu-id="4b18f-577">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span></span> <span data-ttu-id="4b18f-578">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-578">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="4b18f-579">Der abgerufene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-579">The retrieved value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4b18f-580">Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots.</span><span class="sxs-lookup"><span data-stu-id="4b18f-580">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4b18f-581">Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit.</span><span class="sxs-lookup"><span data-stu-id="4b18f-581">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4b18f-582">Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4b18f-582">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4b18f-583">Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-583">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4b18f-584">Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu.</span><span class="sxs-lookup"><span data-stu-id="4b18f-584">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4b18f-585">Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot wieder verwenden, nachdem der Thread abläuft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-585">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="4b18f-586">Daten Slots sind pro Thread eindeutig.</span><span class="sxs-lookup"><span data-stu-id="4b18f-586">Data slots are unique per thread.</span></span> <span data-ttu-id="4b18f-587">Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-587">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-588"><xref:System.Threading.Thread.GetData%2A> ist eine `Shared` Methode, die immer auf den derzeit ausgeführten Thread angewendet wird, auch wenn Sie ihn mit einer Variablen, die auf einen anderen Thread verweist, aufruft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-588"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="4b18f-589">Um Verwirrung zu vermeiden, verwenden Sie den Klassennamen, wenn Sie `Shared` Methoden aufrufen: `Dim test As Object = Thread.GetData(testSlot)`.</span><span class="sxs-lookup"><span data-stu-id="4b18f-589">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-590">Dieser Abschnitt enthält zwei Codebeispiele.</span><span class="sxs-lookup"><span data-stu-id="4b18f-590">This section contains two code examples.</span></span> <span data-ttu-id="4b18f-591">Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-591">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-592">Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.</span><span class="sxs-lookup"><span data-stu-id="4b18f-592">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4b18f-593">**Erstes Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-593">**First Example**</span></span>  
  
 <span data-ttu-id="4b18f-594">Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="4b18f-594">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-595">Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.</span><span class="sxs-lookup"><span data-stu-id="4b18f-595">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4b18f-596">**Zweites Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-596">**Second Example**</span></span>  
  
 <span data-ttu-id="4b18f-597">Im folgenden Beispiel wird veranschaulicht, wie ein Daten Slot zum Speichern Thread spezifischer Informationen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-597">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="4b18f-598">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-598">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="4b18f-599">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</span><span class="sxs-lookup"><span data-stu-id="4b18f-599">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-600">Gibt die aktuelle Domäne zurück, in der der aktuelle Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-600">Returns the current domain in which the current thread is running.</span></span></summary>
        <returns><span data-ttu-id="4b18f-601">Eine <see cref="T:System.AppDomain" />, die die aktuelle Anwendungsdomäne des ausgeführten Threads darstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-601">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4b18f-602">Im folgenden Codebeispiel wird gezeigt, wie der Name und die ID des `AppDomain` abgerufen werden, in dem der Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-602">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-603">Gibt einen eindeutigen Bezeichner der Anwendungsdomäne zurück.</span><span class="sxs-lookup"><span data-stu-id="4b18f-603">Returns a unique application domain identifier.</span></span></summary>
        <returns><span data-ttu-id="4b18f-604">Eine 32-Bit-Ganzzahl mit Vorzeichen, mit der die Anwendungsdomäne eindeutig bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-604">A 32-bit signed integer uniquely identifying the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4b18f-605">Im folgenden Codebeispiel wird gezeigt, wie der Name und die ID des `AppDomain` abgerufen werden, in dem der Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-605">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-606">Gibt einen Hashcode für den aktuellen Thread zurück.</span><span class="sxs-lookup"><span data-stu-id="4b18f-606">Returns a hash code for the current thread.</span></span></summary>
        <returns><span data-ttu-id="4b18f-607">Ein ganzzahliger Hashcodewert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-607">An integer hash code value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-608">Der Hashcode ist nicht garantiert eindeutig.</span><span class="sxs-lookup"><span data-stu-id="4b18f-608">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="4b18f-609">Verwenden Sie die <xref:System.Threading.Thread.ManagedThreadId%2A>-Eigenschaft, wenn Sie einen eindeutigen Bezeichner für einen verwalteten Thread benötigen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-609">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="4b18f-610">Der Name des lokalen Datenslots.</span><span class="sxs-lookup"><span data-stu-id="4b18f-610">The name of the local data slot.</span></span></param>
        <summary><span data-ttu-id="4b18f-611">Sucht einen benannten Datenslot.</span><span class="sxs-lookup"><span data-stu-id="4b18f-611">Looks up a named data slot.</span></span> <span data-ttu-id="4b18f-612">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-612">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="4b18f-613">Ein für diesen Thread reservierter <see cref="T:System.LocalDataStoreSlot" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-613">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4b18f-614">Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots.</span><span class="sxs-lookup"><span data-stu-id="4b18f-614">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4b18f-615">Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit.</span><span class="sxs-lookup"><span data-stu-id="4b18f-615">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4b18f-616">Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4b18f-616">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4b18f-617">Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-617">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4b18f-618">Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu.</span><span class="sxs-lookup"><span data-stu-id="4b18f-618">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4b18f-619">Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot wieder verwenden, nachdem der Thread abläuft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-619">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="4b18f-620">Daten Slots sind pro Thread eindeutig.</span><span class="sxs-lookup"><span data-stu-id="4b18f-620">Data slots are unique per thread.</span></span> <span data-ttu-id="4b18f-621">Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-621">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="4b18f-622">Wenn der benannte Slot nicht vorhanden ist, wird ein neuer Slot zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-622">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="4b18f-623">Benannte Daten Slots sind öffentlich und können von beliebigen Personen bearbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-623">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-624">Dieser Abschnitt enthält zwei Codebeispiele.</span><span class="sxs-lookup"><span data-stu-id="4b18f-624">This section contains two code examples.</span></span> <span data-ttu-id="4b18f-625">Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-625">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-626">Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.</span><span class="sxs-lookup"><span data-stu-id="4b18f-626">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4b18f-627">**Erstes Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-627">**First Example**</span></span>  
  
 <span data-ttu-id="4b18f-628">Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="4b18f-628">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-629">Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.</span><span class="sxs-lookup"><span data-stu-id="4b18f-629">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4b18f-630">**Zweites Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-630">**Second Example**</span></span>  
  
 <span data-ttu-id="4b18f-631">Im folgenden Beispiel wird veranschaulicht, wie ein benannter Datenslot verwendet wird, um Thread spezifische Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-631">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="4b18f-632">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-632">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="4b18f-633">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</span><span class="sxs-lookup"><span data-stu-id="4b18f-633">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-634">Unterbricht einen Thread, der sich im <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />-Threadzustand befindet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-634">Interrupts a thread that is in the <see cref="F:System.Threading.ThreadState.WaitSleepJoin" /> thread state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-635">Wenn dieser Thread momentan nicht in einem Wartezustand, Standbymodus oder joinzustand blockiert ist, wird er beim nächsten Block Vorgang unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-635">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="4b18f-636"><xref:System.Threading.ThreadInterruptedException> wird im unterbrochenen Thread ausgelöst, jedoch nicht, bis der Thread blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-636"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="4b18f-637">Wenn der Thread nie blockiert wird, wird die Ausnahme nie ausgelöst, und der Thread wird daher möglicherweise beendet, ohne jemals unterbrochen zu werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-637">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-638">Im folgenden Codebeispiel wird das Verhalten eines ausgelaufenden Threads veranschaulicht, wenn er unterbrochen und anschließend blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-638">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4b18f-639">Der Aufrufer verfügt nicht über die geeignete <see cref="T:System.Security.Permissions.SecurityPermission" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-639">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4b18f-640">für erweiterte Vorgänge für Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-640">for advanced operations on threads.</span></span> <span data-ttu-id="4b18f-641">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="4b18f-641">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="4b18f-642">Anhalten und Unterbrechen von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-642">Pausing and interrupting threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-643">Ruft einen Wert ab, der den Ausführungsstatus des aktuellen Threads angibt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-643">Gets a value indicating the execution status of the current thread.</span></span></summary>
        <value><span data-ttu-id="4b18f-644"><see langword="true" />, wenn dieser Thread gestartet und ordnungsgemäß beendet bzw. abgebrochen wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-644"><see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-645">Ruft einen Wert ab, der angibt, ob es sich bei einem Thread um einen Hintergrundthread handelt, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="4b18f-645">Gets or sets a value indicating whether or not a thread is a background thread.</span></span></summary>
        <value><span data-ttu-id="4b18f-646"><see langword="true" />, wenn dieser Thread ein Hintergrundthread ist oder zu einem solchen wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-646"><see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-647">Ein Thread ist entweder ein Hintergrund Thread oder ein Vordergrund Thread.</span><span class="sxs-lookup"><span data-stu-id="4b18f-647">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="4b18f-648">Hintergrundthreads sind mit Vorder grundthreads identisch, mit der Ausnahme, dass Hintergrundthreads nicht verhindern, dass ein Prozess beendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-648">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="4b18f-649">Nachdem alle für einen Prozess gehörenden Vordergrundthreads beendet wurden, beendet der Common Language Runtime den Prozess.</span><span class="sxs-lookup"><span data-stu-id="4b18f-649">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="4b18f-650">Alle verbleibenden Hintergrundthreads werden beendet und werden nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-650">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="4b18f-651">Standardmäßig werden die folgenden Threads im Vordergrund ausgeführt (d. h., ihre <xref:System.Threading.Thread.IsBackground%2A>-Eigenschaft gibt `false`zurück):</span><span class="sxs-lookup"><span data-stu-id="4b18f-651">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="4b18f-652">Der primäre Thread (oder Hauptanwendungs Thread).</span><span class="sxs-lookup"><span data-stu-id="4b18f-652">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="4b18f-653">Alle Threads, die durch Aufrufen eines <xref:System.Threading.Thread>-Klassenkonstruktors erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-653">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="4b18f-654">Standardmäßig werden die folgenden Threads im Hintergrund ausgeführt (d. h., ihre <xref:System.Threading.Thread.IsBackground%2A>-Eigenschaft gibt `true`zurück):</span><span class="sxs-lookup"><span data-stu-id="4b18f-654">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="4b18f-655">Thread Poolthreads, bei denen es sich um einen Pool von Arbeitsthreads handelt, die von der Laufzeit verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-655">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="4b18f-656">Sie können den Thread Pool konfigurieren und Arbeitsaufgaben in Thread Pool-Threads planen, indem Sie die <xref:System.Threading.ThreadPool>-Klasse verwenden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-656">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="4b18f-657">Aufgabenbasierte asynchrone Vorgänge werden automatisch in Thread Pool-Threads ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-657">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="4b18f-658">Alle Threads, die aus nicht verwaltetem Code in die verwaltete Ausführungsumgebung eintreten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-658">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-659">Im folgenden Beispiel wird das Verhalten von Vordergrund-und Hintergrundthreads gegenüberstellen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-659">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="4b18f-660">Er erstellt einen Vordergrund Thread und einen Hintergrund Thread.</span><span class="sxs-lookup"><span data-stu-id="4b18f-660">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="4b18f-661">Der Vordergrund Thread sorgt dafür, dass der Prozess ausgeführt wird, bis die `for` Schleife abgeschlossen und beendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-661">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="4b18f-662">Wie die Ausgabe aus dem Beispiel zeigt, wird der Prozess beendet, bevor der Hintergrund Thread die Ausführung abgeschlossen hat, da der Vordergrund Thread die Ausführung abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="4b18f-662">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-663">Der Thread ist deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-663">The thread is dead.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md"><span data-ttu-id="4b18f-664">Vordergrund- und Hintergrundthreads</span><span class="sxs-lookup"><span data-stu-id="4b18f-664">Foreground and Background Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-665">Ruft einen Wert ab, der angibt, ob ein Thread zu dem verwalteten Threadpool gehört.</span><span class="sxs-lookup"><span data-stu-id="4b18f-665">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span></span></summary>
        <value><span data-ttu-id="4b18f-666"><see langword="true" />, wenn der Thread zu dem verwalteten Threadpool gehört, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-666"><see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-667">Weitere Informationen finden Sie [unter Managed Thread Pool](~/docs/standard/threading/the-managed-thread-pool.md).</span><span class="sxs-lookup"><span data-stu-id="4b18f-667">For more information see [The managed thread pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-668">Im folgenden Codebeispiel wird gezeigt, wie ermittelt wird, ob ein Thread aus dem Thread Pool besteht.</span><span class="sxs-lookup"><span data-stu-id="4b18f-668">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="4b18f-669">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="4b18f-669">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4b18f-670">Blockiert den aufrufenden Thread, bis der durch diese Instanz dargestellte Thread beendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-670">Blocks the calling thread until the thread represented by this instance terminates.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-671">Blockiert den aufrufenden Thread, bis der durch diese Instanz dargestellte Thread beendet wird, während das Standard-COM- und das <see langword="SendMessage" />-Pumping fortgesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-671">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-672"><xref:System.Threading.Thread.Join%2A> ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. den Thread, der die-Methode aufruft) blockiert, bis der Thread, dessen <xref:System.Threading.Thread.Join%2A>-Methode aufgerufen wird, abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-672"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="4b18f-673">Verwenden Sie diese Methode, um sicherzustellen, dass ein Thread beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-673">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="4b18f-674">Der Aufrufer blockiert unbegrenzt, wenn der Thread nicht beendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-674">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="4b18f-675">Im folgenden Beispiel ruft der `Thread1` Thread die <xref:System.Threading.Thread.Join>-Methode von `Thread2`auf, die bewirkt, dass `Thread1` blockiert wird, bis `Thread2` abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-675">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="4b18f-676">Wenn der Thread bereits beendet wurde, wenn <xref:System.Threading.Thread.Join%2A> aufgerufen wird, wird die Methode sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-676">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="4b18f-677">Die <xref:System.Threading.Thread.Join%2A>-Methode des <xref:System.Threading.Thread> Objekts, das den aktuellen Thread darstellt, sollte nie aus dem aktuellen Thread aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-677">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="4b18f-678">Dies bewirkt, dass Ihre APP nicht mehr reagiert, da der aktuelle Thread unbegrenzt auf sich selbst wartet,</span><span class="sxs-lookup"><span data-stu-id="4b18f-678">This causes your app to become unresponsive because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="4b18f-679">Diese Methode ändert den Status des aufrufenden Threads, sodass er <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>einschließt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-679">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b18f-680">Sie können `Join` in einem Thread, der sich im <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> Zustand befindet, nicht aufrufen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-680">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-681">Der Aufrufer hat versucht, mit einem Thread zu verknüpfen, der den Zustand <see cref="F:System.Threading.ThreadState.Unstarted" /> hat.</span><span class="sxs-lookup"><span data-stu-id="4b18f-681">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="4b18f-682">Der Thread wird beim Warten unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-682">The thread is interrupted while waiting.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="4b18f-683">Die Anzahl der Millisekunden, die auf das Beenden des Threads gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-683">The number of milliseconds to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="4b18f-684">Blockiert den aufrufenden Thread, bis der von dieser Instanz dargestellte Thread beendet wird, oder die festgelegte Zeit verstreicht, während das Standard-COM- und das SendMessage-Pumping fortgesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-684">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="4b18f-685"><see langword="true" />, wenn der Thread beendet wurde. <see langword="false" />, wenn der Thread nach Ablauf des vom <paramref name="millisecondsTimeout" />-Parameter angegebenen Zeitraums nicht beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-685"><see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-686"><xref:System.Threading.Thread.Join%28System.Int32%29> ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. den Thread, der die-Methode aufruft) blockiert, bis entweder der Thread, dessen <xref:System.Threading.Thread.Join%2A>-Methode aufgerufen wird, abgeschlossen ist oder das Timeout Intervall abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-686"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="4b18f-687">Im folgenden Beispiel ruft der `Thread1` Thread die <xref:System.Threading.Thread.Join>-Methode von `Thread2`auf, wodurch `Thread1` blockiert wird, bis `Thread2` abgeschlossen ist oder 2 Sekunden abgelaufen sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-687">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="4b18f-688">Wenn <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für den `millisecondsTimeout`-Parameter angegeben wird, verhält sich diese Methode identisch mit der <xref:System.Threading.Thread.Join>-Methoden Überladung, mit Ausnahme des Rückgabewerts.</span><span class="sxs-lookup"><span data-stu-id="4b18f-688">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="4b18f-689">Wenn der Thread bereits beendet wurde, wenn <xref:System.Threading.Thread.Join%2A> aufgerufen wird, wird die Methode sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-689">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="4b18f-690">Diese Methode ändert den Status des aufrufenden Threads, sodass er <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>einschließt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-690">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b18f-691">Sie können `Join` in einem Thread, der sich im <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> Zustand befindet, nicht aufrufen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-691">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4b18f-692">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-692">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-693">Der Thread wurde nicht gestartet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-693">The thread has not been started.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4b18f-694"><paramref name="millisecondsTimeout" /> ist kleiner als -1 (Timeout.Infinite).</span><span class="sxs-lookup"><span data-stu-id="4b18f-694"><paramref name="millisecondsTimeout" /> is less than -1 (Timeout.Infinite).</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="4b18f-695">Der Thread wurde beim Warten unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-695">The thread was interrupted while waiting.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="4b18f-696">Ein <see cref="T:System.TimeSpan" />-Wert, der auf den Zeitraum festgelegt ist, während dessen auf das Beenden des Threads gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-696">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="4b18f-697">Blockiert den aufrufenden Thread, bis der von dieser Instanz dargestellte Thread beendet wird, oder die festgelegte Zeit verstreicht, während das Standard-COM- und das SendMessage-Pumping fortgesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-697">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="4b18f-698"><see langword="true" />, wenn der Thread beendet wurde. <see langword="false" />, wenn der Thread nach Ablauf des vom <paramref name="timeout" />-Parameter angegebenen Zeitraums nicht beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-698"><see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-699"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. den Thread, der die-Methode aufruft) blockiert, bis entweder der Thread, dessen <xref:System.Threading.Thread.Join%2A>-Methode aufgerufen wird, abgeschlossen ist oder das Timeout Intervall abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-699"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="4b18f-700">Im folgenden Beispiel ruft der `Thread1` Thread die <xref:System.Threading.Thread.Join>-Methode von `Thread2`auf, wodurch `Thread1` blockiert wird, bis `Thread2` abgeschlossen ist oder 2 Sekunden abgelaufen sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-700">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="4b18f-701">Wenn <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für `timeout`angegeben wird, verhält sich diese Methode identisch mit der <xref:System.Threading.Thread.Join>-Methoden Überladung, mit Ausnahme des Rückgabewerts.</span><span class="sxs-lookup"><span data-stu-id="4b18f-701">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="4b18f-702">Wenn der Thread bereits beendet wurde, wenn <xref:System.Threading.Thread.Join%2A> aufgerufen wird, wird die Methode sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-702">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="4b18f-703">Diese Methode ändert den Zustand des aktuellen Threads, sodass er <xref:System.Threading.ThreadState.WaitSleepJoin>enthält.</span><span class="sxs-lookup"><span data-stu-id="4b18f-703">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="4b18f-704">Sie können `Join` in einem Thread, der sich im <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> Zustand befindet, nicht aufrufen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-704">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-705">Im folgenden Codebeispiel wird veranschaulicht, wie ein `TimeSpan` Wert mit der `Join`-Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-705">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4b18f-706">Der Wert von <paramref name="timeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden oder größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-706">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-707">Der Aufrufer hat versucht, mit einem Thread zu verknüpfen, der den Zustand <see cref="F:System.Threading.ThreadState.Unstarted" /> hat.</span><span class="sxs-lookup"><span data-stu-id="4b18f-707">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-708">Ruft einen eindeutigen Bezeichner für den aktuellen verwalteten Thread ab.</span><span class="sxs-lookup"><span data-stu-id="4b18f-708">Gets a unique identifier for the current managed thread.</span></span></summary>
        <value><span data-ttu-id="4b18f-709">Eine Ganzzahl, die einen eindeutigen Bezeichner für diesen verwalteten Thread darstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-709">An integer that represents a unique identifier for this managed thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-710">Der <xref:System.Threading.Thread.ManagedThreadId%2A>-Eigenschafts Wert eines Threads dient zur eindeutigen Identifizierung des Threads innerhalb des Prozesses.</span><span class="sxs-lookup"><span data-stu-id="4b18f-710">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="4b18f-711">Der Wert der <xref:System.Threading.Thread.ManagedThreadId%2A>-Eigenschaft variiert nicht im Laufe der Zeit, auch wenn nicht verwalteter Code, der die Common Language Runtime hostet, den Thread als Fiber implementiert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-711">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-712">Der Prozessor, der den aktuellen Thread ausführt, kann Anweisungen nicht so neu anordnen, dass Speicherzugriffe vor dem Aufruf von <see cref="M:System.Threading.Thread.MemoryBarrier" /> nach Speicherzugriffen ausgeführt werden, die nach dem Aufruf von <see cref="M:System.Threading.Thread.MemoryBarrier" /> erfolgen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-712">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-713"><xref:System.Threading.Thread.MemoryBarrier%2A> ist nur auf Multiprozessorsystemen mit schwacher Arbeitsspeicher Anordnung erforderlich (z. b. ein System, das mehrere Intel Itanium-Prozessoren verwendet).</span><span class="sxs-lookup"><span data-stu-id="4b18f-713"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="4b18f-714">In den meisten Fällen bieten C# die `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung oder die <xref:System.Threading.Monitor>-Klasse einfachere Möglichkeiten zum Synchronisieren von Daten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-714">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-715">Ruft den Namen des Threads ab oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="4b18f-715">Gets or sets the name of the thread.</span></span></summary>
        <value><span data-ttu-id="4b18f-716">Eine Zeichenfolge mit dem Namen des Threads, oder <see langword="null" />, wenn kein Name festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-716">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-717">Diese Eigenschaft ist "Write-Once".</span><span class="sxs-lookup"><span data-stu-id="4b18f-717">This property is write-once.</span></span> <span data-ttu-id="4b18f-718">Da der Standardwert der <xref:System.Threading.Thread.Name%2A>-Eigenschaft eines Threads `null`ist, können Sie bestimmen, ob dem Thread bereits explizit ein Name zugewiesen wurde, indem Sie ihn mit `null`vergleichen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-718">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="4b18f-719">Die der <xref:System.Threading.Thread.Name%2A>-Eigenschaft zugewiesene Zeichenfolge kann ein beliebiges Unicode-Zeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-719">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-720">Im folgenden Beispiel wird gezeigt, wie ein Thread benennen kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-720">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4b18f-721">Ein SET-Vorgang wurde angefordert, aber die <see langword="Name" />-Eigenschaft wurde bereits festgelegt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-721">A set operation was requested, but the <see langword="Name" /> property has already been set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-722">Ruft einen Wert ab, der die Planungspriorität eines Threads angibt, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="4b18f-722">Gets or sets a value indicating the scheduling priority of a thread.</span></span></summary>
        <value><span data-ttu-id="4b18f-723">Einer der <see cref="T:System.Threading.ThreadPriority" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="4b18f-723">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span></span> <span data-ttu-id="4b18f-724">Der Standardwert ist <see cref="F:System.Threading.ThreadPriority.Normal" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-724">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-725">Einem Thread kann eine der folgenden Prioritäts <xref:System.Threading.ThreadPriority> Werte zugewiesen werden:</span><span class="sxs-lookup"><span data-stu-id="4b18f-725">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="4b18f-726">Betriebssysteme müssen nicht die Priorität eines Threads berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-726">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-727">Das folgende Beispiel zeigt das Ergebnis der Änderung der Priorität eines Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-727">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="4b18f-728">Es werden drei Threads erstellt, die Priorität eines Threads auf <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>festgelegt, und die Priorität einer Sekunde ist auf <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>festgelegt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-728">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b18f-729">Jeder Thread erhöht eine Variable in einer `while` Schleife und wird für eine festgelegte Zeit ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-729">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-730">Der Thread hat einen Endzustand erreicht, z. B. <see cref="F:System.Threading.ThreadState.Aborted" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-730">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4b18f-731">Der für einen SET-Vorgang festgelegte Wert ist kein gültiger <see cref="T:System.Threading.ThreadPriority" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-731">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md"><span data-ttu-id="4b18f-732">Scheduling von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-732">Scheduling threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-733">Bricht ein <see cref="M:System.Threading.Thread.Abort(System.Object)" /> ab, das für den aktuellen Thread angefordert wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-733">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-734">Diese Methode kann nur von Code mit den entsprechenden Berechtigungen aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-734">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="4b18f-735">Wenn `Abort` aufgerufen wird, um einen Thread zu beenden, löst das System eine <xref:System.Threading.ThreadAbortException>aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-735">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="4b18f-736">`ThreadAbortException` ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch am Ende des catch-Blocks erneut ausgelöst wird, es sei denn, `ResetAbort` aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-736">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="4b18f-737">`ResetAbort` bricht die Abbruch Anforderung ab und verhindert, dass der `ThreadAbortException` den Thread beendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-737">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="4b18f-738">Ein Beispiel für das Aufrufen der `ResetAbort`-Methode finden Sie unter <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="4b18f-738">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4b18f-739">Nur .NET Core: Dieser Member wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-739">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-740"><see langword="Abort" /> wurde für den aktuellen Thread nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-740"><see langword="Abort" /> was not invoked on the current thread.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4b18f-741">Der Aufrufer verfügt nicht über die erforderlichen Sicherheitsberechtigungen für den aktuellen Thread.</span><span class="sxs-lookup"><span data-stu-id="4b18f-741">The caller does not have the required security permission for the current thread.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4b18f-742">für erweiterte Vorgänge für Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-742">for advanced operations on threads.</span></span> <span data-ttu-id="4b18f-743">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="4b18f-743">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="4b18f-744">Zerstören von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-744">Destroying threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-745">Nimmt die Ausführung eines angehaltenen Threads wieder auf.</span><span class="sxs-lookup"><span data-stu-id="4b18f-745">Resumes a thread that has been suspended.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="4b18f-746">Verwenden Sie die Methoden <xref:System.Threading.Thread.Suspend%2A> und <xref:System.Threading.Thread.Resume%2A> nicht, um die Aktivitäten von Threads zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="4b18f-746">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="4b18f-747">Sie haben keine Möglichkeit, zu wissen, welcher Code von einem Thread ausgeführt wird, wenn Sie ihn aussetzen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-747">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="4b18f-748">Wenn Sie einen Thread aussetzen, während er während einer Bewertung der Sicherheits Berechtigung Sperren enthält, werden möglicherweise andere Threads in der <xref:System.AppDomain> blockiert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-748">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="4b18f-749">Wenn Sie einen Thread beim Ausführen eines Klassenkonstruktors aussetzen, werden andere Threads in der <xref:System.AppDomain>, die versuchen, diese Klasse zu verwenden, blockiert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-749">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="4b18f-750">Deadlocks können sehr einfach auftreten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-750">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4b18f-751">Nur .NET Core: Dieser Member wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-751">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-752">Der Thread wurde nicht gestartet, ist deaktiviert oder befindet sich nicht im angehaltenen Zustand.</span><span class="sxs-lookup"><span data-stu-id="4b18f-752">The thread has not been started, is dead, or is not in the suspended state.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4b18f-753">Der Aufrufer verfügt nicht über die geeignete <see cref="T:System.Security.Permissions.SecurityPermission" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-753">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4b18f-754">für erweiterte Vorgänge für Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-754">for advanced operations on threads.</span></span> <span data-ttu-id="4b18f-755">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="4b18f-755">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="4b18f-756">Anhalten und Unterbrechen von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-756">Pausing and interrupting threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="4b18f-757">Der neue Apartmentzustand.</span><span class="sxs-lookup"><span data-stu-id="4b18f-757">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="4b18f-758">Legt den Apartmentzustand eines Threads fest, bevor dieser gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-758">Sets the apartment state of a thread before it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-759">Neue Threads werden als <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> initialisiert, wenn der Apartment Zustand nicht festgelegt wurde, bevor Sie gestartet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-759">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="4b18f-760">Der Apartment Zustand muss festgelegt werden, bevor ein Thread gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-760">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-761">Der Haupt Anwendungs Thread wird initialisiert, um standardmäßig <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4b18f-761">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="4b18f-762">Der Apartment Zustand des Hauptanwendungs Threads kann nur auf <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> festgelegt werden, indem das <xref:System.STAThreadAttribute>-Attribut auf die Einstiegspunkt Methode angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-762">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="4b18f-763">Die <xref:System.Threading.Thread.SetApartmentState%2A>-Methode, zusammen mit der <xref:System.Threading.Thread.GetApartmentState%2A>-Methode und der <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode, ersetzt die <xref:System.Threading.Thread.ApartmentState%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-763">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-764">Im folgenden Codebeispiel werden die Methoden <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>und <xref:System.Threading.Thread.TrySetApartmentState%2A> veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="4b18f-764">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="4b18f-765">Im Codebeispiel wird ein Thread erstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-765">The code example creates a thread.</span></span> <span data-ttu-id="4b18f-766">Bevor der Thread gestartet wird, zeigt <xref:System.Threading.Thread.GetApartmentState%2A> den anfänglichen <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> Status an, und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Status in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4b18f-766">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b18f-767">Die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode gibt dann `false` zurück, wenn versucht wird, den Zustand in <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> zu ändern, da der Apartment Zustand bereits festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-767">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="4b18f-768">Wenn der gleiche Vorgang mit <xref:System.Threading.Thread.SetApartmentState%2A>versucht wurde, wurde <xref:System.InvalidOperationException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="4b18f-768">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="4b18f-769">Nachdem der Thread gestartet wurde, wird die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode erneut verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-769">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="4b18f-770">Dieses Mal wird <xref:System.Threading.ThreadStateException> ausgelöst, da der Thread bereits gestartet wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-770">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4b18f-771">Nur .NET Core: Dieser Member wird auf den Plattformen macOS und Linux nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-771">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4b18f-772"><paramref name="state" /> ist kein gültiger Apartmentzustand.</span><span class="sxs-lookup"><span data-stu-id="4b18f-772"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-773">Der Thread wurde bereits gestartet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-773">The thread has already been started.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4b18f-774">Der Apartmentzustand wurde bereits initialisiert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-774">The apartment state has already been initialized.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="stack"><span data-ttu-id="4b18f-775">Das <see cref="T:System.Threading.CompressedStack" />-Objekt, das für den aktuellen Thread übernommen werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-775">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span></span></param>
        <summary><span data-ttu-id="4b18f-776">Übernimmt einen erfassten <see cref="T:System.Threading.CompressedStack" /> für den aktuellen Thread.</span><span class="sxs-lookup"><span data-stu-id="4b18f-776">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-777">Diese Methode wird nicht mehr unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-777">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4b18f-778">In allen Fällen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-778">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4b18f-779">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="4b18f-779">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4b18f-780">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-780">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="4b18f-781">Der <see cref="T:System.LocalDataStoreSlot" />, in dem der Wert festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-781">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span></span></param>
        <param name="data"><span data-ttu-id="4b18f-782">Der festzulegende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-782">The value to be set.</span></span></param>
        <summary><span data-ttu-id="4b18f-783">Legt die Daten im angegebenen Slot auf den derzeit ausgeführten Thread und für die aktuelle Domäne des betreffenden Threads fest.</span><span class="sxs-lookup"><span data-stu-id="4b18f-783">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span></span> <span data-ttu-id="4b18f-784">Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-784">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4b18f-785">Der .NET Framework bietet zwei Mechanismen für die Verwendung von Thread lokalem Speicher (TLS): Thread relative statische Felder (d. h. Felder, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind) und Daten Slots.</span><span class="sxs-lookup"><span data-stu-id="4b18f-785">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4b18f-786">Thread relative statische Felder bieten eine viel bessere Leistung als Daten Slots und ermöglichen eine Typüberprüfung zur Kompilierzeit.</span><span class="sxs-lookup"><span data-stu-id="4b18f-786">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4b18f-787">Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread lokaler Speicher: Thread bezogene statische Felder und Daten Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4b18f-787">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4b18f-788">Threads verwenden einen lokalen Speichermechanismus zum Speichern Thread spezifischer Daten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-788">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4b18f-789">Die Common Language Runtime ordnet jedem Prozess bei der Erstellung ein Datenspeicher Array mit mehreren Slots zu.</span><span class="sxs-lookup"><span data-stu-id="4b18f-789">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4b18f-790">Der Thread kann einen Datenslot im Datenspeicher zuordnen, einen Datenwert im Slot speichern und Abrufen und den Slot zur Wiederverwendung freigeben, nachdem die Thread Prozedur beendet wurde und das <xref:System.Threading.Thread> Objekt von Garbage Collection freigegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-790">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="4b18f-791">Daten Slots sind pro Thread eindeutig.</span><span class="sxs-lookup"><span data-stu-id="4b18f-791">Data slots are unique per thread.</span></span> <span data-ttu-id="4b18f-792">Diese Daten können von keinem anderen Thread (nicht sogar von einem untergeordneten Thread) erhalten werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-792">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-793"><xref:System.Threading.Thread.SetData%2A> ist eine `Shared` Methode, die immer auf den derzeit ausgeführten Thread angewendet wird, auch wenn Sie ihn mit einer Variablen, die auf einen anderen Thread verweist, aufruft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-793"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="4b18f-794">Um Verwirrung zu vermeiden, verwenden Sie den Klassennamen, wenn Sie `Shared` Methoden aufrufen: `Thread.SetData(testSlot, "test data")`.</span><span class="sxs-lookup"><span data-stu-id="4b18f-794">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-795">Dieser Abschnitt enthält zwei Codebeispiele.</span><span class="sxs-lookup"><span data-stu-id="4b18f-795">This section contains two code examples.</span></span> <span data-ttu-id="4b18f-796">Im ersten Beispiel wird gezeigt, wie ein Feld verwendet wird, das mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert ist, um Thread spezifische Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-796">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-797">Im zweiten Beispiel wird gezeigt, wie ein Daten Slot verwendet wird, um das gleiche zu tun.</span><span class="sxs-lookup"><span data-stu-id="4b18f-797">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4b18f-798">**Erstes Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-798">**First Example**</span></span>  
  
 <span data-ttu-id="4b18f-799">Im folgenden Beispiel wird gezeigt, wie Sie ein Feld, das mit <xref:System.ThreadStaticAttribute> gekennzeichnet ist, zum Speichern von Thread spezifischen Informationen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="4b18f-799">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4b18f-800">Diese Technik bietet eine bessere Leistung als die im zweiten Beispiel gezeigte Technik.</span><span class="sxs-lookup"><span data-stu-id="4b18f-800">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4b18f-801">**Zweites Beispiel**</span><span class="sxs-lookup"><span data-stu-id="4b18f-801">**Second Example**</span></span>  
  
 <span data-ttu-id="4b18f-802">Im folgenden Beispiel wird veranschaulicht, wie ein benannter Datenslot verwendet wird, um Thread spezifische Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-802">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="4b18f-803">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-803">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="4b18f-804">Lokaler Threadspeicher: Threadbezogene statische Felder und Datenslots</span><span class="sxs-lookup"><span data-stu-id="4b18f-804">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4b18f-805">Hält den aktuellen Thread während des angegebenen Zeitraums an.</span><span class="sxs-lookup"><span data-stu-id="4b18f-805">Suspends the current thread for the specified amount of time.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="4b18f-806">Die Anzahl von Millisekunden, die der Thread angehalten wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-806">The number of milliseconds for which the thread is suspended.</span></span> <span data-ttu-id="4b18f-807">Wenn der Wert des <paramref name="millisecondsTimeout" />-Arguments 0 (null) lautet, gibt der Thread den Rest seines Zeitanteils an einen beliebigen Thread mit gleicher Priorität ab, der für die Ausführung bereit ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-807">If the value of the <paramref name="millisecondsTimeout" /> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="4b18f-808">Sind keine anderen Threads mit gleicher Priorität vorhanden, die ausgeführt werden können, wird die Ausführung des aktuellen Threads nicht angehalten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-808">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="4b18f-809">Hält den aktuellen Thread für die angegebene Anzahl von Millisekunden an.</span><span class="sxs-lookup"><span data-stu-id="4b18f-809">Suspends the current thread for the specified number of milliseconds.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-810">Der Thread wird für die angegebene Zeitspanne nicht für die Ausführung durch das Betriebssystem geplant.</span><span class="sxs-lookup"><span data-stu-id="4b18f-810">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="4b18f-811">Diese Methode ändert den Status des Threads, sodass er <xref:System.Threading.ThreadState.WaitSleepJoin>enthält.</span><span class="sxs-lookup"><span data-stu-id="4b18f-811">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="4b18f-812">Sie können <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für den Parameter `millisecondsTimeout` angeben, um den Thread unbegrenzt anzuhalten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-812">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="4b18f-813">Es wird jedoch empfohlen, stattdessen andere <xref:System.Threading?displayProperty=nameWithType> Klassen, z. b. <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>oder <xref:System.Threading.Semaphore>, zu verwenden, um Threads zu synchronisieren oder Ressourcen zu verwalten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-813">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to synchronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="4b18f-814">Die Systemuhr wird mit einer bestimmten Rate, die als Takt Auflösung bezeichnet wird, Ticks.</span><span class="sxs-lookup"><span data-stu-id="4b18f-814">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="4b18f-815">Der tatsächliche Timeout Wert ist möglicherweise nicht genau das angegebene Timeout, da das angegebene Timeout an Zeiteinheiten angepasst wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-815">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="4b18f-816">Weitere Informationen zur Takt Auflösung und zum Zeitpunkt der Wartezeit finden Sie im Thema Standby- [Funktion](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) .</span><span class="sxs-lookup"><span data-stu-id="4b18f-816">For more information on clock resolution and the waiting time, see the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) topic.</span></span> <span data-ttu-id="4b18f-817">Diese Methode ruft die [Funktion "Sleep](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) " aus den Windows-System-APIs auf.</span><span class="sxs-lookup"><span data-stu-id="4b18f-817">This method calls the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="4b18f-818">Diese Methode führt keine Standard-com-und SendMessage-Pump durch.</span><span class="sxs-lookup"><span data-stu-id="4b18f-818">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-819">Wenn Sie sich in einem Thread befinden müssen, der über <xref:System.STAThreadAttribute>verfügt, Sie jedoch das Standard-com-und SendMessage-Pump ausführen möchten, sollten Sie eine der über Ladungen der <xref:System.Threading.Thread.Join%2A>-Methode verwenden, die ein Timeout Intervall angibt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-819">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-820">Im folgenden Beispiel wird die <xref:System.Threading.Thread.Sleep%2A>-Methode verwendet, um den Haupt Thread der Anwendung zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="4b18f-820">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4b18f-821">Der Timeoutwert ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-821">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="4b18f-822">Der Zeitraum, während dessen der Thread angehalten wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-822">The amount of time for which the thread is suspended.</span></span> <span data-ttu-id="4b18f-823">Wenn der Wert des <paramref name="millisecondsTimeout" />-Arguments <see cref="F:System.TimeSpan.Zero" /> lautet, gibt der Thread den Rest seines Zeitanteils an einen beliebigen Thread mit gleicher Priorität ab, der für die Ausführung bereit ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-823">If the value of the <paramref name="millisecondsTimeout" /> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="4b18f-824">Sind keine anderen Threads mit gleicher Priorität vorhanden, die ausgeführt werden können, wird die Ausführung des aktuellen Threads nicht angehalten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-824">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="4b18f-825">Hält den aktuellen Thread während des angegebenen Zeitraums an.</span><span class="sxs-lookup"><span data-stu-id="4b18f-825">Suspends the current thread for the specified amount of time.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-826">Der Thread wird für die angegebene Zeitspanne nicht für die Ausführung durch das Betriebssystem geplant.</span><span class="sxs-lookup"><span data-stu-id="4b18f-826">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="4b18f-827">Diese Methode ändert den Status des Threads, sodass er <xref:System.Threading.ThreadState.WaitSleepJoin>enthält.</span><span class="sxs-lookup"><span data-stu-id="4b18f-827">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="4b18f-828">Sie können <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> für den Parameter `timeout` angeben, um den Thread unbegrenzt anzuhalten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-828">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="4b18f-829">Es wird jedoch empfohlen, stattdessen andere <xref:System.Threading?displayProperty=nameWithType> Klassen, z. b. <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>oder <xref:System.Threading.Semaphore>, zu verwenden, um Threads zu synchronisieren oder Ressourcen zu verwalten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-829">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to synchronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="4b18f-830">Diese Überladung von <xref:System.Threading.Thread.Sleep%2A> verwendet die Gesamtzahl ganzer Millisekunden in `timeout`.</span><span class="sxs-lookup"><span data-stu-id="4b18f-830">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="4b18f-831">Bruchteile der Millisekunden werden verworfen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-831">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="4b18f-832">Diese Methode führt keine Standard-com-und SendMessage-Pump durch.</span><span class="sxs-lookup"><span data-stu-id="4b18f-832">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-833">Wenn Sie sich in einem Thread befinden müssen, der über <xref:System.STAThreadAttribute>verfügt, Sie jedoch das Standard-com-und SendMessage-Pump ausführen möchten, sollten Sie eine der über Ladungen der <xref:System.Threading.Thread.Join%2A>-Methode verwenden, die ein Timeout Intervall angibt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-833">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-834">Im folgenden Beispiel wird die <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29>-Methoden Überladung verwendet, um den Haupt Thread der Anwendung fünfmal zu blockieren, zwei Sekunden lang jedes Mal.</span><span class="sxs-lookup"><span data-stu-id="4b18f-834">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4b18f-835">Der Wert von <paramref name="timeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden oder größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-835">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="iterations"><span data-ttu-id="4b18f-836">Eine 32-Bit-Ganzzahl mit Vorzeichen, die den Zeitraum definiert, den ein Thread warten soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-836">A 32-bit signed integer that defines how long a thread is to wait.</span></span></param>
        <summary><span data-ttu-id="4b18f-837">Veranlasst, dass ein Thread so oft wartet, wie vom <paramref name="iterations" />-Parameter definiert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-837">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-838">Die <xref:System.Threading.Thread.SpinWait%2A>-Methode eignet sich für die Implementierung von Sperren.</span><span class="sxs-lookup"><span data-stu-id="4b18f-838">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="4b18f-839">Klassen im .NET Framework, z. b. <xref:System.Threading.Monitor> und <xref:System.Threading.ReaderWriterLock>, verwenden diese Methode intern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-839">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="4b18f-840"><xref:System.Threading.Thread.SpinWait%2A> stellt den Prozessor im Wesentlichen in eine sehr enge Schleife ein, wobei die Schleifen Anzahl durch den `iterations`-Parameter angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-840"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="4b18f-841">Die Dauer der Wartezeit hängt daher von der Geschwindigkeit des Prozessors ab.</span><span class="sxs-lookup"><span data-stu-id="4b18f-841">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="4b18f-842">Vergleichen Sie dies mit der <xref:System.Threading.Thread.Sleep%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="4b18f-842">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="4b18f-843">Ein Thread, der <xref:System.Threading.Thread.Sleep%2A> aufruft, liefert den Rest seines aktuellen Slice der Prozessorzeit, auch wenn das angegebene Intervall 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-843">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="4b18f-844">Wenn Sie ein Intervall ungleich 0 (null) für <xref:System.Threading.Thread.Sleep%2A> angeben, wird der Thread vom Thread Planer bis zum Ablauf des Zeitintervalls von der Überlegung entfernt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-844">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="4b18f-845"><xref:System.Threading.Thread.SpinWait%2A> ist im Allgemeinen nicht für normale Anwendungen nützlich.</span><span class="sxs-lookup"><span data-stu-id="4b18f-845"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="4b18f-846">In den meisten Fällen sollten Sie die Synchronisierungs Klassen verwenden, die vom .NET Framework bereitgestellt werden. Beispielsweise wird <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> oder eine-Anweisung aufgerufen, die <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> umschließt C# (`lock` in oder `SyncLock` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4b18f-846">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="4b18f-847">In den seltenen Fällen, in denen es vorteilhaft ist, einen Kontextwechsel zu vermeiden, z. b. Wenn Sie wissen, dass eine Zustandsänderung bevorstehend ist, führen Sie in ihrer Schleife einen aufzurufenden <xref:System.Threading.Thread.SpinWait%2A>-Methode aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-847">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="4b18f-848">Der Code <xref:System.Threading.Thread.SpinWait%2A> ausgeführt wird, um Probleme zu vermeiden, die auf Computern mit mehreren Prozessoren auftreten können.</span><span class="sxs-lookup"><span data-stu-id="4b18f-848">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="4b18f-849">Beispielsweise verhindert <xref:System.Threading.Thread.SpinWait%2A> auf Computern mit mehreren Intel-Prozessoren, die Hyperthreading Technologie verwenden, in bestimmten Situationen den Prozessor Hunger.</span><span class="sxs-lookup"><span data-stu-id="4b18f-849">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4b18f-850">Bewirkt, dass die Ausführung eines Threads geplant wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-850">Causes a thread to be scheduled for execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-851">Weist das Betriebssystem an, den Zustand der aktuellen Instanz in <see cref="F:System.Threading.ThreadState.Running" /> zu ändern.</span><span class="sxs-lookup"><span data-stu-id="4b18f-851">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-852">Sobald sich ein Thread im <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> Zustand befindet, kann er vom Betriebssystem für die Ausführung geplant werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-852">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="4b18f-853">Der Thread beginnt mit der Ausführung in der ersten Zeile der Methode, die durch den <xref:System.Threading.ThreadStart> oder <xref:System.Threading.ParameterizedThreadStart> Delegaten, der für den Thread-Konstruktor bereitgestellt wird, repräsentiert</span><span class="sxs-lookup"><span data-stu-id="4b18f-853">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="4b18f-854">Beachten Sie, dass der Aufruf von <xref:System.Threading.Thread.Start%2A> den aufrufenden Thread nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-854">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-855">Wenn diese Überladung mit einem Thread verwendet wird, der mit einem <xref:System.Threading.ParameterizedThreadStart> Delegaten erstellt wurde, wird `null` an die vom Thread ausgeführte Methode übermittelt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-855">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="4b18f-856">Nachdem der Thread beendet wurde, kann er nicht mehr mit einem weiteren `Start`aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-856">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-857">Im folgenden Beispiel wird ein Thread erstellt und gestartet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-857">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-858">Der Thread wurde bereits gestartet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-858">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="4b18f-859">Es ist nicht genügend Speicher zum Starten dieses Threads verfügbar.</span><span class="sxs-lookup"><span data-stu-id="4b18f-859">There is not enough memory available to start this thread.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="4b18f-860">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="4b18f-860">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="4b18f-861">Erstellen von Threads und Übergeben von Daten zur Startzeit</span><span class="sxs-lookup"><span data-stu-id="4b18f-861">Creating Threads and Passing Data at Start Time</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="parameter"><span data-ttu-id="4b18f-862">Ein Objekt mit Daten, die von der vom Thread ausgeführten Methode verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-862">An object that contains data to be used by the method the thread executes.</span></span></param>
        <summary><span data-ttu-id="4b18f-863">Bewirkt, dass das Betriebssystem den Zustand der aktuellen Instanz in <see cref="F:System.Threading.ThreadState.Running" /> ändert, und stellt optional ein Objekt mit Daten bereit, die von der vom Thread ausgeführten Methode verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-863">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-864">Sobald sich ein Thread im <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> Zustand befindet, kann er vom Betriebssystem für die Ausführung geplant werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-864">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="4b18f-865">Der Thread beginnt mit der Ausführung in der ersten Zeile der Methode, die durch den <xref:System.Threading.ThreadStart> oder <xref:System.Threading.ParameterizedThreadStart> Delegaten, der für den Thread-Konstruktor bereitgestellt wird, repräsentiert</span><span class="sxs-lookup"><span data-stu-id="4b18f-865">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="4b18f-866">Beachten Sie, dass der Aufruf von <xref:System.Threading.Thread.Start%2A> den aufrufenden Thread nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-866">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="4b18f-867">Nachdem der Thread beendet wurde, kann er nicht mehr mit einem weiteren `Start`aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-867">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="4b18f-868">Diese Überladung und der <xref:System.Threading.ParameterizedThreadStart>-Delegat erleichtern das Übergeben von Daten an eine Thread Prozedur, aber die Technik ist nicht typsicher, da jedes Objekt an diese Überladung übergeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-868">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="4b18f-869">Eine stabilere Methode zum Übergeben von Daten an eine Thread Prozedur besteht darin, die Thread Prozedur und die Datenfelder in ein Workerobjekt einzufügen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-869">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="4b18f-870">Weitere Informationen finden Sie [unter Erstellen von Threads und übergeben von Daten zur Startzeit](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span><span class="sxs-lookup"><span data-stu-id="4b18f-870">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-871">Im folgenden Beispiel wird eine <xref:System.Threading.ParameterizedThreadStart> Delegaten mit einer statischen-Methode und einer Instanzmethode erstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-871">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-872">Der Thread wurde bereits gestartet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-872">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="4b18f-873">Es ist nicht genügend Speicher zum Starten dieses Threads verfügbar.</span><span class="sxs-lookup"><span data-stu-id="4b18f-873">There is not enough memory available to start this thread.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4b18f-874">Dieser Thread wurde mithilfe eines <see cref="T:System.Threading.ThreadStart" />-Delegaten anstelle eines <see cref="T:System.Threading.ParameterizedThreadStart" />-Delegaten erstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-874">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="4b18f-875">Erstellen von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-875">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-876">Hält den Thread an. Hat keine Auswirkungen, wenn der Thread bereits angehalten ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-876">Either suspends the thread, or if the thread is already suspended, has no effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-877">Wenn der Thread bereits angehalten wurde, hat diese Methode keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-877">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="4b18f-878">Verwenden Sie die Methoden <xref:System.Threading.Thread.Suspend%2A> und <xref:System.Threading.Thread.Resume%2A> nicht, um die Aktivitäten von Threads zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="4b18f-878">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="4b18f-879">Sie haben keine Möglichkeit, zu wissen, welcher Code von einem Thread ausgeführt wird, wenn Sie ihn aussetzen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-879">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="4b18f-880">Wenn Sie einen Thread aussetzen, während er während einer Bewertung der Sicherheits Berechtigung Sperren enthält, werden möglicherweise andere Threads in der <xref:System.AppDomain> blockiert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-880">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="4b18f-881">Wenn Sie einen Thread beim Ausführen eines Klassenkonstruktors aussetzen, werden andere Threads in der <xref:System.AppDomain>, die versuchen, diese Klasse zu verwenden, blockiert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-881">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="4b18f-882">Deadlocks können sehr einfach auftreten.</span><span class="sxs-lookup"><span data-stu-id="4b18f-882">Deadlocks can occur very easily.</span></span>

<span data-ttu-id="4b18f-883">Wenn Sie die `Suspend`-Methode für einen Thread aufzurufen, erkennt das System, dass ein Thread angehalten wurde, und ermöglicht die Ausführung des Threads, bis er einen sicheren Punkt erreicht, bevor der Thread tatsächlich angehalten wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-883">When you call the `Suspend` method on a thread, the system notes that a thread suspension has been requested and allows the thread to execute until it reaches a safe point before actually suspending the thread.</span></span> <span data-ttu-id="4b18f-884">Ein sicherer Punkt für einen Thread ist ein Punkt in seiner Ausführung, an dem eine Garbage Collection durchgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-884">A safe point for a thread is a point in its execution at which garbage collection can be performed.</span></span> <span data-ttu-id="4b18f-885">Sobald ein sicherer Punkt erreicht ist, garantiert die Runtime, dass der unterbrochene Thread in verwaltetem Code nicht weiter fortgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-885">Once a safe point is reached, the runtime guarantees that the suspended thread will not make any further progress in managed code.</span></span> <span data-ttu-id="4b18f-886">Ein außerhalb von verwaltetem Code ausgeführter Thread ist stets sicher für die Garbage Collection, und dessen Ausführung wird fortgeführt, bis er versucht, die Ausführung von verwaltetem Code fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-886">A thread executing outside managed code is always safe for garbage collection, and its execution continues until it attempts to resume execution of managed code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4b18f-887">Nur .NET Core: Dieser Member wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-887">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-888">Der Thread wurde nicht gestartet oder reagiert nicht.</span><span class="sxs-lookup"><span data-stu-id="4b18f-888">The thread has not been started or is dead.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4b18f-889">Der Aufrufer verfügt nicht über die geeignete <see cref="T:System.Security.Permissions.SecurityPermission" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-889">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4b18f-890">für erweiterte Vorgänge für Threads.</span><span class="sxs-lookup"><span data-stu-id="4b18f-890">for advanced operations on threads.</span></span> <span data-ttu-id="4b18f-891">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="4b18f-891">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="4b18f-892">Anhalten und Unterbrechen von Threads</span><span class="sxs-lookup"><span data-stu-id="4b18f-892">Pausing and interrupting threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="4b18f-893">Für zukünftige Verwendung reserviert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-893">Reserved for future use.</span></span> <span data-ttu-id="4b18f-894">Muss IID_NULL sein.</span><span class="sxs-lookup"><span data-stu-id="4b18f-894">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="4b18f-895">Das übergebene Array von zuzuordnenden Namen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-895">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="4b18f-896">Die Anzahl der zuzuordnenden Namen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-896">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="4b18f-897">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-897">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="4b18f-898">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-898">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="4b18f-899">Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</span><span class="sxs-lookup"><span data-stu-id="4b18f-899">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-900">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-900">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4b18f-901">Weitere Informationen zu `IDispatch::GetIDsOfNames`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="4b18f-901">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="4b18f-902">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-902">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="4b18f-903">Die zurückzugebenden Typinformationen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-903">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="4b18f-904">Der Gebietsschemabezeichner für die Typinformationen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-904">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="4b18f-905">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-905">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="4b18f-906">Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="4b18f-906">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-907">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-907">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4b18f-908">Weitere Informationen zu `IDispatch::GetTypeInfo`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="4b18f-908">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="4b18f-909">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-909">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="4b18f-910">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-910">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="4b18f-911">Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</span><span class="sxs-lookup"><span data-stu-id="4b18f-911">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-912">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-912">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4b18f-913">Weitere Informationen zu `IDispatch::GetTypeInfoCount`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="4b18f-913">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="4b18f-914">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-914">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="4b18f-915">Bezeichnet den Member.</span><span class="sxs-lookup"><span data-stu-id="4b18f-915">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="4b18f-916">Für zukünftige Verwendung reserviert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-916">Reserved for future use.</span></span> <span data-ttu-id="4b18f-917">Muss IID_NULL sein.</span><span class="sxs-lookup"><span data-stu-id="4b18f-917">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="4b18f-918">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-918">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="4b18f-919">Flags, die den Kontext des Aufrufs beschreiben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-919">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="4b18f-920">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</span><span class="sxs-lookup"><span data-stu-id="4b18f-920">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="4b18f-921">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-921">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="4b18f-922">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-922">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="4b18f-923">Der Index des ersten Arguments mit einem Fehler.</span><span class="sxs-lookup"><span data-stu-id="4b18f-923">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="4b18f-924">Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</span><span class="sxs-lookup"><span data-stu-id="4b18f-924">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-925">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-925">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4b18f-926">Weitere Informationen zu `IDispatch::Invoke`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="4b18f-926">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="4b18f-927">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-927">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4b18f-928">Ruft einen Wert ab, der die Zustände des aktuellen Threads enthält.</span><span class="sxs-lookup"><span data-stu-id="4b18f-928">Gets a value containing the states of the current thread.</span></span></summary>
        <value><span data-ttu-id="4b18f-929">Einer der <see cref="T:System.Threading.ThreadState" />-Werte, der den Zustand des aktuellen Threads angibt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-929">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span></span> <span data-ttu-id="4b18f-930">Der Anfangswert ist <see cref="F:System.Threading.ThreadState.Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-930">The initial value is <see cref="F:System.Threading.ThreadState.Unstarted" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-931">Die <xref:System.Threading.Thread.ThreadState%2A>-Eigenschaft bietet spezifischere Informationen als die <xref:System.Threading.Thread.IsAlive%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-931">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4b18f-932">Der Thread Zustand ist nur in Debugszenarien von Interesse.</span><span class="sxs-lookup"><span data-stu-id="4b18f-932">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="4b18f-933">Sie sollten den Threadzustand niemals verwenden, um die Aktivitäten von Threads zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="4b18f-933">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-934">Im folgenden Codebeispiel wird der Zugriff auf die `ThreadState` eines Threads veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="4b18f-934">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="4b18f-935">Der neue Apartmentzustand.</span><span class="sxs-lookup"><span data-stu-id="4b18f-935">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="4b18f-936">Legt den Apartmentzustand eines Threads fest, bevor dieser gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-936">Sets the apartment state of a thread before it is started.</span></span></summary>
        <returns><span data-ttu-id="4b18f-937"><see langword="true" />, wenn der Apartmentzustand festgelegt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-937"><see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-938">Neue Threads werden als <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> initialisiert, wenn der Apartment Zustand nicht festgelegt wurde, bevor Sie gestartet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-938">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="4b18f-939">Der Apartment Zustand muss festgelegt werden, bevor ein Thread gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-939">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-940">Der Haupt Anwendungs Thread wird initialisiert, um standardmäßig <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4b18f-940">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="4b18f-941">Der Apartment Zustand des Hauptanwendungs Threads kann nur auf <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> festgelegt werden, indem das <xref:System.STAThreadAttribute>-Attribut auf die Einstiegspunkt Methode angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-941">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="4b18f-942">Die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode, zusammen mit der <xref:System.Threading.Thread.GetApartmentState%2A>-Methode und der <xref:System.Threading.Thread.SetApartmentState%2A>-Methode, ersetzt die <xref:System.Threading.Thread.ApartmentState%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="4b18f-942">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b18f-943">Im folgenden Codebeispiel werden die Methoden <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>und <xref:System.Threading.Thread.TrySetApartmentState%2A> veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="4b18f-943">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="4b18f-944">Im Codebeispiel wird ein Thread erstellt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-944">The code example creates a thread.</span></span> <span data-ttu-id="4b18f-945">Bevor der Thread gestartet wird, zeigt <xref:System.Threading.Thread.GetApartmentState%2A> den anfänglichen <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> Status an, und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Status in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4b18f-945">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b18f-946">Die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode gibt dann `false` zurück, wenn versucht wird, den Zustand in <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> zu ändern, da der Apartment Zustand bereits festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-946">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="4b18f-947">Wenn der gleiche Vorgang mit <xref:System.Threading.Thread.SetApartmentState%2A>versucht wurde, wurde <xref:System.InvalidOperationException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="4b18f-947">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="4b18f-948">Nachdem der Thread gestartet wurde, wird die <xref:System.Threading.Thread.TrySetApartmentState%2A>-Methode erneut verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-948">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="4b18f-949">Dieses Mal wird <xref:System.Threading.ThreadStateException> ausgelöst, da der Thread bereits gestartet wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-949">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4b18f-950">Nur .NET Core: Dieser Member wird auf den Plattformen macOS und Linux nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-950">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4b18f-951"><paramref name="state" /> ist kein gültiger Apartmentzustand.</span><span class="sxs-lookup"><span data-stu-id="4b18f-951"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="4b18f-952">Der Thread wurde gestartet und beendet, oder der Aufruf erfolgt nicht aus dem Kontext des Threads, während der Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-952">The thread was started and has terminated, or the call is not being made from the thread's context while the thread is running.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4b18f-953">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-953">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-954">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-954">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : byte -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-955">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-955">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-956">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-956">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-957">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-957">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-958">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-958">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-959"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-959"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-960">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-960">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-961">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-961">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-962">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-962">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-963">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-963">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-964">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-964">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-965">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-965">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-966">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-966">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-967">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-967">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : double -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-968">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-968">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-969">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-969">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-970">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-970">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-971">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-971">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-972"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-972"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-973">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-973">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-974">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-974">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-975">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-975">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-976">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-976">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-977">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-977">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-978">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-978">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-979">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-979">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-980">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-980">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int16 -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-981">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-981">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-982">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-982">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-983">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-983">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-984">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-984">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-985"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-985"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-986">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-986">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-987">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-987">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-988">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-988">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-989">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-989">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-990">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-990">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-991">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-991">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-992">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-992">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-993">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-993">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-994">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-994">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-995">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-995">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-996">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-996">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-997">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-997">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-998"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-998"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-999">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-999">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1000">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1000">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-1001">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1001">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1002">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1002">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1003">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1003">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1004">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1004">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1005">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1005">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1006">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1006">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int64 -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1007">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1007">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-1008">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1008">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-1009">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1009">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-1010">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1010">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1011"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1011"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1012">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1012">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1013">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1013">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-1014">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1014">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1015">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1015">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1016">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1016">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1017">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1017">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1018">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1018">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1019">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1019">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : nativeint -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1020">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1020">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-1021">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1021">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-1022">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1022">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-1023">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1023">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1024"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1024"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1025">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1025">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1026">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1026">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-1027">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1027">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1028">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1028">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1029">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1029">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1030">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1030">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1031">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1031">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1032">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1032">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : obj -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1033">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1033">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-1034">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1034">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-1035">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1035">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-1036">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1036">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1037"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1037"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1038">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1038">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1039">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1039">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-1040">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1040">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1041">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1041">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1042">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1042">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1043">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1043">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1044">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1044">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1045">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1045">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : sbyte -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1046">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1046">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-1047">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1047">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-1048">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1048">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-1049">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1049">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1050"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1050"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1051">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1051">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1052">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1052">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-1053">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1053">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1054">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1054">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1055">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1055">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1056">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1056">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1057">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1057">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1058">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1058">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : single -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1059">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1059">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-1060">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1060">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-1061">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1061">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-1062">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1062">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1063"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1063"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1064">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1064">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1065">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1065">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-1066">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1066">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1067">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1067">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1068">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1068">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1069">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1069">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1070">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1070">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1071">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1071">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint16 -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1072">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1072">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-1073">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1073">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-1074">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1074">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-1075">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1075">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1076"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1076"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1077">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1077">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1078">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1078">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-1079">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1079">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1080">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1080">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1081">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1081">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1082">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1082">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1083">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1083">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1084">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1084">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint32 -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1085">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1085">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-1086">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1086">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-1087">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1087">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-1088">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1088">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1089"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1089"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1090">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1090">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1091">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1091">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-1092">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1092">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1093">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1093">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1094">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1094">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1095">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1095">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1096">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1096">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1097">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1097">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint64 -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1098">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1098">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-1099">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1099">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-1100">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1100">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-1101">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1101">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1102"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1102"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1103">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1103">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1104">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1104">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-1105">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1105">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1106">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1106">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1107">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1107">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1108">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1108">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1109">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1109">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1110">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1110">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : unativeint -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1111">Das zu lesende Feld.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1111">The field to be read.</span></span></param>
        <summary><span data-ttu-id="4b18f-1112">Liest den Wert eines Felds.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1112">Reads the value of a field.</span></span> <span data-ttu-id="4b18f-1113">Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1113">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="4b18f-1114">Der letzte von einem Prozessor in das Feld geschriebene Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1114">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1115"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1115"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1116">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1116">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1117">Auf einem Multiprozessorsystem erhält <xref:System.Threading.Thread.VolatileRead%2A> den neuesten Wert, der von einem beliebigen Prozessor in eine Speicheradresse geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1117">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4b18f-1118">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1118">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1119">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1119">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1120">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1120">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1121">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1121">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1122">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1122">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1123">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1123">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4b18f-1124">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1124">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : byte * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1125">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1125">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1126">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1126">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1127">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1127">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1128"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1128"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1129">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1129">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1130">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1130">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1131">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1131">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1132">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1132">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1133">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1133">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1134">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1134">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1135">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1135">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1136">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1136">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : double * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1137">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1137">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1138">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1138">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1139">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1139">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1140"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1140"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1141">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1141">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1142">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1142">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1143">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1143">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1144">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1144">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1145">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1145">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1146">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1146">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1147">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1147">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1148">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1148">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int16 * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1149">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1149">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1150">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1150">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1151">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1151">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1152"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1152"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1153">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1153">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1154">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1154">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1155">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1155">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1156">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1156">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1157">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1157">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1158">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1158">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1159">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1159">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1160">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1160">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1161">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1161">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1162">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1162">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1163">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1163">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1164"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1164"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1165">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1165">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1166">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1166">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1167">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1167">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1168">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1168">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1169">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1169">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1170">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1170">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1171">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1171">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1172">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1172">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int64 * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1173">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1173">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1174">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1174">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1175">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1175">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1176"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1176"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1177">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1177">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1178">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1178">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1179">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1179">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1180">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1180">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1181">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1181">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1182">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1182">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1183">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1183">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1184">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1184">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : nativeint * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1185">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1185">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1186">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1186">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1187">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1187">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1188"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1188"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1189">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1189">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1190">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1190">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1191">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1191">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1192">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1192">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1193">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1193">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1194">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1194">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1195">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1195">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1196">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1196">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : obj * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1197">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1197">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1198">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1198">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1199">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1199">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1200"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1200"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1201">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1201">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1202">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1202">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1203">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1203">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1204">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1204">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1205">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1205">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1206">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1206">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1207">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1207">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1208">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1208">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : sbyte * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.SByte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1209">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1209">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1210">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1210">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1211">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1211">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1212"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1212"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1213">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1213">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1214">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1214">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1215">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1215">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1216">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1216">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1217">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1217">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1218">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1218">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1219">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1219">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1220">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1220">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : single * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1221">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1221">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1222">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1222">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1223">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1223">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1224"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1224"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1225">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1225">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1226">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1226">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1227">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1227">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1228">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1228">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1229">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1229">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1230">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1230">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1231">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1231">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1232">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1232">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint16 * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1233">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1233">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1234">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1234">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1235">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1235">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1236"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1236"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1237">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1237">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1238">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1238">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1239">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1239">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1240">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1240">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1241">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1241">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1242">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1242">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1243">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1243">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1244">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1244">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint32 * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1245">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1245">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1246">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1246">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1247">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1247">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1248"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1248"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1249">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1249">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1250">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1250">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1251">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1251">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1252">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1252">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1253">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1253">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1254">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1254">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1255">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1255">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1256">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1256">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint64 * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1257">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1257">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1258">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1258">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1259">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1259">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1260"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1260"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1261">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1261">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1262">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1262">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1263">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1263">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1264">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1264">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1265">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1265">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1266">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1266">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1267">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1267">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1268">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1268">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : unativeint * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UIntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4b18f-1269">Das Feld, in das der Wert geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1269">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="4b18f-1270">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1270">The value to be written.</span></span></param>
        <summary><span data-ttu-id="4b18f-1271">Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1271">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1272"><xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sind für spezielle Synchronisierungs Fälle.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1272"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4b18f-1273">Unter normalen Umständen bieten die C# `lock`-Anweisung, die Visual Basic `SyncLock`-Anweisung und die <xref:System.Threading.Monitor>-Klasse einfachere Alternativen.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1273">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4b18f-1274">Auf einem Multiprozessorsystem stellt <xref:System.Threading.Thread.VolatileWrite%2A> sicher, dass ein in eine Speicheradresse geschriebener Wert sofort für alle Prozessoren sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1274">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4b18f-1275">Dies erfordert möglicherweise das Leeren von Prozessor Caches.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1275">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4b18f-1276">Selbst auf einem uniprozessorsystem können <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> sicherstellen, dass ein Wert in den Arbeitsspeicher gelesen oder geschrieben und nicht zwischengespeichert wird (z. b. in einem Prozessor Register).</span><span class="sxs-lookup"><span data-stu-id="4b18f-1276">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4b18f-1277">Daher können Sie Sie zum Synchronisieren des Zugriffs auf ein Feld verwenden, das von einem anderen Thread oder von der Hardware aktualisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1277">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4b18f-1278">Das Aufrufen dieser Methode wirkt sich nur auf einen einzelnen Speicherzugriff aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1278">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4b18f-1279">Um eine effektive Synchronisierung für ein Feld zu ermöglichen, muss für den gesamten Zugriff auf das Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1279">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b18f-1280">In C#gewährleistet die Verwendung des `volatile` Modifizierers für ein Feld, dass der gesamte Zugriff auf dieses Feld <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1280">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4b18f-1281">Bewirkt, dass der aufrufende Thread die Ausführung an einen anderen Thread übergibt, der auf dem aktuellen Prozessor ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1281">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span></span> <span data-ttu-id="4b18f-1282">Das Betriebssystem wählt den Thread für die Übergabe aus.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1282">The operating system selects the thread to yield to.</span></span></summary>
        <returns><span data-ttu-id="4b18f-1283"><see langword="true" />, wenn das Betriebssystem die Ausführung an einen anderen Thread übergeben hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1283"><see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b18f-1284">Wenn diese Methode erfolgreich ausgeführt wird, wird der Rest des aktuellen Zeitabschnitts des Threads zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1284">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="4b18f-1285">Das Betriebssystem plant den aufrufenden Thread für einen anderen Zeit Slice entsprechend seiner Priorität und des Status anderer Threads, die zur Ausführung verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1285">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="4b18f-1286">Das Ergebnis ist auf den Prozessor beschränkt, der den aufrufenden Thread ausführt.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1286">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="4b18f-1287">Das Betriebssystem wechselt nicht zu einem anderen Prozessor, auch wenn sich der Prozessor im Leerlauf befindet oder ein Thread mit niedrigerer Priorität ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1287">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="4b18f-1288">Wenn keine anderen Threads vorhanden sind, die auf dem aktuellen Prozessor ausgeführt werden können, führt das Betriebssystem keine Ausführung aus, und diese Methode gibt `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1288">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="4b18f-1289">Diese Methode entspricht der Verwendung eines Platt Form Aufrufs zum Aufrufen der systemeigenen Win32-`SwitchToThread` Funktion.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1289">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="4b18f-1290">Sie sollten die <xref:System.Threading.Thread.Yield%2A>-Methode anstelle des Platt Form Aufrufs aufrufen, da der Platt Form Aufruf das von dem Host angeforderte benutzerdefinierte Threading Verhalten umgeht.</span><span class="sxs-lookup"><span data-stu-id="4b18f-1290">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
