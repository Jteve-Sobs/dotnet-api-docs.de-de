<Type Name="Overlapped" FullName="System.Threading.Overlapped">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80bd6535da52e3bb68b0053450d31fdd6a797482" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37754760" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Overlapped" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Overlapped extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Overlapped" />
  <TypeSignature Language="VB.NET" Value="Public Class Overlapped" />
  <TypeSignature Language="C++ CLI" Value="public ref class Overlapped" />
  <TypeSignature Language="F#" Value="type Overlapped = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading.Overlapped</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Bietet eine verwaltete Darstellung einer Win32-<c>OVERLAPPED</c>-Struktur, einschließlich Methoden zum Übertragen von Informationen aus einer <see cref="T:System.Threading.Overlapped" />-Instanz in eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Overlapped.Pack%2A> und <xref:System.Threading.Overlapped.UnsafePack%2A> Methoden übertragen von Informationen aus einer <xref:System.Threading.Overlapped> -Objekt an eine <xref:System.Threading.NativeOverlapped> -Struktur, die Win32-API-Funktionen zum asynchronen übergeben werden kann, Datei e/a. Die <xref:System.Threading.Overlapped.Unpack%2A> -Methode überträgt Informationen aus einer <xref:System.Threading.NativeOverlapped> Struktur mit einer Instanz von der <xref:System.Threading.Overlapped> Klasse.  
  
 Änderungen an den Eigenschaften des ein <xref:System.Threading.Overlapped> Objekt beeinflussen, auf die zugehörigen <xref:System.Threading.NativeOverlapped> Struktur, und umgekehrt.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Overlapped" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Overlapped ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Overlapped();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Threading.Overlapped" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Overlapped (int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 offsetLo, int32 offsetHi, int32 hEvent, class System.IAsyncResult ar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (offsetLo As Integer, offsetHi As Integer, hEvent As Integer, ar As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ^ ar);" />
      <MemberSignature Language="F#" Value="new System.Threading.Overlapped : int * int * int * IAsyncResult -&gt; System.Threading.Overlapped" Usage="new System.Threading.Overlapped (offsetLo, offsetHi, hEvent, ar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Not 64bit compatible.  Please use the constructor that takes IntPtr for the event handle")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="offsetLo" Type="System.Int32" />
        <Parameter Name="offsetHi" Type="System.Int32" />
        <Parameter Name="hEvent" Type="System.Int32" />
        <Parameter Name="ar" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="offsetLo">Das niedrige WORD der Dateiposition, an der die Übertragung gestartet werden soll.</param>
        <param name="offsetHi">Das hohe WORD der Dateiposition, an der die Übertragung gestartet werden soll.</param>
        <param name="hEvent">Das Handle zu einem Ereignis, das signalisiert wird, wenn der E/A-Vorgang abgeschlossen ist.</param>
        <param name="ar">Ein Objekt, das die <see cref="T:System.IAsyncResult" />-Schnittstelle implementiert und Statusinformationen über den E/A-Vorgang bereitstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Overlapped" />-Klasse mit der angegebenen Dateiposition, dem 32-Bit-Ganzzahl-Handle für ein Ereignis, das signalisiert wird, wenn der E/A-Vorgang abgeschlossen ist, und einer Schnittstelle, durch die die Ergebnisse des Vorgangs zurückgegeben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=nameWithType> Eigenschaft, um das Handle für den beliebigen verwalteten Synchronisierungsereignisses abzurufen, die von abgeleitet der <xref:System.Threading.WaitHandle> Klasse.  
  
 Die Implementierung von <xref:System.IAsyncResult> Statusinformationen für den e/a-Vorgang bereitstellt. Übergeben Sie es an den Konstruktor in der `ar` Parameter, und rufen Sie es später noch Mal mit der <xref:System.Threading.Overlapped.AsyncResult%2A> Eigenschaft. Wenn für eine Rückrufmethode angegeben wird die <xref:System.Threading.Overlapped.Pack%2A> oder <xref:System.Threading.Overlapped.UnsafePack%2A> -Methode der Rückruf kann Abrufen Ihrer <xref:System.IAsyncResult> durch Entpacken der <xref:System.Threading.NativeOverlapped> Struktur, die es empfängt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Overlapped (int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 offsetLo, int32 offsetHi, native int hEvent, class System.IAsyncResult ar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (offsetLo As Integer, offsetHi As Integer, hEvent As IntPtr, ar As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Overlapped(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ^ ar);" />
      <MemberSignature Language="F#" Value="new System.Threading.Overlapped : int * int * nativeint * IAsyncResult -&gt; System.Threading.Overlapped" Usage="new System.Threading.Overlapped (offsetLo, offsetHi, hEvent, ar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="offsetLo" Type="System.Int32" />
        <Parameter Name="offsetHi" Type="System.Int32" />
        <Parameter Name="hEvent" Type="System.IntPtr" />
        <Parameter Name="ar" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="offsetLo">Das niedrige WORD der Dateiposition, an der die Übertragung gestartet werden soll.</param>
        <param name="offsetHi">Das hohe WORD der Dateiposition, an der die Übertragung gestartet werden soll.</param>
        <param name="hEvent">Das Handle zu einem Ereignis, das signalisiert wird, wenn der E/A-Vorgang abgeschlossen ist.</param>
        <param name="ar">Ein Objekt, das die <see cref="T:System.IAsyncResult" />-Schnittstelle implementiert und Statusinformationen über den E/A-Vorgang bereitstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Overlapped" />-Klasse mit der angegebenen Dateiposition, dem Handle für ein Ereignis, das signalisiert wird, wenn ein E/A-Vorgang abgeschlossen ist, und einer Schnittstelle, durch die die Ergebnisse des Vorgangs zurückgegeben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Handle des verwalteten Synchronisierungsobjekts abzurufen, die von abgeleitet ist die <xref:System.Threading.WaitHandle> Klasse, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=nameWithType> die abzurufende Eigenschaft eine <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Objekt aus, und rufen Sie dann die <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> Methode.  
  
 Die Implementierung von <xref:System.IAsyncResult> Statusinformationen für den e/a-Vorgang bereitstellt. Übergeben Sie es an den Konstruktor in der `ar` Parameter, und rufen Sie es später noch Mal mit der <xref:System.Threading.Overlapped.AsyncResult%2A> Eigenschaft. Wenn für eine Rückrufmethode angegeben wird die <xref:System.Threading.Overlapped.Pack%2A> oder <xref:System.Threading.Overlapped.UnsafePack%2A> -Methode der Rückruf kann Abrufen Ihrer <xref:System.IAsyncResult> durch Entpacken der <xref:System.Threading.NativeOverlapped> Struktur, die es empfängt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncResult">
      <MemberSignature Language="C#" Value="public IAsyncResult AsyncResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IAsyncResult AsyncResult" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Overlapped.AsyncResult" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncResult As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IAsyncResult ^ AsyncResult { IAsyncResult ^ get(); void set(IAsyncResult ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncResult : IAsyncResult with get, set" Usage="System.Threading.Overlapped.AsyncResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das Statusinformationen über den E/A-Vorgang bereitstellt, oder legt es fest.</summary>
        <value>Ein Objekt, das die <see cref="T:System.IAsyncResult" />-Schnittstelle implementiert.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EventHandle">
      <MemberSignature Language="C#" Value="public int EventHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EventHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Overlapped.EventHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property EventHandle As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int EventHandle { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.EventHandle : int with get, set" Usage="System.Threading.Overlapped.EventHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Not 64bit compatible.  Use EventHandleIntPtr instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das 32-Bit-Ganzzahl-Handle eines Synchronisierungsereignisses ab, das angegeben wird, wenn ein E/A-Vorgang abgeschlossen ist, oder legt es fest.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der das Handle des Synchronisierungsereignisses darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann nicht auf 64-Bit-Plattformen verwendet werden. Verwenden Sie stattdessen die <xref:System.Threading.Overlapped.EventHandleIntPtr%2A>-Eigenschaft.  
  
 Verwenden der <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=nameWithType> Eigenschaft, um das Handle für den beliebigen verwalteten Synchronisierungsereignisses abzurufen, die von abgeleitet der <xref:System.Threading.WaitHandle> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EventHandleIntPtr">
      <MemberSignature Language="C#" Value="public IntPtr EventHandleIntPtr { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int EventHandleIntPtr" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Overlapped.EventHandleIntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Property EventHandleIntPtr As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr EventHandleIntPtr { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.EventHandleIntPtr : nativeint with get, set" Usage="System.Threading.Overlapped.EventHandleIntPtr" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Handle eines Synchronisierungsereignisses ab, das angegeben wird, wenn ein E/A-Vorgang abgeschlossen ist, oder legt es fest.</summary>
        <value>Eine <see cref="T:System.IntPtr" />-Struktur, die das Handle des Ereignisses darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Handle des verwalteten Synchronisierungsobjekts abzurufen, die von abgeleitet ist die <xref:System.Threading.WaitHandle> Klasse, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=nameWithType> die abzurufende Eigenschaft eine <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Objekt aus, und rufen Sie dann die <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Free">
      <MemberSignature Language="C#" Value="public static void Free (System.Threading.NativeOverlapped* nativeOverlappedPtr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Free(valuetype System.Threading.NativeOverlapped* nativeOverlappedPtr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Free(System::Threading::NativeOverlapped* nativeOverlappedPtr);" />
      <MemberSignature Language="F#" Value="static member Free : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; unit" Usage="System.Threading.Overlapped.Free nativeOverlappedPtr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeOverlappedPtr" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="nativeOverlappedPtr">Ein Zeiger auf die freizugebende <see cref="T:System.Threading.NativeOverlapped" />-Struktur.</param>
        <summary>Gibt den nicht verwalteten Arbeitsspeicher frei, der einer systemeigenen überlappenden Struktur zugewiesen ist, die von der <see cref="Overload:System.Threading.Overlapped.Pack" />-Methode zugeordnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Threading.Overlapped.Free%2A> -Methode genau einmal für jede <xref:System.Threading.NativeOverlapped> Zeiger Sie von erhalten der <xref:System.Threading.Overlapped.Pack%2A> Methode. Wenn Sie nicht Aufrufen der <xref:System.Threading.Overlapped.Free%2A> -Methode, Sie verlieren Arbeitsspeicher. Wenn Sie beim Aufrufen der <xref:System.Threading.Overlapped.Free%2A> Methode mehr als einmal Speicher beschädigt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="nativeOverlappedPtr" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="OffsetHigh">
      <MemberSignature Language="C#" Value="public int OffsetHigh { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OffsetHigh" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Overlapped.OffsetHigh" />
      <MemberSignature Language="VB.NET" Value="Public Property OffsetHigh As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OffsetHigh { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.OffsetHigh : int with get, set" Usage="System.Threading.Overlapped.OffsetHigh" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das hohe WORD der Dateiposition ab, an der die Übertragung gestartet werden soll, oder legt dieses fest. Die Dateiposition ist ein Byteoffset vom Anfang der Datei.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der das hohe WORD der Dateiposition darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetLow">
      <MemberSignature Language="C#" Value="public int OffsetLow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OffsetLow" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Overlapped.OffsetLow" />
      <MemberSignature Language="VB.NET" Value="Public Property OffsetLow As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OffsetLow { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.OffsetLow : int with get, set" Usage="System.Threading.Overlapped.OffsetLow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das niedrige WORD der Dateiposition ab, an der die Übertragung gestartet werden soll, oder legt dieses fest. Die Dateiposition ist ein Byteoffset vom Anfang der Datei.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der das niedrige WORD der Dateiposition darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Pack">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Packt die aktuelle Instanz in eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pack">
      <MemberSignature Language="C#" Value="public System.Threading.NativeOverlapped* Pack (System.Threading.IOCompletionCallback iocb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.NativeOverlapped* Pack(class System.Threading.IOCompletionCallback iocb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::NativeOverlapped* Pack(System::Threading::IOCompletionCallback ^ iocb);" />
      <MemberSignature Language="F#" Value="member this.Pack : System.Threading.IOCompletionCallback -&gt; nativeptr&lt;System.Threading.NativeOverlapped&gt;" Usage="overlapped.Pack iocb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use Pack(iocb, userData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.NativeOverlapped*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iocb" Type="System.Threading.IOCompletionCallback" />
      </Parameters>
      <Docs>
        <param name="iocb">Ein <see cref="T:System.Threading.IOCompletionCallback" />-Delegat, der die Rückrufmethode darstellt, die aufgerufen wird, wenn der asynchrone E/A-Vorgang abgeschlossen ist.</param>
        <summary>Packt die aktuelle Instanz in eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur und gibt den Delegaten an, der aufgerufen werden soll, wenn der asynchrone E/A-Vorgang abgeschlossen ist.</summary>
        <returns>Ein nicht verwalteter Zeiger auf eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der nicht verwaltete Zeiger, die von dieser Methode zurückgegebene kann für das Betriebssystem in überlappende e/a-Vorgängen übergeben werden. Die <xref:System.Threading.NativeOverlapped> ist eine feste Struktur im physischen Speicher bis <xref:System.Threading.Overlapped.Unpack%2A> aufgerufen wird.  
  
> [!IMPORTANT]
>  Der Aufrufer ist verantwortlich für das Fixieren des Puffers. Wenn die Anwendungsdomäne entladen wird, jedoch das Handle für die fixierten Puffer zerstört wird, und der Puffer wird freigegeben, sodass des e/a-Vorgangs zum Schreiben in die freigegebenen Adresse. Aus diesem Grund ist es besser, verwenden Sie die <xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> -methodenüberladung, in dem die Laufzeit den Puffer hält.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die aktuelle <see cref="T:System.Threading.Overlapped" />-Klasse wurde bereits gepackt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Pack">
      <MemberSignature Language="C#" Value="public System.Threading.NativeOverlapped* Pack (System.Threading.IOCompletionCallback iocb, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.NativeOverlapped* Pack(class System.Threading.IOCompletionCallback iocb, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::NativeOverlapped* Pack(System::Threading::IOCompletionCallback ^ iocb, System::Object ^ userData);" />
      <MemberSignature Language="F#" Value="member this.Pack : System.Threading.IOCompletionCallback * obj -&gt; nativeptr&lt;System.Threading.NativeOverlapped&gt;" Usage="overlapped.Pack (iocb, userData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.NativeOverlapped*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iocb" Type="System.Threading.IOCompletionCallback" />
        <Parameter Name="userData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="iocb">Ein <see cref="T:System.Threading.IOCompletionCallback" />-Delegat, der die Rückrufmethode darstellt, die aufgerufen wird, wenn der asynchrone E/A-Vorgang abgeschlossen ist.</param>
        <param name="userData">Ein Objekt oder ein Objektarray, das den Eingabe- oder den Ausgabepuffer für den Vorgang darstellt. Jedes Objekt stellt einen Puffer dar, z. B. ein Array von Bytes.</param>
        <summary>Packt die aktuelle Instanz in eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur und gibt einen Delegaten, der aufgerufen wird, wenn der asynchrone E/A-Vorgang abgeschlossen ist, und ein verwaltetes Objekt an, das als Puffer dient.</summary>
        <returns>Ein nicht verwalteter Zeiger auf eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der nicht verwaltete Zeiger, die von dieser Methode zurückgegebene kann für das Betriebssystem in überlappende e/a-Vorgängen übergeben werden. Die <xref:System.Threading.NativeOverlapped> ist eine feste Struktur im physischen Speicher bis <xref:System.Threading.Overlapped.Unpack%2A> aufgerufen wird.  
  
 Der bzw. die im angegebenen Puffer `userData` muss identisch mit denen, die an die nicht verwalteten Betriebssystem-Funktion, die asynchrone e/a ausführt.  
  
> [!NOTE]
>  Die Laufzeit hält, der bzw. die im angegebenen Puffer `userData` für die Dauer des e/a-Vorgangs. Wenn die Anwendungsdomäne entladen wird, behält die Laufzeit den Arbeitsspeicher, fixiert, bis der e/a-Vorgang abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die aktuelle <see cref="T:System.Threading.Overlapped" />-Klasse wurde bereits gepackt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unpack">
      <MemberSignature Language="C#" Value="public static System.Threading.Overlapped Unpack (System.Threading.NativeOverlapped* nativeOverlappedPtr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Overlapped Unpack(valuetype System.Threading.NativeOverlapped* nativeOverlappedPtr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Overlapped ^ Unpack(System::Threading::NativeOverlapped* nativeOverlappedPtr);" />
      <MemberSignature Language="F#" Value="static member Unpack : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; System.Threading.Overlapped" Usage="System.Threading.Overlapped.Unpack nativeOverlappedPtr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Overlapped</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeOverlappedPtr" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="nativeOverlappedPtr">Ein nicht verwalteter Zeiger auf eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur.</param>
        <summary>Entpackt die angegebene, nicht verwaltete <see cref="T:System.Threading.NativeOverlapped" />-Struktur in ein verwaltetes <see cref="T:System.Threading.Overlapped" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.Threading.Overlapped" />-Objekt, das die Informationen enthält, die aus der systemeigenen Struktur entpackt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.NativeOverlapped> Struktur wird nicht vom physischen Speicher freigegeben, bis zum Aufruf der <xref:System.Threading.Overlapped.Free%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="nativeOverlappedPtr" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafePack">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Packt die aktuelle Instanz in eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur. Gibt den aufrufenden Stapel nicht weiter.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafePack">
      <MemberSignature Language="C#" Value="public System.Threading.NativeOverlapped* UnsafePack (System.Threading.IOCompletionCallback iocb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.NativeOverlapped* UnsafePack(class System.Threading.IOCompletionCallback iocb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::NativeOverlapped* UnsafePack(System::Threading::IOCompletionCallback ^ iocb);" />
      <MemberSignature Language="F#" Value="member this.UnsafePack : System.Threading.IOCompletionCallback -&gt; nativeptr&lt;System.Threading.NativeOverlapped&gt;" Usage="overlapped.UnsafePack iocb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use UnsafePack(iocb, userData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.NativeOverlapped*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iocb" Type="System.Threading.IOCompletionCallback" />
      </Parameters>
      <Docs>
        <param name="iocb">Ein <see cref="T:System.Threading.IOCompletionCallback" />-Delegat, der die Rückrufmethode darstellt, die aufgerufen wird, wenn der asynchrone E/A-Vorgang abgeschlossen ist.</param>
        <summary>Packt die aktuelle Instanz in eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur und gibt den Delegaten an, der aufgerufen werden soll, wenn der asynchrone E/A-Vorgang abgeschlossen ist. Gibt den aufrufenden Stapel nicht weiter.</summary>
        <returns>Ein nicht verwalteter Zeiger auf eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der nicht verwaltete Zeiger, die von dieser Methode zurückgegebene kann für das Betriebssystem in überlappende e/a-Vorgängen übergeben werden. Die <xref:System.Threading.NativeOverlapped> ist eine feste Struktur im physischen Speicher bis <xref:System.Threading.Overlapped.Unpack%2A> aufgerufen wird.  
  
 Der Aufrufer ist verantwortlich für das Fixieren des Puffers. Wenn die Anwendungsdomäne entladen wird, jedoch das Handle für die fixierten Puffer zerstört wird, und der Puffer wird freigegeben, sodass des e/a-Vorgangs zum Schreiben in die freigegebenen Adresse. Aus diesem Grund ist es besser, verwenden Sie die <xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> -methodenüberladung, in dem die Laufzeit den Puffer hält.  
  
> [!CAUTION]
>  Mithilfe der <xref:System.Threading.Overlapped.UnsafePack%2A> Methode kann eine Sicherheitslücke unbeabsichtigt. Codezugriffssicherheit Basen die berechtigungsüberprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel. Die <xref:System.Threading.Overlapped.UnsafePack%2A> -Methode gibt den aufrufenden Stapel nicht weiter. Bösartiger Code kann diese Option, um die Überprüfung der Ausführungsberechtigung vermeiden ausgenutzt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die aktuelle <see cref="T:System.Threading.Overlapped" />-Klasse wurde bereits gepackt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafePack">
      <MemberSignature Language="C#" Value="public System.Threading.NativeOverlapped* UnsafePack (System.Threading.IOCompletionCallback iocb, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.NativeOverlapped* UnsafePack(class System.Threading.IOCompletionCallback iocb, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::NativeOverlapped* UnsafePack(System::Threading::IOCompletionCallback ^ iocb, System::Object ^ userData);" />
      <MemberSignature Language="F#" Value="member this.UnsafePack : System.Threading.IOCompletionCallback * obj -&gt; nativeptr&lt;System.Threading.NativeOverlapped&gt;" Usage="overlapped.UnsafePack (iocb, userData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.NativeOverlapped*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iocb" Type="System.Threading.IOCompletionCallback" />
        <Parameter Name="userData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="iocb">Ein <see cref="T:System.Threading.IOCompletionCallback" />-Delegat, der die Rückrufmethode darstellt, die aufgerufen wird, wenn der asynchrone E/A-Vorgang abgeschlossen ist.</param>
        <param name="userData">Ein Objekt oder ein Objektarray, das den Eingabe- oder den Ausgabepuffer für den Vorgang darstellt. Jedes Objekt stellt einen Puffer dar, z. B. ein Array von Bytes.</param>
        <summary>Packt die aktuelle Instanz in eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur, und gibt einen Delegaten, der aufgerufen werden soll, wenn der asynchrone E/A-Vorgang abgeschlossen ist, und ein verwaltetes Objekt an, das als Puffer dient. Gibt den aufrufenden Stapel nicht weiter.</summary>
        <returns>Ein nicht verwalteter Zeiger auf eine <see cref="T:System.Threading.NativeOverlapped" />-Struktur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der nicht verwaltete Zeiger, die von dieser Methode zurückgegebene kann für das Betriebssystem in überlappende e/a-Vorgängen übergeben werden. Die <xref:System.Threading.NativeOverlapped> ist eine feste Struktur im physischen Speicher bis <xref:System.Threading.Overlapped.Unpack%2A> aufgerufen wird.  
  
 Der bzw. die im angegebenen Puffer `userData` muss identisch mit denen, die an die nicht verwalteten Betriebssystem-Funktion, die asynchrone e/a ausführt.  
  
 Die Laufzeit hält, der bzw. die im angegebenen Puffer`userData` für die Dauer des e/a-Vorgangs. Wenn die Anwendungsdomäne entladen wird, behält die Laufzeit den Arbeitsspeicher, fixiert, bis der e/a-Vorgang abgeschlossen ist.  
  
> [!CAUTION]
>  Mithilfe der <xref:System.Threading.Overlapped.UnsafePack%2A> Methode kann eine Sicherheitslücke unbeabsichtigt. Codezugriffssicherheit Basen die berechtigungsüberprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel. Die <xref:System.Threading.Overlapped.UnsafePack%2A> -Methode gibt den aufrufenden Stapel nicht weiter. Bösartiger Code kann diese Option, um die Überprüfung der Ausführungsberechtigung vermeiden ausgenutzt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.InvalidOperationException">Die aktuelle <see cref="T:System.Threading.Overlapped" />-Klasse ist bereits gepackt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
  </Members>
</Type>