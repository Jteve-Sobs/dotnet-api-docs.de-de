<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ReaderWriterLockSlim.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52ff770bb9446d6ebe71649784ebe115f60734cc0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2ff770bb9446d6ebe71649784ebe115f60734cc0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</source>
          <target state="translated">Stellt eine Sperre dar, mit der der Zugriff auf eine Ressource verwaltet wird. Mehrere Threads können damit Lesezugriff oder exklusiven Schreibzugriff erhalten.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> to protect a resource that is read by multiple threads and written to by one thread at a time.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> zum Schützen einer Ressource, die durch mehrere Threads gelesen und in einem Thread zu einem Zeitpunkt geschrieben.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> ermöglicht es mehreren Threads im Lesemodus befinden, ermöglicht es einem Thread im Schreibmodus mit exklusiven Besitz der Sperre sein und es einem Thread ermöglicht, die verfügt über Lesezugriff auf die im erweiterbaren Modus zu lesen, werden von dem der Thread den Schreibmodus, ohne sie abgeben aktualisieren können s Lesezugriff auf die Ressource.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> ähnelt <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, verfügt aber über vereinfachte Regeln für Rekursion sowie für Upgrade und Downgrade des Sperrstatus.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> avoids many cases of potential deadlock.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> vermeidet viele potenzielle Deadlocks.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>In addition, the performance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is significantly better than <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">Darüber hinaus ist die Leistung von <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> wesentlich besser als die von <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is recommended for all new development.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> wird für alle Neuentwicklungen empfohlen.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>By default, new instances of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> are created with the <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> flag and do not allow recursion.</source>
          <target state="translated">Standardmäßig werden neue Instanzen eines <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> werden erstellt, mit der <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> kennzeichnen und Rekursion nicht zulassen.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</source>
          <target state="translated">Diese Standardrichtlinie wird für alle Neuentwicklungen empfohlen, da Rekursion unnötige Komplikationen eingeführt und wird der Code anfälliger zu Deadlocks führt.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To simplify migration from existing projects that use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, you can use the <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> flag to create instances of <ph id="ph4">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allow recursion.</source>
          <target state="translated">Zur Vereinfachung der Migration von vorhandenen Projekten, in denen <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, können Sie die <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> Flag zum Erstellen von Instanzen <ph id="ph4">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> , mit denen Rekursion.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</source>
          <target state="translated">Ein Thread kann die Sperre eingeben, in drei Modi: Lesen-Modus, im Schreibmodus befindet und erweiterbaren Modus zu lesen.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter <ph id="ph1">`x`</ph> mode" is used in preference to the longer phrase "enter the lock in <ph id="ph2">`x`</ph> mode".)</source>
          <target state="translated">(Im Rest dieses Themas, "erweiterbaren Lesemodus" wird bezeichnet als "erweiterbaren Modus" aus, und der Ausdruck "Geben Sie <ph id="ph1">`x`</ph> im Modus" aufrufanweisung länger Ausdruck verwendet wird "Geben Sie die Sperre im <ph id="ph2">`x`</ph> Modus".)</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Regardless of recursion policy, only one thread can be in write mode at any time.</source>
          <target state="translated">Unabhängig von der Rekursionsrichtlinie kann nur ein Thread im Schreibmodus zu einem beliebigen Zeitpunkt.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When a thread is in write mode, no other thread can enter the lock in any mode.</source>
          <target state="translated">Wenn ein Thread im Schreibmodus befindet, kann keine anderen Thread die Sperre in jedem Modus eingeben.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Only one thread can be in upgradeable mode at any time.</source>
          <target state="translated">Nur ein Thread kann zu einem beliebigen Zeitpunkt im erweiterbaren Modus befinden.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Eine beliebige Anzahl von Threads kann im Lesemodus, und treten möglicherweise nur ein Thread im erweiterbaren Modus erhalten hat, während andere Threads im Lesemodus befinden.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Dieser Typ implementiert die <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Wenn Sie mithilfe des Typs abgeschlossen haben, sollten Sie es entweder direkt oder indirekt freigeben.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Aufrufen, um den Typ direkt zu verwerfen, dessen <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> Methode in einer <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> Block.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Um es indirekt freizugeben, verwenden Sie ein Sprachkonstrukt z. B. <ph id="ph1">`using`</ph> (in c#) oder <ph id="ph2">`Using`</ph> (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, implementiert IDisposable" in der <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> Thema zur Schnittstelle.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> has managed thread affinity; that is, each <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> object must make its own method calls to enter and exit lock modes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> weist Threadaffinität verwaltet werden. d. h. jede <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> Objekt muss einen eigenen Methodenaufrufe eingeben und Sperrmodi beenden zu machen.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>No thread can change the mode of another thread.</source>
          <target state="translated">Kein Thread kann den Modus eines anderen Threads ändern.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</source>
          <target state="translated">Wenn eine <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> lässt keine Rekursion einen Thread, versucht, die Sperre zu verschiedenen Gründen blockieren können:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</source>
          <target state="translated">Ein Thread, der versucht, den Lesemodus Blöcke eingeben, wenn Threads, die darauf warten, geben im Schreibmodus befindet oder wenn es ein einzelnen Thread im Schreibmodus vorhanden sind.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Blocking new readers when writers are queued is a lock fairness policy that favors writers.</source>
          <target state="translated">Neue Leser blockieren, wenn der Writer in der Warteschlange befinden, ist eine Sperre Ausgewogenheit-Richtlinie, die Schreiber bevorzugt.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</source>
          <target state="translated">Die aktuelle Ausgewogenheit Richtlinie gleicht Ausgewogenheit Reader und Writer, Durchsatz in den folgenden Szenarien höher stufen.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Future versions of the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> may introduce new fairness policies.</source>
          <target state="translated">Zukünftige Versionen von der <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> entstehen neue Ausgewogenheit Richtlinien.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</source>
          <target state="translated">Ein Thread, der versucht, die Blöcke im erweiterbaren Modus zu geben, wenn es ist bereits ein Thread im erweiterbaren Modus erhalten hat, wenn Schreibmodus wartenden Threads vorhanden sind, oder wird es ein einzelnen Thread im Schreibmodus.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</source>
          <target state="translated">Ein Thread, der versucht, geben Schreibmodus blockiert, wenn ein Thread in einem der drei Modi vorhanden ist.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrading and Downgrading Locks</source>
          <target state="translated">Upgrades und Downgrades Sperren</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</source>
          <target state="translated">Im erweiterbaren Modus ist für Fälle vorgesehen, in denen ein Thread in der Regel aus der geschützten Ressource liest, aber möglicherweise zu schreiben, wenn eine Bedingung erfüllt ist.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that has entered a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> methods.</source>
          <target state="translated">Ein Thread, hat eine <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> im erweiterbaren Modus erhalten hat, verfügt über Lesezugriff auf die geschützte Ressource und kann Schreibmodus durch Aufrufen der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</source>
          <target state="translated">Da treten möglicherweise nur ein Thread im erweiterbaren Modus zu einem Zeitpunkt, kann nicht ein Upgrade auf den Schreibmodus Deadlocks, wenn Rekursion nicht zulässig ist, ist die Standardrichtlinie.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Unabhängig von der Rekursionsrichtlinie lesen ein Thread, der ursprünglich eingegebenen Modus nicht so aktualisieren Sie auf den erweiterbaren Modus oder im Schreibmodus befindet, zulässig ist, da dieses Muster eine hohe Wahrscheinlichkeit für Deadlocks entstehen.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For example, if two threads in read mode both try to enter write mode, they will deadlock.</source>
          <target state="translated">Z. B. wenn zwei Threads im Lesemodus versuchen, geben den Schreibmodus, werden sie zu einem deadlock.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode is designed to avoid such deadlocks.</source>
          <target state="translated">Im erweiterbaren Modus dient zum Vermeiden solcher Deadlocks.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If there are other threads in read mode, the thread that is upgrading blocks.</source>
          <target state="translated">Es sind andere Threads im Lesemodus, den Thread, der Blöcke aktualisiert wird.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>While the thread is blocked, other threads that try to enter read mode are blocked.</source>
          <target state="translated">Während der Thread blockiert ist, werden andere Threads, die den Lesemodus blockiert.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</source>
          <target state="translated">Wenn alle Threads den Lesemodus beendet haben, gibt der erweiterbare blockierte Thread im Schreibmodus befindet.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</source>
          <target state="translated">Wenn vorhanden, dass andere Threads darauf warten sind, geben den Schreibmodus, bleiben diese blockiert, da die einzelne Thread, der im erweiterbaren Modus zu verhindern, dass Sie exklusiven Zugriff auf die Ressource.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</source>
          <target state="translated">Wenn der Thread im erweiterbaren Modus Schreibmodus beendet wird, können andere Threads, die Lesemodus warten hierzu Threads, die darauf warten, geben den Schreibmodus, es sei denn, es gibt.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</source>
          <target state="translated">Der Thread im erweiterbaren Modus kann aktualisieren und beliebig oft herabstufen, solange er der einzige Thread ist, der in die geschützte Ressource schreibt.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</source>
          <target state="translated">Wenn Sie zulassen, mehrere Threads dass eingeben schreiben Sie oder den erweiterbaren Modus, Sie nicht auf einen Thread im erweiterbaren Modus Monopol auf zulassen müssen.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</source>
          <target state="translated">Andernfalls schreiben Threads, die versuchen, geben Modus direkt blockiert auf unbestimmte Zeit, und zwar diese blockiert sind, andere Threads nicht Lesemodus.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in upgradeable mode can downgrade to read mode by first calling the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method and then calling the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method.</source>
          <target state="translated">Ein Thread im erweiterbaren Modus können Sie ein downgrade Lesemodus zunächst die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> -Methode und dem anschließenden Aufrufen der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This downgrade pattern is allowed for all lock recursion policies, even <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion&gt;</ph>.</source>
          <target state="translated">Dieses Muster wird auch für alle Sperren Rekursion Richtlinien zulässig <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</source>
          <target state="translated">Nach dem Ausführen eines Downgrades für den Lesemodus, kann kein Thread im erweiterbaren Modus erneut ein, bis er von Lesemodus beendet wurde.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Entering the Lock Recursively</source>
          <target state="translated">Die Sperre rekursiv eingeben</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>You can create a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that supports recursive lock entry by using the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29&gt;</ph> constructor that specifies lock policy, and specifying <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Sie erstellen eine <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> , die rekursive Sperren unterstützt mithilfe der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29&gt;</ph> Konstruktor, der angibt, für die Sperre wird, und gibt <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</source>
          <target state="translated">Die Verwendung der Rekursion wird für neue Entwicklungen nicht empfohlen, da dies unnötige Komplikationen eingeführt und wird der Code anfälliger für Deadlocks.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allows recursion, the following can be said about the modes a thread can enter:</source>
          <target state="translated">Für eine <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> , mit der Rekursion, über die Modi, die ein Thread kann Geben Sie Folgendes gilt:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</source>
          <target state="translated">Ein Thread im Lesemodus kann Lesemodus rekursiv, jedoch kann nicht schreiben oder den erweiterbaren Modus eingeben.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If it tries to do this, a <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn versucht wird, dazu eine <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</source>
          <target state="translated">Eingabe lesen, Modus und geben Sie im Schreibmodus oder erweiterbaren Modus ist ein Muster mit einer starken Wahrscheinlichkeit von Deadlocks, damit es nicht zulässig ist.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</source>
          <target state="translated">Wie bereits erwähnt, wird im erweiterbaren Modus für Fälle bereitgestellt, in denen es notwendig, eine Sperre zu aktualisieren ist.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</source>
          <target state="translated">Ein Thread im erweiterbaren Modus kann Schreibmodus und/oder Lesemodus eingeben und kann eines der drei Modi rekursiv eingeben.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>However, an attempt to enter write mode blocks if there are other threads in read mode.</source>
          <target state="translated">Allerdings ein Versuch, Schreibmodus blockiert, wenn andere Threads im Lesemodus vorhanden sind.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</source>
          <target state="translated">Ein Thread im Schreibmodus kann geben, Lesemodus und/oder erweiterbaren Modus erhalten hat, und Sie können eines der drei Modi rekursiv eingeben.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that has not entered the lock can enter any mode.</source>
          <target state="translated">Ein Thread, der nicht die Sperre zugewiesen ist, kann einem beliebigen Modus eingeben.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</source>
          <target state="translated">Dieser Versuch kann aus denselben Gründen als ein Versuch, eine Sperre nicht rekursiven blockieren.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</source>
          <target state="translated">Ein Thread kann die Modi, die sie in beliebiger Reihenfolge eingegeben hat beenden, solange jeder Modus genau so oft Eingabe, die den Modus beenden.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn ein Thread versucht, einen Modus zu oft zu beenden, oder um einen Modus beenden sie nicht gewechselt hat, eine <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Lock States</source>
          <target state="translated">Konfigurationssperrzustände</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>You may find it useful to think of the lock in terms of its states.</source>
          <target state="translated">Möglicherweise finden Sie es nützlich, um die Sperre im Hinblick auf seine Status vorstellen.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> can be in one of four states: not entered, read, upgrade, and write.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> kann in einem von vier Status: nicht eingegeben werden, lesen, aktualisieren und zu schreiben.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</source>
          <target state="translated">Nicht eingegeben: In diesem Status keine Threads die Sperre eingegeben haben (oder alle Threads die Sperre beendet haben).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Read: In this state, one or more threads have entered the lock for read access to the protected resource.</source>
          <target state="translated">Lesen Sie: In diesem Zustand haben einen oder mehrere Threads die Sperre für den Lesezugriff auf die geschützte Ressource eingegeben.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can enter the lock in read mode by using the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> methods, or by downgrading from upgradeable mode.</source>
          <target state="translated">Ein Thread kann die Sperre im Lesemodus eingeben, mit der <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> Methoden oder Downgrade von erweiterbaren Modus erhalten hat.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</source>
          <target state="translated">Upgrade: In diesem Zustand befindet, ein Thread verfügt über die Sperre für den Lesezugriff mit der Option zum Aktualisieren, um mit dem Schreibzugriff (d. h. im erweiterbaren Modus), und 0 (null) oder mehrere Threads die Sperre für den Lesezugriff eingegeben haben.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</source>
          <target state="translated">Nicht mehr als einem Thread zu einem Zeitpunkt kann die Sperre mit der Option zum Aktualisieren; zusätzliche Threads, die versuchen, die Zuweisung des erweiterbaren Modus werden blockiert.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Write: In this state, one thread has entered the lock for write access to the protected resource.</source>
          <target state="translated">Schreiben: In diesem Zustand befindet, verfügt über ein Thread die Sperre für den Schreibzugriff auf die geschützte Ressource zugewiesen.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>That thread has exclusive possession of the lock.</source>
          <target state="translated">Dieser Thread befindet sich exklusiven Besitz der Sperre.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Any other thread that tries to enter the lock for any reason is blocked.</source>
          <target state="translated">Alle anderen Threads, die versucht, die Sperre aus irgendeinem Grund wird blockiert.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread <ph id="ph1">`t`</ph> takes the action described in the leftmost column.</source>
          <target state="translated">Die folgende Tabelle beschreibt die Übergänge zwischen konfigurationssperrzustände für Sperren, die keine Rekursion, wenn ein Thread zulassen <ph id="ph1">`t`</ph> wird die Aktion, die in der am weitesten links stehende Spalte beschrieben.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>At the time it takes the action, <ph id="ph1">`t`</ph> has no mode.</source>
          <target state="translated">Zum Zeitpunkt die Aktion dauert <ph id="ph1">`t`</ph> weist keine Modus.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(The special case where <ph id="ph1">`t`</ph> is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</source>
          <target state="translated">(Besonderen Fall, in dem <ph id="ph1">`t`</ph> befindet sich im erweiterbaren Modus erhalten hat, wird in die Fußnoten zur Tabelle beschrieben.) Die oberste Zeile beschreibt den Anfangszustand der Sperre.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The cells describe what happens to the thread, and show changes to the lock state in parentheses.</source>
          <target state="translated">Die Zellen beschreiben, was geschieht, an den Thread, und zeigen Änderungen an den Zustand der remotesperre in Klammern.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Not entered (N)</source>
          <target state="translated">Nicht eingegeben (N)</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Read (R)</source>
          <target state="translated">Read (R)</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrade (U)</source>
          <target state="translated">Upgrade (U)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Write (W)</source>
          <target state="translated">Write (W)</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters read mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> in den schreibgeschützten Modus übergeht</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (R).</source>
          <target state="translated"><ph id="ph1">`t`</ph> Gibt ein (R).</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id="ph2">`t`</ph> enters.</source>
          <target state="translated"><ph id="ph1">`t`</ph> blockiert, wenn Threads für den Schreibmodus warten; andernfalls <ph id="ph2">`t`</ph> eingibt.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id="ph2">`t`</ph> enters.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
          <target state="translated"><ph id="ph1">`t`</ph> blockiert, wenn Threads für den Schreibmodus warten; andernfalls <ph id="ph2">`t`</ph> eingibt.<bpt id="p1">&lt;sup&gt;</bpt> 1<ept id="p1">&lt;/sup&gt;</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> blockiert werden.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters upgradeable mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> fordert den erweiterbaren Modus</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (U).</source>
          <target state="translated"><ph id="ph1">`t`</ph> Gibt ein (U).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode or upgrade mode; otherwise, <ph id="ph2">`t`</ph> enters (U).</source>
          <target state="translated"><ph id="ph1">`t`</ph> blockiert, wenn Threads warten schreiben oder den erweiterbaren Modus; andernfalls <ph id="ph2">`t`</ph> (U) eingibt.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> blockiert werden.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> blockiert werden.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters write mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> fordert den Schreibmodus</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (W).</source>
          <target state="translated"><ph id="ph1">`t`</ph> Wechselt (W).</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> blockiert werden.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept></source>
          <target state="translated"><ph id="ph1">`t`</ph> blockiert werden. <bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept></target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> blockiert werden.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept> If <ph id="ph1">`t`</ph> starts out in upgradeable mode, it enters read mode.</source>
          <target state="translated"><bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept> Wenn <ph id="ph1">`t`</ph> startet im erweiterbaren Modus erhalten hat, erhält es out Lesemodus.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This action never blocks.</source>
          <target state="translated">Diese Aktion wird nie blockiert.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The lock state does not change.</source>
          <target state="translated">Der Zustand der remotesperre wird nicht geändert.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</source>
          <target state="translated">(Der Thread kann dann abschließen, ein Downgrade für den Lesemodus, aber beim Verlassen erweiterbaren Modus erhalten hat.)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> If <ph id="ph1">`t`</ph> starts out in upgradeable mode, it blocks if there are threads in read mode.</source>
          <target state="translated"><bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> Wenn <ph id="ph1">`t`</ph> beginnt im erweiterbaren Modus erhalten hat, er blockiert, wenn Threads im Lesemodus vorhanden sind.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Otherwise it upgrades to write mode.</source>
          <target state="translated">Andernfalls wird es den Schreibmodus aktualisiert.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The lock state changes to Write (W).</source>
          <target state="translated">Der Zustand der remotesperre ändert Write (W).</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If <ph id="ph1">`t`</ph> blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</source>
          <target state="translated">Wenn <ph id="ph1">`t`</ph> blockiert wird, weil Threads vorhanden, im Lesemodus sind, er wird im Schreibmodus befindet, als der letzte Thread den Lesemodus beendet, auch wenn Sie Threads, die darauf warten, geben im Schreibmodus.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</source>
          <target state="translated">Wenn eine Zustandsänderung tritt auf, weil ein Thread die Sperre beendet, wird der nächste Thread, der aktiviert, wie folgt ausgewählt:</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</source>
          <target state="translated">Ein Thread, der wartet, wird zunächst im Schreibmodus und ist bereits im erweiterbaren Modus (es kann höchstens ein solcher Thread).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, a thread that is waiting for write mode.</source>
          <target state="translated">Andernfalls ein Thread, der für den Schreibmodus wartet.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, a thread that is waiting for upgradeable mode.</source>
          <target state="translated">Ein Thread, die für den erweiterbaren Modus warten wird fehlschlagen.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, all threads that are waiting for read mode.</source>
          <target state="translated">Falls dies fehlschlägt, alle Threads, die für den Lesemodus warten.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</source>
          <target state="translated">Die nachfolgende Status der Sperre ist immer Write (W) in der ersten beiden Fälle und Upgrade (U) im dritten Fall unabhängig vom Status der Sperre, wenn der vorhandene Thread statusänderung ausgelöst.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</source>
          <target state="translated">Im letzten Fall ist der Status der Sperre aktualisieren (U), wenn es ein Thread im erweiterbaren Modus nach der Änderung und Read (R), andernfalls unabhängig von den vorherigen Zustand.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following example shows a simple synchronized cache that holds strings with integer keys.</source>
          <target state="translated">Das folgende Beispiel zeigt einen einfachen synchronisierten Cache, der Zeichenfolgen mit ganzzahligen Schlüssel enthält.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>An instance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> that serves as the inner cache.</source>
          <target state="translated">Eine Instanz von <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> wird zum Synchronisieren des Zugriffs auf die <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> , die als interner Cache dient.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</source>
          <target state="translated">Das Beispiel enthält einfache Methoden zum Cache hinzugefügt, aus dem Cache löschen und aus dem Cache gelesen.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</source>
          <target state="translated">Zur Veranschaulichung Timeouts umfasst das Beispiel eine Methode, die dem Cache hinzugefügt werden soll, nur, wenn dies in einem angegebenen Timeout erfolgen kann.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Um im erweiterbaren Modus zu demonstrieren, wird im Beispiel enthält eine Methode, die einen Schlüssel zugeordneten Wert abruft und vergleicht ihn mit einem neuen Wert.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Wenn der Wert unverändert ist, gibt die Methode einen Status, der angibt, der keine Änderung.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Sie keinen Wert für den Schlüssel gefunden wird, das Schlüssel/Wert-Paar eingefügt wird.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Wenn der Wert geändert wurde, wird er aktualisiert.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</source>
          <target state="translated">Im erweiterbaren Modus ermöglicht dem Thread zum Aktualisieren von Lesezugriff auf den Zugriff zu schreiben, ohne das Risiko von Deadlocks bei Bedarf.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</source>
          <target state="translated">Das Beispiel enthält eine geschachtelte-Enumeration, die die Rückgabewerte für die Methode gibt an, die im erweiterbaren Modus veranschaulicht.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">Im Beispiel wird den Standardkonstruktor verwendet, um die Sperre zu erstellen, also Rekursion nicht zulässig ist.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programmieren der <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> ist einfacher und weniger fehleranfällig, wenn die Sperre nicht Rekursion möglich ist.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">Im folgenden Codebeispiel wird die <ph id="ph1">`SynchronizedCache`</ph> Objekt, das ein Wörterbuch von Gemüse Namen gespeichert.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>It creates three tasks.</source>
          <target state="translated">Es werden drei Aufgaben erstellt.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Das erste schreibt die Namen der Gemüse gespeichert, die in einem Array an eine <ph id="ph1">`SynchronizedCache`</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">Die zweite und dritte Aufgabe Anzeigenamen Gemüse, die erste Aufgabe in aufsteigender Reihenfolge (von niedrig Index zu hohe Index), das zweite in absteigender Reihenfolge.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">Die letzte Aufgabe sucht nach der Zeichenfolge "Gurken", und wenn, es sucht Ruft die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> Methode, um die Zeichenfolge "Grün Bean" zu ersetzen.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This type is thread safe.</source>
          <target state="translated">Dieser Typ ist threadsicher.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class with default property values.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Klasse mit Standardeigenschaftswerten.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that is initialized with this constructor does not allow recursion.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> , initialisiert wird, mit diesem Konstruktor lässt keine Rekursion.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>That is, the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> property returns <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Das bedeutet, dass die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph>-Eigenschaft <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Weitere Informationen zu Rekursionsrichtlinie und Auswirkungen, finden Sie unter der <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> Enumeration und die <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The following example shows a simple synchronized cache that holds strings with integer keys.</source>
          <target state="translated">Das folgende Beispiel zeigt einen einfachen synchronisierten Cache, der Zeichenfolgen mit ganzzahligen Schlüssel enthält.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>An instance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> that serves as the inner cache.</source>
          <target state="translated">Eine Instanz von <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> wird zum Synchronisieren des Zugriffs auf die <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> , die als interner Cache dient.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The parameterless constructor is used to create the lock.</source>
          <target state="translated">Der parameterlose Konstruktor wird verwendet, um die Sperre zu erstellen.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</source>
          <target state="translated">Das Beispiel enthält einfache Methoden zum Cache hinzugefügt, aus dem Cache löschen und aus dem Cache gelesen.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</source>
          <target state="translated">Zur Veranschaulichung Timeouts umfasst das Beispiel eine Methode, die dem Cache hinzugefügt werden soll, nur, wenn dies in einem angegebenen Timeout erfolgen kann.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Um im erweiterbaren Modus zu demonstrieren, wird im Beispiel enthält eine Methode, die einen Schlüssel zugeordneten Wert abruft und vergleicht ihn mit einem neuen Wert.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Wenn der Wert unverändert ist, gibt die Methode einen Status, der angibt, der keine Änderung.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Sie keinen Wert für den Schlüssel gefunden wird, das Schlüssel/Wert-Paar eingefügt wird.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Wenn der Wert geändert wurde, wird er aktualisiert.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</source>
          <target state="translated">Im erweiterbaren Modus ermöglicht dem Thread zum Aktualisieren von Lesezugriff auf den Zugriff zu schreiben, ohne das Risiko von Deadlocks bei Bedarf.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</source>
          <target state="translated">Das Beispiel enthält eine geschachtelte-Enumeration, die die Rückgabewerte für die Methode gibt an, die im erweiterbaren Modus veranschaulicht.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">Im Beispiel wird den Standardkonstruktor verwendet, um die Sperre zu erstellen, also Rekursion nicht zulässig ist.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programmieren der <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> ist einfacher und weniger fehleranfällig, wenn die Sperre nicht Rekursion möglich ist.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">Im folgenden Codebeispiel wird die <ph id="ph1">`SynchronizedCache`</ph> Objekt, das ein Wörterbuch von Gemüse Namen gespeichert.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>It creates three tasks.</source>
          <target state="translated">Es werden drei Aufgaben erstellt.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Das erste schreibt die Namen der Gemüse gespeichert, die in einem Array an eine <ph id="ph1">`SynchronizedCache`</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">Die zweite und dritte Aufgabe Anzeigenamen Gemüse, die erste Aufgabe in aufsteigender Reihenfolge (von niedrig Index zu hohe Index), das zweite in absteigender Reihenfolge.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">Die letzte Aufgabe sucht nach der Zeichenfolge "Gurken", und wenn, es sucht Ruft die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> Methode, um die Zeichenfolge "Grün Bean" zu ersetzen.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>One of the enumeration values that specifies the lock recursion policy.</source>
          <target state="translated">Einer der Enumerationswerte, der die Rekursionsrichtlinie für die Sperre angibt.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class, specifying the lock recursion policy.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Klasse unter Angabe der Rekursionsrichtlinie für die Sperre.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Recursion policy determines the restrictions on threads that enter the lock more than once.</source>
          <target state="translated">Rekursionsrichtlinie bestimmt die Einschränkungen für Threads, die die Sperre mehrmals eingeben.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>For example, if a lock was created with <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> and a thread has entered the lock in read mode, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.</source>
          <target state="translated">Angenommen, eine Sperre mit erstellte <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> und ein Thread verfügt über die Sperre im Lesemodus, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> wird ausgelöst, wenn der Thread versucht, die Sperre im Lesemodus erneut ein.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Similarly, if a thread has entered the lock in write mode, <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in any mode.</source>
          <target state="translated">Auf ähnliche Weise, wenn ein Thread die Sperre im Schreibmodus zugewiesen ist <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> wird ausgelöst, wenn der Thread versucht, die Sperre in einem beliebigen Modus erneut ein.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</source>
          <target state="translated">Ein Thread im erweiterbaren Modus kann den Schreibmodus oder unabhängig von der Einstellung Rekursion Lesemodus.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Unabhängig von der Rekursionsrichtlinie lesen ein Thread, der ursprünglich eingegebenen Modus nicht so aktualisieren Sie auf den erweiterbaren Modus oder im Schreibmodus befindet, zulässig ist, da dieses Muster eine hohe Wahrscheinlichkeit für Deadlocks entstehen.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Weitere Informationen zu Rekursionsrichtlinie und Auswirkungen, finden Sie unter der <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> Enumeration und die <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The following example shows two exception scenarios, one that depends on the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> setting and one that does not.</source>
          <target state="translated">Das folgende Beispiel zeigt zwei Ausnahme Szenarien, die von abhängig ist die <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> festlegen und eine, die nicht der Fall ist.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</source>
          <target state="translated">Im ersten Szenario wird der Thread in den schreibgeschützten Modus übergeht und versucht dann Lesemodus rekursiv eingeben.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is created by using the default constructor, which sets recursion policy to <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> wird erstellt, mit dem Standardkonstruktor, der Rekursionsrichtlinie wird auf <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>, wird eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> is used to create the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> dient zum Erstellen der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, wird keine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>In the second scenario, the thread enters read mode and then tries to enter write mode.</source>
          <target state="translated">Im zweiten Szenario erhält des Threads den Lesemodus, und klicken Sie dann versucht, geben im Schreibmodus.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown regardless of the lock recursion policy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> unabhängig von der Rekursionsrichtlinie der Sperre ausgelöst.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">Im folgenden Codebeispiel wird die <ph id="ph1">`SynchronizedCache`</ph> Objekt, das ein Wörterbuch von Gemüse Namen gespeichert.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>It creates three tasks.</source>
          <target state="translated">Es werden drei Aufgaben erstellt.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Das erste schreibt die Namen der Gemüse gespeichert, die in einem Array an eine <ph id="ph1">`SynchronizedCache`</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">Die zweite und dritte Aufgabe Anzeigenamen Gemüse, die erste Aufgabe in aufsteigender Reihenfolge (von niedrig Index zu hohe Index), das zweite in absteigender Reihenfolge.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">Die letzte Aufgabe sucht nach der Zeichenfolge "Gurken", und wenn, es sucht Ruft die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> Methode, um die Zeichenfolge "Grün Bean" zu ersetzen.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Gets the total number of unique threads that have entered the lock in read mode.</source>
          <target state="translated">Ruft die Gesamtzahl von eindeutigen Threads ab, denen die Sperre im Lesemodus zugewiesen ist.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The number of unique threads that have entered the lock in read mode.</source>
          <target state="translated">Die Anzahl von eindeutigen Threads, denen die Sperre im Lesemodus zugewiesen ist.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</source>
          <target state="translated">Ein Thread nur einmal gezählt wird, auch wenn die Sperre Rekursion sowie den Thread ermöglicht hat Lesemodus mehrmals eingegeben.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Verwenden Sie diese Eigenschaft nur für Debuggen, profilerstellung und Protokollierungszwecken und nicht auf das Verhalten eines Algorithmus gesteuert.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Die Ergebnisse können ändern, sobald sie berechnet wurden.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A&gt;</ph> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A&gt;</ph> Eigenschaft, um ein Ereignisprotokolleintrag generiert, wenn die Anzahl der Threads im Lesemodus einen Schwellenwert überschreitet.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class.</source>
          <target state="translated">Gibt alle von der aktuellen Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Klasse verwendeten Ressourcen frei.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</source>
          <target state="translated">Rufen Sie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> auf, wenn Sie <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> nicht mehr benötigen.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in an unusable state.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>-Methode bewirkt, dass <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> nicht mehr verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>After calling <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> was occupying.</source>
          <target state="translated">Nach dem Aufruf <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>, müssen Sie alle Verweise auf Freigeben der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> , damit der Garbage Collector den Arbeitsspeicher freigeben kann, die die <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> belegt wurde.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Bereinigen von nicht verwalteten Ressourcen<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> und <bpt id="p2">[</bpt>Implementieren einer Dispose-Methode<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Always call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> object.</source>
          <target state="translated">Rufen Sie immer <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> , bevor Sie den letzten Verweis auf Freigeben der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /&gt;</ph> ist größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /&gt;</ph> ist größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /&gt;</ph> ist größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Tries to enter the lock in read mode.</source>
          <target state="translated">Versucht, die Sperre im Lesemodus zu erhalten.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Diese Methode blockiert, bis der aufrufende Thread die Sperre eintritt, und daher möglicherweise nie zurück.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> Methode für ein angegebenes Intervall blockieren, und klicken Sie dann zurück, wenn sich der aufrufende Thread nicht im Lesemodus, während dieses Intervalls.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Multiple threads can enter read mode at the same time.</source>
          <target state="translated">Mehrere Threads können gleichzeitig Lesemodus eingeben.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Wenn eine oder mehrere Threads Schreibmodus warten, ein Thread, der aufruft, die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> Methode blockiert, bis diese Threads verfügen über eine Timeout oder im Schreibmodus befindet und von ihm dann beendet.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Lesemodus zugewiesen ist rekursiv, eingeben, auch wenn andere Threads Schreibmodus warten.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>At most one thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Darf höchstens ein Thread kann im erweiterbaren Modus befinden, während andere Threads im Lesemodus befinden.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Wenn zusätzliche Threads auf den erweiterbaren Modus warten und es keine Threads werden Schreibmodus warten, auf diesen Aufruf threads die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> Methode Lesemodus sofort und nicht blockieren.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method to enter the lock in read mode.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> Methode, um die Sperre im Lesemodus.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The method shown in the example retrieves the value associated with a key.</source>
          <target state="translated">Die im Beispiel gezeigte Methode ruft einen Schlüssel zugeordnete Wert ab.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If the key is not found, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Wenn der Schlüssel nicht von der inneren ausgelöste Ausnahme gefunden wird, <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> ist zulässig, um die Methode zu beenden.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> method, ensuring that the caller exits read mode.</source>
          <target state="translated">Ein <ph id="ph1">`finally`</ph> Block wird zum Ausführen der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> -Methode, um sicherzustellen, dass der Aufrufer den Lesemodus beendet.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Dieser Code ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The current thread cannot acquire the write lock when it holds the read lock.</source>
          <target state="translated">Der aktuelle Thread kann nicht die Schreibsperre erlangen, wenn er die Lesesperre besitzt.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the read lock.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph>-Eigenschaft ist gleich <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, und der aktuelle Thread hat versucht, die Lesesperre zu erlangen, obwohl er die Lesesperre bereits besitzt.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the write lock.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph>-Eigenschaft ist gleich <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, und der aktuelle Thread hat versucht, die Lesesperre zu erlangen, obwohl er die Schreibsperre bereits besitzt.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This limit is so large that applications should never encounter this exception.</source>
          <target state="translated">Dieser Grenzwert ist so groß, dass diese Ausnahme nie für Anwendungen auftreten sollte.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Objekt wurde verworfen.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Tries to enter the lock in upgradeable mode.</source>
          <target state="translated">Versucht, die Sperre im erweiterbaren Modus zu erhalten.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Diese Methode blockiert, bis der aufrufende Thread die Sperre eintritt, und daher möglicherweise nie zurück.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> Methode für ein angegebenes Intervall blockieren, und klicken Sie dann zurück, wenn der aufrufende Thread nicht im erweiterbaren Modus während dieses Intervalls eingegeben hat.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Erweiterbaren Modus verwenden, wenn ein Thread in der Regel auf die Ressource zugreift, die durch geschützt ist die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in im Lesemodus befindet, aber möglicherweise Schreibmodus, wenn bestimmte Bedingungen erfüllt sind.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</source>
          <target state="translated">Ein Thread im erweiterbaren Modus kann Lesemodus oder den Schreibmodus.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Only one thread can enter upgradeable mode at any given time.</source>
          <target state="translated">Nur ein Thread kann im erweiterbaren Modus zu einem beliebigen Zeitpunkt eingeben.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Wenn ein Thread im erweiterbaren Modus zugewiesen ist, und es keine Threads sind Schreibmodus warten, kann eine beliebige Anzahl von anderen Threads Lesemodus, eingeben, auch wenn Threads den erweiterbaren Modus warten.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Wenn eine oder mehrere Threads Schreibmodus warten, ein Thread, der aufruft, die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> Methode blockiert, bis diese Threads verfügen über eine Timeout oder im Schreibmodus befindet und von ihm dann beendet.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im erweiterbaren Modus zugewiesen ist rekursiv erweiterbaren Modus erhalten hat, eingeben, auch wenn andere Threads Schreibmodus warten.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method to enter the lock in upgradeable mode.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> Methode, um die Sperre im erweiterbaren Modus erhalten hat.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method, ensuring that the caller exits upgradeable mode.</source>
          <target state="translated">Ein <ph id="ph1">`finally`</ph> Block wird zum Ausführen der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> -Methode, um sicherzustellen, dass der Aufrufer den erweiterbaren Modus beendet.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The method shown in the example retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Die Methode, die im Beispiel gezeigte Ruft den Wert, der einem Schlüssel zugeordnet und vergleicht ihn mit einem neuen Wert.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Wenn der Wert unverändert ist, gibt die Methode einen Status, der angibt, der keine Änderung.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Sie keinen Wert für den Schlüssel gefunden wird, das Schlüssel/Wert-Paar eingefügt wird.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Wenn der Wert geändert wurde, wird er aktualisiert.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</source>
          <target state="translated">Im erweiterbaren Modus ermöglicht dem Thread die Lesesperre zu aktualisieren, ohne das Risiko von Deadlocks bei Bedarf.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">Im Beispiel wird den Standardkonstruktor verwendet, um die Sperre zu erstellen, also Rekursion nicht zulässig ist.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programmieren der <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> ist einfacher und weniger fehleranfällig, wenn die Sperre nicht Rekursion möglich ist.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Dieser Code ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock in any mode.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, und dem aktuellen Thread wurde die Sperre bereits in einem der Modi zugewiesen.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Der aktuelle Thread befindet sich im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Objekt wurde verworfen.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>Tries to enter the lock in write mode.</source>
          <target state="translated">Versucht, die Sperre im Schreibmodus zu erhalten.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Diese Methode blockiert, bis der aufrufende Thread die Sperre eintritt, und daher möglicherweise nie zurück.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> Methode für ein angegebenes Intervall blockieren, und klicken Sie dann zurück, wenn der aufrufende Thread nicht im Schreibmodus während dieses Intervalls hat.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode.</source>
          <target state="translated">Wenn andere Threads auf die Sperre im Lesemodus zugewiesen ist, ein Thread, der aufruft, die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> Methode blockiert, bis diese Threads beendet wurden im Lesemodus befindet.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Wenn Schreibmodus warten Threads vorhanden sind, ein Timeout weiteren Threads, die versuchen, geben die Lesemodus oder erweiterbaren Modus zu blockieren, bis alle Threads Schreibmodus warten verfügen über eine oder im Schreibmodus befindet und daraus dann beendet.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Schreibmodus zugewiesen ist Schreibzugriff Modus rekursiv eingeben, auch wenn andere Threads Schreibmodus warten.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method to enter the lock in write mode.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> Methode, um die Sperre im Schreibmodus.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">Die Methode, die im Beispiel gezeigte hinzugefügt synchronisierten Cache ein neues Schlüssel/Wert-Paar.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Wenn der Schlüssel bereits im Cache, die von der inneren Ausnahme <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> ist zulässig, um die Methode zu beenden.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits write mode.</source>
          <target state="translated">Ein <ph id="ph1">`finally`</ph> Block wird zum Ausführen der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> -Methode, um sicherzustellen, dass der Aufrufer den Schreibmodus beendet.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Dieser Code ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock in any mode.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, und dem aktuellen Thread wurde die Sperre bereits in einem der Modi zugewiesen.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.</source>
          <target state="translated">Der aktuelle Thread befindet sich im Lesemodus, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Objekt wurde verworfen.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</source>
          <target state="translated">Verringert die Rekursionszahl für den Lesemodus und beendet den Lesemodus, wenn das Rekursionsergebnis 0 (null) ist.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Diese Methode wird nicht unterschieden Rekursion Reihenfolge.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Z. B. wenn ein Thread eine im erweiterbaren Modus Sperre, und klicken Sie dann die Sperre im Lesemodus, spielt die Reihenfolge, in der der Thread, die zwei Modi beendet, keine Rolle.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread die Sperre im Schreibmodus und geben Sie ihn dann rekursiv im Lesemodus; die Reihenfolge, in dem der Thread beendet wird, im Lesemodus befindet und Schreibvorgänge Modus keine Rolle spielt.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">Das Beenden der Sperre möglicherweise andere wartende Threads zu signalisieren.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> method, ensuring that the caller exits read mode.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie eine <ph id="ph1">`finally`</ph> Block zum Ausführen der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> -Methode, um sicherzustellen, dass der Aufrufer den Lesemodus beendet.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The method shown in the example retrieves the value associated with a key.</source>
          <target state="translated">Die im Beispiel gezeigte Methode ruft einen Schlüssel zugeordnete Wert ab.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>If the key is not found, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Wenn der Schlüssel nicht von der inneren ausgelöste Ausnahme gefunden wird, <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> ist zulässig, um die Methode zu beenden.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method is used to enter read mode.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> Methode wird verwendet, um den Lesemodus.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Dieser Code ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The current thread has not entered the lock in read mode.</source>
          <target state="translated">Der aktuelle Thread befindet sich nicht im Lesemodus.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</source>
          <target state="translated">Verringert die Rekursionszahl für den erweiterbaren Modus und beendet den erweiterbaren Modus, wenn das Rekursionsergebnis 0 (null) ist.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Diese Methode wird nicht unterschieden Rekursion Reihenfolge.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Z. B. wenn ein Thread eine im erweiterbaren Modus Sperre, und klicken Sie dann die Sperre im Schreibmodus, spielt die Reihenfolge, in der der Thread, die zwei Modi beendet, keine Rolle.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread Geben Sie die Sperre im Schreibmodus und geben Sie ihn dann rekursiv im erweiterbaren Modus; die Reihenfolge, in der der Thread den erweiterbaren Modus zu erhalten und den Schreibmodus beendet, spielt keine Rolle.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">Das Beenden der Sperre möglicherweise andere wartende Threads zu signalisieren.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method, ensuring that the caller exits upgradeable mode.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie eine <ph id="ph1">`finally`</ph> Block zum Ausführen der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> -Methode, um sicherzustellen, dass der Aufrufer den erweiterbaren Modus beendet.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The method shown in the example retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Die Methode, die im Beispiel gezeigte Ruft den Wert, der einem Schlüssel zugeordnet und vergleicht ihn mit einem neuen Wert.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Wenn der Wert unverändert ist, gibt die Methode einen Status, der angibt, der keine Änderung.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Sie keinen Wert für den Schlüssel gefunden wird, das Schlüssel/Wert-Paar eingefügt wird.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Wenn der Wert geändert wurde, wird er aktualisiert.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</source>
          <target state="translated">Im erweiterbaren Modus ermöglicht dem Thread die Lesesperre zu aktualisieren, ohne das Risiko von Deadlocks bei Bedarf.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">Im Beispiel wird den Standardkonstruktor verwendet, um die Sperre zu erstellen, also Rekursion nicht zulässig ist.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programmieren der <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> ist einfacher und weniger fehleranfällig, wenn die Sperre nicht Rekursion möglich ist.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Dieser Code ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The current thread has not entered the lock in upgradeable mode.</source>
          <target state="translated">Der aktuelle Thread befindet sich nicht im erweiterbaren Modus.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</source>
          <target state="translated">Verringert die Rekursionszahl für den Schreibmodus und beendet den Schreibmodus, wenn das Rekursionsergebnis 0 (null) ist.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Diese Methode wird nicht unterschieden Rekursion Reihenfolge.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Z. B. wenn ein Thread eine im erweiterbaren Modus Sperre, und klicken Sie dann die Sperre im Schreibmodus, spielt die Reihenfolge, in der der Thread, die zwei Modi beendet, keine Rolle.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread die Sperre im Schreibmodus und geben Sie ihn dann rekursiv im Lesemodus; die Reihenfolge, in dem der Thread beendet wird, im Lesemodus befindet und Schreibvorgänge Modus keine Rolle spielt.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">Das Beenden der Sperre möglicherweise andere wartende Threads zu signalisieren.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits write mode.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie eine <ph id="ph1">`finally`</ph> Block zum Ausführen der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> -Methode, um sicherzustellen, dass der Aufrufer den Schreibmodus beendet.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">Die Methode, die im Beispiel gezeigte hinzugefügt synchronisierten Cache ein neues Schlüssel/Wert-Paar.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Wenn der Schlüssel bereits im Cache, die von der inneren Ausnahme <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> ist zulässig, um die Methode zu beenden.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method is used to enter the lock in write mode.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> Methode wird verwendet, um die Sperre im Schreibmodus.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Dieser Code ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The current thread has not entered the lock in write mode.</source>
          <target state="translated">Der aktuelle Thread befindet sich nicht im Schreibmodus.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in read mode.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im Lesemodus zugewiesen ist.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered read mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn sich der aktuelle Thread im Lesemodus befindet, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Diese Eigenschaft sollte für die Verwendung in bestätigt oder für andere Zwecke Debuggen.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Verwenden Sie es nicht um den Fluss der Ausführung des Programms zu steuern.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered read mode unexpectedly.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A&gt;</ph> Eigenschaft eine Bestätigung generiert, wenn der aktuelle Thread im Lesemodus unerwartet beendet.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im erweiterbaren Modus zugewiesen ist.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered upgradeable mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn sich der aktuelle Thread im erweiterbaren Modus befindet, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Diese Eigenschaft sollte für die Verwendung in bestätigt oder für andere Zwecke Debuggen.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Verwenden Sie es nicht um den Fluss der Ausführung des Programms zu steuern.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A&gt;</ph> Eigenschaft eine Bestätigung generiert, wenn der aktuelle Thread im erweiterbaren Modus unerwartet eingegeben hat.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in write mode.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im Schreibmodus zugewiesen ist.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered write mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn sich der aktuelle Thread im Schreibmodus befindet, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Diese Eigenschaft sollte für die Verwendung in bestätigt oder für andere Zwecke Debuggen.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Verwenden Sie es nicht um den Fluss der Ausführung des Programms zu steuern.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered write mode unexpectedly.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A&gt;</ph> Eigenschaft eine Bestätigung generiert, wenn der aktuelle Thread im Schreibmodus unerwartet beendet wurde.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Gets a value that indicates the recursion policy for the current <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object.</source>
          <target state="translated">Ruft einen Wert ab, der die Rekursionsrichtlinie für das aktuelle <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Objekt angibt.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>One of the enumeration values that specifies the lock recursion policy.</source>
          <target state="translated">Einer der Enumerationswerte, der die Rekursionsrichtlinie für die Sperre angibt.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Recursion policy determines the restrictions on threads that enter the lock more than once.</source>
          <target state="translated">Rekursionsrichtlinie bestimmt die Einschränkungen für Threads, die die Sperre mehrmals eingeben.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>For example, if a lock was created with <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> and a thread has entered the lock in read mode, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.</source>
          <target state="translated">Angenommen, eine Sperre mit erstellte <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> und ein Thread verfügt über die Sperre im Lesemodus, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> wird ausgelöst, wenn der Thread versucht, die Sperre im Lesemodus erneut ein.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</source>
          <target state="translated">Ein Thread im erweiterbaren Modus kann den Schreibmodus oder unabhängig von der Einstellung Rekursion Lesemodus.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Unabhängig von der Rekursionsrichtlinie lesen ein Thread, der ursprünglich eingegebenen Modus nicht so aktualisieren Sie auf den erweiterbaren Modus oder im Schreibmodus befindet, zulässig ist, da dieses Muster eine hohe Wahrscheinlichkeit für Deadlocks entstehen.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Weitere Informationen zu Rekursionsrichtlinie und Auswirkungen, finden Sie unter der <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> Enumeration und die <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</source>
          <target state="translated">Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im Lesemodus zugewiesen ist.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered the lock recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0 (null) Wenn sich der aktuelle Thread nicht im Lesemodus befindet, 1, wenn der Thread im Lesemodus befindet, verfügt jedoch nicht angegeben, rekursiv, oder <bpt id="p1">*</bpt>n<ept id="p1">*</ept> Wenn sich der Thread die Sperre rekursiv <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 Mal.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Verwenden Sie diese Eigenschaft nur für Debuggen, profilerstellung und Protokollierungszwecken und nicht auf das Verhalten eines Algorithmus gesteuert.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Die Ergebnisse können ändern, sobald sie berechnet wurden.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</source>
          <target state="translated">Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im erweiterbaren Modus zugewiesen ist.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered upgradeable mode recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0, wenn sich der aktuelle Thread nicht erweiterbaren Modus, 1, wenn der Thread im erweiterbaren Modus und verfügt über diesen nicht rekursiv, oder <bpt id="p1">*</bpt>n<ept id="p1">*</ept> Wenn sich der Thread im erweiterbaren Modus rekursiv <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 wie oft.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Verwenden Sie diese Eigenschaft nur für Debuggen, profilerstellung und Protokollierungszwecken und nicht auf das Verhalten eines Algorithmus gesteuert.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Die Ergebnisse können ändern, sobald sie berechnet wurden.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</source>
          <target state="translated">Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im Schreibmodus zugewiesen ist.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered write mode recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0, wenn sich der aktuelle Thread nicht Schreibmodus, 1, wenn der Thread im Schreibmodus befindet, verfügt jedoch nicht diesen rekursiv, oder <bpt id="p1">*</bpt>n<ept id="p1">*</ept> Wenn sich der Thread Write-Modus rekursiv <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 Mal.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Verwenden Sie diese Eigenschaft nur für Debuggen, profilerstellung und Protokollierungszwecken und nicht auf das Verhalten eines Algorithmus gesteuert.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Die Ergebnisse können ändern, sobald sie berechnet wurden.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in read mode, with an optional time-out.</source>
          <target state="translated">Versucht, die Sperre im Lesemodus zu erhalten. Optional wird ein Timeout berücksichtigt.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>), um unbegrenzt zu warten.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>Tries to enter the lock in read mode, with an optional integer time-out.</source>
          <target state="translated">Versucht, die Sperre im Lesemodus zu erhalten. Optional wird ein ganzzahliger Timeout berücksichtigt.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered read mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aufrufende Thread den Lesemodus erhalten hat, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Wenn <ph id="ph1">`millisecondsTimeout`</ph> 0 (null) ist, wird diese Methode überprüft den Status der Sperre und gibt <ph id="ph2">`false`</ph> sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>Multiple threads can enter read mode at the same time.</source>
          <target state="translated">Mehrere Threads können gleichzeitig Lesemodus eingeben.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Wenn eine oder mehrere Threads Schreibmodus warten, ein Thread, der aufruft, die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> Methode blockiert, bis diese Threads haben entweder ein Timeout oder im Schreibmodus befindet und dann daraus beendet oder das Timeoutintervall des aufrufenden Threads abläuft.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Lesemodus zugewiesen ist rekursiv, eingeben, auch wenn andere Threads Schreibmodus warten.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>One thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Ein Thread kann im erweiterbaren Modus befinden, während andere Threads im Lesemodus sind.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Wenn zusätzliche Threads auf den erweiterbaren Modus warten und es keine Threads werden Schreibmodus warten, auf diesen Aufruf threads die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> Methode Lesemodus sofort und nicht blockieren.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, und der aktuelle Thread hat die Sperre bereits erhalten.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> ist negativ, aber ungleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), der den einzigen zulässigen negativen Wert darstellt.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Objekt wurde verworfen.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Das Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>Tries to enter the lock in read mode, with an optional time-out.</source>
          <target state="translated">Versucht, die Sperre im Lesemodus zu erhalten. Optional wird ein Timeout berücksichtigt.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered read mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aufrufende Thread den Lesemodus erhalten hat, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Wenn <ph id="ph1">`timeout`</ph> 0 (null) ist, wird diese Methode überprüft den Status der Sperre und gibt <ph id="ph2">`false`</ph> sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>Multiple threads can enter the lock in read mode at the same time.</source>
          <target state="translated">Mehrere Threads können die Sperre im Lesemodus gleichzeitig eingeben.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If one or more threads are queued to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Wenn eine oder mehrere Threads in der Warteschlange werden Schreibmodus, ein Thread, der aufruft, die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> Methode blockiert, bis diese Threads haben entweder ein Timeout oder im Schreibmodus befindet und dann daraus beendet oder das Timeoutintervall des aufrufenden Threads abläuft.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Lesemodus zugewiesen ist rekursiv, eingeben, auch wenn andere Threads Schreibmodus warten.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>One thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Ein Thread kann im erweiterbaren Modus befinden, während andere Threads im Lesemodus sind.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Wenn zusätzliche Threads auf den erweiterbaren Modus warten und es keine Threads werden Schreibmodus warten, auf diesen Aufruf threads die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> Methode Lesemodus sofort und nicht blockieren.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, und der aktuelle Thread hat die Sperre bereits erhalten.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> ist größer als <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> Millisekunden.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Objekt wurde verworfen.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Versucht, die Sperre im erweiterbaren Modus zu erhalten. Optional wird ein Timeout berücksichtigt.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>), um unbegrenzt zu warten.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Versucht, die Sperre im erweiterbaren Modus zu erhalten. Optional wird ein Timeout berücksichtigt.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered upgradeable mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aufrufende Thread den erweiterbaren Modus erhalten hat, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Wenn <ph id="ph1">`millisecondsTimeout`</ph> 0 (null) ist, wird diese Methode überprüft den Status der Sperre und gibt <ph id="ph2">`false`</ph> sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Erweiterbaren Modus verwenden, wenn ein Thread in der Regel auf die Ressource zugreift, die durch geschützt ist die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in im Lesemodus befindet, aber möglicherweise Schreibmodus, wenn bestimmte Bedingungen erfüllt sind.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</source>
          <target state="translated">Ein Thread im erweiterbaren Modus kann den Schreibmodus oder Lesemodus.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Only one thread can enter a lock in upgradeable mode at any given time.</source>
          <target state="translated">Nur ein Thread kann eine Sperre im erweiterbaren Modus zu einem bestimmten Zeitpunkt eingeben.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Wenn ein Thread im erweiterbaren Modus zugewiesen ist, und es keine Threads sind Schreibmodus warten, kann eine beliebige Anzahl von anderen Threads Lesemodus, eingeben, auch wenn Threads den erweiterbaren Modus warten.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Wenn eine oder mehrere Threads Schreibmodus warten, ein Thread, der aufruft, die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> Methode blockiert, bis diese Threads haben entweder ein Timeout oder im Schreibmodus befindet und dann daraus beendet oder das Timeoutintervall des aufrufenden Threads abläuft.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im erweiterbaren Modus zugewiesen ist rekursiv erweiterbaren Modus erhalten hat, eingeben, auch wenn andere Threads Schreibmodus warten.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, und der aktuelle Thread hat die Sperre bereits erhalten.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> ist negativ, aber ungleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), der den einzigen zulässigen negativen Wert darstellt.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Objekt wurde verworfen.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Das Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Versucht, die Sperre im erweiterbaren Modus zu erhalten. Optional wird ein Timeout berücksichtigt.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered upgradeable mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aufrufende Thread den erweiterbaren Modus erhalten hat, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Wenn <ph id="ph1">`timeout`</ph> 0 (null) ist, wird diese Methode überprüft den Status der Sperre und gibt <ph id="ph2">`false`</ph> sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Use upgradeable mode when a thread usually accesses the resource protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Erweiterbaren Modus verwenden, wenn ein Thread durch geschützten Ressource in der Regel greift auf die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in im Lesemodus befindet, aber möglicherweise Schreibmodus, wenn bestimmte Bedingungen erfüllt sind.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</source>
          <target state="translated">Ein Thread im erweiterbaren Modus kann den Schreibmodus oder Lesemodus.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Only one thread can enter a lock in upgradeable mode at any given time.</source>
          <target state="translated">Nur ein Thread kann eine Sperre im erweiterbaren Modus zu einem bestimmten Zeitpunkt eingeben.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Wenn ein Thread im erweiterbaren Modus zugewiesen ist, und es keine Threads sind Schreibmodus warten, kann eine beliebige Anzahl von anderen Threads Lesemodus, eingeben, auch wenn Threads den erweiterbaren Modus warten.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Wenn eine oder mehrere Threads Schreibmodus warten, ein Thread, der aufruft, die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> Methode blockiert, bis diese Threads haben entweder ein Timeout oder im Schreibmodus befindet und dann daraus beendet oder das Timeoutintervall des aufrufenden Threads abläuft.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im erweiterbaren Modus zugewiesen ist rekursiv erweiterbaren Modus erhalten hat, eingeben, auch wenn andere Threads Schreibmodus warten.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, und der aktuelle Thread hat die Sperre bereits erhalten.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> ist größer als <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> Millisekunden.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Objekt wurde verworfen.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Versucht, die Sperre im Schreibmodus zu erhalten. Optional wird ein Timeout berücksichtigt.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>), um unbegrenzt zu warten.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Versucht, die Sperre im Schreibmodus zu erhalten. Optional wird ein Timeout berücksichtigt.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered write mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aufrufende Thread den Schreibmodus erhalten hat, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Wenn <ph id="ph1">`millisecondsTimeout`</ph> 0 (null) ist, wird diese Methode überprüft den Status der Sperre und gibt <ph id="ph2">`false`</ph> sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</source>
          <target state="translated">Wenn andere Threads auf die Sperre im Lesemodus zugewiesen ist, ein Thread, der aufruft, die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> Methode blockiert, bis diese Threads Lesemodus beendet wurden oder bis das Timeoutintervall abgelaufen ist.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Während Threads blockiert sind Schreibmodus warten, blockieren weiteren Threads, die versuchen, den schreibgeschützten Modus oder im erweiterbaren Modus geben, bis alle Threads, die darauf warten, geben den Schreibmodus, entweder ein Timeout oder im Schreibmodus befindet und dann beendet.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Schreibmodus zugewiesen ist Schreibzugriff Modus rekursiv eingeben, auch wenn andere Threads Schreibmodus warten.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> Methode, um die Sperre im Schreibmodus mit einem Timeout. Die Methode, die im Beispiel gezeigte hinzugefügt synchronisierten Cache ein neues Schlüssel/Wert-Paar.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If the specified time-out interval elapses before the thread enters the lock, the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Wenn das angegebene Timeoutintervall abläuft, bevor der Thread die Sperre eintritt, gibt die Methode <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The method returns <ph id="ph1">`true`</ph> if the key/value pair is added.</source>
          <target state="translated">Gibt die Methode <ph id="ph1">`true`</ph> , wenn das Schlüssel/Wert-Paar hinzugefügt wird.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Wenn der Schlüssel bereits im Cache, die von der inneren Ausnahme <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> ist zulässig, um die Methode zu beenden.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits the lock.</source>
          <target state="translated">Ein <ph id="ph1">`finally`</ph> Block wird zum Ausführen der <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> -Methode, um sicherzustellen, dass der Aufrufer die Sperre beendet.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Dieser Code ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, und der aktuelle Thread hat die Sperre bereits erhalten.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</source>
          <target state="translated">Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> ist negativ, aber ungleich <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), der den einzigen zulässigen negativen Wert darstellt.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Objekt wurde verworfen.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Das Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Versucht, die Sperre im Schreibmodus zu erhalten. Optional wird ein Timeout berücksichtigt.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered write mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aufrufende Thread den Schreibmodus erhalten hat, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Wenn <ph id="ph1">`timeout`</ph> 0 (null) ist, wird diese Methode überprüft den Status der Sperre und gibt <ph id="ph2">`false`</ph> sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</source>
          <target state="translated">Wenn andere Threads auf die Sperre im Lesemodus zugewiesen ist, ein Thread, der aufruft, die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> Methode blockiert, bis diese Threads Lesemodus beendet wurden oder bis das Timeoutintervall abgelaufen ist.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Während Threads blockiert sind Schreibmodus warten, blockieren weiteren Threads, die versuchen, den schreibgeschützten Modus oder im erweiterbaren Modus geben, bis alle Threads, die darauf warten, geben den Schreibmodus, entweder ein Timeout oder im Schreibmodus befindet und dann beendet.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Schreibmodus zugewiesen ist Schreibzugriff Modus rekursiv eingeben, auch wenn andere Threads Schreibmodus warten.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, und der aktuelle Thread hat die Sperre bereits erhalten.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</source>
          <target state="translated">Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Der Wert von <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> ist größer als <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> Millisekunden.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>-Objekt wurde verworfen.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Gets the total number of threads that are waiting to enter the lock in read mode.</source>
          <target state="translated">Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung der Sperre im Lesemodus warten.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The total number of threads that are waiting to enter read mode.</source>
          <target state="translated">Die Gesamtzahl von Threads, die auf eine Zuweisung des Lesemodus warten.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Verwenden Sie diese Eigenschaft nur für Debuggen, profilerstellung und Protokollierungszwecken und nicht auf das Verhalten eines Algorithmus gesteuert.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Die Ergebnisse können ändern, sobald sie berechnet wurden.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A&gt;</ph> Eigenschaft, um ein Ereignisprotokolleintrag generiert, wenn die Anzahl der Threads, die darauf warten, Lesemodus, blockiert werden, einen Schwellenwert überschreitet.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</source>
          <target state="translated">Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung der Sperre im erweiterbaren Modus warten.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The total number of threads that are waiting to enter upgradeable mode.</source>
          <target state="translated">Die Gesamtzahl von Threads, die auf eine Zuweisung des erweiterbaren Modus warten.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Verwenden Sie diese Eigenschaft nur für Debuggen, profilerstellung und Protokollierungszwecken und nicht auf das Verhalten eines Algorithmus gesteuert.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Die Ergebnisse können ändern, sobald sie berechnet wurden.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A&gt;</ph> Eigenschaft, um ein Ereignisprotokolleintrag generiert, wenn die Anzahl der Threads, die blockiert sind, darauf warten, erweiterbaren Modus erhalten hat, geben einen Schwellenwert überschreitet.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Gets the total number of threads that are waiting to enter the lock in write mode.</source>
          <target state="translated">Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung der Sperre im Schreibmodus warten.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The total number of threads that are waiting to enter write mode.</source>
          <target state="translated">Die Gesamtzahl von Threads, die auf eine Zuweisung des Schreibmodus warten.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Verwenden Sie diese Eigenschaft nur für Debuggen, profilerstellung und Protokollierungszwecken und nicht auf das Verhalten eines Algorithmus gesteuert.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Die Ergebnisse können ändern, sobald sie berechnet wurden.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A&gt;</ph> Eigenschaft, um ein Ereignisprotokolleintrag generiert, wenn die Anzahl der Threads, die blockiert sind, darauf warten, im Schreibmodus befindet, geben einen Schwellenwert überschreitet.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>