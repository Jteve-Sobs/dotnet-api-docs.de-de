<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e120396dbb247c69f6f7ad04656d156a2cf57415" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83958041" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Core" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="bab50-101">Stellt eine Sperre dar, mit der der Zugriff auf eine Ressource verwaltet wird. Mehrere Threads können damit Lesezugriff oder exklusiven Schreibzugriff erhalten.</span><span class="sxs-lookup"><span data-stu-id="bab50-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-102">Verwenden Sie <xref:System.Threading.ReaderWriterLockSlim>, um eine Ressource zu schützen, die von mehreren Threads gelesen und jeweils von einem Thread geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="bab50-103"><xref:System.Threading.ReaderWriterLockSlim> das zulassen, dass sich mehrere Threads im Lesemodus befinden, kann sich ein Thread im Schreibmodus mit ausschließlicher Besitz der Sperre befinden und ermöglicht es einem Thread, der über Lesezugriff verfügt, im erweiterbaren Lesemodus zu sein, von dem aus der Thread auf den Schreibmodus aktualisiert werden kann, ohne dass der Lesezugriff auf die Ressource aufgegeben werden muss.</span><span class="sxs-lookup"><span data-stu-id="bab50-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-104"><xref:System.Threading.ReaderWriterLockSlim> ähnelt <xref:System.Threading.ReaderWriterLock>, verfügt aber über vereinfachte Regeln für Rekursion sowie für Upgrade und Downgrade des Sperrstatus.</span><span class="sxs-lookup"><span data-stu-id="bab50-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="bab50-105"><xref:System.Threading.ReaderWriterLockSlim> vermeidet viele potenzielle Deadlocks.</span><span class="sxs-lookup"><span data-stu-id="bab50-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="bab50-106">Darüber hinaus ist die Leistung von <xref:System.Threading.ReaderWriterLockSlim> wesentlich besser als die von <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="bab50-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="bab50-107"><xref:System.Threading.ReaderWriterLockSlim> wird für alle Neuentwicklungen empfohlen.</span><span class="sxs-lookup"><span data-stu-id="bab50-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="bab50-108">Standardmäßig werden neue Instanzen von <xref:System.Threading.ReaderWriterLockSlim> mit dem <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>-Flag erstellt und lassen keine Rekursion zu.</span><span class="sxs-lookup"><span data-stu-id="bab50-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="bab50-109">Diese Standard Richtlinie wird für alle neuen Entwicklungen empfohlen, da bei der Rekursion unnötige Komplikationen eingeführt werden und der Code anfälliger für Deadlocks wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="bab50-110">Um die Migration von vorhandenen Projekten zu vereinfachen, die <xref:System.Threading.Monitor> oder <xref:System.Threading.ReaderWriterLock>verwenden, können Sie das <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>-Flag verwenden, um Instanzen von <xref:System.Threading.ReaderWriterLockSlim> zu erstellen, die Rekursion zulassen.</span><span class="sxs-lookup"><span data-stu-id="bab50-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="bab50-111">Ein Thread kann die Sperre in drei Modi eingeben: Lesemodus, Schreibmodus und aktualisierbaren Lesemodus.</span><span class="sxs-lookup"><span data-stu-id="bab50-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="bab50-112">(Im weiteren Verlauf dieses Themas wird "erweiterbare Lesemodus" als "erweiterbaren Modus" bezeichnet, und der Ausdruck "Enter `x` Mode" wird im Gegensatz zum längeren Ausdruck "Sperre in `x` Modus eingeben" verwendet.)</span><span class="sxs-lookup"><span data-stu-id="bab50-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="bab50-113">Unabhängig von der Rekursions Richtlinie kann sich jeweils nur ein Thread im Schreibmodus befinden.</span><span class="sxs-lookup"><span data-stu-id="bab50-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="bab50-114">Wenn sich ein Thread im Schreibmodus befindet, kann kein anderer Thread die Sperre in einem beliebigen Modus eingeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="bab50-115">Nur ein Thread kann jederzeit im erweiterbaren Modus ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="bab50-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="bab50-116">Eine beliebige Anzahl von Threads kann sich im Lesemodus befinden, und es kann ein Thread im erweiterbaren Modus vorhanden sein, während sich andere Threads im Lesemodus befinden.</span><span class="sxs-lookup"><span data-stu-id="bab50-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="bab50-117">Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="bab50-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="bab50-118">Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen.</span><span class="sxs-lookup"><span data-stu-id="bab50-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="bab50-119">Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf.</span><span class="sxs-lookup"><span data-stu-id="bab50-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="bab50-120">Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bab50-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="bab50-121">Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.</span><span class="sxs-lookup"><span data-stu-id="bab50-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="bab50-122"><xref:System.Threading.ReaderWriterLockSlim> hat eine verwaltete Thread Affinität. Das heißt, dass jedes <xref:System.Threading.Thread> Objekt seine eigenen Methodenaufrufe ausführen muss, um Sperr Modi einzugeben und zu beenden.</span><span class="sxs-lookup"><span data-stu-id="bab50-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="bab50-123">Der Modus eines anderen Threads kann von keinem Thread geändert werden.</span><span class="sxs-lookup"><span data-stu-id="bab50-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="bab50-124">Wenn ein <xref:System.Threading.ReaderWriterLockSlim> keine Rekursion zulässt, kann ein Thread, der versucht, die Sperre einzugeben, aus verschiedenen Gründen blockieren:</span><span class="sxs-lookup"><span data-stu-id="bab50-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="bab50-125">Ein Thread, der versucht, in den Lesemodus zu wechseln, wenn Threads darauf warten, in den Schreibmodus zu wechseln, oder wenn ein einzelner Thread im Schreibmodus vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="bab50-126">Das Blockieren neuer Leser, wenn Writer in die Warteschlange eingereiht werden, ist eine Richtlinie für die Sperrung von Sperren</span><span class="sxs-lookup"><span data-stu-id="bab50-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="bab50-127">Die aktuelle Fairness-Richtlinie gleicht die Fairness von Lesern und Writern aus, um den Durchsatz in den gängigsten Szenarien zu fördern.</span><span class="sxs-lookup"><span data-stu-id="bab50-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="bab50-128">In zukünftigen Versionen der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] können neue Fairness-Richtlinien eingeführt werden.</span><span class="sxs-lookup"><span data-stu-id="bab50-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="bab50-129">Ein Thread, der versucht, den erweiterbaren Modus zu wechseln, wenn sich bereits ein Thread im erweiterbaren Modus befindet, wenn Threads darauf warten, in den Schreibmodus zu wechseln, oder wenn ein einzelner Thread im Schreibmodus vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="bab50-130">Ein Thread, der versucht, in den Schreibmodus zu wechseln, wenn ein Thread in einem der drei Modi vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="bab50-131">Aktualisieren und Herabstufen von Sperren</span><span class="sxs-lookup"><span data-stu-id="bab50-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="bab50-132">Der aktualisierbare Modus ist für Fälle vorgesehen, in denen ein Thread normalerweise aus der geschützten Ressource liest, aber möglicherweise in ihn schreiben muss, wenn eine bestimmte Bedingung erfüllt ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="bab50-133">Ein Thread, der einen <xref:System.Threading.ReaderWriterLockSlim> im erweiterbaren Modus eingegeben hat, verfügt über Lesezugriff auf die geschützte Ressource und kann durch Aufrufen der Methoden <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> oder <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> auf den Schreibmodus aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="bab50-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="bab50-134">Da es jeweils nur einen Thread im erweiterbaren Modus geben kann, kann ein Upgrade auf den Schreibmodus nicht durchgeführt werden, wenn die Rekursion nicht zulässig ist. Dies ist die Standard Richtlinie.</span><span class="sxs-lookup"><span data-stu-id="bab50-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="bab50-135">Unabhängig von der Rekursions Richtlinie ist ein Thread, der anfänglich in den Lesemodus wechselt, nicht berechtigt, auf den erweiterbaren Modus oder den Schreibmodus zu aktualisieren, da dieses Muster eine hohe Wahrscheinlichkeit von Deadlocks erzeugt.</span><span class="sxs-lookup"><span data-stu-id="bab50-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="bab50-136">Wenn z. b. zwei Threads im Lesemodus versuchen, in den Schreibmodus zu wechseln, wird ein Deadlock angezeigt.</span><span class="sxs-lookup"><span data-stu-id="bab50-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="bab50-137">Der aktualisierbare Modus ist so konzipiert, dass solche Deadlocks vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="bab50-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="bab50-138">Wenn andere Threads im Lesemodus vorhanden sind, wird der Thread, der die Blöcke aktualisiert, blockiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="bab50-139">Während der Thread blockiert wird, werden andere Threads, die versuchen, in den Lesemodus zu wechseln, blockiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="bab50-140">Wenn alle Threads vom Lesemodus beendet wurden, wechselt der blockierte aktualisierbare Thread in den Schreibmodus.</span><span class="sxs-lookup"><span data-stu-id="bab50-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="bab50-141">Wenn andere Threads auf den Schreibmodus warten, bleiben Sie blockiert, da der einzige Thread, der sich im erweiterbaren Modus befindet, verhindert, dass Sie exklusiven Zugriff auf die Ressource erlangen.</span><span class="sxs-lookup"><span data-stu-id="bab50-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="bab50-142">Wenn der Thread im erweiterbaren Modus den Schreibmodus beendet, können andere Threads, die auf die Eingabe des Lesemodus warten, dies tun, es sei denn, es sind Threads vorhanden, die auf den Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="bab50-143">Der Thread im erweiterbaren Modus kann auf unbestimmte Zeit aktualisiert und herabgestuft werden, solange er der einzige Thread ist, der in die geschützte Ressource schreibt.</span><span class="sxs-lookup"><span data-stu-id="bab50-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="bab50-144">Wenn Sie zulassen, dass mehrere Threads in den Schreibmodus oder den erweiterbaren Modus wechseln, dürfen Sie nicht zulassen, dass ein Thread den aktualisierbaren Modus monopolisiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="bab50-145">Andernfalls können Threads, die versuchen, direkt in den Schreibmodus zu wechseln, unbegrenzt blockiert werden. während Sie blockiert werden, können andere Threads nicht in den Lesemodus wechseln.</span><span class="sxs-lookup"><span data-stu-id="bab50-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="bab50-146">Ein Thread im erweiterbaren Modus kann in den Lesemodus herabgestuft werden, indem zuerst die <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>-Methode aufgerufen und dann die <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="bab50-147">Dieses Downgrade-Muster ist für alle Sperr Rekursions Richtlinien zulässig, auch <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span><span class="sxs-lookup"><span data-stu-id="bab50-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="bab50-148">Nach dem Downgrade in den Lesemodus kann ein Thread den erweiterbaren Modus erst wieder eingeben, wenn er vom Lesemodus beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="bab50-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="bab50-149">Rekursiv Eingabe der Sperre</span><span class="sxs-lookup"><span data-stu-id="bab50-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="bab50-150">Sie können einen <xref:System.Threading.ReaderWriterLockSlim> erstellen, der einen rekursiven Sperr Eintrag unterstützt, indem Sie den <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29>-Konstruktor verwenden, der Sperr Richtlinien angibt, und <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>angeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-151">Die Verwendung von Rekursion ist für die neue Entwicklung nicht empfehlenswert, da dadurch unnötige Komplikationen eingeführt werden und der Code anfälliger für Deadlocks wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="bab50-152">Für eine <xref:System.Threading.ReaderWriterLockSlim>, die Rekursion zulässt, kann Folgendes über die Modi, die ein Thread eingegeben werden kann, aufgeführt werden:</span><span class="sxs-lookup"><span data-stu-id="bab50-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="bab50-153">Ein Thread im Lesemodus kann rekursiv in den Lesemodus wechseln, kann jedoch nicht in den Schreibmodus oder den erweiterbaren Modus wechseln.</span><span class="sxs-lookup"><span data-stu-id="bab50-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="bab50-154">Wenn Sie versucht, dies zu tun, wird eine <xref:System.Threading.LockRecursionException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="bab50-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="bab50-155">Wenn Sie in den Lesemodus wechseln und dann in den Schreibmodus oder den erweiterbaren Modus wechseln, handelt es sich um ein Muster mit einer starken Wahrscheinlichkeit von Deadlocks, sodass es nicht zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="bab50-156">Wie bereits erwähnt, wird der erweiterbare Modus für Fälle bereitgestellt, in denen es erforderlich ist, eine Sperre zu aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="bab50-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="bab50-157">Ein Thread im erweiterbaren Modus kann in den Schreibmodus und/oder den Lesemodus wechseln und jeden der drei Modi rekursiv eingeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="bab50-158">Der Versuch, in den Schreibmodus einzutreten, blockiert jedoch, wenn andere Threads im Lesemodus vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="bab50-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="bab50-159">Ein Thread im Schreibmodus kann in den Lesemodus und/oder den aktualisierbaren Modus wechseln und jeden der drei Modi rekursiv eingeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="bab50-160">Ein Thread, der nicht die Sperre eingegeben hat, kann einen beliebigen Modus eingeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="bab50-161">Dieser Versuch kann aus denselben Gründen blockiert werden, wenn versucht wird, eine nicht rekursive Sperre einzugeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="bab50-162">Ein Thread kann die Modi beenden, die er in beliebiger Reihenfolge eingegeben hat, solange er jeden Modus genau so oft verlässt, wie er in diesen Modus wechselt.</span><span class="sxs-lookup"><span data-stu-id="bab50-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="bab50-163">Wenn ein Thread versucht, den Modus zu häufig zu beenden oder einen Modus zu beenden, der nicht eingegeben wurde, wird eine <xref:System.Threading.SynchronizationLockException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="bab50-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="bab50-164">Sperr Zustände</span><span class="sxs-lookup"><span data-stu-id="bab50-164">Lock States</span></span>  
 <span data-ttu-id="bab50-165">Möglicherweise ist es hilfreich, sich die Sperre in Bezug auf ihre Zustände vorzustellen.</span><span class="sxs-lookup"><span data-stu-id="bab50-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="bab50-166">Eine <xref:System.Threading.ReaderWriterLockSlim> kann einen von vier Zuständen aufweisen: nicht eingegeben, lesen, aktualisieren und schreiben.</span><span class="sxs-lookup"><span data-stu-id="bab50-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="bab50-167">Nicht eingegeben: in diesem Zustand haben keine Threads die Sperre eingegeben (oder alle Threads haben die Sperre verlassen).</span><span class="sxs-lookup"><span data-stu-id="bab50-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="bab50-168">Read: in diesem Zustand hat mindestens ein Thread die Sperre für den Lesezugriff auf die geschützte Ressource erreicht.</span><span class="sxs-lookup"><span data-stu-id="bab50-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="bab50-169">Ein Thread kann die Sperre im Lesemodus mithilfe der Methoden <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> oder <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> oder durch Herabstufen des erweiterbaren Modus eingeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="bab50-170">Upgrade: in diesem Zustand hat ein Thread die Sperre für den Lesezugriff mit der Option zum Aktualisieren auf Schreibzugriff (d. h. im erweiterbaren Modus) und NULL oder mehr Threads in die Sperre für den Lesezugriff eingegeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="bab50-171">Es kann nicht mehr als ein Thread gleichzeitig die Sperre mit der Option zum Aktualisieren eingeben. zusätzliche Threads, die versuchen, den erweiterbaren Modus einzugeben, werden blockiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="bab50-172">Write: in diesem Zustand hat ein Thread die Sperre für Schreibzugriff auf die geschützte Ressource eingegeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="bab50-173">Dieser Thread besitzt exklusiven Besitz der Sperre.</span><span class="sxs-lookup"><span data-stu-id="bab50-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="bab50-174">Jeder andere Thread, der versucht, die Sperre aus irgendeinem Grund einzugeben, wird blockiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="bab50-175">In der folgenden Tabelle werden die Übergänge zwischen Sperr Zuständen für Sperren beschrieben, die keine Rekursion zulassen, wenn ein Thread `t` die in der Spalte ganz links beschriebene Aktion übernimmt.</span><span class="sxs-lookup"><span data-stu-id="bab50-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="bab50-176">Zu dem Zeitpunkt, an dem die Aktion ausgeführt wird, hat `t` keinen Modus.</span><span class="sxs-lookup"><span data-stu-id="bab50-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="bab50-177">(Der Sonderfall, in dem sich `t` im erweiterbaren Modus befindet, wird in den Tabellen Fußnoten beschrieben.) Die obere Zeile beschreibt den Anfangszustand der Sperre.</span><span class="sxs-lookup"><span data-stu-id="bab50-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="bab50-178">Die Zellen beschreiben, was mit dem Thread geschieht, und zeigen Änderungen am Sperr Zustand in Klammern an.</span><span class="sxs-lookup"><span data-stu-id="bab50-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="bab50-179">Nicht eingegeben (N)</span><span class="sxs-lookup"><span data-stu-id="bab50-179">Not entered (N)</span></span>|<span data-ttu-id="bab50-180">Lesen (Read, R)</span><span class="sxs-lookup"><span data-stu-id="bab50-180">Read (R)</span></span>|<span data-ttu-id="bab50-181">Upgrade (U)</span><span class="sxs-lookup"><span data-stu-id="bab50-181">Upgrade (U)</span></span>|<span data-ttu-id="bab50-182">Schreiben (Write, W)</span><span class="sxs-lookup"><span data-stu-id="bab50-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="bab50-183">`t` in den Lesemodus</span><span class="sxs-lookup"><span data-stu-id="bab50-183">`t` enters read mode</span></span>|<span data-ttu-id="bab50-184">`t` in den Einzug (R).</span><span class="sxs-lookup"><span data-stu-id="bab50-184">`t` enters (R).</span></span>|<span data-ttu-id="bab50-185">`t` blockiert, wenn Threads auf den Schreibmodus warten. Andernfalls `t` in den Einzug.</span><span class="sxs-lookup"><span data-stu-id="bab50-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="bab50-186">`t` blockiert, wenn Threads auf den Schreibmodus warten. Andernfalls `t` in den Einzug. <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="bab50-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="bab50-187">`t` Blöcke.</span><span class="sxs-lookup"><span data-stu-id="bab50-187">`t` blocks.</span></span>|  
|<span data-ttu-id="bab50-188">`t` wechselt in den upgradefähigen Modus.</span><span class="sxs-lookup"><span data-stu-id="bab50-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="bab50-189">`t` Enter (U).</span><span class="sxs-lookup"><span data-stu-id="bab50-189">`t` enters (U).</span></span>|<span data-ttu-id="bab50-190">`t` blockiert, wenn Threads auf den Schreibmodus oder den Upgrademodus warten. Andernfalls `t` in den Einzug (U).</span><span class="sxs-lookup"><span data-stu-id="bab50-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="bab50-191">`t` Blöcke.</span><span class="sxs-lookup"><span data-stu-id="bab50-191">`t` blocks.</span></span>|<span data-ttu-id="bab50-192">`t` Blöcke.</span><span class="sxs-lookup"><span data-stu-id="bab50-192">`t` blocks.</span></span>|  
|<span data-ttu-id="bab50-193">`t` in den Schreibmodus</span><span class="sxs-lookup"><span data-stu-id="bab50-193">`t` enters write mode</span></span>|<span data-ttu-id="bab50-194">`t` in den Einzug (W).</span><span class="sxs-lookup"><span data-stu-id="bab50-194">`t` enters (W).</span></span>|<span data-ttu-id="bab50-195">`t` Blöcke.</span><span class="sxs-lookup"><span data-stu-id="bab50-195">`t` blocks.</span></span>|<span data-ttu-id="bab50-196">`t` Blöcke. <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="bab50-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="bab50-197">`t` Blöcke.</span><span class="sxs-lookup"><span data-stu-id="bab50-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="bab50-198"><sup>1</sup> wenn `t` im erweiterbaren Modus gestartet wird, wechselt er in den Lesemodus.</span><span class="sxs-lookup"><span data-stu-id="bab50-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="bab50-199">Diese Aktion blockiert nie.</span><span class="sxs-lookup"><span data-stu-id="bab50-199">This action never blocks.</span></span> <span data-ttu-id="bab50-200">Der Sperr Zustand ändert sich nicht.</span><span class="sxs-lookup"><span data-stu-id="bab50-200">The lock state does not change.</span></span> <span data-ttu-id="bab50-201">(Der Thread kann dann einen Downgrade in den Lesemodus vervollständigen, indem er den aktualisierbaren Modus verlässt.)</span><span class="sxs-lookup"><span data-stu-id="bab50-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="bab50-202"><sup>2</sup> wenn `t` im erweiterbaren Modus gestartet wird, wird blockiert, wenn Threads im Lesemodus vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="bab50-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="bab50-203">Andernfalls wird ein Upgrade auf den Schreibmodus ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="bab50-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="bab50-204">Der Sperr Status ändert sich in Write (W).</span><span class="sxs-lookup"><span data-stu-id="bab50-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="bab50-205">Wenn `t` blockiert, weil Threads im Lesemodus vorhanden sind, wird der Schreibmodus in den Schreibmodus eingefügt, sobald der letzte Thread den Lesemodus beendet, auch wenn Threads vorhanden sind, die auf den Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="bab50-206">Wenn eine Zustandsänderung auftritt, weil ein Thread die Sperre beendet, wird der nächste zu erwachende Thread wie folgt ausgewählt:</span><span class="sxs-lookup"><span data-stu-id="bab50-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="bab50-207">Zuerst ein Thread, der auf den Schreibmodus wartet und sich bereits im erweiterbaren Modus befindet (es kann höchstens ein solcher Thread vorhanden sein).</span><span class="sxs-lookup"><span data-stu-id="bab50-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="bab50-208">Ein Fehler, ein Thread, der auf den Schreibmodus wartet.</span><span class="sxs-lookup"><span data-stu-id="bab50-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="bab50-209">Wenn ein Fehler auftritt, ein Thread, der auf den erweiterbaren Modus wartet.</span><span class="sxs-lookup"><span data-stu-id="bab50-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="bab50-210">Wenn ein Fehler aufgetreten ist, alle Threads, die auf den Lesemodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="bab50-211">Der nachfolgende Status der Sperre lautet in den ersten beiden Fällen immer Write (W) und das Upgrade (U) im dritten Fall, unabhängig vom Status der Sperre, wenn der Ende Thread die Zustandsänderung ausgelöst hat.</span><span class="sxs-lookup"><span data-stu-id="bab50-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="bab50-212">Im letzten Fall lautet der Status der Sperre Upgrade (U), wenn sich nach der Zustandsänderung ein Thread im erweiterbaren Modus befindet, und andernfalls der Lesevorgang (R), unabhängig vom vorherigen Zustand.</span><span class="sxs-lookup"><span data-stu-id="bab50-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-213">Das folgende Beispiel zeigt einen einfachen synchronisierten Cache, der Zeichen folgen mit ganzzahligen Schlüsseln enthält.</span><span class="sxs-lookup"><span data-stu-id="bab50-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="bab50-214">Eine Instanz von <xref:System.Threading.ReaderWriterLockSlim> wird zum Synchronisieren des Zugriffs auf die <xref:System.Collections.Generic.Dictionary%602> verwendet, die als innerer Cache fungiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="bab50-215">Das Beispiel enthält einfache Methoden, die dem Cache hinzugefügt, aus dem Cache gelöscht und aus dem Cache gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="bab50-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="bab50-216">Um Timeouts zu veranschaulichen, enthält das Beispiel eine-Methode, die nur dann dem Cache hinzugefügt wird, wenn dies innerhalb eines angegebenen Timeouts möglich ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="bab50-217">Um den erweiterbaren Modus zu veranschaulichen, enthält das Beispiel eine Methode, die den einem Schlüssel zugeordneten Wert abruft und ihn mit einem neuen Wert vergleicht.</span><span class="sxs-lookup"><span data-stu-id="bab50-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="bab50-218">Wenn der Wert unverändert ist, gibt die Methode einen Status zurück, der angibt, dass keine Änderungen vorgenommen wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="bab50-219">Wenn kein Wert für den Schlüssel gefunden wird, wird das Schlüssel-Wert-Paar eingefügt.</span><span class="sxs-lookup"><span data-stu-id="bab50-219">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="bab50-220">Wenn der Wert geändert wurde, wird er aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="bab50-221">Der aktualisierbare Modus ermöglicht es dem Thread, bei Bedarf von Lesezugriff auf Schreibzugriff zu aktualisieren, ohne dass Deadlocks gefährdet sind.</span><span class="sxs-lookup"><span data-stu-id="bab50-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="bab50-222">Das Beispiel enthält eine geschaltete Enumeration, die die Rückgabewerte für die Methode angibt, die den aktualisierbaren Modus veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="bab50-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="bab50-223">Im Beispiel wird der Parameter lose Konstruktor verwendet, um die Sperre zu erstellen, sodass Rekursion nicht zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-223">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="bab50-224">Das Programmieren der <xref:System.Threading.ReaderWriterLockSlim> ist einfacher und weniger fehleranfällig, wenn die Sperre keine Rekursion zulässt.</span><span class="sxs-lookup"><span data-stu-id="bab50-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="bab50-225">Im folgenden Code wird dann das `SynchronizedCache`-Objekt verwendet, um ein Wörterbuch mit den Namen von Pflanzen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="bab50-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="bab50-226">Es werden drei Aufgaben erstellt.</span><span class="sxs-lookup"><span data-stu-id="bab50-226">It creates three tasks.</span></span> <span data-ttu-id="bab50-227">Der erste schreibt die in einem Array gespeicherten Namen von Gemüse in eine `SynchronizedCache`-Instanz.</span><span class="sxs-lookup"><span data-stu-id="bab50-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="bab50-228">In der zweiten und dritten Aufgabe werden die Namen des Gemüses angezeigt, der erste in aufsteigender Reihenfolge (von niedrigem Index bis zu hohem Index), der zweite in absteigender Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="bab50-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="bab50-229">Die letzte Aufgabe sucht nach der Zeichenfolge "gurber" und ruft, wenn Sie gefunden wird, die <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>-Methode auf, um die Zeichenfolge "grünes Bean" zu ersetzen.</span><span class="sxs-lookup"><span data-stu-id="bab50-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="bab50-230">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="bab50-230">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bab50-231">Initialisiert eine neue Instanz der Klasse <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span><span class="sxs-lookup"><span data-stu-id="bab50-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bab50-232">Initialisiert eine neue Instanz der <see cref="T:System.Threading.ReaderWriterLockSlim" />-Klasse mit Standardeigenschaftswerten.</span><span class="sxs-lookup"><span data-stu-id="bab50-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-233">Eine <xref:System.Threading.ReaderWriterLockSlim>, die mit diesem Konstruktor initialisiert wird, lässt keine Rekursion zu.</span><span class="sxs-lookup"><span data-stu-id="bab50-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="bab50-234">Das bedeutet, dass die <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A>-Eigenschaft <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="bab50-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bab50-235">Weitere Informationen zu Rekursions Richtlinien und deren Auswirkungen finden Sie in der <xref:System.Threading.LockRecursionPolicy>-Enumeration und der <xref:System.Threading.ReaderWriterLockSlim>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="bab50-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-236">Das folgende Beispiel zeigt einen einfachen synchronisierten Cache, der Zeichen folgen mit ganzzahligen Schlüsseln enthält.</span><span class="sxs-lookup"><span data-stu-id="bab50-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="bab50-237">Eine Instanz von <xref:System.Threading.ReaderWriterLockSlim> wird zum Synchronisieren des Zugriffs auf die <xref:System.Collections.Generic.Dictionary%602> verwendet, die als innerer Cache fungiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="bab50-238">Der Parameter lose Konstruktor wird verwendet, um die Sperre zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="bab50-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="bab50-239">Das Beispiel enthält einfache Methoden, die dem Cache hinzugefügt, aus dem Cache gelöscht und aus dem Cache gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="bab50-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="bab50-240">Um Timeouts zu veranschaulichen, enthält das Beispiel eine-Methode, die nur dann dem Cache hinzugefügt wird, wenn dies innerhalb eines angegebenen Timeouts möglich ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="bab50-241">Um den erweiterbaren Modus zu veranschaulichen, enthält das Beispiel eine Methode, die den einem Schlüssel zugeordneten Wert abruft und ihn mit einem neuen Wert vergleicht.</span><span class="sxs-lookup"><span data-stu-id="bab50-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="bab50-242">Wenn der Wert unverändert ist, gibt die Methode einen Status zurück, der angibt, dass keine Änderungen vorgenommen wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="bab50-243">Wenn kein Wert für den Schlüssel gefunden wird, wird das Schlüssel-Wert-Paar eingefügt.</span><span class="sxs-lookup"><span data-stu-id="bab50-243">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="bab50-244">Wenn der Wert geändert wurde, wird er aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="bab50-245">Der aktualisierbare Modus ermöglicht es dem Thread, bei Bedarf von Lesezugriff auf Schreibzugriff zu aktualisieren, ohne dass Deadlocks gefährdet sind.</span><span class="sxs-lookup"><span data-stu-id="bab50-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="bab50-246">Das Beispiel enthält eine geschaltete Enumeration, die die Rückgabewerte für die Methode angibt, die den aktualisierbaren Modus veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="bab50-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="bab50-247">Im Beispiel wird der Parameter lose Konstruktor verwendet, um die Sperre zu erstellen, sodass Rekursion nicht zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-247">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="bab50-248">Das Programmieren der <xref:System.Threading.ReaderWriterLockSlim> ist einfacher und weniger fehleranfällig, wenn die Sperre keine Rekursion zulässt.</span><span class="sxs-lookup"><span data-stu-id="bab50-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="bab50-249">Im folgenden Code wird dann das `SynchronizedCache`-Objekt verwendet, um ein Wörterbuch mit den Namen von Pflanzen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="bab50-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="bab50-250">Es werden drei Aufgaben erstellt.</span><span class="sxs-lookup"><span data-stu-id="bab50-250">It creates three tasks.</span></span> <span data-ttu-id="bab50-251">Der erste schreibt die in einem Array gespeicherten Namen von Gemüse in eine `SynchronizedCache`-Instanz.</span><span class="sxs-lookup"><span data-stu-id="bab50-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="bab50-252">In der zweiten und dritten Aufgabe werden die Namen des Gemüses angezeigt, der erste in aufsteigender Reihenfolge (von niedrigem Index bis zu hohem Index), der zweite in absteigender Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="bab50-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="bab50-253">Die letzte Aufgabe sucht nach der Zeichenfolge "gurber" und ruft, wenn Sie gefunden wird, die <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>-Methode auf, um die Zeichenfolge "grünes Bean" zu ersetzen.</span><span class="sxs-lookup"><span data-stu-id="bab50-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy"><span data-ttu-id="bab50-254">Einer der Enumerationswerte, der die Rekursionsrichtlinie für die Sperre angibt.</span><span class="sxs-lookup"><span data-stu-id="bab50-254">One of the enumeration values that specifies the lock recursion policy.</span></span></param>
        <summary><span data-ttu-id="bab50-255">Initialisiert eine neue Instanz der <see cref="T:System.Threading.ReaderWriterLockSlim" />-Klasse unter Angabe der Rekursionsrichtlinie für die Sperre.</span><span class="sxs-lookup"><span data-stu-id="bab50-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-256">Mit der Rekursions Richtlinie werden die Einschränkungen für Threads festgelegt, die die Sperre mehrmals eingeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="bab50-257">Wenn z. b. eine Sperre mit <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> erstellt wurde und ein Thread die Sperre im Lesemodus erreicht hat, wird <xref:System.Threading.LockRecursionException> ausgelöst, wenn der Thread versucht, die Sperre erneut in den Lesemodus einzugeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="bab50-258">Wenn ein Thread die Sperre im Schreibmodus erreicht hat, wird auch <xref:System.Threading.LockRecursionException> ausgelöst, wenn der Thread versucht, die Sperre in einem beliebigen Modus erneut einzugeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-259">Ein Thread im erweiterbaren Modus kann unabhängig von der Richtlinien Einstellung für die sperrrekursion auf den Schreibmodus oder das Downgrade in den Lesemodus aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="bab50-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="bab50-260">Unabhängig von der Rekursions Richtlinie ist ein Thread, der anfänglich in den Lesemodus wechselt, nicht berechtigt, auf den erweiterbaren Modus oder den Schreibmodus zu aktualisieren, da dieses Muster eine hohe Wahrscheinlichkeit von Deadlocks erzeugt.</span><span class="sxs-lookup"><span data-stu-id="bab50-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="bab50-261">Weitere Informationen zu Rekursions Richtlinien und deren Auswirkungen finden Sie in der <xref:System.Threading.LockRecursionPolicy>-Enumeration und der <xref:System.Threading.ReaderWriterLockSlim>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="bab50-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-262">Das folgende Beispiel zeigt zwei Ausnahme Szenarios, eine, die von der <xref:System.Threading.LockRecursionPolicy> Einstellung abhängt, und eine, die nicht ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="bab50-263">Im ersten Szenario wechselt der Thread in den Lesemodus und versucht dann rekursiv in den Lesemodus zu wechseln.</span><span class="sxs-lookup"><span data-stu-id="bab50-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="bab50-264">Wenn die <xref:System.Threading.ReaderWriterLockSlim> mit dem Parameter losen Konstruktor erstellt wird, mit dem die Rekursions Richtlinie auf <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>festgelegt wird, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="bab50-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the parameterless constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="bab50-265">Wenn <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> zum Erstellen des <xref:System.Threading.ReaderWriterLockSlim>verwendet wird, wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="bab50-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="bab50-266">Im zweiten Szenario wechselt der Thread in den Lesemodus und versucht dann, in den Schreibmodus zu wechseln.</span><span class="sxs-lookup"><span data-stu-id="bab50-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="bab50-267"><xref:System.Threading.LockRecursionException> wird unabhängig von der sperrrekursions Richtlinie ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="bab50-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="bab50-268">Im folgenden Code wird dann das `SynchronizedCache`-Objekt verwendet, um ein Wörterbuch mit den Namen von Pflanzen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="bab50-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="bab50-269">Es werden drei Aufgaben erstellt.</span><span class="sxs-lookup"><span data-stu-id="bab50-269">It creates three tasks.</span></span> <span data-ttu-id="bab50-270">Der erste schreibt die in einem Array gespeicherten Namen von Gemüse in eine `SynchronizedCache`-Instanz.</span><span class="sxs-lookup"><span data-stu-id="bab50-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="bab50-271">In der zweiten und dritten Aufgabe werden die Namen des Gemüses angezeigt, der erste in aufsteigender Reihenfolge (von niedrigem Index bis zu hohem Index), der zweite in absteigender Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="bab50-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="bab50-272">Die letzte Aufgabe sucht nach der Zeichenfolge "gurber" und ruft, wenn Sie gefunden wird, die <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>-Methode auf, um die Zeichenfolge "grünes Bean" zu ersetzen.</span><span class="sxs-lookup"><span data-stu-id="bab50-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bab50-273">Ruft die Gesamtzahl von eindeutigen Threads ab, denen die Sperre im Lesemodus zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-273">Gets the total number of unique threads that have entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="bab50-274">Die Anzahl von eindeutigen Threads, denen die Sperre im Lesemodus zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-274">The number of unique threads that have entered the lock in read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-275">Ein Thread wird nur einmal gezählt, auch wenn die Sperre eine Rekursion zulässt und der Thread mehrmals in den Lesemodus wechselt.</span><span class="sxs-lookup"><span data-stu-id="bab50-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="bab50-276">Verwenden Sie diese Eigenschaft nur für Debuggen, Profilerstellung und Protokollierung und nicht zum Steuern des Verhaltens eines Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="bab50-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="bab50-277">Die Ergebnisse können sich ändern, sobald Sie berechnet wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="bab50-278">Daher ist es nicht sicher, Entscheidungen basierend auf dieser Eigenschaft zu treffen.</span><span class="sxs-lookup"><span data-stu-id="bab50-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-279">Im folgenden Beispiel wird gezeigt, wie die <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A>-Eigenschaft verwendet wird, um einen Ereignisprotokoll Eintrag zu generieren, wenn die Anzahl der Threads im Lesemodus einen Schwellenwert überschreitet.</span><span class="sxs-lookup"><span data-stu-id="bab50-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bab50-280">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.ReaderWriterLockSlim" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="bab50-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-281">Rufen Sie <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> auf, wenn Sie <xref:System.Threading.ReaderWriterLockSlim> nicht mehr benötigen.</span><span class="sxs-lookup"><span data-stu-id="bab50-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="bab50-282">Die <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>-Methode bewirkt, dass <xref:System.Threading.ReaderWriterLockSlim> nicht mehr verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="bab50-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="bab50-283">Nachdem Sie <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>aufgerufen haben, müssen Sie alle Verweise auf die <xref:System.Threading.ReaderWriterLockSlim> freigeben, damit der Garbage Collector den Speicher freigeben kann, den der <xref:System.Threading.ReaderWriterLockSlim> belegt hat.</span><span class="sxs-lookup"><span data-stu-id="bab50-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="bab50-284">Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged) und [Implementieren einer](/dotnet/standard/garbage-collection/implementing-dispose)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="bab50-284">For more information, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged) and [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-285">Immer <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> aufgerufen, bevor Sie den letzten Verweis auf das <xref:System.Threading.ReaderWriterLockSlim>-Objekt freigeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="bab50-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> ist größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="bab50-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="bab50-287">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-287">-or-</span></span> 
 <span data-ttu-id="bab50-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> ist größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="bab50-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="bab50-289">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-289">-or-</span></span> 
 <span data-ttu-id="bab50-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> ist größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="bab50-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bab50-291">Versucht, die Sperre im Lesemodus zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="bab50-291">Tries to enter the lock in read mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-292">Diese Methode wird blockiert, bis der aufrufende Thread in die Sperre eintritt und daher möglicherweise nie zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="bab50-292">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="bab50-293">Verwenden Sie die <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>-Methode, um ein bestimmtes Intervall zu blockieren, und geben Sie dann zurück, wenn der aufrufenden Thread während dieses Intervalls nicht in den Lesemodus wechselt.</span><span class="sxs-lookup"><span data-stu-id="bab50-293">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="bab50-294">Mehrere Threads können gleichzeitig in den Lesemodus wechseln.</span><span class="sxs-lookup"><span data-stu-id="bab50-294">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="bab50-295">Wenn ein oder mehrere Threads auf den Schreibmodus warten, wird ein Thread, der die <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>-Methode aufruft, blockiert, bis für diese Threads ein Timeout aufgetreten ist oder der Schreibmodus gestartet und anschließend beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="bab50-295">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-296">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread, der die Sperre im Lesemodus eingegeben hat, rekursiv in den Lesemodus wechseln, auch wenn andere Threads auf den Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-296">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="bab50-297">Der aktualisierbare Modus kann höchstens einen Thread aufweisen, während sich andere Threads im Lesemodus befinden.</span><span class="sxs-lookup"><span data-stu-id="bab50-297">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="bab50-298">Wenn zusätzliche Threads auf den erweiterbaren Modus warten und keine Threads auf den Schreibmodus warten, werden die Threads, die die <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>-Methode aufzurufen, sofort in den Lesemodus wechseln und dürfen nicht blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="bab50-298">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-299">Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>-Methode verwenden, um die Sperre im Lesemodus zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="bab50-299">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="bab50-300">Die im Beispiel gezeigte-Methode ruft den Wert ab, der einem Schlüssel zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-300">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="bab50-301">Wenn der Schlüssel nicht gefunden wird, wird die von der inneren <xref:System.Collections.Generic.Dictionary%602> ausgelöste Ausnahme zugelassen, um die Methode zu beenden.</span><span class="sxs-lookup"><span data-stu-id="bab50-301">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="bab50-302">Ein `finally`-Block wird verwendet, um die <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>-Methode auszuführen und sicherzustellen, dass der Aufrufer den Lesemodus beendet.</span><span class="sxs-lookup"><span data-stu-id="bab50-302">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="bab50-303">Dieser Code ist Teil eines größeren Beispiels, das für die <xref:System.Threading.ReaderWriterLockSlim>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-303">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="bab50-304">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist gleich <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat versucht, die Lesesperre zu erlangen, obwohl er die Lesesperre bereits besitzt.</span><span class="sxs-lookup"><span data-stu-id="bab50-304">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span></span>  
  
<span data-ttu-id="bab50-305">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-305">-or-</span></span> 
<span data-ttu-id="bab50-306">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist gleich <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat versucht, die Lesesperre zu erlangen, obwohl er die Schreibsperre bereits besitzt.</span><span class="sxs-lookup"><span data-stu-id="bab50-306">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span></span>  
  
<span data-ttu-id="bab50-307">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-307">-or-</span></span> 
<span data-ttu-id="bab50-308">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</span><span class="sxs-lookup"><span data-stu-id="bab50-308">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="bab50-309">Dieser Grenzwert ist so groß, dass diese Ausnahme nie für Anwendungen auftreten sollte.</span><span class="sxs-lookup"><span data-stu-id="bab50-309">This limit is so large that applications should never encounter this exception.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bab50-310">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="bab50-310">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bab50-311">Versucht, die Sperre im erweiterbaren Modus zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="bab50-311">Tries to enter the lock in upgradeable mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-312">Diese Methode wird blockiert, bis der aufrufende Thread in die Sperre eintritt und daher möglicherweise nie zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="bab50-312">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="bab50-313">Verwenden Sie die <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>-Methode, um ein bestimmtes Intervall zu blockieren, und geben Sie dann zurück, wenn der aufrufenden Thread während dieses Intervalls nicht in den erweiterbaren-Modus gewechselt ist</span><span class="sxs-lookup"><span data-stu-id="bab50-313">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="bab50-314">Verwenden Sie den erweiterbaren Modus, wenn ein Thread in der Regel auf die Ressource zugreift, die durch die <xref:System.Threading.ReaderWriterLockSlim> im Lesemodus geschützt ist, aber möglicherweise in den Schreibmodus wechseln muss, wenn bestimmte Bedingungen erfüllt sind.</span><span class="sxs-lookup"><span data-stu-id="bab50-314">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="bab50-315">Ein Thread im erweiterbaren Modus kann auf den Lesemodus Herabstufen oder auf den Schreibmodus aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="bab50-315">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="bab50-316">Nur ein einziger Thread kann zu einem beliebigen Zeitpunkt in den erweiterbaren Modus wechseln.</span><span class="sxs-lookup"><span data-stu-id="bab50-316">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="bab50-317">Wenn sich ein Thread im erweiterbaren Modus befindet und keine Threads auf den Schreibmodus warten, kann eine beliebige Anzahl anderer Threads in den Lesemodus wechseln, auch wenn Threads vorhanden sind, die auf die Eingabe des erweiterbaren Modus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-317">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="bab50-318">Wenn ein oder mehrere Threads auf den Schreibmodus warten, wird ein Thread, der die <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>-Methode aufruft, blockiert, bis für diese Threads ein Timeout aufgetreten ist oder der Schreibmodus gestartet und anschließend beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="bab50-318">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-319">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread, der die Sperre im erweiterbaren Modus eingegeben hat, rekursiv in den aktualisierbaren Modus wechseln, auch wenn andere Threads auf den Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-319">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-320">Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>-Methode verwenden, um die Sperre im erweiterbaren Modus einzugeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-320">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="bab50-321">Ein `finally`-Block wird verwendet, um die <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>-Methode auszuführen und sicherzustellen, dass der Aufrufer den erweiterbaren Modus verlässt.</span><span class="sxs-lookup"><span data-stu-id="bab50-321">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="bab50-322">Die im Beispiel gezeigte-Methode ruft den Wert ab, der einem Schlüssel zugeordnet ist, und vergleicht ihn mit einem neuen Wert.</span><span class="sxs-lookup"><span data-stu-id="bab50-322">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="bab50-323">Wenn der Wert unverändert ist, gibt die Methode einen Status zurück, der angibt, dass keine Änderungen vorgenommen wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-323">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="bab50-324">Es wurde kein Wert für den Schlüssel gefunden, das Schlüssel-Wert-Paar wird eingefügt.</span><span class="sxs-lookup"><span data-stu-id="bab50-324">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="bab50-325">Wenn der Wert geändert wurde, wird er aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-325">If the value has changed, it is updated.</span></span> <span data-ttu-id="bab50-326">Der aktualisierbare Modus ermöglicht es dem Thread, die Lesesperre nach Bedarf zu aktualisieren, ohne dass Deadlocks gefährdet sind.</span><span class="sxs-lookup"><span data-stu-id="bab50-326">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="bab50-327">Im Beispiel wird der Parameter lose Konstruktor verwendet, um die Sperre zu erstellen, sodass Rekursion nicht zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-327">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="bab50-328">Das Programmieren der <xref:System.Threading.ReaderWriterLockSlim> ist einfacher und weniger fehleranfällig, wenn die Sperre keine Rekursion zulässt.</span><span class="sxs-lookup"><span data-stu-id="bab50-328">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="bab50-329">Dieser Code ist Teil eines größeren Beispiels, das für die <xref:System.Threading.ReaderWriterLockSlim>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-329">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="bab50-330">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und dem aktuellen Thread wurde die Sperre bereits in einem der Modi zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="bab50-330">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="bab50-331">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-331">-or-</span></span> 
<span data-ttu-id="bab50-332">Der aktuelle Thread befindet sich im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.</span><span class="sxs-lookup"><span data-stu-id="bab50-332">The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="bab50-333">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-333">-or-</span></span> 
<span data-ttu-id="bab50-334">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</span><span class="sxs-lookup"><span data-stu-id="bab50-334">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="bab50-335">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</span><span class="sxs-lookup"><span data-stu-id="bab50-335">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bab50-336">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="bab50-336">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bab50-337">Versucht, die Sperre im Schreibmodus zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="bab50-337">Tries to enter the lock in write mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-338">Diese Methode wird blockiert, bis der aufrufende Thread in die Sperre eintritt und daher möglicherweise nie zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="bab50-338">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="bab50-339">Verwenden Sie die <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>-Methode, um ein bestimmtes Intervall zu blockieren, und geben Sie dann zurück, wenn der aufrufende Thread während dieses Intervalls nicht in den Schreibmodus wechselt.</span><span class="sxs-lookup"><span data-stu-id="bab50-339">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="bab50-340">Wenn andere Threads die Sperre im Lesemodus eingegeben haben, wird ein Thread, der die <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>-Methode aufruft, blockiert, bis diese Threads den Lesemodus verlassen haben.</span><span class="sxs-lookup"><span data-stu-id="bab50-340">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="bab50-341">Wenn Threads darauf warten, in den Schreibmodus zu wechseln, können zusätzliche Threads, die versuchen, in den Lesemodus oder den erweiterbaren Modus zu wechseln, blockiert werden, bis alle Threads, die auf den Schreibmodus warten, entweder abgelaufen sind oder in den Schreibmodus gewechselt und dann beendet wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-341">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-342">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread, der die Sperre im Schreibmodus eingegeben hat, rekursiv in den Schreibmodus wechseln, auch wenn andere Threads auf den Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-342">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-343">Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>-Methode verwenden, um die Sperre im Schreibmodus einzugeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-343">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="bab50-344">Die im Beispiel gezeigte-Methode fügt dem synchronisierten Cache ein neues Schlüssel-Wert-Paar hinzu.</span><span class="sxs-lookup"><span data-stu-id="bab50-344">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="bab50-345">Wenn der Schlüssel bereits im Cache vorhanden ist, kann die von der inneren <xref:System.Collections.Generic.Dictionary%602> ausgelöste Ausnahme die Methode beenden.</span><span class="sxs-lookup"><span data-stu-id="bab50-345">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="bab50-346">Ein `finally`-Block wird verwendet, um die <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>-Methode auszuführen und sicherzustellen, dass der Aufrufer den Schreibmodus beendet.</span><span class="sxs-lookup"><span data-stu-id="bab50-346">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="bab50-347">Dieser Code ist Teil eines größeren Beispiels, das für die <xref:System.Threading.ReaderWriterLockSlim>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-347">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="bab50-348">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und dem aktuellen Thread wurde die Sperre bereits in einem der Modi zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="bab50-348">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="bab50-349">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-349">-or-</span></span> 
<span data-ttu-id="bab50-350">Der aktuelle Thread befindet sich im Lesemodus und besitzt noch keine Schreibsperre, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.</span><span class="sxs-lookup"><span data-stu-id="bab50-350">The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="bab50-351">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-351">-or-</span></span> 
<span data-ttu-id="bab50-352">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</span><span class="sxs-lookup"><span data-stu-id="bab50-352">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="bab50-353">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</span><span class="sxs-lookup"><span data-stu-id="bab50-353">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bab50-354">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="bab50-354">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bab50-355">Verringert die Rekursionszahl für den Lesemodus und beendet den Lesemodus, wenn das Rekursionsergebnis 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-355">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-356">Diese Methode ist nicht für die Rekursions Reihenfolge empfindlich.</span><span class="sxs-lookup"><span data-stu-id="bab50-356">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="bab50-357">Wenn ein Thread z. b. eine Sperre im erweiterbaren Modus eingibt und dann in den Lesemodus wechselt, spielt die Reihenfolge, in der der Thread die beiden Modi verlässt, keine Rolle.</span><span class="sxs-lookup"><span data-stu-id="bab50-357">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="bab50-358">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread die Sperre im Schreibmodus eingeben und ihn im Lesemodus rekursiv eingeben. die Reihenfolge, in der der Thread den Lesemodus und den Schreibmodus beendet, spielt keine Rolle.</span><span class="sxs-lookup"><span data-stu-id="bab50-358">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="bab50-359">Durch das Beenden der Sperre werden möglicherweise andere wartende Threads signalisiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-359">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-360">Im folgenden Beispiel wird gezeigt, wie ein `finally`-Block verwendet wird, um die <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>-Methode auszuführen und sicherzustellen, dass der Aufrufer den Lesemodus beendet</span><span class="sxs-lookup"><span data-stu-id="bab50-360">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="bab50-361">Die im Beispiel gezeigte-Methode ruft den Wert ab, der einem Schlüssel zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-361">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="bab50-362">Wenn der Schlüssel nicht gefunden wird, wird die von der inneren <xref:System.Collections.Generic.Dictionary%602> ausgelöste Ausnahme zugelassen, um die Methode zu beenden.</span><span class="sxs-lookup"><span data-stu-id="bab50-362">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="bab50-363">Die <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>-Methode wird verwendet, um in den Lesemodus zu wechseln.</span><span class="sxs-lookup"><span data-stu-id="bab50-363">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="bab50-364">Dieser Code ist Teil eines größeren Beispiels, das für die <xref:System.Threading.ReaderWriterLockSlim>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-364">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="bab50-365">Der aktuelle Thread befindet sich nicht im Lesemodus.</span><span class="sxs-lookup"><span data-stu-id="bab50-365">The current thread has not entered the lock in read mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bab50-366">Verringert die Rekursionszahl für den erweiterbaren Modus und beendet den erweiterbaren Modus, wenn das Rekursionsergebnis 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-366">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-367">Diese Methode ist nicht für die Rekursions Reihenfolge empfindlich.</span><span class="sxs-lookup"><span data-stu-id="bab50-367">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="bab50-368">Wenn ein Thread z. b. eine Sperre im erweiterbaren Modus eingibt und dann in den Schreibmodus wechselt, spielt die Reihenfolge, in der der Thread die beiden Modi verlässt, keine Rolle.</span><span class="sxs-lookup"><span data-stu-id="bab50-368">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="bab50-369">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread die Sperre im Schreibmodus eingeben und ihn dann rekursiv im erweiterbaren Modus eingeben. die Reihenfolge, in der der Thread den aktualisierbaren Modus und den Schreibmodus beendet, spielt keine Rolle.</span><span class="sxs-lookup"><span data-stu-id="bab50-369">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="bab50-370">Durch das Beenden der Sperre werden möglicherweise andere wartende Threads signalisiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-370">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-371">Im folgenden Beispiel wird gezeigt, wie ein `finally`-Block verwendet wird, um die <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>-Methode auszuführen und sicherzustellen, dass der Aufrufer den erweiterbaren Modus beendet.</span><span class="sxs-lookup"><span data-stu-id="bab50-371">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="bab50-372">Die im Beispiel gezeigte-Methode ruft den Wert ab, der einem Schlüssel zugeordnet ist, und vergleicht ihn mit einem neuen Wert.</span><span class="sxs-lookup"><span data-stu-id="bab50-372">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="bab50-373">Wenn der Wert unverändert ist, gibt die Methode einen Status zurück, der angibt, dass keine Änderungen vorgenommen wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-373">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="bab50-374">Es wurde kein Wert für den Schlüssel gefunden, das Schlüssel-Wert-Paar wird eingefügt.</span><span class="sxs-lookup"><span data-stu-id="bab50-374">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="bab50-375">Wenn der Wert geändert wurde, wird er aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-375">If the value has changed, it is updated.</span></span> <span data-ttu-id="bab50-376">Der aktualisierbare Modus ermöglicht es dem Thread, die Lesesperre nach Bedarf zu aktualisieren, ohne dass Deadlocks gefährdet sind.</span><span class="sxs-lookup"><span data-stu-id="bab50-376">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="bab50-377">Im Beispiel wird der Parameter lose Konstruktor verwendet, um die Sperre zu erstellen, sodass Rekursion nicht zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-377">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="bab50-378">Das Programmieren der <xref:System.Threading.ReaderWriterLockSlim> ist einfacher und weniger fehleranfällig, wenn die Sperre keine Rekursion zulässt.</span><span class="sxs-lookup"><span data-stu-id="bab50-378">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="bab50-379">Dieser Code ist Teil eines größeren Beispiels, das für die <xref:System.Threading.ReaderWriterLockSlim>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-379">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="bab50-380">Der aktuelle Thread befindet sich nicht im erweiterbaren Modus.</span><span class="sxs-lookup"><span data-stu-id="bab50-380">The current thread has not entered the lock in upgradeable mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bab50-381">Verringert die Rekursionszahl für den Schreibmodus und beendet den Schreibmodus, wenn das Rekursionsergebnis 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-381">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-382">Diese Methode ist nicht für die Rekursions Reihenfolge empfindlich.</span><span class="sxs-lookup"><span data-stu-id="bab50-382">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="bab50-383">Wenn ein Thread z. b. eine Sperre im erweiterbaren Modus eingibt und dann in den Schreibmodus wechselt, spielt die Reihenfolge, in der der Thread die beiden Modi verlässt, keine Rolle.</span><span class="sxs-lookup"><span data-stu-id="bab50-383">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="bab50-384">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread die Sperre im Schreibmodus eingeben und ihn im Lesemodus rekursiv eingeben. die Reihenfolge, in der der Thread den Lesemodus und den Schreibmodus beendet, spielt keine Rolle.</span><span class="sxs-lookup"><span data-stu-id="bab50-384">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="bab50-385">Durch das Beenden der Sperre werden möglicherweise andere wartende Threads signalisiert.</span><span class="sxs-lookup"><span data-stu-id="bab50-385">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-386">Im folgenden Beispiel wird gezeigt, wie ein `finally`-Block verwendet wird, um die <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> Methode auszuführen und sicherzustellen, dass der Aufrufer den Schreibmodus beendet.</span><span class="sxs-lookup"><span data-stu-id="bab50-386">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="bab50-387">Die im Beispiel gezeigte-Methode fügt dem synchronisierten Cache ein neues Schlüssel-Wert-Paar hinzu.</span><span class="sxs-lookup"><span data-stu-id="bab50-387">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="bab50-388">Wenn der Schlüssel bereits im Cache vorhanden ist, kann die von der inneren <xref:System.Collections.Generic.Dictionary%602> ausgelöste Ausnahme die Methode beenden.</span><span class="sxs-lookup"><span data-stu-id="bab50-388">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="bab50-389">Die <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>-Methode wird verwendet, um die Sperre im Schreibmodus einzugeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-389">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="bab50-390">Dieser Code ist Teil eines größeren Beispiels, das für die <xref:System.Threading.ReaderWriterLockSlim>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-390">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="bab50-391">Der aktuelle Thread befindet sich nicht im Schreibmodus.</span><span class="sxs-lookup"><span data-stu-id="bab50-391">The current thread has not entered the lock in write mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bab50-392">Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im Lesemodus zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-392">Gets a value that indicates whether the current thread has entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="bab50-393"><see langword="true" />, wenn sich der aktuelle Thread im Lesemodus befindet, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bab50-393"><see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-394">Diese Eigenschaft ist für die Verwendung in Bestätigungen oder für andere Debuggingzwecke vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="bab50-394">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="bab50-395">Verwenden Sie es nicht, um den Ablauf der Programmausführung zu steuern.</span><span class="sxs-lookup"><span data-stu-id="bab50-395">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-396">Das folgende Beispiel zeigt, wie Sie die <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A>-Eigenschaft verwenden, um eine Assert-Eigenschaft zu generieren, wenn der aktuelle Thread unerwartet in den Lesemodus gewechselt ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-396">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bab50-397">Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im erweiterbaren Modus zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-397">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="bab50-398"><see langword="true" />, wenn sich der aktuelle Thread im erweiterbaren Modus befindet, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bab50-398"><see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-399">Diese Eigenschaft ist für die Verwendung in Bestätigungen oder für andere Debuggingzwecke vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="bab50-399">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="bab50-400">Verwenden Sie es nicht, um den Ablauf der Programmausführung zu steuern.</span><span class="sxs-lookup"><span data-stu-id="bab50-400">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-401">Das folgende Beispiel zeigt, wie Sie die <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A>-Eigenschaft verwenden, um eine Assert-Eigenschaft zu generieren, wenn der aktuelle Thread unerwartet in den erweiterbaren-Modus wechselt.</span><span class="sxs-lookup"><span data-stu-id="bab50-401">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bab50-402">Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im Schreibmodus zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-402">Gets a value that indicates whether the current thread has entered the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="bab50-403"><see langword="true" />, wenn sich der aktuelle Thread im Schreibmodus befindet, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bab50-403"><see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-404">Diese Eigenschaft ist für die Verwendung in Bestätigungen oder für andere Debuggingzwecke vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="bab50-404">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="bab50-405">Verwenden Sie es nicht, um den Ablauf der Programmausführung zu steuern.</span><span class="sxs-lookup"><span data-stu-id="bab50-405">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-406">Im folgenden Beispiel wird gezeigt, wie die <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A>-Eigenschaft verwendet wird, um eine Assert-Eigenschaft zu generieren, wenn der aktuelle Thread unerwartet in den Schreibmodus wechselt.</span><span class="sxs-lookup"><span data-stu-id="bab50-406">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bab50-407">Ruft einen Wert ab, der die Rekursionsrichtlinie für das aktuelle <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt angibt.</span><span class="sxs-lookup"><span data-stu-id="bab50-407">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span></span></summary>
        <value><span data-ttu-id="bab50-408">Einer der Enumerationswerte, der die Rekursionsrichtlinie für die Sperre angibt.</span><span class="sxs-lookup"><span data-stu-id="bab50-408">One of the enumeration values that specifies the lock recursion policy.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-409">Mit der Rekursions Richtlinie werden die Einschränkungen für Threads festgelegt, die die Sperre mehrmals eingeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-409">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="bab50-410">Wenn z. b. eine Sperre mit <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> erstellt wurde und ein Thread die Sperre im Lesemodus erreicht hat, wird <xref:System.Threading.LockRecursionException> ausgelöst, wenn der Thread versucht, die Sperre erneut in den Lesemodus einzugeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-410">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-411">Ein Thread im erweiterbaren Modus kann unabhängig von der Richtlinien Einstellung für die sperrrekursion auf den Schreibmodus oder das Downgrade in den Lesemodus aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="bab50-411">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="bab50-412">Unabhängig von der Rekursions Richtlinie ist ein Thread, der anfänglich in den Lesemodus wechselt, nicht berechtigt, auf den erweiterbaren Modus oder den Schreibmodus zu aktualisieren, da dieses Muster eine hohe Wahrscheinlichkeit von Deadlocks erzeugt.</span><span class="sxs-lookup"><span data-stu-id="bab50-412">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="bab50-413">Weitere Informationen zu Rekursions Richtlinien und deren Auswirkungen finden Sie in der <xref:System.Threading.LockRecursionPolicy>-Enumeration und der <xref:System.Threading.ReaderWriterLockSlim>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="bab50-413">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bab50-414">Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im Lesemodus zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-414">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="bab50-415">0 (null), wenn sich der aktuelle Thread nicht im Lesemodus befindet, 1, wenn der Thread in den Lesemodus gewechselt ist, ihn aber nicht rekursiv eingegeben hat, oder *n* , wenn der Thread die Sperre *n* -1 mal rekursiv eingegeben hat.</span><span class="sxs-lookup"><span data-stu-id="bab50-415">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-416">Verwenden Sie diese Eigenschaft nur für Debuggen, Profilerstellung und Protokollierung und nicht zum Steuern des Verhaltens eines Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="bab50-416">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="bab50-417">Die Ergebnisse können sich ändern, sobald Sie berechnet wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-417">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="bab50-418">Daher ist es nicht sicher, Entscheidungen basierend auf dieser Eigenschaft zu treffen.</span><span class="sxs-lookup"><span data-stu-id="bab50-418">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bab50-419">Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im erweiterbaren Modus zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-419">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="bab50-420">0 (null), wenn sich der aktuelle Thread nicht im erweiterbaren Modus befindet, 1, wenn sich der Thread im erweiterbaren Modus befindet, ihn aber nicht rekursiv eingegeben hat, oder *n* , wenn der Thread den erweiterbaren Modus *n* -1 mal rekursiv eingegeben hat.</span><span class="sxs-lookup"><span data-stu-id="bab50-420">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-421">Verwenden Sie diese Eigenschaft nur für Debuggen, Profilerstellung und Protokollierung und nicht zum Steuern des Verhaltens eines Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="bab50-421">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="bab50-422">Die Ergebnisse können sich ändern, sobald Sie berechnet wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-422">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="bab50-423">Daher ist es nicht sicher, Entscheidungen basierend auf dieser Eigenschaft zu treffen.</span><span class="sxs-lookup"><span data-stu-id="bab50-423">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bab50-424">Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im Schreibmodus zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-424">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="bab50-425">0 (null), wenn sich der aktuelle Thread nicht im Schreibmodus befindet, 1, wenn sich der Thread im Schreibmodus befindet, ihn jedoch nicht rekursiv eingegeben hat, oder *n* , wenn der Thread den Schreibmodus *n* -1 mal rekursiv eingegeben hat.</span><span class="sxs-lookup"><span data-stu-id="bab50-425">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-426">Verwenden Sie diese Eigenschaft nur für Debuggen, Profilerstellung und Protokollierung und nicht zum Steuern des Verhaltens eines Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="bab50-426">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="bab50-427">Die Ergebnisse können sich ändern, sobald Sie berechnet wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-427">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="bab50-428">Daher ist es nicht sicher, Entscheidungen basierend auf dieser Eigenschaft zu treffen.</span><span class="sxs-lookup"><span data-stu-id="bab50-428">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bab50-429">Versucht, die Sperre im Lesemodus zu erhalten. Optional wird ein Timeout berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="bab50-429">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="bab50-430">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<see cref="F:System.Threading.Timeout.Infinite" />), um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-430">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bab50-431">Versucht, die Sperre im Lesemodus zu erhalten. Optional wird ein ganzzahliger Timeout berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="bab50-431">Tries to enter the lock in read mode, with an optional integer time-out.</span></span></summary>
        <returns><span data-ttu-id="bab50-432"><see langword="true" />, wenn der aufrufende Thread den Lesemodus erhalten hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bab50-432"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-433">Wenn `millisecondsTimeout` 0 (null) ist, überprüft diese Methode den Sperr Zustand und gibt `false` sofort zurück, wenn der gewünschte Zustand nicht verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-433">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="bab50-434">Mehrere Threads können gleichzeitig in den Lesemodus wechseln.</span><span class="sxs-lookup"><span data-stu-id="bab50-434">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="bab50-435">Wenn ein oder mehrere Threads auf den Schreibmodus warten, wird ein Thread, der die <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>-Methode aufruft, blockiert, bis diese Threads entweder abgelaufen sind oder in den Schreibmodus gewechselt und dann beendet wurden oder bis das eigene Timeout Intervall für das aufrufende Thread abläuft.</span><span class="sxs-lookup"><span data-stu-id="bab50-435">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-436">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread, der die Sperre im Lesemodus eingegeben hat, rekursiv in den Lesemodus wechseln, auch wenn andere Threads auf den Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-436">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="bab50-437">Ein Thread kann sich im erweiterbaren Modus befinden, während sich andere Threads im Lesemodus befinden.</span><span class="sxs-lookup"><span data-stu-id="bab50-437">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="bab50-438">Wenn zusätzliche Threads auf den erweiterbaren Modus warten und keine Threads auf den Schreibmodus warten, werden die Threads, die die <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>-Methode aufzurufen, sofort in den Lesemodus wechseln und dürfen nicht blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="bab50-438">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="bab50-439">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.</span><span class="sxs-lookup"><span data-stu-id="bab50-439">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="bab50-440">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-440">-or-</span></span> 
<span data-ttu-id="bab50-441">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</span><span class="sxs-lookup"><span data-stu-id="bab50-441">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="bab50-442">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</span><span class="sxs-lookup"><span data-stu-id="bab50-442">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bab50-443">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ, aber ungleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1), der den einzigen zulässigen negativen Wert darstellt.</span><span class="sxs-lookup"><span data-stu-id="bab50-443">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bab50-444">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="bab50-444">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="bab50-445">Das Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-445">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bab50-446">Versucht, die Sperre im Lesemodus zu erhalten. Optional wird ein Timeout berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="bab50-446">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="bab50-447"><see langword="true" />, wenn der aufrufende Thread den Lesemodus erhalten hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bab50-447"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-448">Wenn `timeout` 0 (null) ist, überprüft diese Methode den Sperr Zustand und gibt `false` sofort zurück, wenn der gewünschte Zustand nicht verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-448">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="bab50-449">Mehrere Threads können gleichzeitig in den Lesemodus wechseln.</span><span class="sxs-lookup"><span data-stu-id="bab50-449">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="bab50-450">Wenn ein oder mehrere Threads in die Warteschlange für den Schreibmodus eingereiht werden, wird ein Thread, der die <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>-Methode aufruft, blockiert, bis für diese Threads entweder ein Timeout oder ein Timeout eintritt.</span><span class="sxs-lookup"><span data-stu-id="bab50-450">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-451">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread, der die Sperre im Lesemodus eingegeben hat, rekursiv in den Lesemodus wechseln, auch wenn andere Threads auf den Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-451">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="bab50-452">Ein Thread kann sich im erweiterbaren Modus befinden, während sich andere Threads im Lesemodus befinden.</span><span class="sxs-lookup"><span data-stu-id="bab50-452">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="bab50-453">Wenn zusätzliche Threads auf den erweiterbaren Modus warten und keine Threads auf den Schreibmodus warten, werden die Threads, die die <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>-Methode aufzurufen, sofort in den Lesemodus wechseln und dürfen nicht blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="bab50-453">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="bab50-454">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.</span><span class="sxs-lookup"><span data-stu-id="bab50-454">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="bab50-455">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-455">-or-</span></span> 
<span data-ttu-id="bab50-456">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</span><span class="sxs-lookup"><span data-stu-id="bab50-456">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="bab50-457">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</span><span class="sxs-lookup"><span data-stu-id="bab50-457">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bab50-458">Der Wert von <paramref name="timeout" /> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)</span><span class="sxs-lookup"><span data-stu-id="bab50-458">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="bab50-459">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-459">-or-</span></span> 
<span data-ttu-id="bab50-460">Der Wert von <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="bab50-460">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bab50-461">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="bab50-461">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bab50-462">Versucht, die Sperre im erweiterbaren Modus zu erhalten. Optional wird ein Timeout berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="bab50-462">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="bab50-463">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<see cref="F:System.Threading.Timeout.Infinite" />), um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-463">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bab50-464">Versucht, die Sperre im erweiterbaren Modus zu erhalten. Optional wird ein Timeout berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="bab50-464">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="bab50-465"><see langword="true" />, wenn der aufrufende Thread den erweiterbaren Modus erhalten hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bab50-465"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-466">Wenn `millisecondsTimeout` 0 (null) ist, überprüft diese Methode den Sperr Zustand und gibt `false` sofort zurück, wenn der gewünschte Zustand nicht verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-466">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="bab50-467">Verwenden Sie den erweiterbaren Modus, wenn ein Thread in der Regel auf die Ressource zugreift, die durch die <xref:System.Threading.ReaderWriterLockSlim> im Lesemodus geschützt ist, aber möglicherweise in den Schreibmodus wechseln muss, wenn bestimmte Bedingungen erfüllt sind.</span><span class="sxs-lookup"><span data-stu-id="bab50-467">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="bab50-468">Ein Thread im erweiterbaren Modus kann auf den Schreibmodus oder das Downgrade in den Lesemodus aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="bab50-468">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="bab50-469">Nur ein Thread kann zu einem beliebigen Zeitpunkt eine Sperre im erweiterbaren Modus eingeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-469">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="bab50-470">Wenn sich ein Thread im erweiterbaren Modus befindet und keine Threads auf den Schreibmodus warten, kann eine beliebige Anzahl anderer Threads in den Lesemodus wechseln, auch wenn Threads vorhanden sind, die auf die Eingabe des erweiterbaren Modus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-470">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="bab50-471">Wenn ein oder mehrere Threads auf den Schreibmodus warten, wird ein Thread, der die <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>-Methode aufruft, blockiert, bis diese Threads entweder abgelaufen sind oder in den Schreibmodus gewechselt und dann beendet wurden oder bis das eigene Timeout Intervall für das aufrufende Thread abläuft.</span><span class="sxs-lookup"><span data-stu-id="bab50-471">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-472">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread, der die Sperre im erweiterbaren Modus eingegeben hat, rekursiv in den aktualisierbaren Modus wechseln, auch wenn andere Threads auf den Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-472">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="bab50-473">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.</span><span class="sxs-lookup"><span data-stu-id="bab50-473">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="bab50-474">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-474">-or-</span></span> 
<span data-ttu-id="bab50-475">Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.</span><span class="sxs-lookup"><span data-stu-id="bab50-475">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="bab50-476">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-476">-or-</span></span> 
<span data-ttu-id="bab50-477">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</span><span class="sxs-lookup"><span data-stu-id="bab50-477">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="bab50-478">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</span><span class="sxs-lookup"><span data-stu-id="bab50-478">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bab50-479">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ, aber ungleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1), der den einzigen zulässigen negativen Wert darstellt.</span><span class="sxs-lookup"><span data-stu-id="bab50-479">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bab50-480">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="bab50-480">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="bab50-481">Das Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-481">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bab50-482">Versucht, die Sperre im erweiterbaren Modus zu erhalten. Optional wird ein Timeout berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="bab50-482">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="bab50-483"><see langword="true" />, wenn der aufrufende Thread den erweiterbaren Modus erhalten hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bab50-483"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-484">Wenn `timeout` 0 (null) ist, überprüft diese Methode den Sperr Zustand und gibt `false` sofort zurück, wenn der gewünschte Zustand nicht verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-484">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="bab50-485">Verwenden Sie den erweiterbaren Modus, wenn ein Thread in der Regel auf die Ressource zugreift, die von der <xref:System.Threading.ReaderWriterLockSlim> im Lesemodus geschützt wird. wenn bestimmte Bedingungen erfüllt sind, müssen Sie möglicherweise den Schreibmodus eingeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-485">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="bab50-486">Ein Thread im erweiterbaren Modus kann auf den Schreibmodus oder das Downgrade in den Lesemodus aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="bab50-486">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="bab50-487">Nur ein Thread kann zu einem beliebigen Zeitpunkt eine Sperre im erweiterbaren Modus eingeben.</span><span class="sxs-lookup"><span data-stu-id="bab50-487">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="bab50-488">Wenn sich ein Thread im erweiterbaren Modus befindet und keine Threads auf den Schreibmodus warten, kann eine beliebige Anzahl anderer Threads in den Lesemodus wechseln, auch wenn Threads vorhanden sind, die auf die Eingabe des erweiterbaren Modus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-488">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="bab50-489">Wenn ein oder mehrere Threads auf den Schreibmodus warten, wird ein Thread, der die <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>-Methode aufruft, blockiert, bis diese Threads entweder abgelaufen sind oder in den Schreibmodus gewechselt und dann beendet wurden oder bis das eigene Timeout Intervall für das aufrufende Thread abläuft.</span><span class="sxs-lookup"><span data-stu-id="bab50-489">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-490">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread, der die Sperre im erweiterbaren Modus eingegeben hat, rekursiv in den aktualisierbaren Modus wechseln, auch wenn andere Threads auf den Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-490">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="bab50-491">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.</span><span class="sxs-lookup"><span data-stu-id="bab50-491">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="bab50-492">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-492">-or-</span></span> 
<span data-ttu-id="bab50-493">Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.</span><span class="sxs-lookup"><span data-stu-id="bab50-493">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="bab50-494">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-494">-or-</span></span> 
<span data-ttu-id="bab50-495">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</span><span class="sxs-lookup"><span data-stu-id="bab50-495">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="bab50-496">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</span><span class="sxs-lookup"><span data-stu-id="bab50-496">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bab50-497">Der Wert von <paramref name="timeout" /> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)</span><span class="sxs-lookup"><span data-stu-id="bab50-497">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="bab50-498">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-498">-or-</span></span> 
<span data-ttu-id="bab50-499">Der Wert von <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="bab50-499">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bab50-500">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="bab50-500">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bab50-501">Versucht, die Sperre im Schreibmodus zu erhalten. Optional wird ein Timeout berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="bab50-501">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="bab50-502">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<see cref="F:System.Threading.Timeout.Infinite" />), um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-502">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bab50-503">Versucht, die Sperre im Schreibmodus zu erhalten. Optional wird ein Timeout berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="bab50-503">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="bab50-504"><see langword="true" />, wenn der aufrufende Thread den Schreibmodus erhalten hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bab50-504"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-505">Wenn `millisecondsTimeout` 0 (null) ist, überprüft diese Methode den Sperr Zustand und gibt `false` sofort zurück, wenn der gewünschte Zustand nicht verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-505">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="bab50-506">Wenn andere Threads die Sperre im Lesemodus eingegeben haben, wird ein Thread, der die <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>-Methode aufruft, blockiert, bis diese Threads den Lesemodus verlassen haben oder bis das Timeout Intervall abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-506">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="bab50-507">Während Threads blockiert werden, die auf den Schreibmodus warten, können zusätzliche Threads, die versuchen, in den Lesemodus oder den erweiterbaren Modus zu wechseln, blockiert werden, bis für alle Threads, die auf den Schreibmodus warten, ein Timeout eingetreten ist oder der Schreibmodus beendet und anschließend beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="bab50-507">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-508">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread, der die Sperre im Schreibmodus eingegeben hat, rekursiv in den Schreibmodus wechseln, auch wenn andere Threads auf den Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-508">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-509">Im folgenden Beispiel wird gezeigt, wie die <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>-Methode verwendet wird, um die Sperre im Schreibmodus mit einem Timeout einzugeben. Die im Beispiel gezeigte-Methode fügt dem synchronisierten Cache ein neues Schlüssel-Wert-Paar hinzu.</span><span class="sxs-lookup"><span data-stu-id="bab50-509">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="bab50-510">Wenn das angegebene Timeout Intervall abläuft, bevor der Thread in die Sperre wechselt, gibt die Methode `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="bab50-510">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="bab50-511">Die Methode gibt `true` zurück, wenn das Schlüssel-Wert-Paar hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-511">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="bab50-512">Wenn der Schlüssel bereits im Cache vorhanden ist, kann die von der inneren <xref:System.Collections.Generic.Dictionary%602> ausgelöste Ausnahme die Methode beenden.</span><span class="sxs-lookup"><span data-stu-id="bab50-512">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="bab50-513">Ein `finally`-Block wird verwendet, um die <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>-Methode auszuführen und sicherzustellen, dass der Aufrufer die Sperre beendet.</span><span class="sxs-lookup"><span data-stu-id="bab50-513">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="bab50-514">Dieser Code ist Teil eines größeren Beispiels, das für die <xref:System.Threading.ReaderWriterLockSlim>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="bab50-514">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="bab50-515">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.</span><span class="sxs-lookup"><span data-stu-id="bab50-515">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="bab50-516">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-516">-or-</span></span> 
<span data-ttu-id="bab50-517">Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.</span><span class="sxs-lookup"><span data-stu-id="bab50-517">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="bab50-518">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-518">-or-</span></span> 
<span data-ttu-id="bab50-519">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</span><span class="sxs-lookup"><span data-stu-id="bab50-519">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="bab50-520">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</span><span class="sxs-lookup"><span data-stu-id="bab50-520">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bab50-521">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ, aber ungleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1), der den einzigen zulässigen negativen Wert darstellt.</span><span class="sxs-lookup"><span data-stu-id="bab50-521">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bab50-522">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="bab50-522">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="bab50-523">Das Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-523">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bab50-524">Versucht, die Sperre im Schreibmodus zu erhalten. Optional wird ein Timeout berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="bab50-524">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="bab50-525"><see langword="true" />, wenn der aufrufende Thread den Schreibmodus erhalten hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bab50-525"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-526">Wenn `timeout` 0 (null) ist, überprüft diese Methode den Sperr Zustand und gibt `false` sofort zurück, wenn der gewünschte Zustand nicht verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-526">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="bab50-527">Wenn andere Threads die Sperre im Lesemodus eingegeben haben, wird ein Thread, der die <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>-Methode aufruft, blockiert, bis diese Threads den Lesemodus verlassen haben oder bis das Timeout Intervall abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="bab50-527">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="bab50-528">Während Threads blockiert werden, die auf den Schreibmodus warten, können zusätzliche Threads, die versuchen, in den Lesemodus oder den erweiterbaren Modus zu wechseln, blockiert werden, bis für alle Threads, die auf den Schreibmodus warten, ein Timeout eingetreten ist oder der Schreibmodus beendet und anschließend beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="bab50-528">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bab50-529">Wenn eine Sperre eine Rekursion zulässt, kann ein Thread, der die Sperre im Schreibmodus eingegeben hat, rekursiv in den Schreibmodus wechseln, auch wenn andere Threads auf den Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-529">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="bab50-530">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.</span><span class="sxs-lookup"><span data-stu-id="bab50-530">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="bab50-531">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-531">-or-</span></span> 
<span data-ttu-id="bab50-532">Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.</span><span class="sxs-lookup"><span data-stu-id="bab50-532">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="bab50-533">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-533">-or-</span></span> 
<span data-ttu-id="bab50-534">Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten.</span><span class="sxs-lookup"><span data-stu-id="bab50-534">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="bab50-535">Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</span><span class="sxs-lookup"><span data-stu-id="bab50-535">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bab50-536">Der Wert von <paramref name="timeout" /> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)</span><span class="sxs-lookup"><span data-stu-id="bab50-536">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="bab50-537">Oder</span><span class="sxs-lookup"><span data-stu-id="bab50-537">-or-</span></span> 
<span data-ttu-id="bab50-538">Der Wert von <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="bab50-538">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bab50-539">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="bab50-539">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bab50-540">Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung der Sperre im Lesemodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-540">Gets the total number of threads that are waiting to enter the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="bab50-541">Die Gesamtzahl von Threads, die auf eine Zuweisung des Lesemodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-541">The total number of threads that are waiting to enter read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-542">Verwenden Sie diese Eigenschaft nur für Debuggen, Profilerstellung und Protokollierung und nicht zum Steuern des Verhaltens eines Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="bab50-542">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="bab50-543">Die Ergebnisse können sich ändern, sobald Sie berechnet wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-543">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="bab50-544">Daher ist es nicht sicher, Entscheidungen basierend auf dieser Eigenschaft zu treffen.</span><span class="sxs-lookup"><span data-stu-id="bab50-544">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-545">Im folgenden Beispiel wird gezeigt, wie die <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A>-Eigenschaft verwendet wird, um einen Ereignisprotokoll Eintrag zu generieren, wenn die Anzahl der blockierten Threads, die auf die Eingabe des Lesemodus warten, einen Schwellenwert überschreitet.</span><span class="sxs-lookup"><span data-stu-id="bab50-545">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bab50-546">Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung der Sperre im erweiterbaren Modus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-546">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="bab50-547">Die Gesamtzahl von Threads, die auf eine Zuweisung des erweiterbaren Modus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-547">The total number of threads that are waiting to enter upgradeable mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-548">Verwenden Sie diese Eigenschaft nur für Debuggen, Profilerstellung und Protokollierung und nicht zum Steuern des Verhaltens eines Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="bab50-548">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="bab50-549">Die Ergebnisse können sich ändern, sobald Sie berechnet wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-549">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="bab50-550">Daher ist es nicht sicher, Entscheidungen basierend auf dieser Eigenschaft zu treffen.</span><span class="sxs-lookup"><span data-stu-id="bab50-550">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-551">Im folgenden Beispiel wird gezeigt, wie die <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A>-Eigenschaft verwendet wird, um einen Ereignisprotokoll Eintrag zu generieren, wenn die Anzahl der blockierten Threads, die auf den erweiterbaren Modus warten, einen Schwellenwert überschreitet.</span><span class="sxs-lookup"><span data-stu-id="bab50-551">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bab50-552">Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung der Sperre im Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-552">Gets the total number of threads that are waiting to enter the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="bab50-553">Die Gesamtzahl von Threads, die auf eine Zuweisung des Schreibmodus warten.</span><span class="sxs-lookup"><span data-stu-id="bab50-553">The total number of threads that are waiting to enter write mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bab50-554">Verwenden Sie diese Eigenschaft nur für Debuggen, Profilerstellung und Protokollierung und nicht zum Steuern des Verhaltens eines Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="bab50-554">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="bab50-555">Die Ergebnisse können sich ändern, sobald Sie berechnet wurden.</span><span class="sxs-lookup"><span data-stu-id="bab50-555">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="bab50-556">Daher ist es nicht sicher, Entscheidungen basierend auf dieser Eigenschaft zu treffen.</span><span class="sxs-lookup"><span data-stu-id="bab50-556">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bab50-557">Im folgenden Beispiel wird gezeigt, wie die <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A>-Eigenschaft verwendet wird, um einen Ereignisprotokoll Eintrag zu generieren, wenn die Anzahl der blockierten Threads, die auf den Schreibmodus warten, einen Schwellenwert überschreitet.</span><span class="sxs-lookup"><span data-stu-id="bab50-557">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
