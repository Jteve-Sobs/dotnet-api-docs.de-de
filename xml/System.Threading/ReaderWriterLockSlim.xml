<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3464038fcf06fcd6ab722a9c4b6f82b812141c99" /><Meta Name="ms.sourcegitcommit" Value="84c54c0c7d64827a5637d1f05e74e1f0598606a1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/27/2018" /><Meta Name="ms.locfileid" Value="42942852" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Sperre dar, mit der der Zugriff auf eine Ressource verwaltet wird. Mehrere Threads können damit Lesezugriff oder exklusiven Schreibzugriff erhalten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Threading.ReaderWriterLockSlim> zum Schützen einer Ressource, die von mehreren Threads gelesen und in einem Thread gleichzeitig geschrieben. <xref:System.Threading.ReaderWriterLockSlim> ermöglicht mehreren Threads, die sich im Lesemodus befindet, ermöglicht es einem Thread im Schreibmodus mit exklusiven Besitz der Sperre sein und es einem Thread ermöglicht, die Lesezugriff auf die im erweiterbaren Modus zu lesen, werden von dem der Thread den Schreibmodus, ohne dass sie dafür aktualisieren können s Lesezugriff auf die Ressource an.  
  
> [!NOTE]
>  <xref:System.Threading.ReaderWriterLockSlim> ähnelt <xref:System.Threading.ReaderWriterLock>, verfügt aber über vereinfachte Regeln für Rekursion sowie für Upgrade und Downgrade des Sperrstatus. <xref:System.Threading.ReaderWriterLockSlim> vermeidet viele potenzielle Deadlocks. Darüber hinaus ist die Leistung von <xref:System.Threading.ReaderWriterLockSlim> wesentlich besser als die von <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> wird für alle Neuentwicklungen empfohlen.  
  
 Standardmäßig werden neue Instanzen von <xref:System.Threading.ReaderWriterLockSlim> werden erstellt, mit der <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> kennzeichnen und Rekursion nicht zulassen. Diese Standardrichtlinie wird für alle Neuentwicklungen empfohlen, da Rekursion unnötige Komplikationen eingeführt und wird Ihr Code anfälliger für Deadlocks. Zur Vereinfachung der Migration von vorhandenen Projekten, in denen <xref:System.Threading.Monitor> oder <xref:System.Threading.ReaderWriterLock>, können Sie die <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> Flag zum Erstellen von Instanzen der <xref:System.Threading.ReaderWriterLockSlim> , mit denen Rekursion.  
  
 Ein Thread kann die Sperre eingeben, in drei Modi: Modus Schreibmodus und Lesen im erweiterbaren Modus zu lesen. (Im weiteren Verlauf dieses Themas, "erweiterbaren Lesemodus" wird bezeichnet als "erweiterbaren Modus" aus, und der Ausdruck "Geben Sie `x` im Modus" wird verwendet, statt den längeren Ausdruck "Geben Sie die Sperre im `x` im Modus".)  
  
 Unabhängig von die Rekursionsrichtlinie für die kann nur ein Thread im Schreibmodus zu einem beliebigen Zeitpunkt sein. Wenn ein Thread im Schreibmodus befindet, kann kein anderer Thread die Sperre in einem anderen Modus eingeben. Nur ein Thread kann jederzeit im erweiterbaren Modus sein. Eine beliebige Anzahl von Threads kann im Lesemodus befindet, und kann es möglicherweise ein Thread im erweiterbaren Modus befindet, während andere Threads befinden sich im Lesemodus.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mit dem Typ haben, sollten Sie es entweder direkt oder indirekt freigeben. Damit des Typs direkt freigegeben werden, rufen Sie die <xref:System.IDisposable.Dispose%2A> -Methode in einer `try` / `catch` Block. Um sie indirekt löschen, verwenden Sie ein Sprachkonstrukt wie `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "mithilfe von ein-Objekt, das implementiert" IDisposable "" in der <xref:System.IDisposable> schnittstellenthema.  
  
 <xref:System.Threading.ReaderWriterLockSlim> Thread-Affinität ist verwaltet werden. Das heißt, jedes <xref:System.Threading.Thread> Objekt muss eine eigene Methodenaufrufen zu aktivieren und Deaktivieren des Sperrmodi zu machen. Kein Thread kann es sich um den Modus eines anderen Threads ändern.  
  
 Wenn eine <xref:System.Threading.ReaderWriterLockSlim> lässt keine Rekursion, einen Thread, versucht, die Sperre, verschiedene Ursachen haben blockieren können:  
  
-   Ein Thread, der versucht, die im Lesemodus Blöcke eingeben, wenn andere Threads darauf warten, geben im Schreibmodus oder ein einzelnen Thread im Schreibmodus.  
  
    > [!NOTE]
    >  Neue Leser blockieren, wenn der Writer, in der Warteschlange befinden, ist eine Richtlinie der Sperre-Ausgewogenheit, die Schreiber bevorzugt. Die aktuelle Richtlinie für die Ausgewogenheit Salden Ausgewogenheit Lesern und Schreibern stammen, die zur Förderung der Durchsatz in den meisten häufigen Szenarien. Zukünftige Versionen von der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] kann neue Ausgewogenheit Richtlinien darstellen.  
  
-   Ein Thread, der versucht, die im erweiterbaren Modus Blöcke zu geben, wenn es ist bereits ein Thread im erweiterbaren Modus befindet, wenn es Threads Schreibmodus warten, oder es gibt ein einzelnen Thread im Schreibmodus.  
  
-   Ein Thread, der versucht, Schreibmodus blockiert, wenn ein Thread in jedem der drei Modi vorhanden ist.  
  
## <a name="upgrading-and-downgrading-locks"></a>Upgrades und Downgrades Sperren  
 Zuweisung des erweiterbaren Modus ist für Fälle vorgesehen, in denen ein Thread in der Regel aus der geschützten Ressource liest, aber möglicherweise zu schreiben, wenn eine Bedingung erfüllt ist. Ein Thread, hat eine <xref:System.Threading.ReaderWriterLockSlim> im erweiterbaren Modus befindet, verfügt über Lesezugriff auf die geschützte Ressource und kann zum Schreiben von Modus durch Aufrufen der <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> oder <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> Methoden. Da vorhanden nur ein Thread im erweiterbaren Modus zu einem Zeitpunkt sein können, kann nicht den Schreibmodus Upgrade zu einem deadlock bei Rekursion nicht zulässig ist, ist die Standardrichtlinie.  
  
> [!IMPORTANT]
>  Unabhängig von die Rekursionsrichtlinie für die lesen ein Thread, der ursprünglich eingegebenen Modus darf nicht im erweiterbaren Modus oder im Schreibmodus befindet, aktualisieren, da dieses Muster eine hohe Wahrscheinlichkeit für Deadlocks erstellt. Z. B. wenn zwei Threads im Lesemodus befindet, die beide geben dann den Schreibmodus, sie in einem deadlock. Zuweisung des erweiterbaren Modus soll diese Deadlocks zu vermeiden.  
  
 Wenn es andere Threads im Lesemodus, den Thread, der Blöcke aktualisiert wird. Während der Thread blockiert ist, werden die anderen Threads, die versuchen, den Lesemodus blockiert. Wenn alle Threads den Lesemodus beendet haben, gibt der erweiterbaren blockierte Thread im Schreibmodus. Wenn vorhanden, dass andere Threads darauf warten sind, geben den Schreibmodus, bleiben diese blockiert, da der einzelne Thread im erweiterbaren Modus befindet, die sie erhalten exklusiven Zugriff auf die Ressource verhindert.  
  
 Wenn der Thread im erweiterbaren Modus Schreibmodus beendet wird, können andere Threads, die darauf warten, Lesemodus hierzu Threads darauf warten, geben den Schreibmodus, es sei denn, es gibt. Der Thread im erweiterbaren Modus kann ein upgrade und downgrade auf unbestimmte Zeit, solange er der einzige Thread ist, der auf die geschützte Ressource schreibt.  
  
> [!IMPORTANT]
>  Wenn Sie zulassen, dass mehrere Threads eingeben schreiben Sie oder den erweiterbaren Modus, Sie nicht auf einem Thread im erweiterbaren Modus Monopol auf zulassen müssen. Schreiben Threads, die versuchen, geben andernfalls Modus direkt werden werden auf unbestimmte Zeit blockiert, und während sie blockiert werden, andere Threads nicht Lesemodus.  
  
 Ein Thread im erweiterbaren Modus kann downgrade auf einen schreibgeschützten Modus durch den ersten Aufruf der <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> -Methode und dem anschließenden Aufrufen der <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> Methode. Dieses Muster kann für alle Richtlinien, Sperren Rekursion, sogar <xref:System.Threading.LockRecursionPolicy.NoRecursion>.  
  
 Nach einem Downgrade Lesemodus kann kein Thread im erweiterbaren Modus geben Sie bis dieser den Lesemodus beendet wurde.  
  
## <a name="entering-the-lock-recursively"></a>Die Sperre rekursiv eingeben  
 Sie erstellen eine <xref:System.Threading.ReaderWriterLockSlim> , die rekursive Sperren unterstützt mithilfe der <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> Konstruktor, der angibt, für die Sperre, und geben <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Die Verwendung der Rekursion wird für neue Entwicklungen nicht empfohlen, da es unnötige Komplikationen eingeführt und wird Ihr Code anfälliger für Deadlocks.  
  
 Für eine <xref:System.Threading.ReaderWriterLockSlim> , mit der Rekursion, die Folgendes gilt für die Modi kann ein Thread eingeben:  
  
-   Ein Thread im Lesemodus kann rekursiv, jedoch kann nicht im Schreibmodus oder im erweiterbaren Modus eingeben. Wenn versucht wird, dazu einen <xref:System.Threading.LockRecursionException> ausgelöst. Eingabe gelesen, Modus und die anschließende Eingabe im Schreibmodus oder im erweiterbaren Modus ist ein Muster mit einer starken Wahrscheinlichkeit von Deadlocks, ist es nicht zulässig. Wie bereits erwähnt, wird im erweiterbaren Modus für Fälle bereitgestellt, in denen eine Sperre ein upgrade erforderlich ist.  
  
-   Ein Thread im erweiterbaren Modus Schreibmodus und/oder Lesemodus eingeben kann, und Sie können eines der drei Modi rekursiv eingeben. Allerdings ein Versuch, Schreibmodus blockiert, wenn andere Threads im Lesemodus ausgeführt werden.  
  
-   Ein Thread im Schreibmodus kann geben, Lesemodus und/oder im erweiterbaren Modus befindet, und Sie können eines der drei Modi rekursiv eingeben.  
  
-   Ein Thread, der nicht die Sperre zugewiesen ist, kann einem beliebigen Modus eingeben. Dieser Versuch kann aus denselben Gründen als Versuch, eine nicht rekursive Sperre blockiert.  
  
 Ein Thread kann der Modi, in denen, die es in beliebiger Reihenfolge eingegeben hat, beenden, solange jeder Modus genau so häufig bei der Eingabe dieser Modus beenden. Wenn ein Thread versucht, einen Modus zu oft zu beenden, oder um einen Modus zu beenden, es nicht eingegeben werden wurde, eine <xref:System.Threading.SynchronizationLockException> ausgelöst.  
  
## <a name="lock-states"></a>Status der Sperre  
 Möglicherweise finden Sie es nützlich, um die Sperre bezüglich ihrer Status vorstellen. Ein <xref:System.Threading.ReaderWriterLockSlim> einen von vier Status: nicht zugewiesen werden, lesen, aktualisieren und zu schreiben.  
  
-   Nicht eingegeben: In diesem Status keine Threads die Sperre eingegeben haben (oder alle Threads, die Sperre beendet haben).  
  
-   Lesen: In diesem Zustand haben einen oder mehrere Threads die Sperre für den Lesezugriff auf die geschützte Ressource eingegeben.  
  
    > [!NOTE]
    >  Ein Thread kann die Sperre im Lesemodus Lesemodus, mithilfe der <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> oder <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> Methoden oder ein Downgrade von erweiterbaren Modus erhalten hat.  
  
-   Upgrade: In diesem Fall ein Thread verfügt über die Sperre für den Lesezugriff mit der Option, um Schreibzugriff aktualisieren (d. h. im erweiterbaren Modus), und NULL oder mehr Threads die Sperre für den Lesezugriff eingegeben haben. Nicht mehr als einem Thread zu einem Zeitpunkt kann die Sperre mit der Option zum Aktualisieren; Es werden zusätzliche Threads, die versuchen, die Zuweisung des erweiterbaren Modus blockiert.  
  
-   Schreiben: In diesem Fall hat ein Thread die Sperre für den Schreibzugriff auf die geschützte Ressource zugewiesen. Dieser Thread befindet sich exklusiven Besitz der Sperre. Es wird keinem anderen Thread, der versucht, die Sperre aus irgendeinem Grund blockiert.  
  
 Die folgende Tabelle beschreibt die Übergänge zwischen Zuständen der Sperre, sperren, die keine Rekursion, wenn ein Thread zulassen `t` führt die Aktion, die in der linken Spalte beschrieben. Zum Zeitpunkt die Aktion dauert `t` Modus "keine" hat. (Besonderen Fall, in denen `t` befindet sich im erweiterbaren Modus wird in die Fußnoten zur Tabelle beschrieben.) Die oberste Zeile gibt den ursprünglichen Status der Sperre. Die Zellen beschreiben, was geschieht mit den Thread, und Änderungen an den Sperrzustand in Klammern angezeigt.  
  
||Nicht zugewiesen (N)|Read (R)|Upgrade (U)|Write (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` fordert den Lesemodus|`t` Gibt ein (R).|`t` blockiert, wenn Threads für den Schreibmodus warten; andernfalls `t` eingibt.|`t` blockiert, wenn Threads für den Schreibmodus warten; andernfalls `t` eingibt.<sup> 1</sup>|`t` blockiert.|  
|`t` fordert den erweiterbaren Modus|`t` Gibt ein (U).|`t` blockiert, wenn Threads warten schreiben oder den erweiterbaren Modus; andernfalls `t` eingibt (U).|`t` blockiert.|`t` blockiert.|  
|`t` wird der Schreibmodus|`t` Gibt (W).|`t` blockiert.|`t` blockiert. <sup>2</sup>|`t` blockiert.|  
  
 <sup>1</sup> Wenn `t` startet, gibt es im erweiterbaren Modus befindet, im Lesemodus. Diese Aktion wird nie blockiert. Der Zustand der Sperre wird nicht geändert werden. (Der Thread kann dann eine Herabstufung Lesemodus beim Verlassen des erweiterbaren Modus durchführen.)  
  
 <sup>2</sup> Wenn `t` beginnt im erweiterbaren Modus erhalten hat, er blockiert wird, wenn im Lesemodus Threads vorhanden sind. Andernfalls wird es den Schreibmodus aktualisiert. Der Zustand der remotesperre ändert Write (W). Wenn `t` blockiert, da Threads vorhanden, im Lesemodus sind wird der Schreibmodus, sobald der letzte Thread im Lesemodus beendet wird, auch wenn Threads darauf warten, geben im Schreibmodus.  
  
 Tritt eine statusänderung, da ein Thread die Sperre wieder freigibt, wird der nächste Thread, der aktiviert werden wie folgt ausgewählt:  
  
-   Zunächst wird ein Thread, der wartet, wird im Schreibmodus, und ist bereits im erweiterbaren Modus befindet (es kann sein darf höchstens ein solcher Thread).  
  
-   Andernfalls ein Thread, der für den Schreibmodus wartet.  
  
-   Andernfalls ein Thread, der für den erweiterbaren Modus warten ist.  
  
-   Falls dies fehlschlägt, alle Threads, die für den Lesemodus warten.  
  
 Die nachfolgende Stand der Sperre ist immer Write (W) in der ersten beiden Fälle und Upgrade (U) in den dritten Fall, unabhängig vom Status der Sperre, wenn der vorhandene Thread die statusänderung ausgelöst. Im letzten Fall ist der Status der Sperre aktualisieren (U), wenn es ein Thread im erweiterbaren Modus nach der Änderung und Read (R), andernfalls unabhängig von den vorherigen Zustand.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einen einfachen synchronisierten Cache, der Zeichenfolgen mit ganzzahligen Schlüssel enthält. Eine Instanz von <xref:System.Threading.ReaderWriterLockSlim> wird zum Synchronisieren des Zugriffs auf die <xref:System.Collections.Generic.Dictionary%602> , die als interner Cache fungiert.  
  
 Das Beispiel enthält einfache Methoden, um dem Cache hinzuzufügen, aus dem Cache löschen und aus dem Cache gelesen. Um zeitüberschreitungen zu demonstrieren, umfasst das Beispiel eine Methode, die mit dem Cache hinzugefügt werden soll, nur dann, wenn sie dies in einem angegebenen Timeout ausführen kann.  
  
 Um die Zuweisung des erweiterbaren Modus zu demonstrieren, wird im Beispiel enthält eine Methode, die den Wert eines Schlüssels abruft und vergleicht ihn mit einem neuen Wert. Wenn der Wert unverändert ist, gibt die Methode einen Status, der angibt, der keine Änderung an. Wenn kein Wert für den Schlüssel gefunden wird, wird der Schlüssel/Wert-Paar eingefügt. Wenn der Wert geändert wurde, wird er aktualisiert. Im erweiterbaren Modus kann der Thread von Lesezugriff auf den Zugriff zu schreiben, ohne das Risiko von Deadlocks bei Bedarf aktualisieren.  
  
 Das Beispiel enthält eine geschachtelte-Enumeration, die die Rückgabewerte für die Methode gibt an, die Zuweisung des erweiterbaren Modus veranschaulicht.  
  
 Im Beispiel wird den Standardkonstruktor die Sperre zu erstellen, um die Rekursion nicht zulässig ist. Programmierung der <xref:System.Threading.ReaderWriterLockSlim> einfacher und weniger fehleranfällig ist, wenn die Sperre Rekursion nicht möglich ist.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 Der folgende code verwendet dann die `SynchronizedCache` Objekt, das ein Wörterbuch von vegetable Namen gespeichert. Es werden drei Aufgaben erstellt. Die erste schreibt die Namen der Gemüse gespeichert, die in einem Array auf einem `SynchronizedCache` Instanz. Die zweite und dritte Aufgabe werden die Namen der Gemüse, die erste in aufsteigender Reihenfolge (von niedrigen Index hoher Index), das zweite in absteigender Reihenfolge anzeigen. Die letzte Aufgabe sucht nach der Zeichenfolge "Cucumber", und wenn es gefunden wird, ruft der <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> Methode, um die Zeichenfolge "grüne Bean" zu ersetzen.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.ReaderWriterLockSlim" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.ReaderWriterLockSlim" />-Klasse mit Standardeigenschaftswerten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Threading.ReaderWriterLockSlim> , initialisiert mit diesem Konstruktor lässt keine Rekursion. Das bedeutet, dass die <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A>-Eigenschaft <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> zurückgibt.  
  
 Weitere Informationen zu die Rekursionsrichtlinie für die und die Auswirkungen, finden Sie unter den <xref:System.Threading.LockRecursionPolicy> Enumeration und die <xref:System.Threading.ReaderWriterLockSlim> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einen einfachen synchronisierten Cache, der Zeichenfolgen mit ganzzahligen Schlüssel enthält. Eine Instanz von <xref:System.Threading.ReaderWriterLockSlim> wird zum Synchronisieren des Zugriffs auf die <xref:System.Collections.Generic.Dictionary%602> , die als interner Cache fungiert. Der parameterlose Konstruktor wird verwendet, um die Sperre zu erstellen.  
  
 Das Beispiel enthält einfache Methoden, um dem Cache hinzuzufügen, aus dem Cache löschen und aus dem Cache gelesen. Um zeitüberschreitungen zu demonstrieren, umfasst das Beispiel eine Methode, die mit dem Cache hinzugefügt werden soll, nur dann, wenn sie dies in einem angegebenen Timeout ausführen kann.  
  
 Um die Zuweisung des erweiterbaren Modus zu demonstrieren, wird im Beispiel enthält eine Methode, die den Wert eines Schlüssels abruft und vergleicht ihn mit einem neuen Wert. Wenn der Wert unverändert ist, gibt die Methode einen Status, der angibt, der keine Änderung an. Sie keinen Wert für den Schlüssel gefunden wird, das Schlüssel/Wert-Paar eingefügt wird. Wenn der Wert geändert wurde, wird er aktualisiert. Im erweiterbaren Modus kann der Thread von Lesezugriff auf den Zugriff zu schreiben, ohne das Risiko von Deadlocks bei Bedarf aktualisieren.  
  
 Das Beispiel enthält eine geschachtelte-Enumeration, die die Rückgabewerte für die Methode gibt an, die Zuweisung des erweiterbaren Modus veranschaulicht.  
  
 Im Beispiel wird den Standardkonstruktor die Sperre zu erstellen, um die Rekursion nicht zulässig ist. Programmierung der <xref:System.Threading.ReaderWriterLockSlim> einfacher und weniger fehleranfällig ist, wenn die Sperre Rekursion nicht möglich ist.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 Der folgende code verwendet dann die `SynchronizedCache` Objekt, das ein Wörterbuch von vegetable Namen gespeichert. Es werden drei Aufgaben erstellt. Die erste schreibt die Namen der Gemüse gespeichert, die in einem Array auf einem `SynchronizedCache` Instanz. Die zweite und dritte Aufgabe werden die Namen der Gemüse, die erste in aufsteigender Reihenfolge (von niedrigen Index hoher Index), das zweite in absteigender Reihenfolge anzeigen. Die letzte Aufgabe sucht nach der Zeichenfolge "Cucumber", und wenn es gefunden wird, ruft der <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> Methode, um die Zeichenfolge "grüne Bean" zu ersetzen.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">Einer der Enumerationswerte, der die Rekursionsrichtlinie für die Sperre angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.ReaderWriterLockSlim" />-Klasse unter Angabe der Rekursionsrichtlinie für die Sperre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Rekursionsrichtlinie für die bestimmt, der Einschränkungen für Threads, die die Sperre mehr als einmal. Angenommen, eine Sperre mit erstellte <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> und ein Thread verfügt über die Sperre im Lesemodus <xref:System.Threading.LockRecursionException> wird ausgelöst, wenn der Thread versucht, die Sperre im Lesemodus anzufordern. Auf ähnliche Weise, wenn ein Thread die Sperre im Schreibmodus zugewiesen ist <xref:System.Threading.LockRecursionException> wird ausgelöst, wenn der Thread versucht, die Sperre in einem anderen Modus erneut eingeben.  
  
> [!NOTE]
>  Ein Thread im erweiterbaren Modus kann den Schreibmodus oder unabhängig von der Einstellung Rekursion Lesemodus.  
  
 Unabhängig von die Rekursionsrichtlinie für die lesen ein Thread, der ursprünglich eingegebenen Modus darf nicht im erweiterbaren Modus oder im Schreibmodus befindet, aktualisieren, da dieses Muster eine hohe Wahrscheinlichkeit für Deadlocks erstellt.  
  
 Weitere Informationen zu die Rekursionsrichtlinie für die und die Auswirkungen, finden Sie unter den <xref:System.Threading.LockRecursionPolicy> Enumeration und die <xref:System.Threading.ReaderWriterLockSlim> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt zwei Ausnahme Szenarien, die von abhängig ist die <xref:System.Threading.LockRecursionPolicy> festlegen und eine, die nicht der Fall ist.  
  
 Im ersten Szenario wird der Thread erhält den Lesemodus und versucht dann rekursiv. Wenn die <xref:System.Threading.ReaderWriterLockSlim> wird erstellt, indem Sie mit dem Standardkonstruktor, der Rekursionsrichtlinie für die legt, um fest <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, wird eine Ausnahme ausgelöst. Wenn <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> dient zum Erstellen der <xref:System.Threading.ReaderWriterLockSlim>, wird keine Ausnahme ausgelöst.  
  
 Im zweiten Szenario erhält des Threads den Lesemodus, und klicken Sie dann versucht, geben im Schreibmodus. <xref:System.Threading.LockRecursionException> unabhängig von die Rekursionsrichtlinie der Sperre wird ausgelöst werden.  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 Der folgende code verwendet dann die `SynchronizedCache` Objekt, das ein Wörterbuch von vegetable Namen gespeichert. Es werden drei Aufgaben erstellt. Die erste schreibt die Namen der Gemüse gespeichert, die in einem Array auf einem `SynchronizedCache` Instanz. Die zweite und dritte Aufgabe werden die Namen der Gemüse, die erste in aufsteigender Reihenfolge (von niedrigen Index hoher Index), das zweite in absteigender Reihenfolge anzeigen. Die letzte Aufgabe sucht nach der Zeichenfolge "Cucumber", und wenn es gefunden wird, ruft der <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> Methode, um die Zeichenfolge "grüne Bean" zu ersetzen.  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl von eindeutigen Threads ab, denen die Sperre im Lesemodus zugewiesen ist.</summary>
        <value>Die Anzahl von eindeutigen Threads, denen die Sperre im Lesemodus zugewiesen ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread wird nur einmal gezählt, auch wenn die Sperre lässt das Rekursion verwendet und der Thread wurde im Lesemodus mehrmals.  
  
 Verwenden Sie diese Eigenschaft nur für das Debuggen, profilerstellung und Protokollierungszwecken und nicht für das Verhalten eines Algorithmus steuern. Sobald sie berechnet worden sind, können die Ergebnisse ändern. Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> Eigenschaft, um einen Ereignisprotokolleintrag generiert, wenn die Anzahl der Threads im Lesemodus einen Schwellenwert überschreitet.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.ReaderWriterLockSlim" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> auf, wenn Sie <xref:System.Threading.ReaderWriterLockSlim> nicht mehr benötigen. Die <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>-Methode bewirkt, dass <xref:System.Threading.ReaderWriterLockSlim> nicht mehr verwendet werden kann. Nach dem Aufruf <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, Sie müssen alle Verweise auf Freigeben der <xref:System.Threading.ReaderWriterLockSlim> , damit der Garbage Collector den Arbeitsspeicher freigeben kann, die die <xref:System.Threading.ReaderWriterLockSlim> belegt wurde. Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> bereits vor der Veröffentlichung des letzten Verweis auf die <xref:System.Threading.ReaderWriterLockSlim> Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> ist größer als 0 (null).  
  
- oder -  
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> ist größer als 0 (null).  
  
- oder -  
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> ist größer als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, die Sperre im Lesemodus zu erhalten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert der aufrufende Thread die Sperre eintritt, und daher möglicherweise nie zurück. Verwenden der <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> Methode, um für ein angegebenes Intervall blockiert, und dann zurück, wenn der aufrufende Thread nicht im Lesemodus, während dieses Intervalls.  
  
 Mehrere Threads können Lesemodus zur gleichen Zeit eingeben.  
  
 Wenn ein oder mehrere Threads Schreibmodus warten, einen Thread aufruft der <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> Methode blockiert, bis diese Threads haben ein Timeout oder im Schreibmodus befindet und wieder beendet.  
  
> [!NOTE]
>  Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Lesemodus zugewiesen ist rekursiv, eingeben, auch wenn andere Threads Schreibmodus warten.  
  
 Höchstens ein Thread kann im erweiterbaren Modus sein, während andere Threads im schreibgeschützten Modus befinden. Wenn zusätzliche Threads den erweiterbaren Modus warten und es keine Threads sind Schreibmodus warten, threads diesen Aufruf der <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> Methode geben Sie im Lesemodus sofort und nicht blockieren.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> Methode, die Sperre im Lesemodus. Die Methode, die im Beispiel gezeigte Ruft ab, der Wert mit einem Schlüssel zugeordnet ist. Wenn der Schlüssel nicht die von der inneren Ausnahme gefunden wird, <xref:System.Collections.Generic.Dictionary%602> ist zulässig, um die Methode zu beenden. Ein `finally` Block wird zum Ausführen der <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> -Methode, um sicherzustellen, dass der Aufrufer den Lesemodus beendet.  
  
 Dieser Code ist Teil eines umfangreicheren Beispiels für die <xref:System.Threading.ReaderWriterLockSlim> Klasse.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist gleich <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat versucht, die Lesesperre zu erlangen, obwohl er die Lesesperre bereits besitzt.  
  
- oder -  
Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist gleich <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat versucht, die Lesesperre zu erlangen, obwohl er die Schreibsperre bereits besitzt.  
  
- oder -  
Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten. Dieser Grenzwert ist so groß, dass diese Ausnahme nie für Anwendungen auftreten sollte.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, die Sperre im erweiterbaren Modus zu erhalten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert der aufrufende Thread die Sperre eintritt, und daher möglicherweise nie zurück. Verwenden der <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> Methode, um den block für ein angegebenes Intervall aus, und klicken Sie dann zurück, wenn der aufrufende Thread nicht im erweiterbaren Modus während des Intervalls.  
  
 Erweiterbaren Modus verwenden, wenn ein Thread in der Regel die Ressource zugreift, die durch geschützt ist die <xref:System.Threading.ReaderWriterLockSlim> in im Lesemodus befindet, aber möglicherweise müssen Sie Schreibmodus eingeben, wenn bestimmte Bedingungen erfüllt sind. Ein Thread im erweiterbaren Modus kann Lesemodus oder den Schreibmodus.  
  
 Nur ein Thread kann im erweiterbaren Modus zu jedem Zeitpunkt eingeben. Wenn ein Thread im erweiterbaren Modus ist, und es keine Threads sind Schreibmodus warten, kann eine beliebige Anzahl von anderen Threads Lesemodus eingeben, auch wenn Threads, die den erweiterbaren Modus warten.  
  
 Wenn ein oder mehrere Threads Schreibmodus warten, einen Thread aufruft der <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> Methode blockiert, bis diese Threads haben ein Timeout oder im Schreibmodus befindet und wieder beendet.  
  
> [!NOTE]
>  Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im erweiterbaren Modus zugewiesen ist rekursiv im erweiterbaren Modus befindet, eingeben, auch wenn andere Threads Schreibmodus warten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> Methode, um die Sperre im erweiterbaren Modus erhalten hat. Ein `finally` Block wird zum Ausführen der <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> -Methode, um sicherzustellen, dass der Aufrufer den erweiterbaren Modus beendet.  
  
 Die Methode, die im Beispiel gezeigte Ruft den Wert, der einem Schlüssel zugeordnet und vergleicht ihn mit einem neuen Wert. Wenn der Wert unverändert ist, gibt die Methode einen Status, der angibt, der keine Änderung an. Sie keinen Wert für den Schlüssel gefunden wird, das Schlüssel/Wert-Paar eingefügt wird. Wenn der Wert geändert wurde, wird er aktualisiert. Im erweiterbaren Modus befindet, ermöglicht den Thread den Schreibmodus nach Bedarf, ohne das Risiko von Deadlocks.  
  
 Im Beispiel wird den Standardkonstruktor die Sperre zu erstellen, um die Rekursion nicht zulässig ist. Programmierung der <xref:System.Threading.ReaderWriterLockSlim> einfacher und weniger fehleranfällig ist, wenn die Sperre Rekursion nicht möglich ist.  
  
 Dieser Code ist Teil eines umfangreicheren Beispiels für die <xref:System.Threading.ReaderWriterLockSlim> Klasse.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und dem aktuellen Thread wurde die Sperre bereits in einem der Modi zugewiesen.  
  
- oder -  
Der aktuelle Thread befindet sich im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.  
  
- oder -  
Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, die Sperre im Schreibmodus zu erhalten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert der aufrufende Thread die Sperre eintritt, und daher möglicherweise nie zurück. Verwenden der <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> Methode, um für ein angegebenes Intervall blockieren und dann zurück, wenn sich der aufrufende Thread nicht im Schreibmodus während dieses Intervalls.  
  
 Wenn andere Threads die Sperre im Lesemodus zugewiesen haben, einen Thread, der Aufrufe der <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> Methode blockiert, bis die Threads beendet haben im Lesemodus befindet. Wenn Threads Schreibmodus warten, Timeout zusätzliche Threads, die versuchen, geben im Lesemodus oder im erweiterbaren Modus blockieren, bis alle Threads darauf warten, Schreibmodus haben oder im Schreibmodus befindet und wieder beendet.  
  
> [!NOTE]
>  Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Schreibmodus zugewiesen ist Sperre, eingeben, auch wenn andere Threads Schreibmodus warten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> Methode, um die Sperre im Schreibmodus. Die Methode, die im Beispiel gezeigt hinzugefügt den synchronisierten Cache neues Schlüssel/Wert-Paar. Wenn der Schlüssel bereits im Cache, der von der inneren Ausnahme <xref:System.Collections.Generic.Dictionary%602> ist zulässig, um die Methode zu beenden. Ein `finally` Block wird zum Ausführen der <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> -Methode, um sicherzustellen, dass der Aufrufer den Schreibmodus beendet.  
  
 Dieser Code ist Teil eines umfangreicheren Beispiels für die <xref:System.Threading.ReaderWriterLockSlim> Klasse.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und dem aktuellen Thread wurde die Sperre bereits in einem der Modi zugewiesen.  
  
- oder -  
Der aktuelle Thread befindet sich im Lesemodus und besitzt noch keine Schreibsperre, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.  
  
- oder -  
Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verringert die Rekursionszahl für den Lesemodus und beendet den Lesemodus, wenn das Rekursionsergebnis 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht die Rekursionsreihenfolge berücksichtigt. Z. B. wenn ein Thread eine im erweiterbaren Modus Sperre, und klicken Sie dann die Sperre im Lesemodus befindet, die Reihenfolge, in der der Thread beendet die beiden Modi wird, spielt keine Rolle. Wenn eine Sperre Rekursionen zulässt, kann ein Thread Geben Sie die Sperre im Schreibmodus und geben Sie es rekursiv im Lesemodus befindet; die Reihenfolge, in dem der Thread beendet wird, im Lesemodus befindet, und schreiben, ist nicht von Bedeutung.  
  
 Freigeben der Sperre kann andere wartende Threads zu signalisieren.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit einem `finally` Block zum Ausführen der <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> -Methode, um sicherzustellen, dass der Aufrufer den Lesemodus beendet. Die Methode, die im Beispiel gezeigte Ruft ab, der Wert mit einem Schlüssel zugeordnet ist. Wenn der Schlüssel nicht die von der inneren Ausnahme gefunden wird, <xref:System.Collections.Generic.Dictionary%602> ist zulässig, um die Methode zu beenden. Die <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> Methode wird verwendet, um den Lesemodus.  
  
 Dieser Code ist Teil eines umfangreicheren Beispiels für die <xref:System.Threading.ReaderWriterLockSlim> Klasse.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aktuelle Thread befindet sich nicht im Lesemodus.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verringert die Rekursionszahl für den erweiterbaren Modus und beendet den erweiterbaren Modus, wenn das Rekursionsergebnis 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht die Rekursionsreihenfolge berücksichtigt. Wenn ein Thread eine im erweiterbaren Modus Sperre, und klicken Sie dann die Sperre im Schreibmodus, spielt die Reihenfolge, in der die beiden Modi der Thread beendet wird z. B. keine Rolle. Wenn eine Sperre Rekursionen zulässt, kann ein Thread der Sperre im Schreibmodus und geben Sie es rekursiv im erweiterbaren Modus; die Reihenfolge, in der der Thread den erweiterbaren Modus und Write-Modus beendet, werden, spielt keine Rolle.  
  
 Freigeben der Sperre kann andere wartende Threads zu signalisieren.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit einem `finally` Block zum Ausführen der <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> -Methode, um sicherzustellen, dass der Aufrufer den erweiterbaren Modus beendet.  
  
 Die Methode, die im Beispiel gezeigte Ruft den Wert, der einem Schlüssel zugeordnet und vergleicht ihn mit einem neuen Wert. Wenn der Wert unverändert ist, gibt die Methode einen Status, der angibt, der keine Änderung an. Sie keinen Wert für den Schlüssel gefunden wird, das Schlüssel/Wert-Paar eingefügt wird. Wenn der Wert geändert wurde, wird er aktualisiert. Im erweiterbaren Modus befindet, ermöglicht den Thread den Schreibmodus nach Bedarf, ohne das Risiko von Deadlocks.  
  
 Im Beispiel wird den Standardkonstruktor die Sperre zu erstellen, um die Rekursion nicht zulässig ist. Programmierung der <xref:System.Threading.ReaderWriterLockSlim> einfacher und weniger fehleranfällig ist, wenn die Sperre Rekursion nicht möglich ist.  
  
 Dieser Code ist Teil eines umfangreicheren Beispiels für die <xref:System.Threading.ReaderWriterLockSlim> Klasse.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aktuelle Thread befindet sich nicht im erweiterbaren Modus.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verringert die Rekursionszahl für den Schreibmodus und beendet den Schreibmodus, wenn das Rekursionsergebnis 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht die Rekursionsreihenfolge berücksichtigt. Wenn ein Thread eine im erweiterbaren Modus Sperre, und klicken Sie dann die Sperre im Schreibmodus, spielt die Reihenfolge, in der die beiden Modi der Thread beendet wird z. B. keine Rolle. Wenn eine Sperre Rekursionen zulässt, kann ein Thread Geben Sie die Sperre im Schreibmodus und geben Sie es rekursiv im Lesemodus befindet; die Reihenfolge, in dem der Thread beendet wird, im Lesemodus befindet, und schreiben, ist nicht von Bedeutung.  
  
 Freigeben der Sperre kann andere wartende Threads zu signalisieren.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit einem `finally` Block zum Ausführen der <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> -Methode, um sicherzustellen, dass der Aufrufer den Schreibmodus beendet. Die Methode, die im Beispiel gezeigt hinzugefügt den synchronisierten Cache neues Schlüssel/Wert-Paar. Wenn der Schlüssel bereits im Cache, der von der inneren Ausnahme <xref:System.Collections.Generic.Dictionary%602> ist zulässig, um die Methode zu beenden. Die <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> Methode wird verwendet, um die Sperre im Schreibmodus.  
  
 Dieser Code ist Teil eines umfangreicheren Beispiels für die <xref:System.Threading.ReaderWriterLockSlim> Klasse.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aktuelle Thread befindet sich nicht im Schreibmodus.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im Lesemodus zugewiesen ist.</summary>
        <value><see langword="true" />, wenn sich der aktuelle Thread im Lesemodus befindet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft sollte für die Verwendung im Assert-Vorgänge oder für andere Zwecke Debuggen. Verwenden Sie es nicht um den Fluss der Ausführung des Programms zu steuern.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> Eigenschaft eine Bestätigung generiert, wenn der aktuelle Thread im Lesemodus unerwartet beendet.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im erweiterbaren Modus zugewiesen ist.</summary>
        <value><see langword="true" />, wenn sich der aktuelle Thread im erweiterbaren Modus befindet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft sollte für die Verwendung im Assert-Vorgänge oder für andere Zwecke Debuggen. Verwenden Sie es nicht um den Fluss der Ausführung des Programms zu steuern.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> Eigenschaft eine Bestätigung generiert, wenn der aktuelle Thread im erweiterbaren Modus unerwartet eingegeben hat.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im Schreibmodus zugewiesen ist.</summary>
        <value><see langword="true" />, wenn sich der aktuelle Thread im Schreibmodus befindet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft sollte für die Verwendung im Assert-Vorgänge oder für andere Zwecke Debuggen. Verwenden Sie es nicht um den Fluss der Ausführung des Programms zu steuern.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> Eigenschaft eine Bestätigung generiert, wenn der aktuelle Thread im Schreibmodus unerwartet eingegeben hat.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Rekursionsrichtlinie für das aktuelle <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt angibt.</summary>
        <value>Einer der Enumerationswerte, der die Rekursionsrichtlinie für die Sperre angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Rekursionsrichtlinie für die bestimmt, der Einschränkungen für Threads, die die Sperre mehr als einmal. Angenommen, eine Sperre mit erstellte <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> und ein Thread verfügt über die Sperre im Lesemodus <xref:System.Threading.LockRecursionException> wird ausgelöst, wenn der Thread versucht, die Sperre im Lesemodus anzufordern.  
  
> [!NOTE]
>  Ein Thread im erweiterbaren Modus kann den Schreibmodus oder unabhängig von der Einstellung Rekursion Lesemodus.  
  
 Unabhängig von die Rekursionsrichtlinie für die lesen ein Thread, der ursprünglich eingegebenen Modus darf nicht im erweiterbaren Modus oder im Schreibmodus befindet, aktualisieren, da dieses Muster eine hohe Wahrscheinlichkeit für Deadlocks erstellt.  
  
 Weitere Informationen zu die Rekursionsrichtlinie für die und die Auswirkungen, finden Sie unter den <xref:System.Threading.LockRecursionPolicy> Enumeration und die <xref:System.Threading.ReaderWriterLockSlim> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im Lesemodus zugewiesen ist.</summary>
        <value>0 (null) Wenn der aktuelle Thread nicht im Lesemodus befindet, 1, wenn der Thread im Lesemodus befindet, aber nicht angegeben, die rekursiv oder *n* Wenn sich der Thread die Sperre rekursiv *n* - 1 Mal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft nur für das Debuggen, profilerstellung und Protokollierungszwecken und nicht für das Verhalten eines Algorithmus steuern. Sobald sie berechnet worden sind, können die Ergebnisse ändern. Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im erweiterbaren Modus zugewiesen ist.</summary>
        <value>0, wenn sich der aktuelle Thread nicht im erweiterbaren Modus, 1, wenn der Thread im erweiterbaren Modus und verfügt über diesen nicht rekursiv oder *n* , wenn der Thread im erweiterbaren Modus-rekursiv angefordert hat *n* - 1 wie oft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft nur für das Debuggen, profilerstellung und Protokollierungszwecken und nicht für das Verhalten eines Algorithmus steuern. Sobald sie berechnet worden sind, können die Ergebnisse ändern. Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im Schreibmodus zugewiesen ist.</summary>
        <value>0, wenn sich der aktuelle Thread nicht im, 1, wenn der Thread im Schreibmodus befindet und nicht diesen rekursiv, Schreibmodus oder *n* , wenn der Thread die Sperre eingegeben hat *n* - 1 Mal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft nur für das Debuggen, profilerstellung und Protokollierungszwecken und nicht für das Verhalten eines Algorithmus steuern. Sobald sie berechnet worden sind, können die Ergebnisse ändern. Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, die Sperre im Lesemodus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<see cref="F:System.Threading.Timeout.Infinite" />), um unbegrenzt zu warten.</param>
        <summary>Versucht, die Sperre im Lesemodus zu erhalten. Optional wird ein ganzzahliger Timeout berücksichtigt.</summary>
        <returns><see langword="true" />, wenn der aufrufende Thread den Lesemodus erhalten hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` ist 0 (null), diese Methode überprüft den Sperrstatus und gibt `false` sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.  
  
 Mehrere Threads können Lesemodus zur gleichen Zeit eingeben.  
  
 Wenn ein oder mehrere Threads Schreibmodus warten, einen Thread aufruft der <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> Methode blockiert, bis diese Threads müssen entweder ein Timeout oder im Schreibmodus befindet und wieder beendet, oder bis zum Ablauf des Timeoutintervalls des aufrufenden Threads.  
  
> [!NOTE]
>  Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Lesemodus zugewiesen ist rekursiv, eingeben, auch wenn andere Threads Schreibmodus warten.  
  
 Während andere Threads befinden sich im Lesemodus befindet, kann ein Thread im erweiterbaren Modus befinden. Wenn zusätzliche Threads den erweiterbaren Modus warten und es keine Threads sind Schreibmodus warten, threads diesen Aufruf der <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> Methode geben Sie im Lesemodus sofort und nicht blockieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  
  
- oder -  
Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ, aber ungleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1), der den einzigen zulässigen negativen Wert darstellt.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</param>
        <summary>Versucht, die Sperre im Lesemodus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
        <returns><see langword="true" />, wenn der aufrufende Thread den Lesemodus erhalten hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` ist 0 (null), diese Methode überprüft den Sperrstatus und gibt `false` sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.  
  
 Mehrere Threads können die Sperre im Lesemodus zur gleichen Zeit eingeben.  
  
 Wenn ein oder mehrere Threads auf Schreibmodus eine, einen Thread aufruft der <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> Methode blockiert, bis diese Threads müssen entweder ein Timeout oder im Schreibmodus befindet und wieder beendet, oder bis zum Ablauf des Timeoutintervalls des aufrufenden Threads.  
  
> [!NOTE]
>  Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Lesemodus zugewiesen ist rekursiv, eingeben, auch wenn andere Threads Schreibmodus warten.  
  
 Während andere Threads befinden sich im Lesemodus befindet, kann ein Thread im erweiterbaren Modus befinden. Wenn zusätzliche Threads den erweiterbaren Modus warten und es keine Threads sind Schreibmodus warten, threads diesen Aufruf der <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> Methode geben Sie im Lesemodus sofort und nicht blockieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  
  
- oder -  
Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)  
  
- oder -  
Der Wert von <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, die Sperre im erweiterbaren Modus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<see cref="F:System.Threading.Timeout.Infinite" />), um unbegrenzt zu warten.</param>
        <summary>Versucht, die Sperre im erweiterbaren Modus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
        <returns><see langword="true" />, wenn der aufrufende Thread den erweiterbaren Modus erhalten hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` ist 0 (null), diese Methode überprüft den Sperrstatus und gibt `false` sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.  
  
 Erweiterbaren Modus verwenden, wenn ein Thread in der Regel die Ressource zugreift, die durch geschützt ist die <xref:System.Threading.ReaderWriterLockSlim> in im Lesemodus befindet, aber möglicherweise müssen Sie Schreibmodus eingeben, wenn bestimmte Bedingungen erfüllt sind. Ein Thread im erweiterbaren Modus kann den Schreibmodus oder Lesemodus.  
  
 Nur ein Thread kann eine Sperre im erweiterbaren Modus zu einem bestimmten Zeitpunkt eingeben. Wenn ein Thread im erweiterbaren Modus ist, und es keine Threads sind Schreibmodus warten, kann eine beliebige Anzahl von anderen Threads Lesemodus eingeben, auch wenn Threads, die den erweiterbaren Modus warten.  
  
 Wenn ein oder mehrere Threads Schreibmodus warten, einen Thread aufruft der <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> Methode blockiert, bis diese Threads müssen entweder ein Timeout oder im Schreibmodus befindet und wieder beendet, oder bis zum Ablauf des Timeoutintervalls des aufrufenden Threads.  
  
> [!NOTE]
>  Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im erweiterbaren Modus zugewiesen ist rekursiv im erweiterbaren Modus befindet, eingeben, auch wenn andere Threads Schreibmodus warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  
  
- oder -  
Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.  
  
- oder -  
Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ, aber ungleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1), der den einzigen zulässigen negativen Wert darstellt.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</param>
        <summary>Versucht, die Sperre im erweiterbaren Modus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
        <returns><see langword="true" />, wenn der aufrufende Thread den erweiterbaren Modus erhalten hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` ist 0 (null), diese Methode überprüft den Sperrstatus und gibt `false` sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.  
  
 Erweiterbaren Modus verwenden, wenn ein Thread, die durch geschützte Ressource in der Regel greift auf die <xref:System.Threading.ReaderWriterLockSlim> in im Lesemodus befindet, aber möglicherweise müssen Sie Schreibmodus eingeben, wenn bestimmte Bedingungen erfüllt sind. Ein Thread im erweiterbaren Modus kann den Schreibmodus oder Lesemodus.  
  
 Nur ein Thread kann eine Sperre im erweiterbaren Modus zu einem bestimmten Zeitpunkt eingeben. Wenn ein Thread im erweiterbaren Modus ist, und es keine Threads sind Schreibmodus warten, kann eine beliebige Anzahl von anderen Threads Lesemodus eingeben, auch wenn Threads, die den erweiterbaren Modus warten.  
  
 Wenn ein oder mehrere Threads Schreibmodus warten, einen Thread aufruft der <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> Methode blockiert, bis diese Threads müssen entweder ein Timeout oder im Schreibmodus befindet und wieder beendet, oder bis zum Ablauf des Timeoutintervalls des aufrufenden Threads.  
  
> [!NOTE]
>  Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im erweiterbaren Modus zugewiesen ist rekursiv im erweiterbaren Modus befindet, eingeben, auch wenn andere Threads Schreibmodus warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  
  
- oder -  
Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.  
  
- oder -  
Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)  
  
- oder -  
Der Wert von <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, die Sperre im Schreibmodus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<see cref="F:System.Threading.Timeout.Infinite" />), um unbegrenzt zu warten.</param>
        <summary>Versucht, die Sperre im Schreibmodus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
        <returns><see langword="true" />, wenn der aufrufende Thread den Schreibmodus erhalten hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` ist 0 (null), diese Methode überprüft den Sperrstatus und gibt `false` sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.  
  
 Wenn andere Threads die Sperre im Lesemodus zugewiesen haben, einen Thread, der Aufrufe der <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> Methode blockiert, bis die Threads im Lesemodus beendet haben, oder bis das Timeoutintervall abgelaufen ist. Während Threads blockiert sind Schreibmodus warten, blockiert zusätzliche Threads, die versuchen, den schreibgeschützten Modus oder im erweiterbaren Modus befindet, geben, bis alle Threads darauf warten, geben den Schreibmodus, entweder ein Timeout oder im Schreibmodus befindet und wieder beendet.  
  
> [!NOTE]
>  Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Schreibmodus zugewiesen ist Sperre, eingeben, auch wenn andere Threads Schreibmodus warten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> Methode, die Sperre im Schreibmodus, mit einem Timeout. Die Methode, die im Beispiel gezeigt hinzugefügt den synchronisierten Cache neues Schlüssel/Wert-Paar. Die Methode gibt zurück, wenn das angegebene Timeoutintervall abläuft, bevor der Thread die Sperre eintritt, `false`. Gibt die Methode zurück `true` Wenn Schlüssel/Wert-Paar hinzugefügt wird.  
  
 Wenn der Schlüssel bereits im Cache, der von der inneren Ausnahme <xref:System.Collections.Generic.Dictionary%602> ist zulässig, um die Methode zu beenden. Ein `finally` Block wird zum Ausführen der <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> -Methode, um sicherzustellen, dass der Aufrufer die Sperre wieder freigibt.  
  
 Dieser Code ist Teil eines umfangreicheren Beispiels für die <xref:System.Threading.ReaderWriterLockSlim> Klasse.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  
  
- oder -  
Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.  
  
- oder -  
Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ, aber ungleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1), der den einzigen zulässigen negativen Wert darstellt.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</param>
        <summary>Versucht, die Sperre im Schreibmodus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
        <returns><see langword="true" />, wenn der aufrufende Thread den Schreibmodus erhalten hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` ist 0 (null), diese Methode überprüft den Sperrstatus und gibt `false` sofort, wenn Sie der gewünschte Zustand nicht verfügbar ist.  
  
 Wenn andere Threads die Sperre im Lesemodus zugewiesen haben, einen Thread, der Aufrufe der <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> Methode blockiert, bis die Threads im Lesemodus beendet haben, oder bis das Timeoutintervall abgelaufen ist. Während Threads blockiert sind Schreibmodus warten, blockiert zusätzliche Threads, die versuchen, den schreibgeschützten Modus oder im erweiterbaren Modus befindet, geben, bis alle Threads darauf warten, geben den Schreibmodus, entweder ein Timeout oder im Schreibmodus befindet und wieder beendet.  
  
> [!NOTE]
>  Wenn eine Sperre Rekursionen zulässt, kann ein Thread, der die Sperre im Schreibmodus zugewiesen ist Sperre, eingeben, auch wenn andere Threads Schreibmodus warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  
  
- oder -  
Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.  
  
- oder -  
Die Anzahl von Rekursionen würde die Kapazität des Zählers überschreiten. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)  
  
- oder -  
Der Wert von <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung der Sperre im Lesemodus warten.</summary>
        <value>Die Gesamtzahl von Threads, die auf eine Zuweisung des Lesemodus warten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft nur für das Debuggen, profilerstellung und Protokollierungszwecken und nicht für das Verhalten eines Algorithmus steuern. Sobald sie berechnet worden sind, können die Ergebnisse ändern. Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> Eigenschaft, um einen Ereignisprotokolleintrag generiert, wenn die Anzahl der Threads, die darauf warten, Lesemodus blockiert werden, um einen Schwellenwert überschreitet.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung der Sperre im erweiterbaren Modus warten.</summary>
        <value>Die Gesamtzahl von Threads, die auf eine Zuweisung des erweiterbaren Modus warten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft nur für das Debuggen, profilerstellung und Protokollierungszwecken und nicht für das Verhalten eines Algorithmus steuern. Sobald sie berechnet worden sind, können die Ergebnisse ändern. Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> Eigenschaft, um einen Ereignisprotokolleintrag generiert, wenn die Anzahl der Threads, die darauf warten, erweiterbaren Modus blockiert werden, um einen Schwellenwert überschreitet.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung der Sperre im Schreibmodus warten.</summary>
        <value>Die Gesamtzahl von Threads, die auf eine Zuweisung des Schreibmodus warten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft nur für das Debuggen, profilerstellung und Protokollierungszwecken und nicht für das Verhalten eines Algorithmus steuern. Sobald sie berechnet worden sind, können die Ergebnisse ändern. Aus diesem Grund ist es nicht sicher für Entscheidungen basierend auf dieser Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> Eigenschaft, um einen Ereignisprotokolleintrag generiert, wenn die Anzahl der Threads, die darauf warten, Schreibmodus, blockiert werden, um einen Schwellenwert überschreitet.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>