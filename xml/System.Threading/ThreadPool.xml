<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b87f69a5dd9c6aca60dbefb92ca706cd5c1ff31c" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77233656" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="0d330-101">Stellt einen Threadpool bereit, der verwendet werden kann, um Aufgaben auszuführen, Arbeitselemente bereitzustellen, asynchrone E/A zu verarbeiten, im Auftrag anderer Threads zu warten und Zeitgeber zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="0d330-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-102">Viele Anwendungen erstellen Threads, die sehr viel Zeit in den Ruhezustand investieren und auf das Eintreten eines Ereignisses warten.</span><span class="sxs-lookup"><span data-stu-id="0d330-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="0d330-103">Andere Threads können nur dann in den Ruhezustand versetzt werden, wenn Sie regelmäßig aktiviert werden, um eine Änderung oder Update Statusinformationen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="0d330-104">Der Thread Pool ermöglicht es Ihnen, Threads effizienter zu verwenden, indem Sie der Anwendung einen Pool von Arbeitsthreads bereitstellen, die vom System verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="0d330-105">Beispiele für Vorgänge, die Thread Pool-Threads verwenden, sind die folgenden:</span><span class="sxs-lookup"><span data-stu-id="0d330-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="0d330-106">Wenn Sie eine <xref:System.Threading.Tasks.Task> oder <xref:System.Threading.Tasks.Task%601> Objekt erstellen, um eine Aufgabe asynchron auszuführen, wird der Task standardmäßig für die Ausführung in einem Thread Pool Thread eingeplant.</span><span class="sxs-lookup"><span data-stu-id="0d330-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="0d330-107">Asynchrone Timer verwenden den Thread Pool.</span><span class="sxs-lookup"><span data-stu-id="0d330-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="0d330-108">Thread Pool-Threads führen Rückrufe aus der <xref:System.Threading.Timer?displayProperty=nameWithType>-Klasse aus und rufen Ereignisse aus der <xref:System.Timers.Timer?displayProperty=nameWithType>-Klasse auf.</span><span class="sxs-lookup"><span data-stu-id="0d330-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="0d330-109">Wenn Sie registrierte Wait-Handles verwenden, überwacht ein System Thread den Status der Wait-Handles.</span><span class="sxs-lookup"><span data-stu-id="0d330-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="0d330-110">Wenn ein warte Vorgang abgeschlossen ist, führt ein Arbeits Thread aus dem Thread Pool die entsprechende Rückruffunktion aus.</span><span class="sxs-lookup"><span data-stu-id="0d330-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="0d330-111">Wenn Sie die <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>-Methode aufzurufen, um eine Methode zur Ausführung in einem Thread Pool Thread in die Warteschlange zu stellen</span><span class="sxs-lookup"><span data-stu-id="0d330-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="0d330-112">Dies erreichen Sie, indem Sie die-Methode an einen <xref:System.Threading.WaitCallback> Delegaten übergeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="0d330-113">Der Delegat hat die Signatur.</span><span class="sxs-lookup"><span data-stu-id="0d330-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="0d330-114">Dabei ist `state` ein Objekt, das Daten enthält, die vom Delegaten verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="0d330-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="0d330-115">Die tatsächlichen Daten können durch Aufrufen der <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>-Methode an den Delegaten übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0d330-116">Bei den Threads im verwalteten Thread Pool handelt es sich um Hintergrundthreads.</span><span class="sxs-lookup"><span data-stu-id="0d330-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="0d330-117">Das heißt, ihre <xref:System.Threading.Thread.IsBackground%2A> Eigenschaften werden `true`.</span><span class="sxs-lookup"><span data-stu-id="0d330-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="0d330-118">Dies bedeutet, dass ein <xref:System.Threading.ThreadPool> Thread die Ausführung einer Anwendung nicht aufrecht erhält, nachdem alle Vordergrundthreads beendet wurden.</span><span class="sxs-lookup"><span data-stu-id="0d330-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0d330-119">Wenn der Thread Pool einen Thread wieder verwendet, löscht er nicht die Daten im lokalen Thread Speicher oder in Feldern, die mit dem <xref:System.ThreadStaticAttribute>-Attribut markiert sind.</span><span class="sxs-lookup"><span data-stu-id="0d330-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="0d330-120">Wenn eine Methode z. b. Thread lokalen Speicher oder Felder überprüft, die mit dem <xref:System.ThreadStaticAttribute>-Attribut gekennzeichnet sind, können die gefundenen Werte von einer früheren Verwendung des Thread Pool Threads ausgelassen werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="0d330-121">Sie können auch Arbeitselemente in die Warteschlange stellen, die nicht mit einem warte Vorgang im Thread Pool verknüpft sind.</span><span class="sxs-lookup"><span data-stu-id="0d330-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="0d330-122">Um anzufordern, dass ein Arbeits Element von einem Thread im Thread Pool behandelt werden soll, müssen Sie die <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="0d330-123">Diese Methode verwendet als Parameter einen Verweis auf die Methode oder den Delegaten, die von dem aus dem Thread Pool ausgewählten Thread aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="0d330-124">Es gibt keine Möglichkeit, ein Arbeits Element abzubrechen, nachdem es in die Warteschlange eingereiht wurde.</span><span class="sxs-lookup"><span data-stu-id="0d330-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="0d330-125">Timer-Queue-Timer und registrierte warte Vorgänge verwenden ebenfalls den Thread Pool.</span><span class="sxs-lookup"><span data-stu-id="0d330-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="0d330-126">Die Rückruf Funktionen werden in die Warteschlange des Thread Pools eingereiht.</span><span class="sxs-lookup"><span data-stu-id="0d330-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="0d330-127">Es gibt einen Thread Pool pro Prozess.</span><span class="sxs-lookup"><span data-stu-id="0d330-127">There is one thread pool per process.</span></span> <span data-ttu-id="0d330-128">Ab [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ist die Standardgröße des Threadpools für einen Prozess von mehreren Faktoren abhängig, z. B. von der Größe des virtuellen Adressraums.</span><span class="sxs-lookup"><span data-stu-id="0d330-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="0d330-129">Ein Prozess kann die <xref:System.Threading.ThreadPool.GetMaxThreads%2A>-Methode aufrufen, um die Anzahl der Threads zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="0d330-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="0d330-130">Die Anzahl der Threads im Thread Pool kann mithilfe der <xref:System.Threading.ThreadPool.SetMaxThreads%2A>-Methode geändert werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="0d330-131">Jeder Thread verwendet die Standard Stapelgröße und wird mit der Standardpriorität ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="0d330-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0d330-132">Nicht verwalteter Code, der den .NET Framework hostet, kann die Größe des Thread Pools mithilfe der `CorSetMaxThreads`-Funktion ändern, die in der Datei "mscoree. h" definiert ist.</span><span class="sxs-lookup"><span data-stu-id="0d330-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="0d330-133">Der Thread Pool stellt bei Bedarf neue Arbeitsthreads oder e/a-abschlusthreads bereit, bis die Mindestanzahl für jede Kategorie erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="0d330-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="0d330-134">Wenn ein Minimalwert erreicht wird, kann der Thread Pool zusätzliche Threads in dieser Kategorie erstellen oder warten, bis einige Tasks beendet wurden.</span><span class="sxs-lookup"><span data-stu-id="0d330-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="0d330-135">Ab [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] erstellt und zerstört der Threadpool Arbeitsthreads, um den Durchsatz zu optimieren. Der Durchsatz ist als die Anzahl der Aufgaben definiert, die pro Zeiteinheit abgeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="0d330-136">Bei zu wenigen Threads werden die verfügbaren Ressourcen möglicherweise nicht optimal genutzt, wohingegen bei zu vielen Threads Ressourcenkonflikte auftreten können.</span><span class="sxs-lookup"><span data-stu-id="0d330-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0d330-137">Wenn die Anforderungen niedrig sind, kann die tatsächliche Anzahl der Threads im Threadpool unterhalb der Mindestwerte liegen.</span><span class="sxs-lookup"><span data-stu-id="0d330-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="0d330-138">Sie können die <xref:System.Threading.ThreadPool.GetMinThreads%2A>-Methode verwenden, um diese Mindestwerte abzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0d330-139">Sie können die <xref:System.Threading.ThreadPool.SetMinThreads%2A>-Methode verwenden, um die Mindestanzahl von Threads zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="0d330-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="0d330-140">Allerdings kann ein unnötiges Erhöhen dieses Wertes zu Leistungsproblemen führen.</span><span class="sxs-lookup"><span data-stu-id="0d330-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="0d330-141">Wenn zu viele Aufgaben gleichzeitig gestartet werden, werden möglicherweise alle Aufgaben zu langsam ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="0d330-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="0d330-142">In den meisten Fällen erreicht der Threadpool mit dem eigenen Algorithmus für die Zuordnung von Threads eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="0d330-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0d330-143">Im folgenden Beispiel fügt der Haupt Anwendungs Thread eine Methode mit dem Namen `ThreadProc` in die Warteschlange ein, um Sie in einem Thread Pool Thread auszuführen, in einer Sekunde zu warten und dann beendet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="0d330-144">Die `ThreadProc`-Methode zeigt einfach eine Meldung an.</span><span class="sxs-lookup"><span data-stu-id="0d330-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="0d330-145">Wenn Sie den <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode aufzurufen, wird der Haupt Thread beendet, bevor die-Methode im Thread Pool Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="0d330-146">Der Thread Pool verwendet Hintergrundthreads, bei denen die Anwendung nicht ausgeführt wird, wenn alle Vordergrundthreads beendet wurden.</span><span class="sxs-lookup"><span data-stu-id="0d330-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="0d330-147">(Dies ist ein einfaches Beispiel für eine Racebedingung.)</span><span class="sxs-lookup"><span data-stu-id="0d330-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="0d330-148">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="0d330-148">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="0d330-149">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="0d330-149">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-150">Das verwaltete Thread Pooling</span><span class="sxs-lookup"><span data-stu-id="0d330-150">The Managed Thread Pooling</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0d330-151">Bindet ein Betriebssystemhandle an den <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-151">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="0d330-152">Ein <see cref="T:System.IntPtr" />, das den Handle enthält.</span><span class="sxs-lookup"><span data-stu-id="0d330-152">An <see cref="T:System.IntPtr" /> that holds the handle.</span></span> <span data-ttu-id="0d330-153">Das Handle muss für überlappende E/A auf der nicht verwalteten Seite geöffnet worden sein.</span><span class="sxs-lookup"><span data-stu-id="0d330-153">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="0d330-154">Bindet ein Betriebssystemhandle an den <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-154">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="0d330-155"><see langword="true" />, wenn das Handle gebunden ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-155"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0d330-156">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="0d330-156">The caller does not have the required permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="0d330-157">Ein <see cref="T:System.Runtime.InteropServices.SafeHandle" />, das das Betriebssystemhandle enthält.</span><span class="sxs-lookup"><span data-stu-id="0d330-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span></span> <span data-ttu-id="0d330-158">Das Handle muss für überlappende E/A auf der nicht verwalteten Seite geöffnet worden sein.</span><span class="sxs-lookup"><span data-stu-id="0d330-158">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="0d330-159">Bindet ein Betriebssystemhandle an den <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-159">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="0d330-160"><see langword="true" />, wenn das Handle gebunden ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-160"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-161">Der `osHandle`-Parameter sollte ein <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>sein, der von der abstrakten <xref:System.Runtime.InteropServices.SafeHandle>-Klasse abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-161">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d330-162"><paramref name="osHandle" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-162"><paramref name="osHandle" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CompletedWorkItemCount">
      <MemberSignature Language="C#" Value="public static long CompletedWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 CompletedWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long CompletedWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedWorkItemCount : int64" Usage="System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0d330-163">Ruft die Anzahl der Arbeitselemente ab, die bisher verarbeitet wurden.</span><span class="sxs-lookup"><span data-stu-id="0d330-163">Gets the number of work items that have been processed so far.</span></span></summary>
        <value><span data-ttu-id="0d330-164">Die Anzahl der bisher verarbeiteten Arbeitselemente.</span><span class="sxs-lookup"><span data-stu-id="0d330-164">The number of work items that have been processed so far.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="0d330-165">Wenn eine Thread Pool Implementierung verschiedene Typen von Arbeitsaufgaben aufweisen kann, enthält die Anzahl alle Typen.</span><span class="sxs-lookup"><span data-stu-id="0d330-165">If a thread pool implementation may have different types of work items, the count includes all types.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="0d330-166">Die Anzahl der verfügbaren Arbeitsthreads.</span><span class="sxs-lookup"><span data-stu-id="0d330-166">The number of available worker threads.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="0d330-167">Die Anzahl der verfügbaren asynchronen E/A-Threads.</span><span class="sxs-lookup"><span data-stu-id="0d330-167">The number of available asynchronous I/O threads.</span></span></param>
        <summary><span data-ttu-id="0d330-168">Ruft die Differenz zwischen der von der <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />-Methode zurückgegebenen maximalen Anzahl der Threads im Threadpool und der Anzahl der gerade aktiven Threads ab.</span><span class="sxs-lookup"><span data-stu-id="0d330-168">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-169">Wenn <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> zurückgibt, enthält die durch `workerThreads` angegebene Variable die Anzahl zusätzlicher Arbeitsthreads, die gestartet werden können, und die durch `completionPortThreads` angegebene Variable enthält die Anzahl der zusätzlichen asynchronen e/a-Threads, die gestartet werden können.</span><span class="sxs-lookup"><span data-stu-id="0d330-169">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="0d330-170">Wenn keine Threads verfügbar sind, verbleiben zusätzliche Thread Pool Anforderungen in der Warteschlange, bis die Threads des Thread Pools verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="0d330-170">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0d330-171">Im folgenden Beispiel wird die Anzahl der Arbeitsthreads und e/a-Threads angezeigt, die verfügbar sind, wenn eine einfache APP gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-171">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="0d330-172">Die maximale Anzahl der Arbeitsthreads im Threadpool.</span><span class="sxs-lookup"><span data-stu-id="0d330-172">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="0d330-173">Die maximale Anzahl asynchroner E/A-Threads im Threadpool.</span><span class="sxs-lookup"><span data-stu-id="0d330-173">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="0d330-174">Ruft die Anzahl der Anforderungen für den Threadpool ab, die gleichzeitig aktiv sein können.</span><span class="sxs-lookup"><span data-stu-id="0d330-174">Retrieves the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="0d330-175">Alle über diese Zahl hinausgehenden Anforderungen bleiben in der Warteschlange, bis die Threads des Threadpools verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="0d330-175">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-176">Wenn <xref:System.Threading.ThreadPool.GetMaxThreads%2A> zurückgibt, enthält die durch `workerThreads` angegebene Variable die maximal zulässige Anzahl von Arbeitsthreads im Thread Pool, und die durch `completionPortThreads` angegebene Variable enthält die maximale Anzahl von asynchronen e/a-Threads, die im Thread Pool zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="0d330-176">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="0d330-177">Sie können die <xref:System.Threading.ThreadPool.GetAvailableThreads%2A>-Methode verwenden, um die tatsächliche Anzahl der Threads im Thread Pool zu einem beliebigen Zeitpunkt zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="0d330-177">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="0d330-178">Sie können den <xref:System.Threading.ThreadPool.SetMaxThreads%2A> verwenden, um die maximale Anzahl von Arbeitsthreads und asynchronen e/a-Threads im Thread Pool festzulegen.</span><span class="sxs-lookup"><span data-stu-id="0d330-178">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="0d330-179">Sie können so viele Thread Pool Anforderungen in die Warteschlange stellen, wie der Systemspeicher zulässt.</span><span class="sxs-lookup"><span data-stu-id="0d330-179">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="0d330-180">Wenn mehr Anforderungen als Thread Pool-Threads vorhanden sind, verbleiben die zusätzlichen Anforderungen in der Warteschlange, bis die Threads des Thread Pools verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="0d330-180">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0d330-181">Im folgenden Codebeispiel wird gezeigt, wie die Anzahl der maximalen und verfügbaren Threads im Thread Pool abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-181">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="0d330-182">Ein Arbeits Element wird in die Warteschlange eingereiht, das `FileStream` verwendet, um asynchron in zwei Dateien zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="0d330-182">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="0d330-183">Die Rückruf Methoden werden zeitlich überlappt.</span><span class="sxs-lookup"><span data-stu-id="0d330-183">The callback methods are timed to overlap.</span></span> <span data-ttu-id="0d330-184">Ein Arbeits Thread verarbeitet die Arbeitsaufgabe, und in Abhängigkeit von der Geschwindigkeit und der Anzahl der Prozessoren auf dem Computer werden die Schreibvorgänge von einem oder zwei Beendigungs Port Threads verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="0d330-184">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="0d330-185">Enthält nach der Rückgabe dieser Methode die Mindestanzahl von Arbeitsthreads, die der Threadpool bei Bedarf erstellt.</span><span class="sxs-lookup"><span data-stu-id="0d330-185">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="0d330-186">Enthält nach der Rückgabe dieser Methode die Mindestanzahl von asynchronen E/A-Threads, die der Threadpool bei Bedarf erstellt.</span><span class="sxs-lookup"><span data-stu-id="0d330-186">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="0d330-187">Ruft die Mindestanzahl von Threads ab, die der Threadpool bei Bedarf erstellt, wenn neue Anforderungen gestellt werden, bevor zu einem Algorithmus zum Verwalten von Threaderstellung und -löschung gewechselt wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-187">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-188">Der Thread Pool stellt bei Bedarf neue Arbeitsthreads oder e/a-abschlusthreads bereit, bis die Mindestanzahl für jede Kategorie erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="0d330-188">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="0d330-189">Standardmäßig entspricht die minimale Anzahl von Threads der Anzahl von Prozessoren in einem System.</span><span class="sxs-lookup"><span data-stu-id="0d330-189">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="0d330-190">Wenn der Minimalwert erreicht wird, kann der Thread Pool zusätzliche Threads in dieser Kategorie erstellen oder warten, bis einige Tasks beendet wurden.</span><span class="sxs-lookup"><span data-stu-id="0d330-190">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="0d330-191">Beginnend mit dem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]erstellt und zerstört der Thread Pool Threads, um den Durchsatz zu optimieren, der als die Anzahl der Aufgaben definiert ist, die pro Zeiteinheit ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-191">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="0d330-192">Bei zu wenigen Threads werden die verfügbaren Ressourcen möglicherweise nicht optimal genutzt, wohingegen bei zu vielen Threads Ressourcenkonflikte auftreten können.</span><span class="sxs-lookup"><span data-stu-id="0d330-192">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0d330-193">Wenn die Anforderungen niedrig sind, kann die tatsächliche Anzahl der Threads im Threadpool unterhalb der Mindestwerte liegen.</span><span class="sxs-lookup"><span data-stu-id="0d330-193">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0d330-194">Im folgenden Beispiel wird die Mindestanzahl von Arbeitsthreads auf vier festgelegt, und der ursprüngliche Wert für die Mindestanzahl von asynchronen e/a-abschlusthreads wird beibehalten.</span><span class="sxs-lookup"><span data-stu-id="0d330-194">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="PendingWorkItemCount">
      <MemberSignature Language="C#" Value="public static long PendingWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 PendingWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PendingWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long PendingWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PendingWorkItemCount : int64" Usage="System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0d330-195">Ruft die Anzahl von Arbeitselementen ab, die sich derzeit in der Verarbeitungswarteschlange befinden.</span><span class="sxs-lookup"><span data-stu-id="0d330-195">Gets the number of work items that are currently queued to be processed.</span></span></summary>
        <value><span data-ttu-id="0d330-196">Die Anzahl der Arbeitsaufgaben, die derzeit zur Verarbeitung in die Warteschlange eingereiht werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-196">The number of work items that are currently queued to be processed.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="0d330-197">Wenn eine Thread Pool Implementierung verschiedene Typen von Arbeitsaufgaben aufweisen kann, schließt die Anzahl alle Typen ein, die nachverfolgt werden können. Dies sind möglicherweise nur die Arbeitsaufgaben des Benutzers, einschließlich der Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="0d330-197">If a thread pool implementation may have different types of work items, the count includes all types that can be tracked, which may only be the user work items, including tasks.</span></span> <span data-ttu-id="0d330-198">Einige Implementierungen können auch Zeit Geber in der Warteschlange und warte Rückrufe in der Anzahl enthalten.</span><span class="sxs-lookup"><span data-stu-id="0d330-198">Some implementations may also include queued timer and wait callbacks in the count.</span></span> <span data-ttu-id="0d330-199">Unter Windows enthält die Anzahl wahrscheinlich nicht die Anzahl der ausstehenden e/a-Vervollständigungen, da Sie direkt an einen e/a-Abschlussport gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-199">On Windows, the count is unlikely to include the number of pending IO completions, because they are posted directly to an IO completion port.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0d330-200">Fügt der Warteschlange eine auszuführende Methode hinzu.</span><span class="sxs-lookup"><span data-stu-id="0d330-200">Queues a method for execution.</span></span> <span data-ttu-id="0d330-201">Die Methode wird ausgeführt, wenn ein Thread des Threadpools verfügbar wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-201">The method executes when a thread pool thread becomes available.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="0d330-202">Ein <see cref="T:System.Threading.WaitCallback" />, der die auszuführende Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="0d330-202">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span></span></param>
        <summary><span data-ttu-id="0d330-203">Fügt der Warteschlange eine auszuführende Methode hinzu.</span><span class="sxs-lookup"><span data-stu-id="0d330-203">Queues a method for execution.</span></span> <span data-ttu-id="0d330-204">Die Methode wird ausgeführt, wenn ein Thread des Threadpools verfügbar wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-204">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="0d330-205"><see langword="true" />, wenn die Methode erfolgreich in die Warteschlange eingereiht wurde. <see cref="T:System.NotSupportedException" /> wird ausgelöst, wenn das Arbeitselement nicht in die Warteschlange eingereiht werden konnte.</span><span class="sxs-lookup"><span data-stu-id="0d330-205"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-206">Sie können Daten, die von der in der Warteschlange befindlichen Methode benötigt werden, in die Instanzfelder der Klasse platzieren, in der die Methode definiert ist, oder Sie können die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> Überladung verwenden, die ein Objekt akzeptiert, das die erforderlichen Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="0d330-206">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0d330-207">Visual Basic Benutzer den <xref:System.Threading.WaitCallback>-Konstruktor weglassen und einfach den `AddressOf`-Operator verwenden können, wenn Sie die Rückruf Methode an <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>übergeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-207">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="0d330-208">Visual Basic ruft automatisch den richtigen Delegatkonstruktor auf.</span><span class="sxs-lookup"><span data-stu-id="0d330-208">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="0d330-209">Versionsinformationen</span><span class="sxs-lookup"><span data-stu-id="0d330-209">Version Information</span></span>  
 <span data-ttu-id="0d330-210">In der .NET Framework Version 2,0 wird der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>-Eigenschafts Wert mithilfe der <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>-Methode an Arbeitsthreads weitergegeben, die in Warteschlangen eingereiht wurden</span><span class="sxs-lookup"><span data-stu-id="0d330-210">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="0d330-211">In früheren Versionen werden die Prinzipal Informationen nicht weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-211">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0d330-212">Im folgenden Beispiel wird die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29>-Methoden Überladung verwendet, um eine Aufgabe, die durch die `ThreadProc`-Methode dargestellt wird, in die Warteschlange zu stellen, wenn ein Thread verfügbar wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-212">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="0d330-213">Mit dieser Überladung werden keine Task Informationen bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="0d330-213">No task information is supplied with this overload.</span></span> <span data-ttu-id="0d330-214">Daher sind die Informationen, die für die `ThreadProc`-Methode verfügbar sind, auf das Objekt beschränkt, zu dem die Methode gehört.</span><span class="sxs-lookup"><span data-stu-id="0d330-214">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d330-215"><paramref name="callBack" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-215"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0d330-216">Die Common Language Runtime (CLR) wird gehostet, und der Host unterstützt diese Aktion nicht.</span><span class="sxs-lookup"><span data-stu-id="0d330-216">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-217">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="0d330-217">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="0d330-218">Ein <see cref="T:System.Threading.WaitCallback" />, der die auszuführende Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="0d330-218">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-219">Ein Objekt, das die von der Methode zu verwendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="0d330-219">An object containing data to be used by the method.</span></span></param>
        <summary><span data-ttu-id="0d330-220">Fügt der Warteschlange eine auszuführende Methode hinzu und gibt ein Objekt an, das die von der Methode zu verwendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="0d330-220">Queues a method for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="0d330-221">Die Methode wird ausgeführt, wenn ein Thread des Threadpools verfügbar wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-221">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="0d330-222"><see langword="true" />, wenn die Methode erfolgreich in die Warteschlange eingereiht wurde. <see cref="T:System.NotSupportedException" /> wird ausgelöst, wenn das Arbeitselement nicht in die Warteschlange eingereiht werden konnte.</span><span class="sxs-lookup"><span data-stu-id="0d330-222"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-223">Wenn für die Rückruf Methode komplexe Daten erforderlich sind, können Sie eine Klasse definieren, die die Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="0d330-223">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0d330-224">Visual Basic Benutzer den <xref:System.Threading.WaitCallback>-Konstruktor weglassen und einfach den `AddressOf`-Operator verwenden können, wenn Sie die Rückruf Methode an <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>übergeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-224">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="0d330-225">Visual Basic ruft automatisch den richtigen Delegatkonstruktor auf.</span><span class="sxs-lookup"><span data-stu-id="0d330-225">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="0d330-226">Versionsinformationen</span><span class="sxs-lookup"><span data-stu-id="0d330-226">Version Information</span></span>  
 <span data-ttu-id="0d330-227">In der .NET Framework Version 2,0 wird der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>-Eigenschafts Wert mithilfe der <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>-Methode an Arbeitsthreads weitergegeben, die in Warteschlangen eingereiht wurden</span><span class="sxs-lookup"><span data-stu-id="0d330-227">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="0d330-228">In früheren Versionen werden die Prinzipal Informationen nicht weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-228">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0d330-229">Im folgenden Beispiel wird der .net-Thread Pool verwendet, um das `Fibonacci` Ergebnis für fünf Zahlen zwischen 20 und 40 zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="0d330-229">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="0d330-230">Jedes `Fibonacci`-Ergebnis wird von der `Fibonacci`-Klasse repräsentiert, die eine Methode mit dem Namen `ThreadPoolCallback` bietet, die die Berechnung durchführt.</span><span class="sxs-lookup"><span data-stu-id="0d330-230">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="0d330-231">Ein Objekt, das jeden `Fibonacci`-Wert repräsentiert, wird erstellt, und die `ThreadPoolCallback`-Methode wird an <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> übergeben, das dem Pool einen verfügbaren Thread zuweist, um die Methode auszuführen.</span><span class="sxs-lookup"><span data-stu-id="0d330-231">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="0d330-232">Da jedem `Fibonacci` Objekt ein halb zufälliger Wert zur Berechnung zugewiesen wird, und da jeder Thread für die Prozessorzeit konkurrieren wird, können Sie nicht im Voraus wissen, wie lange es dauern wird, bis alle fünf Ergebnisse berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-232">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="0d330-233">Deshalb wird jedem `Fibonacci`-Objekt eine Instanz der <xref:System.Threading.ManualResetEvent>-Klasse während der Konstruktion übergeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-233">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="0d330-234">Jedes Objekt signalisiert dem bereitgestellten Ereignis Objekt, wenn die Berechnung vollständig ist. Dadurch kann der primäre Thread die Ausführung mit <xref:System.Threading.WaitHandle.WaitAll%2A> blockieren, bis alle fünf `Fibonacci` Objekte ein Ergebnis berechnet haben.</span><span class="sxs-lookup"><span data-stu-id="0d330-234">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="0d330-235">Die `Main`-Methode zeigt dann jedes `Fibonacci`-Ergebnis an.</span><span class="sxs-lookup"><span data-stu-id="0d330-235">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0d330-236">Die Common Language Runtime (CLR) wird gehostet, und der Host unterstützt diese Aktion nicht.</span><span class="sxs-lookup"><span data-stu-id="0d330-236">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d330-237"><paramref name="callBack" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-237"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-238">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="0d330-238">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="0d330-239">Der Typ der Elemente von <paramref name="state" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-239">The type of elements of <paramref name="state" />.</span></span></typeparam>
        <param name="callBack"><span data-ttu-id="0d330-240">Eine <see cref="T:System.Action`1" />, die die auszuführende Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="0d330-240">An <see cref="T:System.Action`1" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-241">Ein Objekt, das die von der Methode zu verwendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="0d330-241">An object containing data to be used by the method.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="0d330-242">Mit <see langword="true" /> fügen Sie das Arbeitselement in eine Warteschlange in der Nähe des aktuellen Threads ein; <see langword="false" /> für das Einfügen des Arbeitselements in die vom Threadpool freigegebene Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="0d330-242"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="0d330-243">Fügt der Warteschlange eine Methode hinzu, die von einem <see cref="T:System.Action`1" />-Delegat zur Ausführung angegeben wird, und stellt die von der Methode zu verwendenden Daten bereit.</span><span class="sxs-lookup"><span data-stu-id="0d330-243">Queues a method specified by an <see cref="T:System.Action`1" /> delegate for execution, and provides data to be used by the method.</span></span> <span data-ttu-id="0d330-244">Die Methode wird ausgeführt, wenn ein Thread des Threadpools verfügbar wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-244">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="0d330-245"><see langword="true" />, wenn die Methode erfolgreich in die Warteschlange eingereiht wurde. <see cref="T:System.NotSupportedException" /> wird ausgelöst, wenn das Arbeitselement nicht in die Warteschlange eingereiht werden konnte.</span><span class="sxs-lookup"><span data-stu-id="0d330-245"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span>
<span data-ttu-id="0d330-246">.</span><span class="sxs-lookup"><span data-stu-id="0d330-246">.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0d330-247">Registriert einen Delegaten, der auf ein <see cref="T:System.Threading.WaitHandle" /> wartet.</span><span class="sxs-lookup"><span data-stu-id="0d330-247">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="0d330-248">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-248">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="0d330-249">Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-249">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="0d330-250">Der <see cref="T:System.Threading.WaitOrTimerCallback" />-Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-250">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-251">Das an den Delegaten übergebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="0d330-251">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="0d330-252">Das Timeout in Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="0d330-252">The time-out in milliseconds.</span></span> <span data-ttu-id="0d330-253">Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="0d330-253">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="0d330-254">Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</span><span class="sxs-lookup"><span data-stu-id="0d330-254">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="0d330-255"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-255"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="0d330-256">Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 32-Bit-Ganzzahl mit Vorzeichen angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-256">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="0d330-257">Das <see cref="T:System.Threading.RegisteredWaitHandle" />, das das systemeigene Handle kapselt.</span><span class="sxs-lookup"><span data-stu-id="0d330-257">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-258">Wenn Sie die <xref:System.Threading.RegisteredWaitHandle>, die von dieser Methode zurückgegeben wird, nicht mehr benötigen, wenden Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode an, um Verweise auf das Wait-Handle freizugeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-258">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="0d330-259">Es wird empfohlen, immer die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode aufzurufen, auch wenn Sie `true` für `executeOnlyOnce`angeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-259">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="0d330-260">Die Garbage Collection funktioniert effizienter, wenn Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode anstelle von dem Finalizer des registrierten Wait-Handles aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-260">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="0d330-261">Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode fügt den angegebenen Delegaten in die Warteschlange des Thread Pools ein.</span><span class="sxs-lookup"><span data-stu-id="0d330-261">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="0d330-262">Ein Arbeits Thread führt den Delegaten aus, wenn eine der folgenden Aktionen auftritt:</span><span class="sxs-lookup"><span data-stu-id="0d330-262">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="0d330-263">Das angegebene-Objekt befindet sich im signalisierten Zustand.</span><span class="sxs-lookup"><span data-stu-id="0d330-263">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="0d330-264">Das Timeout Intervall ist abgelaufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-264">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="0d330-265">Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode überprüft den aktuellen Status des <xref:System.Threading.WaitHandle>des angegebenen Objekts.</span><span class="sxs-lookup"><span data-stu-id="0d330-265">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="0d330-266">Wenn der Zustand des Objekts nicht signalisiert ist, registriert die Methode einen Warte Vorgang.</span><span class="sxs-lookup"><span data-stu-id="0d330-266">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="0d330-267">Der Warte Vorgang wird von einem Thread aus dem Thread Pool ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="0d330-267">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="0d330-268">Der Delegat wird von einem Arbeits Thread ausgeführt, wenn der Zustand des Objekts signalisiert wird oder das Timeout Intervall abläuft.</span><span class="sxs-lookup"><span data-stu-id="0d330-268">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="0d330-269">Wenn der `timeOutInterval`-Parameter nicht 0 (null) ist und der `executeOnlyOnce`-Parameter `false`ist, wird der Timer jedes Mal zurückgesetzt, wenn das Ereignis signalisiert wird oder das Timeout Intervall abläuft.</span><span class="sxs-lookup"><span data-stu-id="0d330-269">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0d330-270">Die Verwendung einer <xref:System.Threading.Mutex> für `waitObject` stellt keinen gegenseitigen Ausschluss für die Rückrufe bereit, da die zugrunde liegende Windows-API das Standard-`WT_EXECUTEDEFAULT`-Flag verwendet, sodass jeder Rückruf in einem separaten Thread Pool Thread gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-270">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="0d330-271">Verwenden Sie anstelle eines <xref:System.Threading.Mutex>eine <xref:System.Threading.Semaphore> mit einer maximalen Anzahl von 1.</span><span class="sxs-lookup"><span data-stu-id="0d330-271">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="0d330-272">Rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode auf, um den warte Vorgang abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="0d330-272">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="0d330-273">Der Warte Thread verwendet die Win32-`WaitForMultipleObjects`-Funktion, um registrierte warte Vorgänge zu überwachen.</span><span class="sxs-lookup"><span data-stu-id="0d330-273">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="0d330-274">Wenn Sie das gleiche systemeigene Betriebssystem Handle in mehreren Aufrufen von <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>verwenden müssen, müssen Sie daher das Handle mithilfe der Win32-`DuplicateHandle`-Funktion duplizieren.</span><span class="sxs-lookup"><span data-stu-id="0d330-274">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="0d330-275">Beachten Sie, dass Sie ein Ereignis Objekt, das an <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>übertragen wird, nicht durchlaufen sollten, da der Warte Thread möglicherweise nicht erkennt, dass das Ereignis vor dem Zurücksetzen signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-275">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="0d330-276">Vor der Rückgabe ändert die-Funktion den Zustand einiger Typen von Synchronisierungs Objekten.</span><span class="sxs-lookup"><span data-stu-id="0d330-276">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="0d330-277">Die Änderung erfolgt nur für das Objekt, dessen signalisierter Zustand bewirkt hat, dass die Warte Bedingung erfüllt ist.</span><span class="sxs-lookup"><span data-stu-id="0d330-277">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="0d330-278">Beispielsweise wird die Anzahl eines Semaphors um eins verringert.</span><span class="sxs-lookup"><span data-stu-id="0d330-278">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="0d330-279">Versionsinformationen</span><span class="sxs-lookup"><span data-stu-id="0d330-279">Version Information</span></span>  
 <span data-ttu-id="0d330-280">Beginnend mit der .NET Framework Version 2,0 wird der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>-Eigenschafts Wert mithilfe der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode an Arbeitsthreads weitergegeben, die in Warteschlangen eingereiht wurden.</span><span class="sxs-lookup"><span data-stu-id="0d330-280">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="0d330-281">In früheren Versionen werden die Prinzipal Informationen nicht weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-281">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0d330-282">Der <paramref name="millisecondsTimeOutInterval" />-Parameter ist kleiner als -1.</span><span class="sxs-lookup"><span data-stu-id="0d330-282">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-283">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="0d330-283">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="0d330-284">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-284">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="0d330-285">Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-285">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="0d330-286">Der <see cref="T:System.Threading.WaitOrTimerCallback" />-Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-286">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-287">Das an den Delegaten übergebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="0d330-287">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="0d330-288">Das Timeout in Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="0d330-288">The time-out in milliseconds.</span></span> <span data-ttu-id="0d330-289">Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="0d330-289">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="0d330-290">Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</span><span class="sxs-lookup"><span data-stu-id="0d330-290">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="0d330-291"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-291"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="0d330-292">Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 64-Bit-Ganzzahl mit Vorzeichen angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-292">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="0d330-293">Das <see cref="T:System.Threading.RegisteredWaitHandle" />, das das systemeigene Handle kapselt.</span><span class="sxs-lookup"><span data-stu-id="0d330-293">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-294">Wenn Sie die <xref:System.Threading.RegisteredWaitHandle>, die von dieser Methode zurückgegeben wird, nicht mehr benötigen, wenden Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode an, um Verweise auf das Wait-Handle freizugeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-294">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="0d330-295">Es wird empfohlen, immer die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode aufzurufen, auch wenn Sie `true` für `executeOnlyOnce`angeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-295">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="0d330-296">Die Garbage Collection funktioniert effizienter, wenn Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode anstelle von dem Finalizer des registrierten Wait-Handles aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-296">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="0d330-297">Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode fügt den angegebenen Delegaten in die Warteschlange des Thread Pools ein.</span><span class="sxs-lookup"><span data-stu-id="0d330-297">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="0d330-298">Ein Arbeits Thread führt den Delegaten aus, wenn eine der folgenden Aktionen auftritt:</span><span class="sxs-lookup"><span data-stu-id="0d330-298">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="0d330-299">Das angegebene-Objekt befindet sich im signalisierten Zustand.</span><span class="sxs-lookup"><span data-stu-id="0d330-299">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="0d330-300">Das Timeout Intervall ist abgelaufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-300">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="0d330-301">Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode überprüft den aktuellen Status des <xref:System.Threading.WaitHandle>des angegebenen Objekts.</span><span class="sxs-lookup"><span data-stu-id="0d330-301">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="0d330-302">Wenn der Zustand des Objekts nicht signalisiert ist, registriert die Methode einen Warte Vorgang.</span><span class="sxs-lookup"><span data-stu-id="0d330-302">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="0d330-303">Der Warte Vorgang wird von einem Thread aus dem Thread Pool ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="0d330-303">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="0d330-304">Der Delegat wird von einem Arbeits Thread ausgeführt, wenn der Zustand des Objekts signalisiert wird oder das Timeout Intervall abläuft.</span><span class="sxs-lookup"><span data-stu-id="0d330-304">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="0d330-305">Wenn der `timeOutInterval`-Parameter nicht 0 (null) ist und der `executeOnlyOnce`-Parameter `false`ist, wird der Timer jedes Mal zurückgesetzt, wenn das Ereignis signalisiert wird oder das Timeout Intervall abläuft.</span><span class="sxs-lookup"><span data-stu-id="0d330-305">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0d330-306">Die Verwendung einer <xref:System.Threading.Mutex> für `waitObject` stellt keinen gegenseitigen Ausschluss für die Rückrufe bereit, da die zugrunde liegende Windows-API das Standard-`WT_EXECUTEDEFAULT`-Flag verwendet, sodass jeder Rückruf in einem separaten Thread Pool Thread gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-306">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="0d330-307">Verwenden Sie anstelle eines <xref:System.Threading.Mutex>eine <xref:System.Threading.Semaphore> mit einer maximalen Anzahl von 1.</span><span class="sxs-lookup"><span data-stu-id="0d330-307">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="0d330-308">Rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode auf, um den warte Vorgang abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="0d330-308">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="0d330-309">Der Warte Thread verwendet die Win32-`WaitForMultipleObjects`-Funktion, um registrierte warte Vorgänge zu überwachen.</span><span class="sxs-lookup"><span data-stu-id="0d330-309">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="0d330-310">Wenn Sie das gleiche systemeigene Betriebssystem Handle in mehreren Aufrufen von <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>verwenden müssen, müssen Sie daher das Handle mithilfe der Win32-`DuplicateHandle`-Funktion duplizieren.</span><span class="sxs-lookup"><span data-stu-id="0d330-310">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="0d330-311">Beachten Sie, dass Sie ein Ereignis Objekt, das an <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>übertragen wird, nicht durchlaufen sollten, da der Warte Thread möglicherweise nicht erkennt, dass das Ereignis vor dem Zurücksetzen signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-311">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="0d330-312">Vor der Rückgabe ändert die-Funktion den Zustand einiger Typen von Synchronisierungs Objekten.</span><span class="sxs-lookup"><span data-stu-id="0d330-312">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="0d330-313">Die Änderung erfolgt nur für das Objekt, dessen signalisierter Zustand bewirkt hat, dass die Warte Bedingung erfüllt ist.</span><span class="sxs-lookup"><span data-stu-id="0d330-313">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="0d330-314">Beispielsweise wird die Anzahl eines Semaphors um eins verringert.</span><span class="sxs-lookup"><span data-stu-id="0d330-314">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="0d330-315">Versionsinformationen</span><span class="sxs-lookup"><span data-stu-id="0d330-315">Version Information</span></span>  
 <span data-ttu-id="0d330-316">Beginnend mit der .NET Framework Version 2,0 wird der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>-Eigenschafts Wert mithilfe der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode an Arbeitsthreads weitergegeben, die in Warteschlangen eingereiht wurden.</span><span class="sxs-lookup"><span data-stu-id="0d330-316">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="0d330-317">In früheren Versionen werden die Prinzipal Informationen nicht weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-317">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0d330-318">Der <paramref name="millisecondsTimeOutInterval" />-Parameter ist kleiner als -1.</span><span class="sxs-lookup"><span data-stu-id="0d330-318">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-319">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="0d330-319">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="0d330-320">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-320">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="0d330-321">Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-321">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="0d330-322">Der <see cref="T:System.Threading.WaitOrTimerCallback" />-Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-322">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-323">Das an den Delegaten übergebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="0d330-323">The object passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="0d330-324">Das durch eine <see cref="T:System.TimeSpan" /> dargestellte Timeout.</span><span class="sxs-lookup"><span data-stu-id="0d330-324">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="0d330-325">Wenn <paramref name="timeout" /> den Wert 0 (null) hat, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="0d330-325">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="0d330-326">Wenn <paramref name="timeout" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</span><span class="sxs-lookup"><span data-stu-id="0d330-326">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="0d330-327"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-327"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="0d330-328">Registriert einen Delegaten, der auf ein <see cref="T:System.Threading.WaitHandle" /> wartet, und gibt einen <see cref="T:System.TimeSpan" />-Wert für das Timeout an.</span><span class="sxs-lookup"><span data-stu-id="0d330-328">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="0d330-329">Das <see cref="T:System.Threading.RegisteredWaitHandle" />, das das systemeigene Handle kapselt.</span><span class="sxs-lookup"><span data-stu-id="0d330-329">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-330">Wenn Sie die <xref:System.Threading.RegisteredWaitHandle>, die von dieser Methode zurückgegeben wird, nicht mehr benötigen, wenden Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode an, um Verweise auf das Wait-Handle freizugeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-330">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="0d330-331">Es wird empfohlen, immer die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode aufzurufen, auch wenn Sie `true` für `executeOnlyOnce`angeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-331">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="0d330-332">Die Garbage Collection funktioniert effizienter, wenn Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode anstelle von dem Finalizer des registrierten Wait-Handles aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-332">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="0d330-333">Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode fügt den angegebenen Delegaten in die Warteschlange des Thread Pools ein.</span><span class="sxs-lookup"><span data-stu-id="0d330-333">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="0d330-334">Ein Arbeits Thread führt den Delegaten aus, wenn eine der folgenden Aktionen auftritt:</span><span class="sxs-lookup"><span data-stu-id="0d330-334">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="0d330-335">Das angegebene-Objekt befindet sich im signalisierten Zustand.</span><span class="sxs-lookup"><span data-stu-id="0d330-335">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="0d330-336">Das Timeout Intervall ist abgelaufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-336">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="0d330-337">Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode überprüft den aktuellen Status des <xref:System.Threading.WaitHandle>des angegebenen Objekts.</span><span class="sxs-lookup"><span data-stu-id="0d330-337">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="0d330-338">Wenn der Zustand des Objekts nicht signalisiert ist, registriert die Methode einen Warte Vorgang.</span><span class="sxs-lookup"><span data-stu-id="0d330-338">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="0d330-339">Der Warte Vorgang wird von einem Thread aus dem Thread Pool ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="0d330-339">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="0d330-340">Der Delegat wird von einem Arbeits Thread ausgeführt, wenn der Zustand des Objekts signalisiert wird oder das Timeout Intervall abläuft.</span><span class="sxs-lookup"><span data-stu-id="0d330-340">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="0d330-341">Wenn der `timeOutInterval`-Parameter nicht 0 (null) ist und der `executeOnlyOnce`-Parameter `false`ist, wird der Timer jedes Mal zurückgesetzt, wenn das Ereignis signalisiert wird oder das Timeout Intervall abläuft.</span><span class="sxs-lookup"><span data-stu-id="0d330-341">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0d330-342">Die Verwendung einer <xref:System.Threading.Mutex> für `waitObject` stellt keinen gegenseitigen Ausschluss für die Rückrufe bereit, da die zugrunde liegende Windows-API das Standard-`WT_EXECUTEDEFAULT`-Flag verwendet, sodass jeder Rückruf in einem separaten Thread Pool Thread gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-342">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="0d330-343">Verwenden Sie anstelle eines <xref:System.Threading.Mutex>eine <xref:System.Threading.Semaphore> mit einer maximalen Anzahl von 1.</span><span class="sxs-lookup"><span data-stu-id="0d330-343">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="0d330-344">Rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode auf, um den warte Vorgang abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="0d330-344">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="0d330-345">Der Warte Thread verwendet die Win32-`WaitForMultipleObjects`-Funktion, um registrierte warte Vorgänge zu überwachen.</span><span class="sxs-lookup"><span data-stu-id="0d330-345">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="0d330-346">Wenn Sie das gleiche systemeigene Betriebssystem Handle in mehreren Aufrufen von <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>verwenden müssen, müssen Sie daher das Handle mithilfe der Win32-`DuplicateHandle`-Funktion duplizieren.</span><span class="sxs-lookup"><span data-stu-id="0d330-346">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="0d330-347">Beachten Sie, dass Sie ein Ereignis Objekt, das an <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>übertragen wird, nicht durchlaufen sollten, da der Warte Thread möglicherweise nicht erkennt, dass das Ereignis vor dem Zurücksetzen signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-347">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="0d330-348">Vor der Rückgabe ändert die-Funktion den Zustand einiger Typen von Synchronisierungs Objekten.</span><span class="sxs-lookup"><span data-stu-id="0d330-348">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="0d330-349">Die Änderung erfolgt nur für das Objekt, dessen signalisierter Zustand bewirkt hat, dass die Warte Bedingung erfüllt ist.</span><span class="sxs-lookup"><span data-stu-id="0d330-349">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="0d330-350">Beispielsweise wird die Anzahl eines Semaphors um eins verringert.</span><span class="sxs-lookup"><span data-stu-id="0d330-350">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="0d330-351">Versionsinformationen</span><span class="sxs-lookup"><span data-stu-id="0d330-351">Version Information</span></span>  
 <span data-ttu-id="0d330-352">Beginnend mit der .NET Framework Version 2,0 wird der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>-Eigenschafts Wert mithilfe der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode an Arbeitsthreads weitergegeben, die in Warteschlangen eingereiht wurden.</span><span class="sxs-lookup"><span data-stu-id="0d330-352">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="0d330-353">In früheren Versionen werden die Prinzipal Informationen nicht weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-353">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0d330-354">Der <paramref name="timeout" />-Parameter ist kleiner als -1.</span><span class="sxs-lookup"><span data-stu-id="0d330-354">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0d330-355">Der <paramref name="timeout" />-Parameter ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-355">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-356">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="0d330-356">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="0d330-357">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-357">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="0d330-358">Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-358">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="0d330-359">Der <see cref="T:System.Threading.WaitOrTimerCallback" />-Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-359">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-360">Das an den Delegaten übergebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="0d330-360">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="0d330-361">Das Timeout in Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="0d330-361">The time-out in milliseconds.</span></span> <span data-ttu-id="0d330-362">Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="0d330-362">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="0d330-363">Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</span><span class="sxs-lookup"><span data-stu-id="0d330-363">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="0d330-364"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-364"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="0d330-365">Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 32-Bit-Ganzzahl ohne Vorzeichen angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-365">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="0d330-366">Das <see cref="T:System.Threading.RegisteredWaitHandle" />, mit dem der registrierte Wartevorgang abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="0d330-366">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-367">Wenn Sie die <xref:System.Threading.RegisteredWaitHandle>, die von dieser Methode zurückgegeben wird, nicht mehr benötigen, wenden Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode an, um Verweise auf das Wait-Handle freizugeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-367">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="0d330-368">Es wird empfohlen, immer die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode aufzurufen, auch wenn Sie `true` für `executeOnlyOnce`angeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-368">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="0d330-369">Die Garbage Collection funktioniert effizienter, wenn Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode anstelle von dem Finalizer des registrierten Wait-Handles aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-369">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="0d330-370">Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode fügt den angegebenen Delegaten in die Warteschlange des Thread Pools ein.</span><span class="sxs-lookup"><span data-stu-id="0d330-370">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="0d330-371">Ein Arbeits Thread führt den Delegaten aus, wenn eine der folgenden Aktionen auftritt:</span><span class="sxs-lookup"><span data-stu-id="0d330-371">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="0d330-372">Das angegebene-Objekt befindet sich im signalisierten Zustand.</span><span class="sxs-lookup"><span data-stu-id="0d330-372">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="0d330-373">Das Timeout Intervall ist abgelaufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-373">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="0d330-374">Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode überprüft den aktuellen Status des <xref:System.Threading.WaitHandle>des angegebenen Objekts.</span><span class="sxs-lookup"><span data-stu-id="0d330-374">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="0d330-375">Wenn der Zustand des Objekts nicht signalisiert ist, registriert die Methode einen Warte Vorgang.</span><span class="sxs-lookup"><span data-stu-id="0d330-375">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="0d330-376">Der Warte Vorgang wird von einem Thread aus dem Thread Pool ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="0d330-376">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="0d330-377">Der Delegat wird von einem Arbeits Thread ausgeführt, wenn der Zustand des Objekts signalisiert wird oder das Timeout Intervall abläuft.</span><span class="sxs-lookup"><span data-stu-id="0d330-377">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="0d330-378">Wenn der `timeOutInterval`-Parameter nicht 0 (null) ist und der `executeOnlyOnce`-Parameter `false`ist, wird der Timer jedes Mal zurückgesetzt, wenn das Ereignis signalisiert wird oder das Timeout Intervall abläuft.</span><span class="sxs-lookup"><span data-stu-id="0d330-378">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0d330-379">Die Verwendung einer <xref:System.Threading.Mutex> für `waitObject` stellt keinen gegenseitigen Ausschluss für die Rückrufe bereit, da die zugrunde liegende Windows-API das Standard-`WT_EXECUTEDEFAULT`-Flag verwendet, sodass jeder Rückruf in einem separaten Thread Pool Thread gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-379">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="0d330-380">Verwenden Sie anstelle eines <xref:System.Threading.Mutex>eine <xref:System.Threading.Semaphore> mit einer maximalen Anzahl von 1.</span><span class="sxs-lookup"><span data-stu-id="0d330-380">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="0d330-381">Rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode auf, um den warte Vorgang abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="0d330-381">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="0d330-382">Der Warte Thread verwendet die Win32-`WaitForMultipleObjects`-Funktion, um registrierte warte Vorgänge zu überwachen.</span><span class="sxs-lookup"><span data-stu-id="0d330-382">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="0d330-383">Wenn Sie das gleiche systemeigene Betriebssystem Handle in mehreren Aufrufen von <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>verwenden müssen, müssen Sie daher das Handle mithilfe der Win32-`DuplicateHandle`-Funktion duplizieren.</span><span class="sxs-lookup"><span data-stu-id="0d330-383">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="0d330-384">Beachten Sie, dass Sie ein Ereignis Objekt, das an <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>übertragen wird, nicht durchlaufen sollten, da der Warte Thread möglicherweise nicht erkennt, dass das Ereignis vor dem Zurücksetzen signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-384">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="0d330-385">Vor der Rückgabe ändert die-Funktion den Zustand einiger Typen von Synchronisierungs Objekten.</span><span class="sxs-lookup"><span data-stu-id="0d330-385">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="0d330-386">Die Änderung erfolgt nur für das Objekt, dessen signalisierter Zustand bewirkt hat, dass die Warte Bedingung erfüllt ist.</span><span class="sxs-lookup"><span data-stu-id="0d330-386">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="0d330-387">Beispielsweise wird die Anzahl eines Semaphors um eins verringert.</span><span class="sxs-lookup"><span data-stu-id="0d330-387">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="0d330-388">Versionsinformationen</span><span class="sxs-lookup"><span data-stu-id="0d330-388">Version Information</span></span>  
 <span data-ttu-id="0d330-389">Beginnend mit der .NET Framework Version 2,0 wird der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>-Eigenschafts Wert mithilfe der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode an Arbeitsthreads weitergegeben, die in Warteschlangen eingereiht wurden.</span><span class="sxs-lookup"><span data-stu-id="0d330-389">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="0d330-390">In früheren Versionen werden die Prinzipal Informationen nicht weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-390">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0d330-391">Im folgenden Beispiel wird gezeigt, wie die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode verwendet wird, um eine angegebene Rückruf Methode auszuführen, wenn ein angegebenes Wait-Handle signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-391">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="0d330-392">In diesem Beispiel ist die Rückruf Methode `WaitProc`, und das Wait-Handle ist ein <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="0d330-392">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="0d330-393">Im Beispiel wird eine `TaskInfo` Klasse definiert, die die Informationen enthält, die bei der Ausführung an den Rückruf übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-393">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="0d330-394">Im Beispiel wird ein `TaskInfo`-Objekt erstellt, und es werden Zeichen folgen Daten zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="0d330-394">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="0d330-395">Der <xref:System.Threading.RegisteredWaitHandle>, der von der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode zurückgegeben wird, wird dem `Handle`-Feld des `TaskInfo` Objekts zugewiesen, sodass die Rückruf Methode Zugriff auf den <xref:System.Threading.RegisteredWaitHandle>hat.</span><span class="sxs-lookup"><span data-stu-id="0d330-395">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="0d330-396">Zusätzlich zur Angabe `TaskInfo` als Objekt, das an die Rückruf Methode übergeben werden soll, gibt der Aufruf der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode die <xref:System.Threading.AutoResetEvent> an, auf die der Task wartet, einen <xref:System.Threading.WaitOrTimerCallback> Delegaten, der die `WaitProc` Rückruf Methode darstellt, ein zweites Timeout Intervall und mehrere Rückrufe.</span><span class="sxs-lookup"><span data-stu-id="0d330-396">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="0d330-397">Wenn der Haupt Thread die <xref:System.Threading.AutoResetEvent> durch Aufrufen seiner <xref:System.Threading.EventWaitHandle.Set%2A>-Methode signalisiert, wird der <xref:System.Threading.WaitOrTimerCallback> Delegat aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-397">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="0d330-398">Die `WaitProc`-Methode testet <xref:System.Threading.RegisteredWaitHandle>, um zu bestimmen, ob ein Timeout aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="0d330-398">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="0d330-399">Wenn der Rückruf aufgerufen wurde, weil das Wait-Handle signalisiert wurde, hebt die `WaitProc` Methode die Registrierung des <xref:System.Threading.RegisteredWaitHandle>auf und beendet weitere Rückrufe.</span><span class="sxs-lookup"><span data-stu-id="0d330-399">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="0d330-400">Im Fall eines Timeouts wartet der Task weiterhin.</span><span class="sxs-lookup"><span data-stu-id="0d330-400">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="0d330-401">Die `WaitProc`-Methode wird beendet, indem eine Meldung an die Konsole ausgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-401">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0d330-402">Der <paramref name="millisecondsTimeOutInterval" />-Parameter ist kleiner als -1.</span><span class="sxs-lookup"><span data-stu-id="0d330-402">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-403">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="0d330-403">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="0d330-404">Die maximale Anzahl der Arbeitsthreads im Threadpool.</span><span class="sxs-lookup"><span data-stu-id="0d330-404">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="0d330-405">Die maximale Anzahl asynchroner E/A-Threads im Threadpool.</span><span class="sxs-lookup"><span data-stu-id="0d330-405">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="0d330-406">Legt die Anzahl der Anforderungen für den Threadpool fest, die gleichzeitig aktiv sein können.</span><span class="sxs-lookup"><span data-stu-id="0d330-406">Sets the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="0d330-407">Alle über diese Zahl hinausgehenden Anforderungen bleiben in der Warteschlange, bis die Threads des Threadpools verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="0d330-407">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <returns><span data-ttu-id="0d330-408"><see langword="true" />, wenn die Änderung erfolgreich ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-408"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-409">Sie können die maximale Anzahl von Arbeitsthreads oder e/a-Abschluss Threads nicht auf eine Zahl festlegen, die kleiner ist als die Anzahl der Prozessoren auf dem Computer.</span><span class="sxs-lookup"><span data-stu-id="0d330-409">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="0d330-410">Rufen Sie den Wert der <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType>-Eigenschaft ab, um zu bestimmen, wie viele Prozessoren vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="0d330-410">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="0d330-411">Außerdem können Sie nicht die maximale Anzahl von Arbeitsthreads oder e/a-Abschluss Threads auf eine Zahl festlegen, die kleiner ist als die entsprechende Mindestanzahl von Arbeitsthreads oder e/a-abschlusthreads.</span><span class="sxs-lookup"><span data-stu-id="0d330-411">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="0d330-412">Um die minimale Thread Pool Größe zu ermitteln, müssen Sie die <xref:System.Threading.ThreadPool.GetMinThreads%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-412">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="0d330-413">Wenn die Common Language Runtime gehostet wird, z. b. durch Internetinformationsdienste (IIS) oder SQL Server, kann der Host Änderungen an der Thread Pool Größe einschränken oder verhindern.</span><span class="sxs-lookup"><span data-stu-id="0d330-413">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="0d330-414">Gehen Sie vorsichtig vor, wenn Sie die maximale Anzahl von Threads im Thread Pool ändern.</span><span class="sxs-lookup"><span data-stu-id="0d330-414">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="0d330-415">Während der Code von Vorteil sein kann, haben die Änderungen möglicherweise eine negative Auswirkung auf die verwendeten Codebibliotheken.</span><span class="sxs-lookup"><span data-stu-id="0d330-415">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="0d330-416">Wenn Sie die Größe des Thread Pools zu groß festlegen, kann dies zu Leistungsproblemen führen.</span><span class="sxs-lookup"><span data-stu-id="0d330-416">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="0d330-417">Wenn zu viele Threads gleichzeitig ausgeführt werden, wird der Task Wechsel Aufwand zu einem bedeutenden Faktor.</span><span class="sxs-lookup"><span data-stu-id="0d330-417">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="0d330-418">Die Mindestanzahl von Arbeitsthreads, die der Threadpool bei Bedarf erstellt.</span><span class="sxs-lookup"><span data-stu-id="0d330-418">The minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="0d330-419">Die Mindestanzahl von asynchronen E/A-Threads, die der Threadpool bei Bedarf erstellt.</span><span class="sxs-lookup"><span data-stu-id="0d330-419">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="0d330-420">Legt die Mindestanzahl von Threads fest, die der Threadpool bei Bedarf erstellt, wenn neue Anforderungen gestellt werden, bevor zu einem Algorithmus zum Verwalten von Threaderstellung und -löschung gewechselt wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-420">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <returns><span data-ttu-id="0d330-421"><see langword="true" />, wenn die Änderung erfolgreich ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-421"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-422">Der Thread Pool stellt bei Bedarf neue Arbeitsthreads oder e/a-abschlusthreads bereit, bis die Mindestanzahl für jede Kategorie erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="0d330-422">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="0d330-423">Wenn der Minimalwert erreicht wird, kann der Thread Pool zusätzliche Threads in dieser Kategorie erstellen oder warten, bis einige Tasks beendet wurden.</span><span class="sxs-lookup"><span data-stu-id="0d330-423">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="0d330-424">Beginnend mit dem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]erstellt und zerstört der Thread Pool Threads, um den Durchsatz zu optimieren, der als die Anzahl der Aufgaben definiert ist, die pro Zeiteinheit ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-424">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="0d330-425">Bei zu wenigen Threads werden die verfügbaren Ressourcen möglicherweise nicht optimal genutzt, wohingegen bei zu vielen Threads Ressourcenkonflikte auftreten können.</span><span class="sxs-lookup"><span data-stu-id="0d330-425">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="0d330-426">Wenn die Anforderungen niedrig sind, kann die tatsächliche Anzahl der Threads im Threadpool unterhalb der Mindestwerte liegen.</span><span class="sxs-lookup"><span data-stu-id="0d330-426">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="0d330-427">Wenn Sie eine negative Zahl oder eine Zahl angeben, die größer ist als die maximale Anzahl aktiver Thread Pool-Threads (mit <xref:System.Threading.ThreadPool.GetMaxThreads%2A>abgerufen), gibt <xref:System.Threading.ThreadPool.SetMinThreads%2A> `false` zurück und ändert keinen der Minimalwerte.</span><span class="sxs-lookup"><span data-stu-id="0d330-427">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0d330-428">Standardmäßig entspricht die minimale Anzahl von Threads der Anzahl von Prozessoren in einem System.</span><span class="sxs-lookup"><span data-stu-id="0d330-428">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="0d330-429">Sie können die <xref:System.Threading.ThreadPool.SetMinThreads%2A>-Methode verwenden, um die Mindestanzahl von Threads zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="0d330-429">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="0d330-430">Allerdings kann ein unnötiges Erhöhen dieses Wertes zu Leistungsproblemen führen.</span><span class="sxs-lookup"><span data-stu-id="0d330-430">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="0d330-431">Wenn zu viele Aufgaben gleichzeitig gestartet werden, werden möglicherweise alle Aufgaben zu langsam ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="0d330-431">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="0d330-432">In den meisten Fällen wird der Thread Pool besser mit seinem eigenen Algorithmus zum Zuordnen von Threads durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="0d330-432">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="0d330-433">Wenn Sie die minimale Anzahl von Prozessoren verringern, kann dies auch die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="0d330-433">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0d330-434">Im folgenden Beispiel wird die Mindestanzahl von Arbeitsthreads auf vier festgelegt, und der ursprüngliche Wert für die Mindestanzahl von asynchronen e/a-abschlusthreads wird beibehalten.</span><span class="sxs-lookup"><span data-stu-id="0d330-434">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="ThreadCount">
      <MemberSignature Language="C#" Value="public static int ThreadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ThreadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.ThreadCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ThreadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ThreadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadCount : int" Usage="System.Threading.ThreadPool.ThreadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0d330-435">Ruft die Anzahl der derzeit vorhandenen Threads im Threadpool ab.</span><span class="sxs-lookup"><span data-stu-id="0d330-435">Gets the number of thread pool threads that currently exist.</span></span></summary>
        <value><span data-ttu-id="0d330-436">Die Anzahl der zurzeit vorhandenen Threads im Thread Pool.</span><span class="sxs-lookup"><span data-stu-id="0d330-436">The number of thread pool threads that currently exist.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="0d330-437">Wenn eine Thread Pool Implementierung verschiedene Thread Typen aufweisen kann, schließt die Anzahl alle Typen ein.</span><span class="sxs-lookup"><span data-stu-id="0d330-437">If a thread pool implementation may have different types of threads, the count includes all types.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="overlapped"><span data-ttu-id="0d330-438">Die <see cref="T:System.Threading.NativeOverlapped" />-Struktur, die in die Warteschlange gestellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="0d330-438">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span></span></param>
        <summary><span data-ttu-id="0d330-439">Stellt einen überlappenden E/A-Vorgang zur Ausführung in die Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="0d330-439">Queues an overlapped I/O operation for execution.</span></span></summary>
        <returns><span data-ttu-id="0d330-440"><see langword="true" />, wenn die Operation erfolgreich in die Warteschlange eines E/A-Abschlussanschlusses gestellt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-440"><see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-441">Informationen zur Verwendung von nativen Win32-überlappenden e/a-Vorgängen finden Sie in der <xref:System.Threading.Overlapped>-Klasse, der <xref:System.Threading.NativeOverlapped>-Struktur und der `OVERLAPPED`-Struktur im Win32 Platform SDK.</span><span class="sxs-lookup"><span data-stu-id="0d330-441">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0d330-442">Wenn Sie die <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>-Methode verwenden, könnte eine Sicherheitslücke versehentlich geöffnet werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-442">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="0d330-443">Die Code Zugriffssicherheit basiert auf den Berechtigungs Überprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="0d330-443">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="0d330-444">Wenn die Arbeit in einem Thread Pool Thread mithilfe <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>in die Warteschlange eingereiht wird, verfügt der Stapel des Thread Pool Threads nicht über den Kontext der eigentlichen Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="0d330-444">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="0d330-445">Bösartiger Code kann dies ausnutzen, um Berechtigungs Überprüfungen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="0d330-445">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="0d330-446">Das aufzurufende Arbeitselement, wenn ein Thread im Threadpool das Arbeitselement aufruft.</span><span class="sxs-lookup"><span data-stu-id="0d330-446">The work item to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="0d330-447">Mit <see langword="true" /> fügen Sie das Arbeitselement in eine Warteschlange in der Nähe des aktuellen Threads ein; <see langword="false" /> für das Einfügen des Arbeitselements in die vom Threadpool freigegebene Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="0d330-447"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="0d330-448">Fügt das angegebene Arbeitselementobjekt in die Warteschlange des Threadpools ein.</span><span class="sxs-lookup"><span data-stu-id="0d330-448">Queues the specified work item object to the thread pool.</span></span></summary>
        <returns><span data-ttu-id="0d330-449"><see langword="true" />, wenn die Methode erfolgreich ist. <see cref="T:System.OutOfMemoryException" /> wird ausgelöst, wenn die Arbeitsaufgabe nicht in die Warteschlange gestellt werden konnte.</span><span class="sxs-lookup"><span data-stu-id="0d330-449"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="0d330-450">Der Thread Pool Ruft die <xref:System.Threading.IThreadPoolWorkItem.Execute> Methode des Arbeits Elements auf.</span><span class="sxs-lookup"><span data-stu-id="0d330-450">The thread pool will invoke the work item's <xref:System.Threading.IThreadPoolWorkItem.Execute> method.</span></span> <span data-ttu-id="0d330-451">Es liegt in der Verantwortung des Arbeits Elements, <xref:System.Threading.ExecutionContext> bei Bedarf weiterzugeben. der Thread Pool wird dies nicht tun.</span><span class="sxs-lookup"><span data-stu-id="0d330-451">It is the responsibility of that work item to propagate <xref:System.Threading.ExecutionContext> if it's needed; the thread pool will not do so.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d330-452"><paramref name="callback" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-452"><paramref name="callback" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0d330-453">Das Arbeitselement ist eine <see cref="T:System.Threading.Tasks.Task" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="0d330-453">The work item is a <see cref="T:System.Threading.Tasks.Task" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="0d330-454">Das Arbeitselement konnte nicht in die Warteschlange eingereiht werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-454">The work item could not be queued.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="0d330-455">Ein <see cref="T:System.Threading.WaitCallback" />, der den Delegaten darstellt, der aufgerufen werden soll, wenn ein Thread im Threadpool die Arbeitsaufgabe aufnimmt.</span><span class="sxs-lookup"><span data-stu-id="0d330-455">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-456">Das Objekt, das an den Delegaten übergeben wird, wenn die Bearbeitung aus dem Threadpool erfolgt.</span><span class="sxs-lookup"><span data-stu-id="0d330-456">The object that is passed to the delegate when serviced from the thread pool.</span></span></param>
        <summary><span data-ttu-id="0d330-457">Stellt den angegebenen Delegaten in eine Warteschlange für den Threadpool, leitet die Aufrufliste jedoch nicht an den Arbeitsthread weiter.</span><span class="sxs-lookup"><span data-stu-id="0d330-457">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="0d330-458"><see langword="true" />, wenn die Methode erfolgreich ist. <see cref="T:System.OutOfMemoryException" /> wird ausgelöst, wenn die Arbeitsaufgabe nicht in die Warteschlange gestellt werden konnte.</span><span class="sxs-lookup"><span data-stu-id="0d330-458"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-459">Anders als bei der <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>-Methode gibt <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> den aufrufenden Stapel nicht an den Arbeits Thread weiter.</span><span class="sxs-lookup"><span data-stu-id="0d330-459">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="0d330-460">Dies ermöglicht es dem Code, den aufrufenden Stapel zu verlieren und dadurch seine Sicherheits Privilegien zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="0d330-460">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0d330-461">Die Verwendung von <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> könnte versehentlich eine Sicherheitslücke eröffnen.</span><span class="sxs-lookup"><span data-stu-id="0d330-461">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="0d330-462">Die Code Zugriffssicherheit basiert auf den Berechtigungs Überprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="0d330-462">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="0d330-463">Wenn die Arbeit in einem Thread Pool Thread mithilfe <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>in die Warteschlange eingereiht wird, verfügt der Stapel des Thread Pool Threads nicht über den Kontext der eigentlichen Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="0d330-463">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="0d330-464">Bösartiger Code kann dies ausnutzen, um Berechtigungs Überprüfungen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="0d330-464">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0d330-465">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="0d330-465">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="0d330-466">Es war nicht genügend Arbeitsspeicher vorhanden.</span><span class="sxs-lookup"><span data-stu-id="0d330-466">An out-of-memory condition was encountered.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="0d330-467">Das Arbeitselement konnte nicht in die Warteschlange eingereiht werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-467">The work item could not be queued.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d330-468"><paramref name="callBack" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-468"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-469">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="0d330-469">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="0d330-470">Der Typ der Elemente von <paramref name="state" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-470">The type of elements of <paramref name="state" />.</span></span></typeparam>
        <param name="callBack"><span data-ttu-id="0d330-471">Ein Delegat, der die auszuführende Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="0d330-471">A delegate representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-472">Ein Objekt, das die von der Methode zu verwendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="0d330-472">An object containing data to be used by the method.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="0d330-473">Mit <see langword="true" /> fügen Sie das Arbeitselement in eine Warteschlange in der Nähe des aktuellen Threads ein; <see langword="false" /> für das Einfügen des Arbeitselements in die vom Threadpool freigegebene Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="0d330-473"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="0d330-474">Fügt der Warteschlange eine Methode hinzu, die von einem <see cref="T:System.Action`1" />-Delegat zur Ausführung angegeben wurde, und gibt ein Objekt an, das die von der Methode zu verwendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="0d330-474">Queues a method specified by an <see cref="T:System.Action`1" /> delegate for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="0d330-475">Die Methode wird ausgeführt, wenn ein Thread des Threadpools verfügbar wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-475">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="0d330-476"><see langword="true" />, wenn die Methode erfolgreich in die Warteschlange eingereiht wurde. <see cref="T:System.NotSupportedException" /> wird ausgelöst, wenn das Arbeitselement nicht in die Warteschlange eingereiht werden konnte.</span><span class="sxs-lookup"><span data-stu-id="0d330-476"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d330-477"><paramref name="callback" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-477"><paramref name="callback" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0d330-478">Das Arbeitselement konnte nicht in die Warteschlange eingereiht werden.</span><span class="sxs-lookup"><span data-stu-id="0d330-478">The work item could not be queued.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0d330-479">Registriert einen Delegaten, damit auf ein <see cref="T:System.Threading.WaitHandle" /> gewartet wird. Die Aufrufliste wird jedoch nicht an den Arbeitsthread weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="0d330-479">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="0d330-480">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-480">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="0d330-481">Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-481">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="0d330-482">Der Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-482">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-483">Das an den Delegaten übergebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="0d330-483">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="0d330-484">Das Timeout in Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="0d330-484">The time-out in milliseconds.</span></span> <span data-ttu-id="0d330-485">Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="0d330-485">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="0d330-486">Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</span><span class="sxs-lookup"><span data-stu-id="0d330-486">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="0d330-487"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-487"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="0d330-488">Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 32-Bit-Ganzzahl mit Vorzeichen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-488">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="0d330-489">Diese Methode leitet den aufrufenden Stapel nicht an den Arbeitsthread weiter.</span><span class="sxs-lookup"><span data-stu-id="0d330-489">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="0d330-490">Das <see cref="T:System.Threading.RegisteredWaitHandle" />-Objekt, mit dem der registrierte Wartevorgang abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="0d330-490">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-491">Anders als bei der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode gibt <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> den aufrufenden Stapel nicht an den Arbeits Thread weiter.</span><span class="sxs-lookup"><span data-stu-id="0d330-491">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="0d330-492">Dies ermöglicht es dem Code, den aufrufenden Stapel zu verlieren und dadurch seine Sicherheits Privilegien zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="0d330-492">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0d330-493">Die Verwendung von <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> könnte versehentlich eine Sicherheitslücke eröffnen.</span><span class="sxs-lookup"><span data-stu-id="0d330-493">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="0d330-494">Die Code Zugriffssicherheit basiert auf den Berechtigungs Überprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="0d330-494">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="0d330-495">Wenn die Arbeit in einem Thread Pool Thread mithilfe <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>in die Warteschlange eingereiht wird, verfügt der Stapel des Thread Pool Threads nicht über den Kontext der eigentlichen Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="0d330-495">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="0d330-496">Bösartiger Code kann dies ausnutzen, um Berechtigungs Überprüfungen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="0d330-496">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="0d330-497">Die Verwendung einer <xref:System.Threading.Mutex> für `waitObject` stellt keinen gegenseitigen Ausschluss für die Rückrufe bereit, da die zugrunde liegende Windows-API das Standard-`WT_EXECUTEDEFAULT`-Flag verwendet, sodass jeder Rückruf in einem separaten Thread Pool Thread gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-497">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="0d330-498">Wenn Sie die <xref:System.Threading.RegisteredWaitHandle>, die von dieser Methode zurückgegeben wird, nicht mehr benötigen, wenden Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode an, um Verweise auf das Wait-Handle freizugeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-498">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="0d330-499">Es wird empfohlen, immer die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode aufzurufen, auch wenn Sie `true` für `executeOnlyOnce`angeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-499">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="0d330-500">Die Garbage Collection funktioniert effizienter, wenn Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode anstelle von dem Finalizer des registrierten Wait-Handles aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-500">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0d330-501">Der <paramref name="millisecondsTimeOutInterval" />-Parameter ist kleiner als -1.</span><span class="sxs-lookup"><span data-stu-id="0d330-501">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0d330-502">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="0d330-502">The caller does not have the required permission.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-503">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="0d330-503">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="0d330-504">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-504">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="0d330-505">Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-505">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="0d330-506">Der Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-506">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-507">Das an den Delegaten übergebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="0d330-507">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="0d330-508">Das Timeout in Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="0d330-508">The time-out in milliseconds.</span></span> <span data-ttu-id="0d330-509">Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="0d330-509">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="0d330-510">Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</span><span class="sxs-lookup"><span data-stu-id="0d330-510">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="0d330-511"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-511"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="0d330-512">Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 64-Bit-Ganzzahl mit Vorzeichen angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-512">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="0d330-513">Diese Methode leitet den aufrufenden Stapel nicht an den Arbeitsthread weiter.</span><span class="sxs-lookup"><span data-stu-id="0d330-513">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="0d330-514">Das <see cref="T:System.Threading.RegisteredWaitHandle" />-Objekt, mit dem der registrierte Wartevorgang abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="0d330-514">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-515">Anders als bei der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode gibt <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> den aufrufenden Stapel nicht an den Arbeits Thread weiter.</span><span class="sxs-lookup"><span data-stu-id="0d330-515">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="0d330-516">Dies ermöglicht es dem Code, den aufrufenden Stapel zu verlieren und dadurch seine Sicherheits Privilegien zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="0d330-516">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0d330-517">Die Verwendung von <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> könnte versehentlich eine Sicherheitslücke eröffnen.</span><span class="sxs-lookup"><span data-stu-id="0d330-517">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="0d330-518">Die Code Zugriffssicherheit basiert auf den Berechtigungs Überprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="0d330-518">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="0d330-519">Wenn die Arbeit in einem Thread Pool Thread mithilfe <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>in die Warteschlange eingereiht wird, verfügt der Stapel des Thread Pool Threads nicht über den Kontext der eigentlichen Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="0d330-519">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="0d330-520">Bösartiger Code kann dies ausnutzen, um Berechtigungs Überprüfungen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="0d330-520">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="0d330-521">Die Verwendung einer <xref:System.Threading.Mutex> für `waitObject` stellt keinen gegenseitigen Ausschluss für die Rückrufe bereit, da die zugrunde liegende Windows-API das Standard-`WT_EXECUTEDEFAULT`-Flag verwendet, sodass jeder Rückruf in einem separaten Thread Pool Thread gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-521">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="0d330-522">Wenn Sie die <xref:System.Threading.RegisteredWaitHandle>, die von dieser Methode zurückgegeben wird, nicht mehr benötigen, wenden Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode an, um Verweise auf das Wait-Handle freizugeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-522">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="0d330-523">Es wird empfohlen, immer die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode aufzurufen, auch wenn Sie `true` für `executeOnlyOnce`angeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-523">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="0d330-524">Die Garbage Collection funktioniert effizienter, wenn Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode anstelle von dem Finalizer des registrierten Wait-Handles aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-524">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0d330-525">Der <paramref name="millisecondsTimeOutInterval" />-Parameter ist kleiner als -1.</span><span class="sxs-lookup"><span data-stu-id="0d330-525">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0d330-526">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="0d330-526">The caller does not have the required permission.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-527">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="0d330-527">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="0d330-528">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-528">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="0d330-529">Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-529">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="0d330-530">Der Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-530">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-531">Das an den Delegaten übergebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="0d330-531">The object that is passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="0d330-532">Das durch eine <see cref="T:System.TimeSpan" /> dargestellte Timeout.</span><span class="sxs-lookup"><span data-stu-id="0d330-532">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="0d330-533">Wenn <paramref name="timeout" /> den Wert 0 (null) hat, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="0d330-533">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="0d330-534">Wenn <paramref name="timeout" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</span><span class="sxs-lookup"><span data-stu-id="0d330-534">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="0d330-535"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-535"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="0d330-536">Registriert einen Delegaten, der auf ein <see cref="T:System.Threading.WaitHandle" /> wartet, und gibt einen <see cref="T:System.TimeSpan" />-Wert für das Timeout an. Diese Methode leitet den aufrufenden Stapel nicht an den Arbeitsthread weiter.</span><span class="sxs-lookup"><span data-stu-id="0d330-536">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="0d330-537">Das <see cref="T:System.Threading.RegisteredWaitHandle" />-Objekt, mit dem der registrierte Wartevorgang abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="0d330-537">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-538">Anders als bei der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode gibt <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> den aufrufenden Stapel nicht an den Arbeits Thread weiter.</span><span class="sxs-lookup"><span data-stu-id="0d330-538">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="0d330-539">Dies ermöglicht es dem Code, den aufrufenden Stapel zu verlieren und dadurch seine Sicherheits Privilegien zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="0d330-539">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0d330-540">Die Verwendung von <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> könnte versehentlich eine Sicherheitslücke eröffnen.</span><span class="sxs-lookup"><span data-stu-id="0d330-540">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="0d330-541">Die Code Zugriffssicherheit basiert auf den Berechtigungs Überprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="0d330-541">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="0d330-542">Wenn die Arbeit in einem Thread Pool Thread mithilfe <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>in die Warteschlange eingereiht wird, verfügt der Stapel des Thread Pool Threads nicht über den Kontext der eigentlichen Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="0d330-542">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="0d330-543">Bösartiger Code kann dies ausnutzen, um Berechtigungs Überprüfungen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="0d330-543">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="0d330-544">Die Verwendung einer <xref:System.Threading.Mutex> für `waitObject` stellt keinen gegenseitigen Ausschluss für die Rückrufe bereit, da die zugrunde liegende Windows-API das Standard-`WT_EXECUTEDEFAULT`-Flag verwendet, sodass jeder Rückruf in einem separaten Thread Pool Thread gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-544">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="0d330-545">Wenn Sie die <xref:System.Threading.RegisteredWaitHandle>, die von dieser Methode zurückgegeben wird, nicht mehr benötigen, wenden Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode an, um Verweise auf das Wait-Handle freizugeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-545">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="0d330-546">Es wird empfohlen, immer die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode aufzurufen, auch wenn Sie `true` für `executeOnlyOnce`angeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-546">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="0d330-547">Die Garbage Collection funktioniert effizienter, wenn Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode anstelle von dem Finalizer des registrierten Wait-Handles aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-547">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0d330-548">Der <paramref name="timeout" />-Parameter ist kleiner als -1.</span><span class="sxs-lookup"><span data-stu-id="0d330-548">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0d330-549">Der <paramref name="timeout" />-Parameter ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-549">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0d330-550">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="0d330-550">The caller does not have the required permission.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-551">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="0d330-551">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="0d330-552">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-552">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="0d330-553">Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="0d330-553">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="0d330-554">Der Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-554">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="0d330-555">Das an den Delegaten übergebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="0d330-555">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="0d330-556">Das Timeout in Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="0d330-556">The time-out in milliseconds.</span></span> <span data-ttu-id="0d330-557">Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="0d330-557">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="0d330-558">Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</span><span class="sxs-lookup"><span data-stu-id="0d330-558">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="0d330-559"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-559"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="0d330-560">Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 32-Bit-Ganzzahl ohne Vorzeichen angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-560">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span> <span data-ttu-id="0d330-561">Diese Methode leitet den aufrufenden Stapel nicht an den Arbeitsthread weiter.</span><span class="sxs-lookup"><span data-stu-id="0d330-561">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="0d330-562">Das <see cref="T:System.Threading.RegisteredWaitHandle" />-Objekt, mit dem der registrierte Wartevorgang abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="0d330-562">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d330-563">Anders als bei der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>-Methode gibt <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> den aufrufenden Stapel nicht an den Arbeits Thread weiter.</span><span class="sxs-lookup"><span data-stu-id="0d330-563">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="0d330-564">Dies ermöglicht es dem Code, den aufrufenden Stapel zu verlieren und dadurch seine Sicherheits Privilegien zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="0d330-564">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0d330-565">Die Verwendung von <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> könnte versehentlich eine Sicherheitslücke eröffnen.</span><span class="sxs-lookup"><span data-stu-id="0d330-565">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="0d330-566">Die Code Zugriffssicherheit basiert auf den Berechtigungs Überprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="0d330-566">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="0d330-567">Wenn die Arbeit in einem Thread Pool Thread mithilfe <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>in die Warteschlange eingereiht wird, verfügt der Stapel des Thread Pool Threads nicht über den Kontext der eigentlichen Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="0d330-567">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="0d330-568">Bösartiger Code kann dies ausnutzen, um Berechtigungs Überprüfungen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="0d330-568">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="0d330-569">Die Verwendung einer <xref:System.Threading.Mutex> für `waitObject` stellt keinen gegenseitigen Ausschluss für die Rückrufe bereit, da die zugrunde liegende Windows-API das Standard-`WT_EXECUTEDEFAULT`-Flag verwendet, sodass jeder Rückruf in einem separaten Thread Pool Thread gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="0d330-569">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="0d330-570">Wenn Sie die <xref:System.Threading.RegisteredWaitHandle>, die von dieser Methode zurückgegeben wird, nicht mehr benötigen, wenden Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode an, um Verweise auf das Wait-Handle freizugeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-570">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="0d330-571">Es wird empfohlen, immer die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode aufzurufen, auch wenn Sie `true` für `executeOnlyOnce`angeben.</span><span class="sxs-lookup"><span data-stu-id="0d330-571">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="0d330-572">Die Garbage Collection funktioniert effizienter, wenn Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>-Methode anstelle von dem Finalizer des registrierten Wait-Handles aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0d330-572">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0d330-573">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="0d330-573">The caller does not have the required permission.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="0d330-574">Verwalteter Threadpool</span><span class="sxs-lookup"><span data-stu-id="0d330-574">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
