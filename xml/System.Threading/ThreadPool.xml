<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="238f807decc4260faeb59f462b071f85556afa35" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/17/2019" /><Meta Name="ms.locfileid" Value="59676688" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Threadpool bereit, der verwendet werden kann, um Aufgaben auszuführen, Arbeitselemente bereitzustellen, asynchrone E/A zu verarbeiten, im Auftrag anderer Threads zu warten und Zeitgeber zu verarbeiten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viele Anwendungen erstellen, Threads, die verbringen viel Zeit in den inaktiven Zustand Eintreten eines Ereignisses gewartet wird. Andere Threads könnten einen inaktiven Status nur für die in regelmäßigen Abständen aktiviert werden, um Abfragen für eine Änderung oder Aktualisieren von Statusinformationen eingeben. Der Threadpool können Sie Threads effizienter durch die Bereitstellung Ihrer Anwendung mit einem Pool von Arbeitsthreads, die vom System verwaltet werden. Die folgenden: Beispiele für Vorgänge, die Threads im Threadpool zu verwenden  
  
-   Bei der Erstellung einer <xref:System.Threading.Tasks.Task> oder <xref:System.Threading.Tasks.Task%601> Objekt einige Aufgaben werden standardmäßig asynchron durchführen der Task zur Ausführung auf einem Threadpool-Thread geplant ist.  
  
-   Asynchroner Timer verwenden den Threadpool. Threads im Threadpool ausführen Rückrufe aus der <xref:System.Threading.Timer?displayProperty=nameWithType> Klasse und Auslösen von Ereignissen aus dem <xref:System.Timers.Timer?displayProperty=nameWithType> Klasse.  
  
-   Bei Verwendung von registrierten Wait-Handles überwacht Systemthread den Status der Wait-Handles. Wenn ein Wait-Vorgang abgeschlossen ist, führt ein Arbeitsthread aus dem Threadpool die entsprechenden Callback-Funktion.  
  
-   Beim Aufrufen der <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Methode, um eine Methode für die Ausführung auf einem Threadpool-Thread in die Warteschlange. Die Methode übergeben Sie dazu eine <xref:System.Threading.WaitCallback> delegieren.   Der Delegat besitzt die Signatur  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     wo `state` ist ein Objekt, das Daten enthält, durch den Delegaten verwendet werden. Die tatsächlichen Daten an den Delegaten übergeben werden können, durch den Aufruf der <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> Methode.  
  
> [!NOTE]
>  Die Threads im Pool verwalteten Threads sind Hintergrundthreads. D. h. deren <xref:System.Threading.Thread.IsBackground%2A> Eigenschaften sind `true`. Dies bedeutet, dass eine <xref:System.Threading.ThreadPool> Thread hält sich nicht auf eine Anwendung ausgeführt wird, nachdem alle Vordergrundthreads beendet haben.  
  
> [!IMPORTANT]
>  Wenn der Threadpool einen Thread wiederverwendet, es löscht nicht Daten im threadlokalen Speicher oder mit markierten Felder der <xref:System.ThreadStaticAttribute> Attribut. Aus diesem Grund werden, wenn eine Methode untersucht threadlokalen Speicher oder Felder, die mit markiert sind, die <xref:System.ThreadStaticAttribute> -Attribut, die gefundenen Werte bleiben daher eventuell über aus einer früheren Verwendung der Threadpool-Thread.  
  
 Sie können auch Arbeitselemente Warteschlange, die nicht mit einem "Wait"-Vorgang für den Threadpool verknüpft sind. Um ein Arbeitselement von einem Thread im Threadpool verarbeitet werden, rufen die <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Methode. Diese Methode verwendet als Parameter einen Verweis auf die Methode oder der Delegat, der aufgerufen wird, von dem Thread aus dem Threadpool ausgewählt. Es ist keine Option zum Abbrechen eines Arbeitselements, nachdem es in die Warteschlange gestellt wurde.  
  
 Timerwarteschlange Timer und registrierte Wartevorgänge, auch den Threadpool verwenden. Die Rückruffunktionen werden an den Threadpool in die Warteschlange eingereiht.  
  
 Es gibt einen Threadpool pro Prozess. Ab [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ist die Standardgröße des Threadpools für einen Prozess von mehreren Faktoren abhängig, z. B. von der Größe des virtuellen Adressraums. Ein Prozess kann die <xref:System.Threading.ThreadPool.GetMaxThreads%2A>-Methode aufrufen, um die Anzahl der Threads zu bestimmen.  Die Anzahl der Threads im Threadpool kann geändert werden, mithilfe der <xref:System.Threading.ThreadPool.SetMaxThreads%2A> Methode. Jeder Thread die Standardstapelgröße verwendet und auf die Standardpriorität ausgeführt wird.  
  
> [!NOTE]
>  Nicht verwaltete Code, der das .NET Framework hostet kann die Größe des Threadpools ändern, indem Sie mit der `CorSetMaxThreads` Funktion, die in der Datei mscoree.h definiert.  
  
 Der Threadpool stellt neue Workerthreads oder e/a-Abschlussthreads nach Bedarf, bis der Mindestwert für jede Kategorie erreicht. Wenn ein Minimum erreicht ist, kann Threadpool der Warteschleife hinzu Weitere Threads in dieser Kategorie erstellen oder warten Sie, bis einige Aufgaben abgeschlossen sind. Ab [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] erstellt und zerstört der Threadpool Arbeitsthreads, um den Durchsatz zu optimieren. Der Durchsatz ist als die Anzahl der Aufgaben definiert, die pro Zeiteinheit abgeschlossen werden. Bei zu wenigen Threads werden die verfügbaren Ressourcen möglicherweise nicht optimal genutzt, wohingegen bei zu vielen Threads Ressourcenkonflikte auftreten können.   
  
> [!NOTE]
>  Wenn die Anforderungen niedrig sind, kann die tatsächliche Anzahl der Threads im Threadpool unterhalb der Mindestwerte liegen.  
  
 Sie können die <xref:System.Threading.ThreadPool.GetMinThreads%2A>-Methode verwenden, um diese Mindestwerte abzurufen.   
  
> [!CAUTION]
>  Sie können die <xref:System.Threading.ThreadPool.SetMinThreads%2A> Methode, um die minimale Anzahl von Threads zu erhöhen. Allerdings kann ein unnötiges Erhöhen dieses Wertes zu Leistungsproblemen führen. Wenn zu viele Aufgaben gleichzeitig gestartet werden, werden möglicherweise alle Aufgaben zu langsam ausgeführt. In den meisten Fällen erreicht der Threadpool mit dem eigenen Algorithmus für die Zuordnung von Threads eine bessere Leistung.  
  
   
  
## Examples  
 Im folgenden Beispiel stellt eine Methode namens Thread der hauptanwendung Warteschlange `ThreadProc` zum Ausführen auf einem Thread eines Threadpools, ruht für eine Sekunde, und klicken Sie dann beendet wird. Die `ThreadProc` Methode zeigt einfach eine Nachricht an.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 Wenn Sie den Aufruf Auskommentieren der <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> -Methode der Hauptthread beendet wird, bevor die Methode auf der Threadpool-Thread ausgeführt wird.  Der Threadpool verwendet Hintergrundthreads, die nicht beibehalten wird, führen Sie die Anwendung ausgeführt wird, wenn alle Vordergrundthreads beendet wurden.  (Dies ist ein einfaches Beispiel einer Racebedingung.)  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads und Threading</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Die verwalteten Threadpooling</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bindet ein Betriebssystemhandle an den <see cref="T:System.Threading.ThreadPool" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="osHandle">Ein <see cref="T:System.IntPtr" />, das den Handle enthält. Das Handle muss für überlappende E/A auf der nicht verwalteten Seite geöffnet worden sein.</param>
        <summary>Bindet ein Betriebssystemhandle an den <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns><see langword="true" />, wenn das Handle gebunden ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle">Ein <see cref="T:System.Runtime.InteropServices.SafeHandle" />, das das Betriebssystemhandle enthält. Das Handle muss für überlappende E/A auf der nicht verwalteten Seite geöffnet worden sein.</param>
        <summary>Bindet ein Betriebssystemhandle an den <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns><see langword="true" />, wenn das Handle gebunden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `osHandle` Parameter muss ein <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, die abgeleitet wird von der abstrakten <xref:System.Runtime.InteropServices.SafeHandle> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="osHandle" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Die Anzahl der verfügbaren Arbeitsthreads.</param>
        <param name="completionPortThreads">Die Anzahl der verfügbaren asynchronen E/A-Threads.</param>
        <summary>Ruft die Differenz zwischen der von der <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />-Methode zurückgegebenen maximalen Anzahl der Threads im Threadpool und der Anzahl der gerade aktiven Threads ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> zurückgibt, die von angegebene Variable `workerThreads` enthält die Anzahl der zusätzlichen Worker-Threads, die gestartet werden können, und die Variable, die anhand des `completionPortThreads` enthält die Anzahl der zusätzlichen asynchronen e/a-Threads, die sein können gestartet.  
  
 Wenn keine verfügbaren Threads vorhanden sind, durch zusätzliche Threads Pool Anforderungen in der Warteschlange bleiben bis Threads des Threadpools verfügbar sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Anzahl der Arbeitsthreads und e/a-Threads zur Verfügung, wenn eine einfache app gestartet wird.  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Die maximale Anzahl der Arbeitsthreads im Threadpool.</param>
        <param name="completionPortThreads">Die maximale Anzahl asynchroner E/A-Threads im Threadpool.</param>
        <summary>Ruft die Anzahl der Anforderungen für den Threadpool ab, die gleichzeitig aktiv sein können. Alle über diese Zahl hinausgehenden Anforderungen bleiben in der Warteschlange, bis die Threads des Threadpools verfügbar sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Threading.ThreadPool.GetMaxThreads%2A> zurückgibt, die von angegebene Variable `workerThreads` enthält die maximale Anzahl von Arbeitsthreads im Threadpool zulässig, und die Variable, die anhand des `completionPortThreads` enthält die maximale Anzahl von asynchronen e/a-Threads, die innerhalb der ThreadPool.  
  
 Sie können die <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> Methode, um die tatsächliche Anzahl der Threads im Threadpool der Warteschleife hinzu zu jedem Zeitpunkt zu bestimmen.  
  
 Sie können die <xref:System.Threading.ThreadPool.SetMaxThreads%2A> , legen Sie die maximale Anzahl von Arbeitsthreads und asynchrone e/a-Threads im Threadpool der Warteschleife hinzu.  
  
 Sie können die Warteschlange wie viele Anforderungen von Pool thread, während der Systemspeicher ermöglicht. Wenn es mehr Anforderungen als Threadpool-Threads sind, die zusätzlichen Anforderungen in der Warteschlange bleiben bis Threads des Threadpools verfügbar sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Abrufen der maximalen und der verfügbaren Anzahl von Threads im Threadpool der Warteschleife hinzu. Ein Arbeitselement wird in die Warteschlange, die verwendet `FileStream` asynchron in zwei Dateien geschrieben. Die Rückrufmethoden zeitlich gesteuert, die sich überschneiden. Ein Arbeitsthread verarbeitet das Arbeitselement, und abhängig von der Geschwindigkeit und die Anzahl der Prozessoren auf dem Computer, ein oder zwei abschlussportthreads behandelt die Schreibvorgänge.  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Enthält nach der Rückgabe dieser Methode die Mindestanzahl von Arbeitsthreads, die der Threadpool bei Bedarf erstellt.</param>
        <param name="completionPortThreads">Enthält nach der Rückgabe dieser Methode die Mindestanzahl von asynchronen E/A-Threads, die der Threadpool bei Bedarf erstellt.</param>
        <summary>Ruft die Mindestanzahl von Threads ab, die der Threadpool bei Bedarf erstellt, wenn neue Anforderungen gestellt werden, bevor zu einem Algorithmus zum Verwalten von Threaderstellung und -löschung gewechselt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Threadpool stellt neue Workerthreads oder e/a-Abschlussthreads nach Bedarf, bis der Mindestwert für jede Kategorie erreicht. Standardmäßig ist die minimale Anzahl von Threads auf die Anzahl der Prozessoren auf einem System festgelegt. Wenn das Minimum erreicht ist, kann Threadpool der Warteschleife hinzu Weitere Threads in dieser Kategorie erstellen oder warten Sie, bis einige Aufgaben abgeschlossen sind. Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], der Threadpool erstellt und zerstört Threads um Durchsatz zu optimieren, die als die Anzahl der Aufgaben definiert ist, die pro Zeiteinheit abgeschlossen. Bei zu wenigen Threads werden die verfügbaren Ressourcen möglicherweise nicht optimal genutzt, wohingegen bei zu vielen Threads Ressourcenkonflikte auftreten können.   
  
> [!NOTE]
>  Wenn die Anforderungen niedrig sind, kann die tatsächliche Anzahl der Threads im Threadpool unterhalb der Mindestwerte liegen.  
  
   
  
## Examples  
 Im folgende Beispiel legt die minimale Anzahl von Arbeitsthreads auf vier, und behält den ursprünglichen Wert für die minimale Anzahl von asynchronen e/a-Abschlussthreads.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der Warteschlange eine auszuführende Methode hinzu. Die Methode wird ausgeführt, wenn ein Thread des Threadpools verfügbar wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">Ein <see cref="T:System.Threading.WaitCallback" />, der die auszuführende Methode darstellt.</param>
        <summary>Fügt der Warteschlange eine auszuführende Methode hinzu. Die Methode wird ausgeführt, wenn ein Thread des Threadpools verfügbar wird.</summary>
        <returns><see langword="true" />, wenn die Methode erfolgreich in die Warteschlange eingereiht wurde. <see cref="T:System.NotSupportedException" /> wird ausgelöst, wenn das Arbeitselement nicht in die Warteschlange eingereiht werden konnte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie von der Methode in der Warteschlange in den Instanzfeldern der Klasse in der die Methode definiert ist, oder Sie können Daten platzieren der <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> Überladung, die ein Objekt mit den erforderlichen Daten akzeptiert.  
  
> [!NOTE]
>  Visual Basic-Benutzer können weglassen der <xref:System.Threading.WaitCallback> Konstruktor, und verwenden Sie einfach die `AddressOf` beim Übergeben der Rückrufmethode, um den Operator <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic ruft automatisch den richtigen Delegaten-Konstruktor.  
  
## <a name="version-information"></a>Versionsinformationen  
 In .NET Framework, Version 2.0 der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> Eigenschaftswert an Arbeitsthreads weitergegeben, in der Warteschlange mit der <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Methode. In früheren Versionen wird die dienstprinzipalinformationen nicht weitergegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> -methodenüberladung, um einen Task, der durch dargestellt wird in die Warteschlange die `ThreadProc` Methode, um ausgeführt werden, wenn ein Thread verfügbar wird. Es sind keine Taskinformationen wird mit dieser Überladung bereitgestellt. Aus diesem Grund die Informationen, die zur Verfügung steht die `ThreadProc` Methode ist beschränkt auf das Objekt, das die Methode gehört.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Common Language Runtime (CLR) wird gehostet, und der Host unterstützt diese Aktion nicht.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">Ein <see cref="T:System.Threading.WaitCallback" />, der die auszuführende Methode darstellt.</param>
        <param name="state">Ein Objekt, das die von der Methode zu verwendenden Daten enthält.</param>
        <summary>Fügt der Warteschlange eine auszuführende Methode hinzu und gibt ein Objekt an, das die von der Methode zu verwendenden Daten enthält. Die Methode wird ausgeführt, wenn ein Thread des Threadpools verfügbar wird.</summary>
        <returns><see langword="true" />, wenn die Methode erfolgreich in die Warteschlange eingereiht wurde. <see cref="T:System.NotSupportedException" /> wird ausgelöst, wenn das Arbeitselement nicht in die Warteschlange eingereiht werden konnte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Callback-Methode auf komplexe Daten erfordert, können Sie eine Klasse, um die Daten enthalten definieren.  
  
> [!NOTE]
>  Visual Basic-Benutzer können weglassen der <xref:System.Threading.WaitCallback> Konstruktor, und verwenden Sie einfach die `AddressOf` beim Übergeben der Rückrufmethode, um den Operator <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic ruft automatisch den richtigen Delegaten-Konstruktor.  
  
## <a name="version-information"></a>Versionsinformationen  
 In .NET Framework, Version 2.0 der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> Eigenschaftswert an Arbeitsthreads weitergegeben, in der Warteschlange mit der <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Methode. In früheren Versionen wird die dienstprinzipalinformationen nicht weitergegeben.  
  
   
  
## Examples  
 Das folgende Beispiel verwendet den .NET Threadpool zum Berechnen der `Fibonacci` Ergebnis für fünf Zahlen zwischen 20 und 40. Jedes `Fibonacci`-Ergebnis wird von der `Fibonacci`-Klasse repräsentiert, die eine Methode mit dem Namen `ThreadPoolCallback` bietet, die die Berechnung durchführt. Ein Objekt, das jeden `Fibonacci`-Wert repräsentiert, wird erstellt, und die `ThreadPoolCallback`-Methode wird an <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> übergeben, das dem Pool einen verfügbaren Thread zuweist, um die Methode auszuführen.  
  
 Da jede `Fibonacci` Objekt erhält einen halb-zufälliger Wert zum Berechnen, und da jeder Thread für die Prozessorzeit konkurrieren, wissen Sie, können nicht im voraus, wie lange es für alle fünf Ergebnisse berechnet werden dauert. Deshalb wird jedem `Fibonacci`-Objekt eine Instanz der <xref:System.Threading.ManualResetEvent>-Klasse während der Konstruktion übergeben. Jedes Objekt gibt das angegebenen Ereignisobjekt wenn seine Berechnung abgeschlossen ist, wodurch den primären Thread die Ausführung von Block mit <xref:System.Threading.WaitHandle.WaitAll%2A> bis alle fünf `Fibonacci` Objekte ein Ergebnis berechnet haben. Die `Main`-Methode zeigt dann jedes `Fibonacci`-Ergebnis an.
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Common Language Runtime (CLR) wird gehostet, und der Host unterstützt diese Aktion nicht.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">Der Typ der Elemente von <paramref name="state" />.</typeparam>
        <param name="callBack">Eine <see cref="T:System.Action`1" />, die die auszuführende Methode darstellt.</param>
        <param name="state">Ein Objekt, das die von der Methode zu verwendenden Daten enthält.</param>
        <param name="preferLocal">Im Gegensatz zu anderen QueueUserWorkItem-Methoden wird die Ausführung im lokalen Threadpool und nicht der im globalen Threadpool vorgezogen.</param>
        <summary>Fügt der Warteschlange eine Methode hinzu, die von einem <see cref="T:System.Action`1" />-Delegat zur Ausführung angegeben wird, und stellt die von der Methode zu verwendenden Daten bereit. Die Methode wird ausgeführt, wenn ein Thread des Threadpools verfügbar wird.</summary>
        <returns><see langword="true" />, wenn die Methode erfolgreich in die Warteschlange eingereiht wurde. <see cref="T:System.NotSupportedException" /> wird ausgelöst, wenn das Arbeitselement nicht in die Warteschlange eingereiht werden konnte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert einen Delegaten, der auf ein <see cref="T:System.Threading.WaitHandle" /> wartet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />. Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Der <see cref="T:System.Threading.WaitOrTimerCallback" />-Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</param>
        <param name="state">Das an den Delegaten übergebene Objekt.</param>
        <param name="millisecondsTimeOutInterval">Das Timeout in Millisekunden. Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück. Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</param>
        <param name="executeOnlyOnce"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</param>
        <summary>Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 32-Bit-Ganzzahl mit Vorzeichen angegeben wird.</summary>
        <returns>Das <see cref="T:System.Threading.RegisteredWaitHandle" />, das das systemeigene Handle kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie fertig sind mit den <xref:System.Threading.RegisteredWaitHandle> , die von dieser Methode zurückgegeben wird, rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode, um Verweise auf das Wait-Handle freigeben. Es wird empfohlen, Sie rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> -Methode, selbst wenn Sie angeben, `true` für `executeOnlyOnce`. Die automatische speicherbereinigung wird effizienter Aufrufen der <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode anstelle von abhängig von der registrierten Wait-Handles Finalizer.  
  
 Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode fügt den angegebenen Delegaten an den Threadpool. Ein Arbeitsthread wird der Delegat ausgeführt, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Das angegebene Objekt ist in den signalisierten Zustand.  
  
-   Das Timeoutintervall abgelaufen ist.  
  
 Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode überprüft den aktuellen Zustand des angegebenen Objekts <xref:System.Threading.WaitHandle>. Wenn der Zustand des Objekts nicht signalisiert ist, registriert die Methode eine "Wait"-Vorgang aus. Der Wartevorgang wird durch einen Thread aus dem Threadpool ausgeführt. Der Delegat wird von einem Arbeitsthread ausgeführt, wenn es sich bei den Zustand des Objekts signalisiert wird oder das Timeoutintervall abgelaufen ist. Wenn die `timeOutInterval` Parameter ist nicht 0 (null) und die `executeOnlyOnce` Parameter `false`, der Zeitgeber wird zurückgesetzt, jedes Mal, wenn das Ereignis signalisiert wird, oder das Timeoutintervall abgelaufen ist.  
  
> [!IMPORTANT]
>  Mit einem <xref:System.Threading.Mutex> für `waitObject` bietet keine gegenseitigen Ausschluss für die Rückrufe aus, da die zugrunde liegende Windows-API verwendet `WT_EXECUTEDEFAULT` kennzeichnen, sodass jeder Rückruf auf einem separaten Thread eines Threadpools verteilt wird. Statt eine <xref:System.Threading.Mutex>, verwenden Sie eine <xref:System.Threading.Semaphore> mit einer maximalen Anzahl von 1.  
  
 Um den Wartevorgang zu löschen, rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode.  
  
 Der Wait-Thread mithilfe der Win32- `WaitForMultipleObjects` Funktion registrierte Wartevorgänge zu überwachen. Aus diesem Grund werden, wenn Sie in der gleichen systemeigenes Betriebssystem-Handle verwenden, müssen mehrere Aufrufe <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, müssen Sie mithilfe der Win32-Handles duplizieren `DuplicateHandle` Funktion. Beachten Sie, dass Sie kein Ereignisobjekt an übergeben IWV (Puls) sollten <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, da der Wartethread möglicherweise nicht erkennt, dass das Ereignis signalisiert wird, bevor es zurückgesetzt wird.  
  
 Vor der Rückgabe, ändert die Funktion den Zustand des einige Typen von Synchronisierungsobjekten. Änderung wird vorgenommen, nur für das Objekt, dessen signalisierten Zustand verursacht, die wartebedingung erfüllt hat. Beispielsweise wird die Anzahl der ein Semaphor um 1 verringert.  
  
## <a name="version-information"></a>Versionsinformationen  
 Ab .NET Framework, Version 2.0 der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> Eigenschaftswert an Arbeitsthreads weitergegeben, in der Warteschlange mit der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode. In früheren Versionen wird die dienstprinzipalinformationen nicht weitergegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="millisecondsTimeOutInterval" />-Parameter ist kleiner als -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />. Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Der <see cref="T:System.Threading.WaitOrTimerCallback" />-Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</param>
        <param name="state">Das an den Delegaten übergebene Objekt.</param>
        <param name="millisecondsTimeOutInterval">Das Timeout in Millisekunden. Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück. Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</param>
        <param name="executeOnlyOnce"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</param>
        <summary>Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 64-Bit-Ganzzahl mit Vorzeichen angegeben wird.</summary>
        <returns>Das <see cref="T:System.Threading.RegisteredWaitHandle" />, das das systemeigene Handle kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie fertig sind mit den <xref:System.Threading.RegisteredWaitHandle> , die von dieser Methode zurückgegeben wird, rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode, um Verweise auf das Wait-Handle freigeben. Es wird empfohlen, Sie rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> -Methode, selbst wenn Sie angeben, `true` für `executeOnlyOnce`. Die automatische speicherbereinigung wird effizienter Aufrufen der <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode anstelle von abhängig von der registrierten Wait-Handles Finalizer.  
  
 Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode fügt den angegebenen Delegaten an den Threadpool. Ein Arbeitsthread wird der Delegat ausgeführt, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Das angegebene Objekt ist in den signalisierten Zustand.  
  
-   Das Timeoutintervall abgelaufen ist.  
  
 Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode überprüft den aktuellen Zustand des angegebenen Objekts <xref:System.Threading.WaitHandle>. Wenn der Zustand des Objekts nicht signalisiert ist, registriert die Methode eine "Wait"-Vorgang aus. Der Wartevorgang wird durch einen Thread aus dem Threadpool ausgeführt. Der Delegat wird von einem Arbeitsthread ausgeführt, wenn es sich bei den Zustand des Objekts signalisiert wird oder das Timeoutintervall abgelaufen ist. Wenn die `timeOutInterval` Parameter ist nicht 0 (null) und die `executeOnlyOnce` Parameter `false`, der Zeitgeber wird zurückgesetzt, jedes Mal, wenn das Ereignis signalisiert wird, oder das Timeoutintervall abgelaufen ist.  
  
> [!IMPORTANT]
>  Mit einem <xref:System.Threading.Mutex> für `waitObject` bietet keine gegenseitigen Ausschluss für die Rückrufe aus, da die zugrunde liegende Windows-API verwendet `WT_EXECUTEDEFAULT` kennzeichnen, sodass jeder Rückruf auf einem separaten Thread eines Threadpools verteilt wird. Statt eine <xref:System.Threading.Mutex>, verwenden Sie eine <xref:System.Threading.Semaphore> mit einer maximalen Anzahl von 1.  
  
 Um den Wartevorgang zu löschen, rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode.  
  
 Der Wait-Thread mithilfe der Win32- `WaitForMultipleObjects` Funktion registrierte Wartevorgänge zu überwachen. Aus diesem Grund werden, wenn Sie in der gleichen systemeigenes Betriebssystem-Handle verwenden, müssen mehrere Aufrufe <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, müssen Sie mithilfe der Win32-Handles duplizieren `DuplicateHandle` Funktion. Beachten Sie, dass Sie kein Ereignisobjekt an übergeben IWV (Puls) sollten <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, da der Wartethread möglicherweise nicht erkennt, dass das Ereignis signalisiert wird, bevor es zurückgesetzt wird.  
  
 Vor der Rückgabe, ändert die Funktion den Zustand des einige Typen von Synchronisierungsobjekten. Änderung wird vorgenommen, nur für das Objekt, dessen signalisierten Zustand verursacht, die wartebedingung erfüllt hat. Beispielsweise wird die Anzahl der ein Semaphor um 1 verringert.  
  
## <a name="version-information"></a>Versionsinformationen  
 Ab .NET Framework, Version 2.0 der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> Eigenschaftswert an Arbeitsthreads weitergegeben, in der Warteschlange mit der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode. In früheren Versionen wird die dienstprinzipalinformationen nicht weitergegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="millisecondsTimeOutInterval" />-Parameter ist kleiner als -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />. Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Der <see cref="T:System.Threading.WaitOrTimerCallback" />-Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</param>
        <param name="state">Das an den Delegaten übergebene Objekt.</param>
        <param name="timeout">Das durch eine <see cref="T:System.TimeSpan" /> dargestellte Timeout. Wenn <paramref name="timeout" /> den Wert 0 (null) hat, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück. Wenn <paramref name="timeout" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</param>
        <param name="executeOnlyOnce"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</param>
        <summary>Registriert einen Delegaten, der auf ein <see cref="T:System.Threading.WaitHandle" /> wartet, und gibt einen <see cref="T:System.TimeSpan" />-Wert für das Timeout an.</summary>
        <returns>Das <see cref="T:System.Threading.RegisteredWaitHandle" />, das das systemeigene Handle kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie fertig sind mit den <xref:System.Threading.RegisteredWaitHandle> , die von dieser Methode zurückgegeben wird, rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode, um Verweise auf das Wait-Handle freigeben. Es wird empfohlen, Sie rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> -Methode, selbst wenn Sie angeben, `true` für `executeOnlyOnce`. Die automatische speicherbereinigung wird effizienter Aufrufen der <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode anstelle von abhängig von der registrierten Wait-Handles Finalizer.  
  
 Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode fügt den angegebenen Delegaten an den Threadpool. Ein Arbeitsthread wird der Delegat ausgeführt, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Das angegebene Objekt ist in den signalisierten Zustand.  
  
-   Das Timeoutintervall abgelaufen ist.  
  
 Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode überprüft den aktuellen Zustand des angegebenen Objekts <xref:System.Threading.WaitHandle>. Wenn der Zustand des Objekts nicht signalisiert ist, registriert die Methode eine "Wait"-Vorgang aus. Der Wartevorgang wird durch einen Thread aus dem Threadpool ausgeführt. Der Delegat wird von einem Arbeitsthread ausgeführt, wenn es sich bei den Zustand des Objekts signalisiert wird oder das Timeoutintervall abgelaufen ist. Wenn die `timeOutInterval` Parameter ist nicht 0 (null) und die `executeOnlyOnce` Parameter `false`, der Zeitgeber wird zurückgesetzt, jedes Mal, wenn das Ereignis signalisiert wird, oder das Timeoutintervall abgelaufen ist.  
  
> [!IMPORTANT]
>  Mit einem <xref:System.Threading.Mutex> für `waitObject` bietet keine gegenseitigen Ausschluss für die Rückrufe aus, da die zugrunde liegende Windows-API verwendet `WT_EXECUTEDEFAULT` kennzeichnen, sodass jeder Rückruf auf einem separaten Thread eines Threadpools verteilt wird. Statt eine <xref:System.Threading.Mutex>, verwenden Sie eine <xref:System.Threading.Semaphore> mit einer maximalen Anzahl von 1.  
  
 Um den Wartevorgang zu löschen, rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode.  
  
 Der Wait-Thread mithilfe der Win32- `WaitForMultipleObjects` Funktion registrierte Wartevorgänge zu überwachen. Aus diesem Grund werden, wenn Sie in der gleichen systemeigenes Betriebssystem-Handle verwenden, müssen mehrere Aufrufe <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, müssen Sie mithilfe der Win32-Handles duplizieren `DuplicateHandle` Funktion. Beachten Sie, dass Sie kein Ereignisobjekt an übergeben IWV (Puls) sollten <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, da der Wartethread möglicherweise nicht erkennt, dass das Ereignis signalisiert wird, bevor es zurückgesetzt wird.  
  
 Vor der Rückgabe, ändert die Funktion den Zustand des einige Typen von Synchronisierungsobjekten. Änderung wird vorgenommen, nur für das Objekt, dessen signalisierten Zustand verursacht, die wartebedingung erfüllt hat. Beispielsweise wird die Anzahl der ein Semaphor um 1 verringert.  
  
## <a name="version-information"></a>Versionsinformationen  
 Ab .NET Framework, Version 2.0 der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> Eigenschaftswert an Arbeitsthreads weitergegeben, in der Warteschlange mit der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode. In früheren Versionen wird die dienstprinzipalinformationen nicht weitergegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="timeout" />-Parameter ist kleiner als -1.</exception>
        <exception cref="T:System.NotSupportedException">Der <paramref name="timeout" />-Parameter ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />. Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Der <see cref="T:System.Threading.WaitOrTimerCallback" />-Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</param>
        <param name="state">Das an den Delegaten übergebene Objekt.</param>
        <param name="millisecondsTimeOutInterval">Das Timeout in Millisekunden. Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück. Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</param>
        <param name="executeOnlyOnce"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</param>
        <summary>Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 32-Bit-Ganzzahl ohne Vorzeichen angegeben wird.</summary>
        <returns>Das <see cref="T:System.Threading.RegisteredWaitHandle" />, mit dem der registrierte Wartevorgang abgebrochen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie fertig sind mit den <xref:System.Threading.RegisteredWaitHandle> , die von dieser Methode zurückgegeben wird, rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode, um Verweise auf das Wait-Handle freigeben. Es wird empfohlen, Sie rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> -Methode, selbst wenn Sie angeben, `true` für `executeOnlyOnce`. Die automatische speicherbereinigung wird effizienter Aufrufen der <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode anstelle von abhängig von der registrierten Wait-Handles Finalizer.  
  
 Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode fügt den angegebenen Delegaten an den Threadpool. Ein Arbeitsthread wird der Delegat ausgeführt, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Das angegebene Objekt ist in den signalisierten Zustand.  
  
-   Das Timeoutintervall abgelaufen ist.  
  
 Die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode überprüft den aktuellen Zustand des angegebenen Objekts <xref:System.Threading.WaitHandle>. Wenn der Zustand des Objekts nicht signalisiert ist, registriert die Methode eine "Wait"-Vorgang aus. Der Wartevorgang wird durch einen Thread aus dem Threadpool ausgeführt. Der Delegat wird von einem Arbeitsthread ausgeführt, wenn es sich bei den Zustand des Objekts signalisiert wird oder das Timeoutintervall abgelaufen ist. Wenn die `timeOutInterval` Parameter ist nicht 0 (null) und die `executeOnlyOnce` Parameter `false`, der Zeitgeber wird zurückgesetzt, jedes Mal, wenn das Ereignis signalisiert wird, oder das Timeoutintervall abgelaufen ist.  
  
> [!IMPORTANT]
>  Mit einem <xref:System.Threading.Mutex> für `waitObject` bietet keine gegenseitigen Ausschluss für die Rückrufe aus, da die zugrunde liegende Windows-API verwendet `WT_EXECUTEDEFAULT` kennzeichnen, sodass jeder Rückruf auf einem separaten Thread eines Threadpools verteilt wird. Statt eine <xref:System.Threading.Mutex>, verwenden Sie eine <xref:System.Threading.Semaphore> mit einer maximalen Anzahl von 1.  
  
 Um den Wartevorgang zu löschen, rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode.  
  
 Der Wait-Thread mithilfe der Win32- `WaitForMultipleObjects` Funktion registrierte Wartevorgänge zu überwachen. Aus diesem Grund werden, wenn Sie in der gleichen systemeigenes Betriebssystem-Handle verwenden, müssen mehrere Aufrufe <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, müssen Sie mithilfe der Win32-Handles duplizieren `DuplicateHandle` Funktion. Beachten Sie, dass Sie kein Ereignisobjekt an übergeben IWV (Puls) sollten <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, da der Wartethread möglicherweise nicht erkennt, dass das Ereignis signalisiert wird, bevor es zurückgesetzt wird.  
  
 Vor der Rückgabe, ändert die Funktion den Zustand des einige Typen von Synchronisierungsobjekten. Änderung wird vorgenommen, nur für das Objekt, dessen signalisierten Zustand verursacht, die wartebedingung erfüllt hat. Beispielsweise wird die Anzahl der ein Semaphor um 1 verringert.  
  
## <a name="version-information"></a>Versionsinformationen  
 Ab .NET Framework, Version 2.0 der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> Eigenschaftswert an Arbeitsthreads weitergegeben, in der Warteschlange mit der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode. In früheren Versionen wird die dienstprinzipalinformationen nicht weitergegeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode, um eine angegebene Rückrufmethode ausführen, wenn einem angegebenen Wait-Handle signalisiert wird. In diesem Beispiel wird die Rückrufmethode `WaitProc`, und das Wait-Handle ist ein <xref:System.Threading.AutoResetEvent>.  
  
 Das Beispiel definiert eine `TaskInfo` Klasse, die die Informationen enthält, die an den Rückruf übergeben wird, wenn er ausgeführt wird. Das Beispiel erstellt eine `TaskInfo` -Objekt und weist ihr einige Zeichenfolgendaten. Die <xref:System.Threading.RegisteredWaitHandle> von zurückgegebenen der <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode zugewiesen ist die `Handle` Feld der `TaskInfo` Objekts, sodass die Callback-Methode zugreifen der <xref:System.Threading.RegisteredWaitHandle>.  
  
 Zusätzlich zur Angabe `TaskInfo` -Objekts, das an die Rückrufmethode, die den Aufruf übergeben die <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode gibt die <xref:System.Threading.AutoResetEvent> , die die Aufgabe wartet, eine <xref:System.Threading.WaitOrTimerCallback> Delegat, der darstellt der `WaitProc` Callback-Methode, eine eine zweite Timeoutintervalls und mehrerer Rückrufe.  
  
 Wenn der Hauptthread signalisiert der <xref:System.Threading.AutoResetEvent> durch Aufrufen der <xref:System.Threading.EventWaitHandle.Set%2A> -Methode, die <xref:System.Threading.WaitOrTimerCallback> Delegat wird aufgerufen. Die `WaitProc` Methode Tests <xref:System.Threading.RegisteredWaitHandle> zu bestimmen, ob ein Timeout aufgetreten ist. Wenn der Rückruf aufgerufen wurde, weil das Wait-Handle signalisiert wurde, die `WaitProc` Methode hebt die Registrierung der <xref:System.Threading.RegisteredWaitHandle>, zusätzlicher Rückrufe zu beenden. Im Falle eines Timeouts weiter die Aufgabe wartet auf. Die `WaitProc` Methode beendet wird, wird eine Meldung an die Konsole.  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="millisecondsTimeOutInterval" />-Parameter ist kleiner als -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Die maximale Anzahl der Arbeitsthreads im Threadpool.</param>
        <param name="completionPortThreads">Die maximale Anzahl asynchroner E/A-Threads im Threadpool.</param>
        <summary>Legt die Anzahl der Anforderungen für den Threadpool fest, die gleichzeitig aktiv sein können. Alle über diese Zahl hinausgehenden Anforderungen bleiben in der Warteschlange, bis die Threads des Threadpools verfügbar sind.</summary>
        <returns><see langword="true" />, wenn die Änderung erfolgreich ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können nicht die maximale Anzahl von Arbeitsthreads oder e/a-Abschlussthreads in eine Zahl kleiner als die Anzahl der Prozessoren auf dem Computer festlegen. Um zu bestimmen, wie viele Prozessoren vorhanden sind, Abrufen des Werts der <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> Eigenschaft. Darüber hinaus können nicht die maximale Anzahl von Arbeitsthreads oder e/a-Abschlussthreads in eine Zahl kleiner als die entsprechende minimale Anzahl von Arbeitsthreads oder e/a-Abschlussthreads festlegen. Um die Größe des Pools mindestens erforderlichen Threadanzahl zu bestimmen, rufen die <xref:System.Threading.ThreadPool.GetMinThreads%2A> Methode.  
  
 Wenn die common Language Runtime gehostet wird, z. B. indem Sie Internet Information Services (IIS) oder SQL Server, kann der Host einschränken oder zu verhindern, dass Änderungen der Größe des Thread-Pools.  
  
 Vorsichtig, wenn Sie die maximale Anzahl von Threads im Threadpool der Warteschleife hinzu. Während Ihr Code von Vorteil sein könnte, möglicherweise die Änderungen eine negative Auswirkung auf Code-Bibliotheken, die Sie verwenden.  
  
 Festlegen der Größe des Thread-Pools zu groß, kann zu Leistungsproblemen führen. Wenn zu viele Threads gleichzeitig ausgeführt werden, wird die programmumschaltung Aufwand ein bedeutender Faktor.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit zur Steuerung von Threads. Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Die Mindestanzahl von Arbeitsthreads, die der Threadpool bei Bedarf erstellt.</param>
        <param name="completionPortThreads">Die Mindestanzahl von asynchronen E/A-Threads, die der Threadpool bei Bedarf erstellt.</param>
        <summary>Legt die Mindestanzahl von Threads fest, die der Threadpool bei Bedarf erstellt, wenn neue Anforderungen gestellt werden, bevor zu einem Algorithmus zum Verwalten von Threaderstellung und -löschung gewechselt wird.</summary>
        <returns><see langword="true" />, wenn die Änderung erfolgreich ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Threadpool stellt neue Workerthreads oder e/a-Abschlussthreads nach Bedarf, bis der Mindestwert für jede Kategorie erreicht. Wenn das Minimum erreicht ist, kann Threadpool der Warteschleife hinzu Weitere Threads in dieser Kategorie erstellen oder warten Sie, bis einige Aufgaben abgeschlossen sind. Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], der Threadpool erstellt und zerstört Threads um Durchsatz zu optimieren, die als die Anzahl der Aufgaben definiert ist, die pro Zeiteinheit abgeschlossen. Bei zu wenigen Threads werden die verfügbaren Ressourcen möglicherweise nicht optimal genutzt, wohingegen bei zu vielen Threads Ressourcenkonflikte auftreten können.   
  
 Wenn die Anforderungen niedrig sind, kann die tatsächliche Anzahl der Threads im Threadpool unterhalb der Mindestwerte liegen.  
  
 Wenn Sie eine negative Zahl oder eine Zahl größer als die maximale Anzahl von aktiven Threads im Threadpool angeben (abgerufen mithilfe von <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> gibt `false` und ändert sich der Mindestwerte nicht.  
  
> [!CAUTION]
>  Standardmäßig ist die minimale Anzahl von Threads auf die Anzahl der Prozessoren auf einem System festgelegt. Sie können die <xref:System.Threading.ThreadPool.SetMinThreads%2A> Methode, um die minimale Anzahl von Threads zu erhöhen. Allerdings kann ein unnötiges Erhöhen dieses Wertes zu Leistungsproblemen führen. Wenn zu viele Aufgaben gleichzeitig gestartet werden, werden möglicherweise alle Aufgaben zu langsam ausgeführt. In den meisten Fällen wird der Threadpool mit dem eigenen Algorithmus für die Zuordnung von Threads eine bessere Leistung. Die Mindestanzahl auf weniger als die Anzahl der Prozessoren auch die Leistung beeinträchtigen kann.  
  
   
  
## Examples  
 Im folgende Beispiel legt die minimale Anzahl von Arbeitsthreads auf vier, und behält den ursprünglichen Wert für die minimale Anzahl von asynchronen e/a-Abschlussthreads.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit zur Steuerung von Threads. Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="overlapped">Die <see cref="T:System.Threading.NativeOverlapped" />-Struktur, die in die Warteschlange gestellt werden soll.</param>
        <summary>Stellt einen überlappenden E/A-Vorgang zur Ausführung in die Warteschlange.</summary>
        <returns><see langword="true" />, wenn die Operation erfolgreich in die Warteschlange eines E/A-Abschlussanschlusses gestellt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Verwendung von systemeigenen Win32 e/a überlappend, finden Sie unter der <xref:System.Threading.Overlapped> -Klasse, die <xref:System.Threading.NativeOverlapped> Struktur, und die `OVERLAPPED` Struktur im Win32-Plattform-SDK.  
  
> [!CAUTION]
>  Mithilfe der <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> Methode kann eine Sicherheitslücke unbeabsichtigt. Codezugriffssicherheit Basen die berechtigungsüberprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel. Wenn Arbeit wird in die Warteschlange ein Thread im Threadpool mit <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, der Stapel des Threadpoolthreads verfügt nicht über den Kontext des tatsächlichen Aufrufers. Bösartiger Code möglicherweise nutzen Sie diese Option, um die Überprüfung der Ausführungsberechtigung zu vermeiden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callBack">Ein <see cref="T:System.Threading.WaitCallback" />, der den aufzurufenden Delegaten darstellt, wenn ein Thread im Threadpool das Arbeitselement aufnimmt.</param>
        <param name="state">Das Objekt, das an den Delegaten übergeben wird, wenn die Bearbeitung aus dem Threadpool erfolgt.</param>
        <summary>Stellt den angegebenen Delegaten in eine Warteschlange für den Threadpool, leitet die Aufrufliste jedoch nicht an den Arbeitsthread weiter.</summary>
        <returns><see langword="true" />, wenn die Methode erfolgreich ist. <see cref="T:System.OutOfMemoryException" /> wird ausgelöst, wenn die Arbeitsaufgabe nicht in die Warteschlange gestellt werden konnte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Methode <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> den aufrufenden Stapel an den Arbeitsthread wird nicht weitergegeben. Dadurch kann Code, den aufrufenden Stapel verloren gehen und somit auch die Sicherheitsberechtigungen zu erhöhen.  
  
> [!CAUTION]
>  Mithilfe von <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> kann unbeabsichtigt eine Sicherheitslücke. Codezugriffssicherheit Basen die berechtigungsüberprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel. Wenn Arbeit wird in die Warteschlange ein Thread im Threadpool mit <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, der Stapel des Threadpoolthreads müssen sich nicht auf den Kontext des tatsächlichen Aufrufers. Bösartiger Code möglicherweise nutzen Sie diese Option, um die Überprüfung der Ausführungsberechtigung zu vermeiden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ApplicationException">Es war nicht genügend Arbeitsspeicher vorhanden.</exception>
        <exception cref="T:System.OutOfMemoryException">Das Arbeitselement konnte nicht in die Warteschlange eingereiht werden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">Der Typ der Elemente von <paramref name="state" />.</typeparam>
        <param name="callBack">Ein Delegat, der die auszuführende Methode darstellt.</param>
        <param name="state">Ein Objekt, das die von der Methode zu verwendenden Daten enthält.</param>
        <param name="preferLocal">`true` für die Ausführung im lokalen Threadpool, `false` für die Ausführung im globalen Threadpool.</param>
        <summary>Fügt der Warteschlange eine Methode hinzu, die von einem <see cref="T:System.Action`1" />-Delegat zur Ausführung angegeben wurde, und gibt ein Objekt an, das die von der Methode zu verwendenden Daten enthält. Die Methode wird ausgeführt, wenn ein Thread des Threadpools verfügbar wird.</summary>
        <returns><see langword="true" />, wenn die Methode erfolgreich in die Warteschlange eingereiht wurde. <see cref="T:System.NotSupportedException" /> wird ausgelöst, wenn das Arbeitselement nicht in die Warteschlange eingereiht werden konnte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert einen Delegaten, damit auf ein <see cref="T:System.Threading.WaitHandle" /> gewartet wird. Die Aufrufliste wird jedoch nicht an den Arbeitsthread weitergeleitet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />. Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Der Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</param>
        <param name="state">Das an den Delegaten übergebene Objekt.</param>
        <param name="millisecondsTimeOutInterval">Das Timeout in Millisekunden. Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück. Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</param>
        <param name="executeOnlyOnce"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</param>
        <summary>Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 32-Bit-Ganzzahl mit Vorzeichen verwendet wird. Diese Methode leitet den aufrufenden Stapel nicht an den Arbeitsthread weiter.</summary>
        <returns>Das <see cref="T:System.Threading.RegisteredWaitHandle" />-Objekt, mit dem der registrierte Wartevorgang abgebrochen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> den aufrufenden Stapel an den Arbeitsthread wird nicht weitergegeben. Dadurch kann Code, den aufrufenden Stapel verloren gehen und somit auch die Sicherheitsberechtigungen zu erhöhen.  
  
> [!CAUTION]
>  Mithilfe von <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> kann unbeabsichtigt eine Sicherheitslücke. Codezugriffssicherheit Basen die berechtigungsüberprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel. Wenn Arbeit wird in die Warteschlange ein Thread im Threadpool mit <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, der Stapel des Threadpoolthreads müssen sich nicht auf den Kontext des tatsächlichen Aufrufers. Bösartiger Code möglicherweise nutzen Sie diese Option, um die Überprüfung der Ausführungsberechtigung zu vermeiden.  
  
 Mit einem <xref:System.Threading.Mutex> für `waitObject` bietet keine gegenseitigen Ausschluss für die Rückrufe aus, da die zugrunde liegende Windows-API verwendet `WT_EXECUTEDEFAULT` kennzeichnen, sodass jeder Rückruf auf einem separaten Thread eines Threadpools verteilt wird.  
  
 Wenn Sie fertig sind mit den <xref:System.Threading.RegisteredWaitHandle> , die von dieser Methode zurückgegeben wird, rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode, um Verweise auf das Wait-Handle freigeben. Es wird empfohlen, Sie rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> -Methode, selbst wenn Sie angeben, `true` für `executeOnlyOnce`. Die automatische speicherbereinigung wird effizienter Aufrufen der <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode anstelle von abhängig von der registrierten Wait-Handles Finalizer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="millisecondsTimeOutInterval" />-Parameter ist kleiner als -1.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />. Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Der Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</param>
        <param name="state">Das an den Delegaten übergebene Objekt.</param>
        <param name="millisecondsTimeOutInterval">Das Timeout in Millisekunden. Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück. Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</param>
        <param name="executeOnlyOnce"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</param>
        <summary>Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 64-Bit-Ganzzahl mit Vorzeichen angegeben wird. Diese Methode leitet den aufrufenden Stapel nicht an den Arbeitsthread weiter.</summary>
        <returns>Das <see cref="T:System.Threading.RegisteredWaitHandle" />-Objekt, mit dem der registrierte Wartevorgang abgebrochen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> den aufrufenden Stapel an den Arbeitsthread wird nicht weitergegeben. Dadurch kann Code, den aufrufenden Stapel verloren gehen und somit auch die Sicherheitsberechtigungen zu erhöhen.  
  
> [!CAUTION]
>  Mithilfe von <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> kann unbeabsichtigt eine Sicherheitslücke. Codezugriffssicherheit Basen die berechtigungsüberprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel. Wenn Arbeit wird in die Warteschlange ein Thread im Threadpool mit <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, der Stapel des Threadpoolthreads müssen sich nicht auf den Kontext des tatsächlichen Aufrufers. Bösartiger Code möglicherweise nutzen Sie diese Option, um die Überprüfung der Ausführungsberechtigung zu vermeiden.  
  
 Mit einem <xref:System.Threading.Mutex> für `waitObject` bietet keine gegenseitigen Ausschluss für die Rückrufe aus, da die zugrunde liegende Windows-API verwendet `WT_EXECUTEDEFAULT` kennzeichnen, sodass jeder Rückruf auf einem separaten Thread eines Threadpools verteilt wird.  
  
 Wenn Sie fertig sind mit den <xref:System.Threading.RegisteredWaitHandle> , die von dieser Methode zurückgegeben wird, rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode, um Verweise auf das Wait-Handle freigeben. Es wird empfohlen, Sie rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> -Methode, selbst wenn Sie angeben, `true` für `executeOnlyOnce`. Die automatische speicherbereinigung wird effizienter Aufrufen der <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode anstelle von abhängig von der registrierten Wait-Handles Finalizer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="millisecondsTimeOutInterval" />-Parameter ist kleiner als -1.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />. Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Der Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</param>
        <param name="state">Das an den Delegaten übergebene Objekt.</param>
        <param name="timeout">Das durch eine <see cref="T:System.TimeSpan" /> dargestellte Timeout. Wenn <paramref name="timeout" /> den Wert 0 (null) hat, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück. Wenn <paramref name="timeout" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</param>
        <param name="executeOnlyOnce"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</param>
        <summary>Registriert einen Delegaten, der auf ein <see cref="T:System.Threading.WaitHandle" /> wartet, und gibt einen <see cref="T:System.TimeSpan" />-Wert für das Timeout an. Diese Methode leitet den aufrufenden Stapel nicht an den Arbeitsthread weiter.</summary>
        <returns>Das <see cref="T:System.Threading.RegisteredWaitHandle" />-Objekt, mit dem der registrierte Wartevorgang abgebrochen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> den aufrufenden Stapel an den Arbeitsthread wird nicht weitergegeben. Dadurch kann Code, den aufrufenden Stapel verloren gehen und somit auch die Sicherheitsberechtigungen zu erhöhen.  
  
> [!CAUTION]
>  Mithilfe von <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> kann unbeabsichtigt eine Sicherheitslücke. Codezugriffssicherheit Basen die berechtigungsüberprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel. Wenn Arbeit wird in die Warteschlange ein Thread im Threadpool mit <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, der Stapel des Threadpoolthreads müssen sich nicht auf den Kontext des tatsächlichen Aufrufers. Bösartiger Code möglicherweise nutzen Sie diese Option, um die Überprüfung der Ausführungsberechtigung zu vermeiden.  
  
 Mit einem <xref:System.Threading.Mutex> für `waitObject` bietet keine gegenseitigen Ausschluss für die Rückrufe aus, da die zugrunde liegende Windows-API verwendet `WT_EXECUTEDEFAULT` kennzeichnen, sodass jeder Rückruf auf einem separaten Thread eines Threadpools verteilt wird.  
  
 Wenn Sie fertig sind mit den <xref:System.Threading.RegisteredWaitHandle> , die von dieser Methode zurückgegeben wird, rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode, um Verweise auf das Wait-Handle freigeben. Es wird empfohlen, Sie rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> -Methode, selbst wenn Sie angeben, `true` für `executeOnlyOnce`. Die automatische speicherbereinigung wird effizienter Aufrufen der <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode anstelle von abhängig von der registrierten Wait-Handles Finalizer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="timeout" />-Parameter ist kleiner als -1.</exception>
        <exception cref="T:System.NotSupportedException">Der <paramref name="timeout" />-Parameter ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">Die zu registrierende <see cref="T:System.Threading.WaitHandle" />. Verwenden Sie ein anderes <see cref="T:System.Threading.WaitHandle" /> als <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Der Delegat, der aufgerufen werden soll, wenn der <paramref name="waitObject" />-Parameter signalisiert wird.</param>
        <param name="state">Das an den Delegaten übergebene Objekt.</param>
        <param name="millisecondsTimeOutInterval">Das Timeout in Millisekunden. Wenn der <paramref name="millisecondsTimeOutInterval" />-Parameter 0 (null) ist, prüft die Funktion den Zustand des Objekts und kehrt sofort zurück. Wenn <paramref name="millisecondsTimeOutInterval" /> den Wert -1 hat, läuft das Timeoutintervall der Funktion nie ab.</param>
        <param name="executeOnlyOnce"><see langword="true" />, um anzugeben, dass der Thread nach dem Aufruf des Delegaten nicht mehr auf den <paramref name="waitObject" />-Parameter warten soll. <see langword="false" />, um anzugeben, dass der Zeitgeber nach jedem Abschluss des Wartevorgangs zurückgesetzt wird, bis die Registrierung des Wartevorgangs aufgehoben wird.</param>
        <summary>Registriert einen Delegaten, der auf eine <see cref="T:System.Threading.WaitHandle" />-Klasse wartet, wobei für das Timeout in Millisekunden eine 32-Bit-Ganzzahl ohne Vorzeichen angegeben wird. Diese Methode leitet den aufrufenden Stapel nicht an den Arbeitsthread weiter.</summary>
        <returns>Das <see cref="T:System.Threading.RegisteredWaitHandle" />-Objekt, mit dem der registrierte Wartevorgang abgebrochen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Methode <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> den aufrufenden Stapel an den Arbeitsthread wird nicht weitergegeben. Dadurch kann Code, den aufrufenden Stapel verloren gehen und somit auch die Sicherheitsberechtigungen zu erhöhen.  
  
> [!CAUTION]
>  Mithilfe von <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> kann unbeabsichtigt eine Sicherheitslücke. Codezugriffssicherheit Basen die berechtigungsüberprüfungen für die Berechtigungen aller Aufrufer auf dem Stapel. Wenn Arbeit wird in die Warteschlange ein Thread im Threadpool mit <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, der Stapel des Threadpoolthreads müssen sich nicht auf den Kontext des tatsächlichen Aufrufers. Bösartiger Code möglicherweise nutzen Sie diese Option, um die Überprüfung der Ausführungsberechtigung zu vermeiden.  
  
 Mit einem <xref:System.Threading.Mutex> für `waitObject` bietet keine gegenseitigen Ausschluss für die Rückrufe aus, da die zugrunde liegende Windows-API verwendet `WT_EXECUTEDEFAULT` kennzeichnen, sodass jeder Rückruf auf einem separaten Thread eines Threadpools verteilt wird.  
  
 Wenn Sie fertig sind mit den <xref:System.Threading.RegisteredWaitHandle> , die von dieser Methode zurückgegeben wird, rufen Sie die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode, um Verweise auf das Wait-Handle freigeben. Es wird empfohlen, Sie rufen die <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> -Methode, selbst wenn Sie angeben, `true` für `executeOnlyOnce`. Die automatische speicherbereinigung wird effizienter Aufrufen der <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> Methode anstelle von abhängig von der registrierten Wait-Handles Finalizer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
      </Docs>
    </Member>
  </Members>
</Type>