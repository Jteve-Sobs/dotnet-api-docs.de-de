<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="884d8409d444644ff76ec42dc6d480256597df45" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83541743" /></Metadata><TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="e4b61-101">Stellt ein Threadsynchronisierungsereignis dar.</span><span class="sxs-lookup"><span data-stu-id="e4b61-101">Represents a thread synchronization event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-102">Mit der <xref:System.Threading.EventWaitHandle>-Klasse können Threads miteinander kommunizieren, indem Sie signalisieren.</span><span class="sxs-lookup"><span data-stu-id="e4b61-102">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling.</span></span> <span data-ttu-id="e4b61-103">In der Regel wird ein oder mehrere Threads auf einem <xref:System.Threading.EventWaitHandle> blockiert, bis ein nicht blockierter Thread die <xref:System.Threading.EventWaitHandle.Set%2A>-Methode aufruft und einen oder mehrere der blockierten Threads freigibt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-103">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads.</span></span> <span data-ttu-id="e4b61-104">Ein Thread kann eine <xref:System.Threading.EventWaitHandle> signalisieren und ihn dann blockieren, indem er die `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-104">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e4b61-105">Die <xref:System.Threading.EventWaitHandle>-Klasse ermöglicht den Zugriff auf benannte System Synchronisierungs Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="e4b61-105">The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.</span></span>  
  
 <span data-ttu-id="e4b61-106">Das Verhalten eines <xref:System.Threading.EventWaitHandle>, das signalisiert wurde, hängt von seinem Reset-Modus ab.</span><span class="sxs-lookup"><span data-stu-id="e4b61-106">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode.</span></span> <span data-ttu-id="e4b61-107">Ein <xref:System.Threading.EventWaitHandle>, das mit dem <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>-Flag erstellt wurde, wird automatisch zurückgesetzt, wenn ein einziger wartender Thread freigegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="e4b61-107">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="e4b61-108">Eine mit der <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellte <xref:System.Threading.EventWaitHandle.Reset%2A> bleibt so lange ein Signal, bis die <xref:System.Threading.EventWaitHandle>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="e4b61-108">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="e4b61-109">Automatische Zurücksetzungs Ereignisse bieten exklusiven Zugriff auf eine Ressource.</span><span class="sxs-lookup"><span data-stu-id="e4b61-109">Automatic reset events provide exclusive access to a resource.</span></span> <span data-ttu-id="e4b61-110">Wenn ein Ereignis mit automatischer Rücksetzung als Signal verwendet wird und zu diesem Zeitpunkt keine Threads warten, bleibt es ein Signal, bis ein Thread versucht, darauf zu warten.</span><span class="sxs-lookup"><span data-stu-id="e4b61-110">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="e4b61-111">Das Ereignis gibt den Thread frei und wird sofort zurückgesetzt, sodass nachfolgende Threads blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="e4b61-111">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
 <span data-ttu-id="e4b61-112">Manuelle Zurücksetzungs Ereignisse sind wie Gates.</span><span class="sxs-lookup"><span data-stu-id="e4b61-112">Manual reset events are like gates.</span></span> <span data-ttu-id="e4b61-113">Wenn das Ereignis nicht signalisiert wird, werden Threads, die darauf warten, blockiert.</span><span class="sxs-lookup"><span data-stu-id="e4b61-113">When the event is not signaled, threads that wait on it will block.</span></span> <span data-ttu-id="e4b61-114">Wenn das Ereignis signalisiert wird, werden alle wartenden Threads freigegeben, und das Ereignis bleibt signalisiert (d. h. nachfolgende warte Vorgänge werden nicht blockiert), bis seine <xref:System.Threading.EventWaitHandle.Reset%2A>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="e4b61-114">When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="e4b61-115">Manuelle Zurücksetzungs Ereignisse sind nützlich, wenn ein Thread eine Aktivität beenden muss, bevor andere Threads fortfahren können.</span><span class="sxs-lookup"><span data-stu-id="e4b61-115">Manual reset events are useful when one thread must complete an activity before other threads can proceed.</span></span>  
  
 <span data-ttu-id="e4b61-116"><xref:System.Threading.EventWaitHandle> Objekte können mit der `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> und <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> Methoden verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="e4b61-116"><xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="e4b61-117">Weitere Informationen finden Sie im Artikel [Thread Interaktion oder Signalisierung](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) im Artikel [Übersicht über Synchronisierungs primitive](~/docs/standard/threading/overview-of-synchronization-primitives.md) .</span><span class="sxs-lookup"><span data-stu-id="e4b61-117">For more information, see the [Thread interaction, or signaling](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) section of the [Overview of synchronization primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md) article.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e4b61-118">Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>-Methoden Überladung verwendet, damit der Haupt Thread einen blockierten Thread signalisiert und dann wartet, bis der Thread eine Aufgabe abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="e4b61-118">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="e4b61-119">Im Beispiel werden fünf Threads gestartet und ermöglicht das Blockieren einer <xref:System.Threading.EventWaitHandle>, die mit dem <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>-Flag erstellt wurde. Anschließend wird ein Thread freigegeben, wenn der Benutzer die EINGABETASTE drückt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-119">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="e4b61-120">Im Beispiel werden dann weitere fünf Threads in die Warteschlange eingereiht und mit einem <xref:System.Threading.EventWaitHandle> freigegeben, das mit dem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellt wurde</span><span class="sxs-lookup"><span data-stu-id="e4b61-120">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="e4b61-121">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="e4b61-121">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e4b61-122">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="e4b61-122">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e4b61-123">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="e4b61-123">Overview of synchronization primitives</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e4b61-124">Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="e4b61-124">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="e4b61-125"><see langword="true" />, wenn der anfängliche Zustand auf signalisiert festgelegt werden soll. <see langword="false" />, wenn er auf nicht signalisiert festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="e4b61-125"><see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="e4b61-126">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="e4b61-126">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <summary><span data-ttu-id="e4b61-127">Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse und gibt an, ob das WaitHandle anfänglich signalisiert ist und ob es automatisch oder manuell zurückgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="e4b61-127">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-128">Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre.</span><span class="sxs-lookup"><span data-stu-id="e4b61-128">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="e4b61-129">Wenn der Anfangszustand signalisiert ist und das <xref:System.Threading.EventResetMode.ManualReset>-Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="e4b61-129">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="e4b61-130">Wenn der Anfangszustand signalisiert ist und `mode` <xref:System.Threading.EventResetMode.AutoReset>ist, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="e4b61-130">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e4b61-131">Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>-Methoden Überladung verwendet, damit der Haupt Thread einen blockierten Thread signalisiert und dann wartet, bis der Thread eine Aufgabe abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="e4b61-131">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="e4b61-132">Im Beispiel werden fünf Threads gestartet und ermöglicht das Blockieren einer <xref:System.Threading.EventWaitHandle>, die mit dem <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>-Flag erstellt wurde. Anschließend wird ein Thread freigegeben, wenn der Benutzer die EINGABETASTE drückt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-132">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses ENTER key.</span></span> <span data-ttu-id="e4b61-133">Im Beispiel werden dann weitere fünf Threads in die Warteschlange eingereiht und mit einem <xref:System.Threading.EventWaitHandle> freigegeben, das mit dem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellt wurde</span><span class="sxs-lookup"><span data-stu-id="e4b61-133">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e4b61-134">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="e4b61-134">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="e4b61-135"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</span><span class="sxs-lookup"><span data-stu-id="e4b61-135"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="e4b61-136">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="e4b61-136">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="e4b61-137">Der Name des systemweiten Synchronisierungsereignisses.</span><span class="sxs-lookup"><span data-stu-id="e4b61-137">The name of a system-wide synchronization event.</span></span></param>
        <summary><span data-ttu-id="e4b61-138">Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, gibt an, ob das WaitHandle anfänglich signalisiert ist, wenn es als Ergebnis dieses Aufrufs erstellt wurde, ob es automatisch oder manuell zurückgesetzt wird, und gibt den Namen eines Systemsynchronisierungsereignisses an.</span><span class="sxs-lookup"><span data-stu-id="e4b61-138">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-139">Wenn `name` `null` oder eine leere Zeichenfolge ist, wird eine lokale <xref:System.Threading.EventWaitHandle> erstellt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-139">If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created.</span></span>  
  
 <span data-ttu-id="e4b61-140">Wenn ein System Ereignis mit dem für den `name`-Parameter angegebenen Namen bereits vorhanden ist, wird der `initialState` Parameter ignoriert.</span><span class="sxs-lookup"><span data-stu-id="e4b61-140">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e4b61-141">Wenn Sie diesen Konstruktor für benannte Systemereignisse verwenden, geben Sie `false` für `initialState`an.</span><span class="sxs-lookup"><span data-stu-id="e4b61-141">When using this constructor for named system events, specify `false` for `initialState`.</span></span> <span data-ttu-id="e4b61-142">Dieser Konstruktor bietet keine Möglichkeit, zu bestimmen, ob ein benanntes System Ereignis erstellt wurde, sodass Sie keine Annahmen über den Status des benannten Ereignisses treffen können.</span><span class="sxs-lookup"><span data-stu-id="e4b61-142">This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</span></span> <span data-ttu-id="e4b61-143">Verwenden Sie den <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29>-Konstruktor oder den <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29>-Konstruktor, um zu bestimmen, ob ein benanntes Ereignis erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="e4b61-143">To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.</span></span>  
  
 <span data-ttu-id="e4b61-144">Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre.</span><span class="sxs-lookup"><span data-stu-id="e4b61-144">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="e4b61-145">Wenn der Anfangszustand signalisiert ist und das <xref:System.Threading.EventResetMode.ManualReset>-Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="e4b61-145">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="e4b61-146">Wenn der Anfangszustand signalisiert ist und `mode` <xref:System.Threading.EventResetMode.AutoReset>ist, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="e4b61-146">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="e4b61-147">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="e4b61-147">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="e4b61-148">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="e4b61-148">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="e4b61-149">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</span><span class="sxs-lookup"><span data-stu-id="e4b61-149">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4b61-150"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-150"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e4b61-151">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="e4b61-151">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string * bool -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="e4b61-152"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</span><span class="sxs-lookup"><span data-stu-id="e4b61-152"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="e4b61-153">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="e4b61-153">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="e4b61-154">Der Name des systemweiten Synchronisierungsereignisses.</span><span class="sxs-lookup"><span data-stu-id="e4b61-154">The name of a system-wide synchronization event.</span></span></param>
        <param name="createdNew"><span data-ttu-id="e4b61-155">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Ereignis erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemereignis erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsereignis bereits vorhanden war.</span><span class="sxs-lookup"><span data-stu-id="e4b61-155">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span></span> <span data-ttu-id="e4b61-156">Dieser Parameter wird nicht initialisiert übergeben.</span><span class="sxs-lookup"><span data-stu-id="e4b61-156">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="e4b61-157">Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, die Folgendes angibt: ob das Wait-Handle anfänglich signalisiert wird, wenn es als Ergebnis dieses Aufrufs erstellt wird; ob es automatisch oder manuell zurückgesetzt wird; den Namen eines Systemsynchronisierungsereignisses und eine boolesche Variable, deren Wert nach dem Aufruf angibt, ob das benannte Systemereignis erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="e4b61-157">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-158">Wenn ein System Ereignis mit dem für den `name`-Parameter angegebenen Namen bereits vorhanden ist, wird der `initialState` Parameter ignoriert.</span><span class="sxs-lookup"><span data-stu-id="e4b61-158">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="e4b61-159">Nachdem Sie diesen Konstruktor aufgerufen haben, verwenden Sie den Wert in der Variablen, die für den `ref`-Parameter angegeben wurde (`ByRef` Parameter in Visual Basic)`createdNew`, um zu bestimmen, ob das benannte System Ereignis bereits vorhanden war oder erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="e4b61-159">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="e4b61-160">Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre.</span><span class="sxs-lookup"><span data-stu-id="e4b61-160">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="e4b61-161">Wenn der Anfangszustand signalisiert ist und das <xref:System.Threading.EventResetMode.ManualReset>-Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="e4b61-161">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="e4b61-162">Wenn der Anfangszustand signalisiert ist und `mode` <xref:System.Threading.EventResetMode.AutoReset>ist, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="e4b61-162">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="e4b61-163">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="e4b61-163">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="e4b61-164">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="e4b61-164">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="e4b61-165">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</span><span class="sxs-lookup"><span data-stu-id="e4b61-165">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4b61-166"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-166"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e4b61-167">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="e4b61-167">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string * bool * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="e4b61-168"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</span><span class="sxs-lookup"><span data-stu-id="e4b61-168"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="e4b61-169">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="e4b61-169">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="e4b61-170">Der Name des systemweiten Synchronisierungsereignisses.</span><span class="sxs-lookup"><span data-stu-id="e4b61-170">The name of a system-wide synchronization event.</span></span></param>
        <param name="createdNew"><span data-ttu-id="e4b61-171">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Ereignis erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemereignis erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsereignis bereits vorhanden war.</span><span class="sxs-lookup"><span data-stu-id="e4b61-171">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span></span> <span data-ttu-id="e4b61-172">Dieser Parameter wird nicht initialisiert übergeben.</span><span class="sxs-lookup"><span data-stu-id="e4b61-172">This parameter is passed uninitialized.</span></span></param>
        <param name="eventSecurity"><span data-ttu-id="e4b61-173">Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemereignis angewendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="e4b61-173">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span></span></param>
        <summary><span data-ttu-id="e4b61-174">Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, die Folgendes angibt: ob das Wait-Handle anfänglich signalisiert wird, wenn es als Ergebnis dieses Aufrufs erstellt wird; ob es automatisch oder manuell zurückgesetzt wird; den Namen eines Systemsynchronisierungsereignisses, eine boolesche Variable, deren Wert nach dem Aufruf angibt, ob das benannte Systemereignis erstellt wurde, und die Zugriffssteuerungssicherheit, die auf das benannte Ereignis angewandt werden soll, falls es erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="e4b61-174">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-175">Verwenden Sie diesen Konstruktor, um die Zugriffs Steuerungs Sicherheit auf ein benanntes System Ereignis anzuwenden, wenn es erstellt wird. Dadurch wird verhindert, dass anderer Code die Steuerung des Ereignisses übernimmt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-175">Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</span></span>  
  
 <span data-ttu-id="e4b61-176">Dieser Konstruktor initialisiert ein <xref:System.Threading.EventWaitHandle> Objekt, das ein System Ereignis darstellt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-176">This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event.</span></span> <span data-ttu-id="e4b61-177">Sie können mehrere <xref:System.Threading.EventWaitHandle> Objekte erstellen, die das gleiche System Ereignis darstellen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-177">You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.</span></span>  
  
 <span data-ttu-id="e4b61-178">Wenn das System Ereignis nicht vorhanden ist, wird es mit der angegebenen Zugriffs Steuerungs Sicherheit erstellt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-178">If the system event does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="e4b61-179">Wenn das Ereignis vorhanden ist, wird die angegebene Zugriffs Steuerungs Sicherheit ignoriert.</span><span class="sxs-lookup"><span data-stu-id="e4b61-179">If the event exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e4b61-180">Der Aufrufer hat die vollständige Kontrolle über das neu erstellte <xref:System.Threading.EventWaitHandle> Objekt, auch wenn `eventSecurity` dem aktuellen Benutzer einige Zugriffsrechte verweigert oder ihm nicht zuweist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-180">The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="e4b61-181">Wenn der aktuelle Benutzer jedoch versucht, ein anderes <xref:System.Threading.EventWaitHandle> Objekt zu erhalten, das das gleiche benannte Ereignis repräsentiert, entweder mithilfe eines Konstruktors oder der <xref:System.Threading.EventWaitHandle.OpenExisting%2A>-Methode, wird die Windows-Zugriffs Steuerungs Sicherheit angewendet.</span><span class="sxs-lookup"><span data-stu-id="e4b61-181">However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="e4b61-182">Wenn ein System Ereignis mit dem für den `name`-Parameter angegebenen Namen bereits vorhanden ist, wird der `initialState` Parameter ignoriert.</span><span class="sxs-lookup"><span data-stu-id="e4b61-182">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="e4b61-183">Nachdem Sie diesen Konstruktor aufgerufen haben, verwenden Sie den Wert in der Variablen, die für den `ref`-Parameter angegeben wurde (`ByRef` Parameter in Visual Basic) `createdNew`, um zu bestimmen, ob das benannte System Ereignis bereits vorhanden war oder erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="e4b61-183">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="e4b61-184">Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre.</span><span class="sxs-lookup"><span data-stu-id="e4b61-184">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="e4b61-185">Wenn der Anfangszustand signalisiert ist und das <xref:System.Threading.EventResetMode.ManualReset>-Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="e4b61-185">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="e4b61-186">Wenn der Anfangszustand signalisiert ist und `mode` <xref:System.Threading.EventResetMode.AutoReset>ist, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="e4b61-186">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e4b61-187">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e4b61-187">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="e4b61-188">Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-188">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="e4b61-189">Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-189">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="e4b61-190">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="e4b61-190">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="e4b61-191">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="e4b61-191">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e4b61-192">Nachdem die Berechtigungen geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="e4b61-192">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="e4b61-193">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-193">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="e4b61-194">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="e4b61-194">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="e4b61-195">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="e4b61-195">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="e4b61-196">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</span><span class="sxs-lookup"><span data-stu-id="e4b61-196">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4b61-197"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-197"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e4b61-198">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="e4b61-198">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4b61-199">Ruft ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt ab, das die Zugriffssteuerungssicherheit für das benannte Systemereignis darstellt, das durch das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="e4b61-199">Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</span></span></summary>
        <returns><span data-ttu-id="e4b61-200">Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit für das benannte Systemereignis darstellt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-200">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-201">Die <xref:System.Threading.EventWaitHandle.GetAccessControl%2A>-Methode verwendet die folgende Kombination von-Flags (kombiniert mithilfe des bitweisen OR-Vorgangs), um nach Berechtigungen zu suchen: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e4b61-201">The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="e4b61-202">Der Benutzer muss über <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> Rechte verfügen, um diese Methode aufzurufen, und das Ereignis muss mit dem <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType>-Flag geöffnet worden sein.</span><span class="sxs-lookup"><span data-stu-id="e4b61-202">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e4b61-203">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e4b61-203">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="e4b61-204">Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-204">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="e4b61-205">Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-205">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="e4b61-206">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="e4b61-206">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="e4b61-207">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="e4b61-207">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e4b61-208">Nachdem die Berechtigungen mithilfe der <xref:System.Threading.EventWaitHandle.GetAccessControl%2A>-Methode gelesen und geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="e4b61-208">After the permissions have been read, using the <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method, and changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="e4b61-209">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-209">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="e4b61-210">Das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt ein benanntes Systemereignis dar, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span><span class="sxs-lookup"><span data-stu-id="e4b61-210">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span></span>  
  
<span data-ttu-id="e4b61-211">- oder -</span><span class="sxs-lookup"><span data-stu-id="e4b61-211">-or-</span></span> 
<span data-ttu-id="e4b61-212">Das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt ein benanntes Systemereignis dar und wurde nicht mit <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /> geöffnet.</span><span class="sxs-lookup"><span data-stu-id="e4b61-212">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="e4b61-213">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-213">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="e4b61-214">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für diesen <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-214">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e4b61-215">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="e4b61-215">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e4b61-216">Öffnet ein bestimmtes benanntes Synchronisierungsereignis, wenn es bereits vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-216">Opens a specified named synchronization event, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="e4b61-217">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</span><span class="sxs-lookup"><span data-stu-id="e4b61-217">The name of the system synchronization event to open.</span></span></param>
        <summary><span data-ttu-id="e4b61-218">Öffnet das bestimmte benannte Synchronisierungsereignis, wenn es bereits vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-218">Opens the specified named synchronization event, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="e4b61-219">Ein Objekt, das das benannte Systemereignis darstellt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-219">An  object that represents the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-220">Die <xref:System.Threading.EventWaitHandle.OpenExisting%2A>-Methode versucht, das angegebene benannte System Ereignis zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-220">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event.</span></span> <span data-ttu-id="e4b61-221">Wenn das System Ereignis nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System Ereignis zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-221">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="e4b61-222">Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="e4b61-222">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e4b61-223">Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-223">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 <span data-ttu-id="e4b61-224">Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs.</span><span class="sxs-lookup"><span data-stu-id="e4b61-224">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="e4b61-225">Das Angeben des <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flags ermöglicht einem Thread, auf das benannte System Ereignis zu warten, und die Angabe des <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.EventWaitHandle.Set%2A>-und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-225">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e4b61-226">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e4b61-226">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="e4b61-227">Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-227">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="e4b61-228">Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-228">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="e4b61-229">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="e4b61-229">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="e4b61-230">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="e4b61-230">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e4b61-231">Nachdem die Berechtigungen geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="e4b61-231">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="e4b61-232">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-232">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4b61-233"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="e4b61-233"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="e4b61-234">- oder -</span><span class="sxs-lookup"><span data-stu-id="e4b61-234">-or-</span></span> 
 <span data-ttu-id="e4b61-235"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-235"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e4b61-236"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="e4b61-236"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="e4b61-237">Das benannte Systemereignis ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="e4b61-237">The named system event does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="e4b61-238">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="e4b61-238">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="e4b61-239">Das benannte Ereignis ist vorhanden, der Benutzer verfügt jedoch nicht über den nötigen Sicherheitszugriff, um es zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="e4b61-239">The named event exists, but the user does not have the security access required to use it.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e4b61-240">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="e4b61-240">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="e4b61-241">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</span><span class="sxs-lookup"><span data-stu-id="e4b61-241">The name of the system synchronization event to open.</span></span></param>
        <param name="rights"><span data-ttu-id="e4b61-242">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-242">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="e4b61-243">Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</span><span class="sxs-lookup"><span data-stu-id="e4b61-243">Opens the specified named synchronization event, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="e4b61-244">Ein Objekt, das das benannte Systemereignis darstellt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-244">An object that represents the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-245">Der `rights`-Parameter muss das <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads auf das Ereignis warten können, und das <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.EventWaitHandle.Set%2A>-und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden aufrufen können.</span><span class="sxs-lookup"><span data-stu-id="e4b61-245">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="e4b61-246">Die <xref:System.Threading.EventWaitHandle.OpenExisting%2A>-Methode versucht, ein vorhandenes benanntes System Ereignis zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-246">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event.</span></span> <span data-ttu-id="e4b61-247">Wenn das System Ereignis nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System Ereignis zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-247">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="e4b61-248">Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="e4b61-248">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e4b61-249">Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-249">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e4b61-250">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e4b61-250">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="e4b61-251">Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-251">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="e4b61-252">Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-252">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="e4b61-253">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="e4b61-253">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="e4b61-254">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="e4b61-254">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e4b61-255">Nachdem die Berechtigungen geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="e4b61-255">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="e4b61-256">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-256">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4b61-257"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="e4b61-257"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="e4b61-258">- oder -</span><span class="sxs-lookup"><span data-stu-id="e4b61-258">-or-</span></span> 
 <span data-ttu-id="e4b61-259"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-259"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e4b61-260"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="e4b61-260"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="e4b61-261">Das benannte Systemereignis ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="e4b61-261">The named system event does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="e4b61-262">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="e4b61-262">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="e4b61-263">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</span><span class="sxs-lookup"><span data-stu-id="e4b61-263">The named event exists, but the user does not have the desired security access.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e4b61-264">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="e4b61-264">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4b61-265">Legt den Zustand des Ereignisses auf „nicht signalisiert“ fest, sodass Threads blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="e4b61-265">Sets the state of the event to nonsignaled, causing threads to block.</span></span></summary>
        <returns><span data-ttu-id="e4b61-266"><see langword="true" />, wenn die Operation erfolgreich ausgeführt wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e4b61-266"><see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="e4b61-267">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für diesen <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-267">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e4b61-268">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="e4b61-268">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4b61-269">Legt den Zustand des Ereignisses auf „signalisiert“ fest und ermöglicht so einem oder mehreren wartenden Threads das Fortfahren.</span><span class="sxs-lookup"><span data-stu-id="e4b61-269">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</span></span></summary>
        <returns><span data-ttu-id="e4b61-270"><see langword="true" />, wenn die Operation erfolgreich ausgeführt wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e4b61-270"><see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-271">Bei einer <xref:System.Threading.EventWaitHandle> mit <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (einschließlich <xref:System.Threading.AutoResetEvent>) gibt die <xref:System.Threading.EventWaitHandle.Set%2A>-Methode einen einzelnen Thread frei.</span><span class="sxs-lookup"><span data-stu-id="e4b61-271">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread.</span></span> <span data-ttu-id="e4b61-272">Wenn keine wartenden Threads vorhanden sind, bleibt das Wait-Handle signalisiert, bis ein Thread versucht, darauf zu warten, oder bis seine <xref:System.Threading.EventWaitHandle.Reset%2A>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="e4b61-272">If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e4b61-273">Es gibt keine Garantie dafür, dass jeder aufzurufende <xref:System.Threading.EventWaitHandle.Set%2A> Methode einen Thread von einem <xref:System.Threading.EventWaitHandle> freigibt, dessen Zurücksetzungs Modus <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-273">There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e4b61-274">Wenn zwei Aufrufe zu eng beieinander liegen, sodass der zweite Aufruf stattfindet, bevor ein Thread freigegeben wurde, wird nur ein Thread freigegeben.</span><span class="sxs-lookup"><span data-stu-id="e4b61-274">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</span></span> <span data-ttu-id="e4b61-275">Dies ist der Fall, wenn der zweite-Vorgang nicht durchgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="e4b61-275">It is as if the second call did not happen.</span></span> <span data-ttu-id="e4b61-276">Wenn <xref:System.Threading.EventWaitHandle.Set%2A> aufgerufen wird, wenn keine Threads warten und der <xref:System.Threading.EventWaitHandle> bereits signalisiert ist, hat der Aufruf keine Auswirkung.</span><span class="sxs-lookup"><span data-stu-id="e4b61-276">Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.</span></span>  
  
 <span data-ttu-id="e4b61-277">Bei einer <xref:System.Threading.EventWaitHandle> mit <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (einschließlich <xref:System.Threading.ManualResetEvent>) verlässt der Aufruf der <xref:System.Threading.EventWaitHandle.Set%2A>-Methode den Wait-Handle in einem signalisierten Zustand, bis seine <xref:System.Threading.EventWaitHandle.Reset%2A>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="e4b61-277">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e4b61-278">Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>-Methoden Überladung verwendet, damit der Haupt Thread einen blockierten Thread signalisiert und dann wartet, bis der Thread eine Aufgabe abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="e4b61-278">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="e4b61-279">Im Beispiel werden fünf Threads gestartet und ermöglicht das Blockieren einer <xref:System.Threading.EventWaitHandle>, die mit dem <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>-Flag erstellt wurde. Anschließend wird ein Thread freigegeben, wenn der Benutzer die EINGABETASTE drückt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-279">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="e4b61-280">Im Beispiel werden dann weitere fünf Threads in die Warteschlange eingereiht und mit einem <xref:System.Threading.EventWaitHandle> freigegeben, das mit dem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellt wurde</span><span class="sxs-lookup"><span data-stu-id="e4b61-280">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="e4b61-281">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für diesen <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-281">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e4b61-282">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="e4b61-282">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="eventSecurity"><span data-ttu-id="e4b61-283">Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemereignis angewendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="e4b61-283">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span></span></param>
        <summary><span data-ttu-id="e4b61-284">Legt die Zugriffssteuerungssicherheit für ein benanntes Systemereignis fest.</span><span class="sxs-lookup"><span data-stu-id="e4b61-284">Sets the access control security for a named system event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-285">Der Benutzer muss über <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> Rechte verfügen, um diese Methode aufzurufen, und das Ereignis muss mit dem <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType>-Flag geöffnet worden sein.</span><span class="sxs-lookup"><span data-stu-id="e4b61-285">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e4b61-286">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e4b61-286">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="e4b61-287">Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-287">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="e4b61-288">Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-288">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="e4b61-289">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="e4b61-289">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="e4b61-290">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="e4b61-290">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e4b61-291">Nachdem die Berechtigungen mithilfe der <xref:System.Threading.EventWaitHandle.SetAccessControl%2A>-Methode geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="e4b61-291">After the permissions are changed, using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="e4b61-292">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-292">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e4b61-293"><paramref name="eventSecurity" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="e4b61-293"><paramref name="eventSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="e4b61-294">Der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span><span class="sxs-lookup"><span data-stu-id="e4b61-294">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span></span>  
  
<span data-ttu-id="e4b61-295">- oder -</span><span class="sxs-lookup"><span data-stu-id="e4b61-295">-or-</span></span> 
<span data-ttu-id="e4b61-296">Das Ereignis wurde nicht mit <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /> geöffnet.</span><span class="sxs-lookup"><span data-stu-id="e4b61-296">The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="e4b61-297">Die aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt kein benanntes Systemereignis dar.</span><span class="sxs-lookup"><span data-stu-id="e4b61-297">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="e4b61-298">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für diesen <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-298">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e4b61-299">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="e4b61-299">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e4b61-300">Öffnet ein bestimmtes benanntes Synchronisierungsereignis, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="e4b61-300">Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * EventWaitHandle -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="e4b61-301">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</span><span class="sxs-lookup"><span data-stu-id="e4b61-301">The name of the system synchronization event to open.</span></span></param>
        <param name="result"><span data-ttu-id="e4b61-302">Enthält nach Rückgabe dieser Methode ein <see cref="T:System.Threading.EventWaitHandle" />-Objekt, das das benannte Synchronisierungsereignis darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn beim Aufruf ein Fehler aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-302">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="e4b61-303">Dieser Parameter wird als nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-303">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="e4b61-304">Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="e4b61-304">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e4b61-305"><see langword="true" />, wenn das benannte Synchronisierungsereignis erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e4b61-305"><see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-306">Wenn das benannte Synchronisierungs Ereignis nicht vorhanden ist, wird es von dieser Methode nicht erstellt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-306">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="e4b61-307">Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="e4b61-307">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e4b61-308">Wenn Sie unsicher sind, ob ein benanntes Synchronisierungs Ereignis vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn das Synchronisierungs Ereignis nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-308">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="e4b61-309">Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs.</span><span class="sxs-lookup"><span data-stu-id="e4b61-309">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="e4b61-310">Das Angeben des <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flags ermöglicht einem Thread, auf das benannte System Ereignis zu warten, und die Angabe des <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.EventWaitHandle.Set%2A>-und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-310">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="e4b61-311">Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-311">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4b61-312"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="e4b61-312"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="e4b61-313">- oder -</span><span class="sxs-lookup"><span data-stu-id="e4b61-313">-or-</span></span> 
 <span data-ttu-id="e4b61-314"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-314"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e4b61-315"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="e4b61-315"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="e4b61-316">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="e4b61-316">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="e4b61-317">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</span><span class="sxs-lookup"><span data-stu-id="e4b61-317">The named event exists, but the user does not have the desired security access.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights * EventWaitHandle -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="e4b61-318">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</span><span class="sxs-lookup"><span data-stu-id="e4b61-318">The name of the system synchronization event to open.</span></span></param>
        <param name="rights"><span data-ttu-id="e4b61-319">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-319">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="e4b61-320">Enthält nach Rückgabe dieser Methode ein <see cref="T:System.Threading.EventWaitHandle" />-Objekt, das das benannte Synchronisierungsereignis darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn beim Aufruf ein Fehler aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-320">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="e4b61-321">Dieser Parameter wird als nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-321">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="e4b61-322">Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits mit dem gewünschten Sicherheitszugriff vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="e4b61-322">Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e4b61-323"><see langword="true" />, wenn das benannte Synchronisierungsereignis erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e4b61-323"><see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4b61-324">Wenn das benannte Synchronisierungs Ereignis nicht vorhanden ist, wird es von dieser Methode nicht erstellt.</span><span class="sxs-lookup"><span data-stu-id="e4b61-324">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="e4b61-325">Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="e4b61-325">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e4b61-326">Wenn Sie unsicher sind, ob ein benanntes Synchronisierungs Ereignis vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn das Synchronisierungs Ereignis nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="e4b61-326">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="e4b61-327">Der `rights`-Parameter muss das <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads auf das Ereignis warten können, und das <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.EventWaitHandle.Set%2A>-und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden aufrufen können.</span><span class="sxs-lookup"><span data-stu-id="e4b61-327">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="e4b61-328">Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-328">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4b61-329"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="e4b61-329"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="e4b61-330">- oder -</span><span class="sxs-lookup"><span data-stu-id="e4b61-330">-or-</span></span> 
 <span data-ttu-id="e4b61-331"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="e4b61-331"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e4b61-332"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="e4b61-332"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="e4b61-333">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="e4b61-333">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="e4b61-334">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</span><span class="sxs-lookup"><span data-stu-id="e4b61-334">The named event exists, but the user does not have the desired security access.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
