<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="67b695d0bcb5709fc1454451c3739cb1df8c0012" /><Meta Name="ms.sourcegitcommit" Value="0d09f5af167c53ca4797424c362e6c2616a36009" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/05/2019" /><Meta Name="ms.locfileid" Value="55739772" /></Metadata><TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Threadsynchronisierungsereignis dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.EventWaitHandle> -Klasse ermöglicht Threads, durch Signalisieren miteinander kommunizieren. In der Regel eine oder mehrere Threads blockiert eine <xref:System.Threading.EventWaitHandle> bis ein nicht blockierter Thread Ruft die <xref:System.Threading.EventWaitHandle.Set%2A> -Methode, einen oder mehrere blockierte Threads freigibt. Ein Thread kann signalisieren eine <xref:System.Threading.EventWaitHandle> und dann blockieren, durch den Aufruf der `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> Methode.  
  
> [!NOTE]
>  Die <xref:System.Threading.EventWaitHandle> Klasse bietet Zugriff auf benannte Synchronisierungsereignisse.  
  
 Das Verhalten einer <xref:System.Threading.EventWaitHandle> , signalisiert wurde hängt von den Zurücksetzmodus. Ein <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flag wird automatisch zurückgesetzt, wenn signalisiert wird, nachdem ein einzelner wartender Thread freigegeben,. Eine mit der <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellte <xref:System.Threading.EventWaitHandle.Reset%2A> bleibt so lange ein Signal, bis die <xref:System.Threading.EventWaitHandle>-Methode aufgerufen wird.  
  
 Ereignisse mit automatischer Rücksetzung bieten exklusiven Zugriff auf eine Ressource. Wenn ein Ereignis mit automatischer Rücksetzung als Signal verwendet wird und zu diesem Zeitpunkt keine Threads warten, bleibt es ein Signal, bis ein Thread versucht, darauf zu warten. Das Ereignis gibt den Thread frei und wird sofort zurückgesetzt, sodass nachfolgende Threads blockiert werden.  
  
 Manuelle Zurücksetzung, die Ereignisse wie Gates werden. Wenn das Ereignis nicht signalisiert wird, werden Threads, die darauf warten, blockiert. Wenn das Ereignis signalisiert wird, alle wartenden Threads freigegeben werden, und das Ereignis signalisiert bleibt (d.h. nachfolgende Wartevorgänge werden nicht blockiert) bis der <xref:System.Threading.EventWaitHandle.Reset%2A> Methode wird aufgerufen. Manuelle Zurücksetzung Ereignisse sind nützlich, wenn ein Thread eine Aktivität abgeschlossen werden muss, damit andere Threads fortgesetzt werden können.  
  
 <xref:System.Threading.EventWaitHandle> Objekte können verwendet werden, mit der `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> und <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> Methoden.  
  
 Weitere Informationen finden Sie unter den [Thread Interaktion oder Signalisierung](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) Teil der [Übersicht über Synchronisierungsprimitiven](~/docs/standard/threading/overview-of-synchronization-primitives.md) Artikel.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> -methodenüberladung, um ermöglichen den Hauptthread auf einen blockierten Thread zu signalisieren und warten Sie, bis der Thread eine Aufgabe abgeschlossen ist.  
  
 Im Beispiel fünf Threads gestartet, und blockieren können eine <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flag, und klicken Sie dann auf Versionen ein Threadzeit, die der Benutzer drückt die EINGABETASTE. Im Beispiel wird dann fünf weitere Threads und mithilfe einer eine <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> Flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" />, wenn der anfängliche Zustand auf signalisiert festgelegt werden soll. <see langword="false" />, wenn er auf nicht signalisiert festgelegt werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse und gibt an, ob das WaitHandle anfänglich signalisiert ist und ob es automatisch oder manuell zurückgesetzt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der ursprüngliche Zustand des Ereignisses auf "nicht signalisiert" festgelegt ist, werden Threads, die auf das Ereignis warten blockiert. Wenn der anfängliche Zustand signalisiert wird, und die <xref:System.Threading.EventResetMode.ManualReset> Flag angegeben wird, für die `mode`, Threads, die auf das Ereignis warten nicht blockiert. Wenn der anfängliche Zustand signalisiert wird, und `mode` ist <xref:System.Threading.EventResetMode.AutoReset>, der erste Thread, der auf das Ereignis wartet sofort freigegeben, nach dem das Ereignis zurückgesetzt wird, und nachfolgende Threads blockiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> -methodenüberladung, um ermöglichen den Hauptthread auf einen blockierten Thread zu signalisieren und warten Sie, bis der Thread eine Aufgabe abgeschlossen ist.  
  
 Im Beispiel fünf Threads gestartet, und blockieren können eine <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flag, und klicken Sie dann auf Versionen ein Threadzeit, die der Benutzer drückt die EINGABETASTE. Im Beispiel wird dann fünf weitere Threads und mithilfe einer eine <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> Flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <param name="name">Der Name des systemweiten Synchronisierungsereignisses.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, gibt an, ob das WaitHandle anfänglich signalisiert ist, wenn es als Ergebnis dieses Aufrufs erstellt wurde, ob es automatisch oder manuell zurückgesetzt wird, und gibt den Namen eines Systemsynchronisierungsereignisses an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `name` ist `null` oder eine leere Zeichenfolge, die eine lokale <xref:System.Threading.EventWaitHandle> erstellt wird.  
  
 Wenn ein Systemereignis mit der angegebene Name für die `name` Parameter bereits vorhanden ist, die `initialState` Parameter wird ignoriert.  
  
> [!IMPORTANT]
>  Geben Sie bei Verwendung dieses Konstruktors für den benannten Systemereignisse `false` für `initialState`. Dieser Konstruktor bietet keine Möglichkeit festzustellen, ob ein benanntes Systemereignis erstellt wurde, damit Sie keine Annahmen über den Status der das benannte Ereignis vornehmen können. Um zu bestimmen, ob ein benanntes Ereignis erstellt wurde, verwenden die <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> Konstruktor oder die <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> Konstruktor.  
  
 Wenn der ursprüngliche Zustand des Ereignisses auf "nicht signalisiert" festgelegt ist, werden Threads, die auf das Ereignis warten blockiert. Wenn der anfängliche Zustand signalisiert wird, und die <xref:System.Threading.EventResetMode.ManualReset> Flag angegeben wird, für die `mode`, Threads, die auf das Ereignis warten nicht blockiert. Wenn der anfängliche Zustand signalisiert wird, und `mode` ist <xref:System.Threading.EventResetMode.AutoReset>, der erste Thread, der auf das Ereignis wartet sofort freigegeben, nach dem das Ereignis zurückgesetzt wird, und nachfolgende Threads blockiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <param name="name">Der Name des systemweiten Synchronisierungsereignisses.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Ereignis erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemereignis erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsereignis bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, die Folgendes angibt: ob das Wait-Handle anfänglich signalisiert wird, wenn es als Ergebnis dieses Aufrufs erstellt wird; ob es automatisch oder manuell zurückgesetzt wird; den Namen eines Systemsynchronisierungsereignisses und eine boolesche Variable, deren Wert nach dem Aufruf angibt, ob das benannte Systemereignis erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Systemereignis mit der angegebene Name für die `name` Parameter bereits vorhanden ist, die `initialState` Parameter wird ignoriert. Verwenden Sie nach dem Aufrufen des Konstruktors den Wert in der Variablen angegeben, für die `ref` Parameter (`ByRef` -Parameter in Visual Basic)`createdNew` zu bestimmen, ob das benannte Systemereignis bereits vorhanden war oder erstellt wurde.  
  
 Wenn der ursprüngliche Zustand des Ereignisses auf "nicht signalisiert" festgelegt ist, werden Threads, die auf das Ereignis warten blockiert. Wenn der anfängliche Zustand signalisiert wird, und die <xref:System.Threading.EventResetMode.ManualReset> Flag angegeben wird, für die `mode`, Threads, die auf das Ereignis warten nicht blockiert. Wenn der anfängliche Zustand signalisiert wird, und `mode` ist <xref:System.Threading.EventResetMode.AutoReset>, der erste Thread, der auf das Ereignis wartet sofort freigegeben, nach dem das Ereignis zurückgesetzt wird, und nachfolgende Threads blockiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <param name="name">Der Name des systemweiten Synchronisierungsereignisses.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Ereignis erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemereignis erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsereignis bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="eventSecurity">Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemereignis angewendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, die Folgendes angibt: ob das Wait-Handle anfänglich signalisiert wird, wenn es als Ergebnis dieses Aufrufs erstellt wird; ob es automatisch oder manuell zurückgesetzt wird; den Namen eines Systemsynchronisierungsereignisses, eine boolesche Variable, deren Wert nach dem Aufruf angibt, ob das benannte Systemereignis erstellt wurde, und die Zugriffssteuerungssicherheit, die auf das benannte Ereignis angewandt werden soll, falls es erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, Steuerung des Zugriffs auf ein benanntes Systemereignis bei der Erstellung wird verhindert, dass anderer Code die Übernahme der Kontrolle über das Ereignis angewendet wird.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.EventWaitHandle> Objekt, das eine Systemereignis darstellt. Sie können mehrere erstellen <xref:System.Threading.EventWaitHandle> Objekte, die das gleiche Systemereignis darstellen.  
  
 Wenn das Systemereignis nicht vorhanden ist, wird es mit der angegebenen zugriffssteuerungssicherheit erstellt. Wenn das Ereignis vorhanden ist, wird die angegebene zugriffssteuerungssicherheit ignoriert.  
  
> [!NOTE]
>  Der Aufrufer hat vollständige Kontrolle über die neu erstellte <xref:System.Threading.EventWaitHandle> Objekt, selbst wenn `eventSecurity` verweigert, oder ein Fehler auftritt, um einige über die Zugriffsrechte für den aktuellen Benutzer zu gewähren. Allerdings, wenn der aktuelle Benutzer versucht, erhalten einen anderen <xref:System.Threading.EventWaitHandle> Objekt zur Darstellung der gleichen Ereignis unter Verwendung entweder mit dem Namen eines Konstruktors oder der <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Methode, die Windows-zugriffssteuerungssicherheit angewendet wird.  
  
 Wenn ein Systemereignis mit der angegebene Name für die `name` Parameter bereits vorhanden ist, die `initialState` Parameter wird ignoriert. Verwenden Sie nach dem Aufrufen des Konstruktors den Wert in der Variablen angegeben, für die `ref` Parameter (`ByRef` -Parameter in Visual Basic) `createdNew` zu bestimmen, ob das benannte Systemereignis bereits vorhanden war oder erstellt wurde.  
  
 Wenn der ursprüngliche Zustand des Ereignisses auf "nicht signalisiert" festgelegt ist, werden Threads, die auf das Ereignis warten blockiert. Wenn der anfängliche Zustand signalisiert wird, und die <xref:System.Threading.EventResetMode.ManualReset> Flag angegeben wird, für die `mode`, Threads, die auf das Ereignis warten nicht blockiert. Wenn der anfängliche Zustand signalisiert wird, und `mode` ist <xref:System.Threading.EventResetMode.AutoReset>, der erste Thread, der auf das Ereignis wartet sofort freigegeben, nach dem das Ereignis zurückgesetzt wird, und nachfolgende Threads blockiert.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten ein benanntes Systemereignis mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Ereignisses zu testen.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und die zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Ereignis zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für das Ereignis.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -methodenüberladung, um mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen auf das Ereignis warten.  
  
 Nachdem die Berechtigungen geändert werden, wird das Ereignis mit den erforderlichen Benutzerrechten zum Warten und signalisieren Sie es geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird das Beispiel mit die neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt ab, das die Zugriffssteuerungssicherheit für das benannte Systemereignis darstellt, das durch das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt dargestellt wird.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit für das benannte Systemereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> -Methode verwendet die folgende Kombination von Flags (bitweise OR-Operation) für Berechtigungen suchen: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Der Benutzer <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> Rechte zum Aufrufen dieser Methode, und das Ereignis geöffnet worden sein müssen mit der <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> Flag.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten ein benanntes Systemereignis mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Ereignisses zu testen.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und die zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Ereignis zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für das Ereignis.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -methodenüberladung, um mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen auf das Ereignis warten.  
  
 Nachdem die Berechtigungen mit gelesen wurden, die <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> -Methode und geändert, wird das Ereignis mit den erforderlichen Benutzerrechten zum Warten und signalisieren Sie es geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird das Beispiel mit die neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt ein benanntes Systemereignis dar, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
- oder - 
Das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt ein benanntes Systemereignis dar und wurde nicht mit <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /> geöffnet.</exception>
        <exception cref="T:System.NotSupportedException">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für dieses <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein bestimmtes benanntes Synchronisierungsereignis, wenn es bereits vorhanden ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <summary>Öffnet das bestimmte benannte Synchronisierungsereignis, wenn es bereits vorhanden ist.</summary>
        <returns>Ein Objekt, das das benannte Systemereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Methode versucht, die das angegebene benannte Systemereignis zu öffnen. Wenn das Systemereignis nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemereignis an. Erstellen Sie das Systemereignis, wenn es nicht bereits vorhanden ist, verwenden Sie eine der der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` ist nicht unbedingt zurück, die gleiche <xref:System.Threading.EventWaitHandle> Objekt, auch wenn die Objekte, die zurückgegeben werden, die dasselbe benannte Systemereignis darstellt.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -methodenüberladung, und geben <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Rechte, die mithilfe einer bitweise OR-Operation kombiniert.  
  
 Angeben der <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread wartet auf das benannte Systemereignis, und geben Sie die <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread zum Aufrufen der <xref:System.Threading.EventWaitHandle.Set%2A> und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten ein benanntes Systemereignis mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Ereignisses zu testen.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und die zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Ereignis zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für das Ereignis.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -methodenüberladung, um mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen auf das Ereignis warten.  
  
 Nachdem die Berechtigungen geändert werden, wird das Ereignis mit den erforderlichen Benutzerrechten zum Warten und signalisieren Sie es geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird das Beispiel mit die neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Systemereignis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, der Benutzer verfügt jedoch nicht über den nötigen Sicherheitszugriff, um es zu verwenden.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <summary>Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</summary>
        <returns>Ein Objekt, das das benannte Systemereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `rights` Parameter enthalten muss der <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flag, um Threads warten auf das Ereignis zu ermöglichen und die <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flag, um Threads aufgerufen werden können die <xref:System.Threading.EventWaitHandle.Set%2A> und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden.  
  
 Die <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Methode versucht, ein vorhandene benannte Systemereignis zu öffnen. Wenn das Systemereignis nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemereignis an. Erstellen Sie das Systemereignis, wenn es nicht bereits vorhanden ist, verwenden Sie eine der der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` ist nicht unbedingt zurück, die gleiche <xref:System.Threading.EventWaitHandle> Objekt, auch wenn die Objekte, die zurückgegeben werden, die dasselbe benannte Systemereignis darstellt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten ein benanntes Systemereignis mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Ereignisses zu testen.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und die zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Ereignis zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für das Ereignis.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -methodenüberladung, um mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen auf das Ereignis warten.  
  
 Nachdem die Berechtigungen geändert werden, wird das Ereignis mit den erforderlichen Benutzerrechten zum Warten und signalisieren Sie es geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird das Beispiel mit die neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Systemereignis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt den Zustand des Ereignisses auf „nicht signalisiert“ fest, sodass Threads blockiert werden.</summary>
        <returns><see langword="true" />, wenn die Operation erfolgreich ausgeführt wird, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für dieses <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt den Zustand des Ereignisses auf „signalisiert“ fest und ermöglicht so einem oder mehreren wartenden Threads das Fortfahren.</summary>
        <returns><see langword="true" />, wenn die Operation erfolgreich ausgeführt wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für eine <xref:System.Threading.EventWaitHandle> mit <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (einschließlich <xref:System.Threading.AutoResetEvent>), wird die <xref:System.Threading.EventWaitHandle.Set%2A> Methode gibt einen einzelnen Thread frei. Wenn keine wartenden Threads vorhanden sind, das Wait-Handle bleibt signalisiert, bis ein Thread versucht, das Warten darauf, oder bis die <xref:System.Threading.EventWaitHandle.Reset%2A> Methode wird aufgerufen.  
  
> [!IMPORTANT]
>  Es gibt keine Garantie, die für jeden Aufruf der <xref:System.Threading.EventWaitHandle.Set%2A> Methode wird einen Thread aus freigegeben ein <xref:System.Threading.EventWaitHandle> , deren Zurücksetzmodus ist <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Wenn zwei Aufrufe zu eng beieinander liegen, sind, sodass der zweite Aufruf erfolgt, bevor ein Thread freigegeben wurde, wird nur ein Thread freigegeben. Es ist, als wäre der zweite Aufruf nicht der Fall. Auch wenn <xref:System.Threading.EventWaitHandle.Set%2A> wird aufgerufen, wenn es sind keine Threads warten und die <xref:System.Threading.EventWaitHandle> bereits signalisiert wird, wird der Aufruf hat keine Auswirkungen.  
  
 Für eine <xref:System.Threading.EventWaitHandle> mit <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (einschließlich <xref:System.Threading.ManualResetEvent>), wird beim Aufruf der <xref:System.Threading.EventWaitHandle.Set%2A> -Methode bewirkt, dass das Wait-Handle in einem signalisierten Zustand, bis die <xref:System.Threading.EventWaitHandle.Reset%2A> Methode wird aufgerufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> -methodenüberladung, um ermöglichen den Hauptthread auf einen blockierten Thread zu signalisieren und warten Sie, bis der Thread eine Aufgabe abgeschlossen ist.  
  
 Im Beispiel fünf Threads gestartet, und blockieren können eine <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flag, und klicken Sie dann auf Versionen ein Threadzeit, die der Benutzer drückt die EINGABETASTE. Im Beispiel wird dann fünf weitere Threads und mithilfe einer eine <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> Flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für dieses <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemereignis angewendet werden soll.</param>
        <summary>Legt die Zugriffssteuerungssicherheit für ein benanntes Systemereignis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> Rechte zum Aufrufen dieser Methode, und das Ereignis geöffnet worden sein müssen mit der <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> Flag.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten ein benanntes Systemereignis mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Ereignisses zu testen.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und die zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Ereignis zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für das Ereignis.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -methodenüberladung, um mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen auf das Ereignis warten.  
  
 Nach dem Ändern der Berechtigungen mithilfe der <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> Methode, die das Ereignis wird mit den erforderlichen Benutzerrechten zum Warten und signalisieren Sie es geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird das Beispiel mit die neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="eventSecurity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
- oder - 
Das Ereignis wurde nicht mit <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /> geöffnet.</exception>
        <exception cref="T:System.SystemException">Die aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt kein benanntes Systemereignis dar.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für dieses <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein bestimmtes benanntes Synchronisierungsereignis, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <param name="result">Enthält nach Rückgabe dieser Methode ein <see cref="T:System.Threading.EventWaitHandle" />-Objekt, das das benannte Synchronisierungsereignis darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn beim Aufruf ein Fehler aufgetreten ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn das benannte Synchronisierungsereignis erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Synchronisierungsereignis nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Erstellen Sie das Systemereignis, wenn es nicht bereits vorhanden ist, verwenden Sie eine der der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Wenn Sie unsicher sind, ob ein benanntes Synchronisierungsereignis vorhanden ist, verwenden Sie die Überladung dieser Methode nicht die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> methodenüberladung, die eine Ausnahme auslöst, ist das Synchronisierungsereignis ist nicht vorhanden.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> -methodenüberladung, und geben <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Rechte, die mithilfe einer bitweise OR-Operation kombiniert. Angeben der <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread wartet auf das benannte Systemereignis, und geben Sie die <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread zum Aufrufen der <xref:System.Threading.EventWaitHandle.Set%2A> und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` ist nicht unbedingt zurück, die gleiche <xref:System.Threading.EventWaitHandle> Objekt, auch wenn die Objekte, die zurückgegeben werden, die dasselbe benannte Systemereignis darstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <param name="result">Enthält nach Rückgabe dieser Methode ein <see cref="T:System.Threading.EventWaitHandle" />-Objekt, das das benannte Synchronisierungsereignis darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn beim Aufruf ein Fehler aufgetreten ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits mit dem gewünschten Sicherheitszugriff vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn das benannte Synchronisierungsereignis erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Synchronisierungsereignis nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Erstellen Sie das Systemereignis, wenn es nicht bereits vorhanden ist, verwenden Sie eine der der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Wenn Sie unsicher sind, ob ein benanntes Synchronisierungsereignis vorhanden ist, verwenden Sie die Überladung dieser Methode nicht die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> methodenüberladung, die eine Ausnahme auslöst, ist das Synchronisierungsereignis ist nicht vorhanden.  
  
 Die `rights` Parameter enthalten muss der <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flag, um Threads warten auf das Ereignis zu ermöglichen und die <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flag, um Threads aufgerufen werden können die <xref:System.Threading.EventWaitHandle.Set%2A> und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` ist nicht unbedingt zurück, die gleiche <xref:System.Threading.EventWaitHandle> Objekt, auch wenn die Objekte, die zurückgegeben werden, die dasselbe benannte Systemereignis darstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
  </Members>
</Type>