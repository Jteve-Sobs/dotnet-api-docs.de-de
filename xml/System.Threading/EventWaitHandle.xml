<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4ac88c525ccdf6333d0fa5e68f2b6a05ec622e49" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82319609" /></Metadata><TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Threadsynchronisierungsereignis dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Threading.EventWaitHandle>-Klasse können Threads miteinander kommunizieren, indem Sie signalisieren. In der Regel wird ein oder mehrere Threads auf einem <xref:System.Threading.EventWaitHandle> blockiert, bis ein nicht blockierter Thread die <xref:System.Threading.EventWaitHandle.Set%2A>-Methode aufruft und einen oder mehrere der blockierten Threads freigibt. Ein Thread kann eine <xref:System.Threading.EventWaitHandle> signalisieren und ihn dann blockieren, indem er die `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
> [!NOTE]
>  Die <xref:System.Threading.EventWaitHandle>-Klasse ermöglicht den Zugriff auf benannte System Synchronisierungs Ereignisse.  
  
 Das Verhalten eines <xref:System.Threading.EventWaitHandle>, das signalisiert wurde, hängt von seinem Reset-Modus ab. Ein <xref:System.Threading.EventWaitHandle>, das mit dem <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>-Flag erstellt wurde, wird automatisch zurückgesetzt, wenn ein einziger wartender Thread freigegeben wurde. Eine mit der <xref:System.Threading.EventWaitHandle>-Flag erstellte <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> bleibt so lange ein Signal, bis die <xref:System.Threading.EventWaitHandle.Reset%2A>-Methode aufgerufen wird.  
  
 Automatische Zurücksetzungs Ereignisse bieten exklusiven Zugriff auf eine Ressource. Wenn ein Ereignis mit automatischer Rücksetzung als Signal verwendet wird und zu diesem Zeitpunkt keine Threads warten, bleibt es ein Signal, bis ein Thread versucht, darauf zu warten. Das Ereignis gibt den Thread frei und wird sofort zurückgesetzt, sodass nachfolgende Threads blockiert werden.  
  
 Manuelle Zurücksetzungs Ereignisse sind wie Gates. Wenn das Ereignis nicht signalisiert wird, werden Threads, die darauf warten, blockiert. Wenn das Ereignis signalisiert wird, werden alle wartenden Threads freigegeben, und das Ereignis bleibt signalisiert (d. h. nachfolgende warte Vorgänge werden nicht blockiert), bis seine <xref:System.Threading.EventWaitHandle.Reset%2A>-Methode aufgerufen wird. Manuelle Zurücksetzungs Ereignisse sind nützlich, wenn ein Thread eine Aktivität beenden muss, bevor andere Threads fortfahren können.  
  
 <xref:System.Threading.EventWaitHandle> Objekte können mit der `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> und <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> Methoden verwendet werden.  
  
 Weitere Informationen finden Sie im Artikel [Thread Interaktion oder Signalisierung](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) im Artikel [Übersicht über Synchronisierungs primitive](~/docs/standard/threading/overview-of-synchronization-primitives.md) .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>-Methoden Überladung verwendet, damit der Haupt Thread einen blockierten Thread signalisiert und dann wartet, bis der Thread eine Aufgabe abgeschlossen hat.  
  
 Im Beispiel werden fünf Threads gestartet und ermöglicht das Blockieren einer <xref:System.Threading.EventWaitHandle>, die mit dem <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>-Flag erstellt wurde. Anschließend wird ein Thread freigegeben, wenn der Benutzer die EINGABETASTE drückt. Im Beispiel werden dann weitere fünf Threads in die Warteschlange eingereiht und mit einem <xref:System.Threading.EventWaitHandle> freigegeben, das mit dem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellt wurde  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Threading.EventWaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" />, wenn der anfängliche Zustand auf signalisiert festgelegt werden soll. <see langword="false" />, wenn er auf nicht signalisiert festgelegt werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse und gibt an, ob das WaitHandle anfänglich signalisiert ist und ob es automatisch oder manuell zurückgesetzt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre. Wenn der Anfangszustand signalisiert ist und das <xref:System.Threading.EventResetMode.ManualReset>-Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert. Wenn der Anfangszustand signalisiert ist und `mode` <xref:System.Threading.EventResetMode.AutoReset>ist, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>-Methoden Überladung verwendet, damit der Haupt Thread einen blockierten Thread signalisiert und dann wartet, bis der Thread eine Aufgabe abgeschlossen hat.  
  
 Im Beispiel werden fünf Threads gestartet und ermöglicht das Blockieren einer <xref:System.Threading.EventWaitHandle>, die mit dem <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>-Flag erstellt wurde. Anschließend wird ein Thread freigegeben, wenn der Benutzer die EINGABETASTE drückt. Im Beispiel werden dann weitere fünf Threads in die Warteschlange eingereiht und mit einem <xref:System.Threading.EventWaitHandle> freigegeben, das mit dem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellt wurde  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <param name="name">Der Name des systemweiten Synchronisierungsereignisses.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, gibt an, ob das WaitHandle anfänglich signalisiert ist, wenn es als Ergebnis dieses Aufrufs erstellt wurde, ob es automatisch oder manuell zurückgesetzt wird, und gibt den Namen eines Systemsynchronisierungsereignisses an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `name` `null` oder eine leere Zeichenfolge ist, wird eine lokale <xref:System.Threading.EventWaitHandle> erstellt.  
  
 Wenn ein System Ereignis mit dem für den `name`-Parameter angegebenen Namen bereits vorhanden ist, wird der `initialState` Parameter ignoriert.  
  
> [!IMPORTANT]
>  Wenn Sie diesen Konstruktor für benannte Systemereignisse verwenden, geben Sie `false` für `initialState`an. Dieser Konstruktor bietet keine Möglichkeit, zu bestimmen, ob ein benanntes System Ereignis erstellt wurde, sodass Sie keine Annahmen über den Status des benannten Ereignisses treffen können. Verwenden Sie den <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29>-Konstruktor oder den <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29>-Konstruktor, um zu bestimmen, ob ein benanntes Ereignis erstellt wurde.  
  
 Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre. Wenn der Anfangszustand signalisiert ist und das <xref:System.Threading.EventResetMode.ManualReset>-Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert. Wenn der Anfangszustand signalisiert ist und `mode` <xref:System.Threading.EventResetMode.AutoReset>ist, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string * bool -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <param name="name">Der Name des systemweiten Synchronisierungsereignisses.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Ereignis erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemereignis erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsereignis bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, die Folgendes angibt: ob das Wait-Handle anfänglich signalisiert wird, wenn es als Ergebnis dieses Aufrufs erstellt wird; ob es automatisch oder manuell zurückgesetzt wird; den Namen eines Systemsynchronisierungsereignisses und eine boolesche Variable, deren Wert nach dem Aufruf angibt, ob das benannte Systemereignis erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein System Ereignis mit dem für den `name`-Parameter angegebenen Namen bereits vorhanden ist, wird der `initialState` Parameter ignoriert. Nachdem Sie diesen Konstruktor aufgerufen haben, verwenden Sie den Wert in der Variablen, die für den `ref`-Parameter angegeben wurde (`ByRef` Parameter in Visual Basic)`createdNew`, um zu bestimmen, ob das benannte System Ereignis bereits vorhanden war oder erstellt wurde.  
  
 Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre. Wenn der Anfangszustand signalisiert ist und das <xref:System.Threading.EventResetMode.ManualReset>-Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert. Wenn der Anfangszustand signalisiert ist und `mode` <xref:System.Threading.EventResetMode.AutoReset>ist, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string * bool * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <param name="name">Der Name des systemweiten Synchronisierungsereignisses.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Ereignis erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemereignis erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsereignis bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="eventSecurity">Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemereignis angewendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, die Folgendes angibt: ob das Wait-Handle anfänglich signalisiert wird, wenn es als Ergebnis dieses Aufrufs erstellt wird; ob es automatisch oder manuell zurückgesetzt wird; den Namen eines Systemsynchronisierungsereignisses, eine boolesche Variable, deren Wert nach dem Aufruf angibt, ob das benannte Systemereignis erstellt wurde, und die Zugriffssteuerungssicherheit, die auf das benannte Ereignis angewandt werden soll, falls es erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, um die Zugriffs Steuerungs Sicherheit auf ein benanntes System Ereignis anzuwenden, wenn es erstellt wird. Dadurch wird verhindert, dass anderer Code die Steuerung des Ereignisses übernimmt.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.EventWaitHandle> Objekt, das ein System Ereignis darstellt. Sie können mehrere <xref:System.Threading.EventWaitHandle> Objekte erstellen, die das gleiche System Ereignis darstellen.  
  
 Wenn das System Ereignis nicht vorhanden ist, wird es mit der angegebenen Zugriffs Steuerungs Sicherheit erstellt. Wenn das Ereignis vorhanden ist, wird die angegebene Zugriffs Steuerungs Sicherheit ignoriert.  
  
> [!NOTE]
>  Der Aufrufer hat die vollständige Kontrolle über das neu erstellte <xref:System.Threading.EventWaitHandle> Objekt, auch wenn `eventSecurity` dem aktuellen Benutzer einige Zugriffsrechte verweigert oder ihm nicht zuweist. Wenn der aktuelle Benutzer jedoch versucht, ein anderes <xref:System.Threading.EventWaitHandle> Objekt zu erhalten, das das gleiche benannte Ereignis repräsentiert, entweder mithilfe eines Konstruktors oder der <xref:System.Threading.EventWaitHandle.OpenExisting%2A>-Methode, wird die Windows-Zugriffs Steuerungs Sicherheit angewendet.  
  
 Wenn ein System Ereignis mit dem für den `name`-Parameter angegebenen Namen bereits vorhanden ist, wird der `initialState` Parameter ignoriert. Nachdem Sie diesen Konstruktor aufgerufen haben, verwenden Sie den Wert in der Variablen, die für den `ref`-Parameter angegeben wurde (`ByRef` Parameter in Visual Basic) `createdNew`, um zu bestimmen, ob das benannte System Ereignis bereits vorhanden war oder erstellt wurde.  
  
 Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre. Wenn der Anfangszustand signalisiert ist und das <xref:System.Threading.EventResetMode.ManualReset>-Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert. Wenn der Anfangszustand signalisiert ist und `mode` <xref:System.Threading.EventResetMode.AutoReset>ist, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt ab, das die Zugriffssteuerungssicherheit für das benannte Systemereignis darstellt, das durch das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt dargestellt wird.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit für das benannte Systemereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.EventWaitHandle.GetAccessControl%2A>-Methode verwendet die folgende Kombination von-Flags (kombiniert mithilfe des bitweisen OR-Vorgangs), um nach Berechtigungen zu suchen: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Der Benutzer muss über <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> Rechte verfügen, um diese Methode aufzurufen, und das Ereignis muss mit dem <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType>-Flag geöffnet worden sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen mithilfe der <xref:System.Threading.EventWaitHandle.GetAccessControl%2A>-Methode gelesen und geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt ein benanntes Systemereignis dar, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
Oder 
Das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt ein benanntes Systemereignis dar und wurde nicht mit <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /> geöffnet.</exception>
        <exception cref="T:System.NotSupportedException">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für diesen <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein bestimmtes benanntes Synchronisierungsereignis, wenn es bereits vorhanden ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <summary>Öffnet das bestimmte benannte Synchronisierungsereignis, wenn es bereits vorhanden ist.</summary>
        <returns>Ein Objekt, das das benannte Systemereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.EventWaitHandle.OpenExisting%2A>-Methode versucht, das angegebene benannte System Ereignis zu öffnen. Wenn das System Ereignis nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System Ereignis zu erstellen. Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs.  
  
 Das Angeben des <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flags ermöglicht einem Thread, auf das benannte System Ereignis zu warten, und die Angabe des <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.EventWaitHandle.Set%2A>-und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden aufzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Systemereignis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, der Benutzer verfügt jedoch nicht über den nötigen Sicherheitszugriff, um es zu verwenden.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <summary>Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</summary>
        <returns>Ein Objekt, das das benannte Systemereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `rights`-Parameter muss das <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads auf das Ereignis warten können, und das <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.EventWaitHandle.Set%2A>-und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden aufrufen können.  
  
 Die <xref:System.Threading.EventWaitHandle.OpenExisting%2A>-Methode versucht, ein vorhandenes benanntes System Ereignis zu öffnen. Wenn das System Ereignis nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System Ereignis zu erstellen. Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Systemereignis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt den Zustand des Ereignisses auf „nicht signalisiert“ fest, sodass Threads blockiert werden.</summary>
        <returns><see langword="true" />, wenn die Operation erfolgreich ausgeführt wird, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für diesen <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt den Zustand des Ereignisses auf „signalisiert“ fest und ermöglicht so einem oder mehreren wartenden Threads das Fortfahren.</summary>
        <returns><see langword="true" />, wenn die Operation erfolgreich ausgeführt wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einer <xref:System.Threading.EventWaitHandle> mit <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (einschließlich <xref:System.Threading.AutoResetEvent>) gibt die <xref:System.Threading.EventWaitHandle.Set%2A>-Methode einen einzelnen Thread frei. Wenn keine wartenden Threads vorhanden sind, bleibt das Wait-Handle signalisiert, bis ein Thread versucht, darauf zu warten, oder bis seine <xref:System.Threading.EventWaitHandle.Reset%2A>-Methode aufgerufen wird.  
  
> [!IMPORTANT]
>  Es gibt keine Garantie dafür, dass jeder aufzurufende <xref:System.Threading.EventWaitHandle.Set%2A> Methode einen Thread von einem <xref:System.Threading.EventWaitHandle> freigibt, dessen Zurücksetzungs Modus <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>ist. Wenn zwei Aufrufe zu eng beieinander liegen, sodass der zweite Aufruf stattfindet, bevor ein Thread freigegeben wurde, wird nur ein Thread freigegeben. Dies ist der Fall, wenn der zweite-Vorgang nicht durchgeführt wurde. Wenn <xref:System.Threading.EventWaitHandle.Set%2A> aufgerufen wird, wenn keine Threads warten und der <xref:System.Threading.EventWaitHandle> bereits signalisiert ist, hat der Aufruf keine Auswirkung.  
  
 Bei einer <xref:System.Threading.EventWaitHandle> mit <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (einschließlich <xref:System.Threading.ManualResetEvent>) verlässt der Aufruf der <xref:System.Threading.EventWaitHandle.Set%2A>-Methode den Wait-Handle in einem signalisierten Zustand, bis seine <xref:System.Threading.EventWaitHandle.Reset%2A>-Methode aufgerufen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>-Methoden Überladung verwendet, damit der Haupt Thread einen blockierten Thread signalisiert und dann wartet, bis der Thread eine Aufgabe abgeschlossen hat.  
  
 Im Beispiel werden fünf Threads gestartet und ermöglicht das Blockieren einer <xref:System.Threading.EventWaitHandle>, die mit dem <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>-Flag erstellt wurde. Anschließend wird ein Thread freigegeben, wenn der Benutzer die EINGABETASTE drückt. Im Beispiel werden dann weitere fünf Threads in die Warteschlange eingereiht und mit einem <xref:System.Threading.EventWaitHandle> freigegeben, das mit dem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellt wurde  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für diesen <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemereignis angewendet werden soll.</param>
        <summary>Legt die Zugriffssteuerungssicherheit für ein benanntes Systemereignis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss über <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> Rechte verfügen, um diese Methode aufzurufen, und das Ereignis muss mit dem <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType>-Flag geöffnet worden sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen mithilfe der <xref:System.Threading.EventWaitHandle.SetAccessControl%2A>-Methode geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="eventSecurity" /> ist <see langword="null" /></exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
Oder 
Das Ereignis wurde nicht mit <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /> geöffnet.</exception>
        <exception cref="T:System.SystemException">Die aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt kein benanntes Systemereignis dar.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für diesen <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein bestimmtes benanntes Synchronisierungsereignis, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * EventWaitHandle -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <param name="result">Enthält nach Rückgabe dieser Methode ein <see cref="T:System.Threading.EventWaitHandle" />-Objekt, das das benannte Synchronisierungsereignis darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn beim Aufruf ein Fehler aufgetreten ist. Dieser Parameter wird als nicht initialisiert behandelt.</param>
        <summary>Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn das benannte Synchronisierungsereignis erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Synchronisierungs Ereignis nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Wenn Sie unsicher sind, ob ein benanntes Synchronisierungs Ereignis vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn das Synchronisierungs Ereignis nicht vorhanden ist.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs. Das Angeben des <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flags ermöglicht einem Thread, auf das benannte System Ereignis zu warten, und die Angabe des <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.EventWaitHandle.Set%2A>-und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden aufzurufen.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights * EventWaitHandle -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <param name="result">Enthält nach Rückgabe dieser Methode ein <see cref="T:System.Threading.EventWaitHandle" />-Objekt, das das benannte Synchronisierungsereignis darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn beim Aufruf ein Fehler aufgetreten ist. Dieser Parameter wird als nicht initialisiert behandelt.</param>
        <summary>Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits mit dem gewünschten Sicherheitszugriff vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn das benannte Synchronisierungsereignis erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Synchronisierungs Ereignis nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.EventWaitHandle.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Wenn Sie unsicher sind, ob ein benanntes Synchronisierungs Ereignis vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn das Synchronisierungs Ereignis nicht vorhanden ist.  
  
 Der `rights`-Parameter muss das <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads auf das Ereignis warten können, und das <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.EventWaitHandle.Set%2A>-und <xref:System.Threading.EventWaitHandle.Reset%2A> Methoden aufrufen können.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
