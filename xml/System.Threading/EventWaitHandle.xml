<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fc1d0f39e32f0e1f04f469845918aa4cdb230b30" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70409166" /></Metadata><TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Threadsynchronisierungsereignis dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mithilfe <xref:System.Threading.EventWaitHandle> der-Klasse können Threads miteinander kommunizieren, indem Sie signalisieren. In der Regel wird ein oder mehrere Threads auf <xref:System.Threading.EventWaitHandle> einem-Block blockiert, bis ein <xref:System.Threading.EventWaitHandle.Set%2A> nicht blockierter Thread die-Methode aufruft und einen oder mehrere der blockierten Threads freigibt. <xref:System.Threading.EventWaitHandle> Ein Thread kann einen signalisieren und ihn dann blockieren, indem er die `static` -Methode`Shared` (in Visual Basic <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> ) aufrufen.  
  
> [!NOTE]
>  Die <xref:System.Threading.EventWaitHandle> -Klasse ermöglicht den Zugriff auf benannte System Synchronisierungs Ereignisse.  
  
 Das Verhalten eines <xref:System.Threading.EventWaitHandle> , das signalisiert wurde, hängt von seinem Reset-Modus ab. Ein <xref:System.Threading.EventWaitHandle> , das mit <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> dem-Flag erstellt wird, wenn signalisiert wird, nachdem ein einzelner wartender Thread freigegeben wurde. Eine mit der <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellte <xref:System.Threading.EventWaitHandle.Reset%2A> bleibt so lange ein Signal, bis die <xref:System.Threading.EventWaitHandle>-Methode aufgerufen wird.  
  
 Automatische Zurücksetzungs Ereignisse bieten exklusiven Zugriff auf eine Ressource. Wenn ein Ereignis mit automatischer Rücksetzung als Signal verwendet wird und zu diesem Zeitpunkt keine Threads warten, bleibt es ein Signal, bis ein Thread versucht, darauf zu warten. Das Ereignis gibt den Thread frei und wird sofort zurückgesetzt, sodass nachfolgende Threads blockiert werden.  
  
 Manuelle Zurücksetzungs Ereignisse sind wie Gates. Wenn das Ereignis nicht signalisiert wird, werden Threads, die darauf warten, blockiert. Wenn das Ereignis signalisiert wird, werden alle wartenden Threads freigegeben, und das Ereignis bleibt signalisiert (d. h. nachfolgende warte Vorgänge werden nicht <xref:System.Threading.EventWaitHandle.Reset%2A> blockiert), bis die zugehörige-Methode aufgerufen wird. Manuelle Zurücksetzungs Ereignisse sind nützlich, wenn ein Thread eine Aktivität beenden muss, bevor andere Threads fortfahren können.  
  
 <xref:System.Threading.EventWaitHandle>-Objekte können mit der ( `static``Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> -Methode <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> und der-Methode verwendet werden.  
  
 Weitere Informationen finden Sie im Artikel [Thread Interaktion oder Signalisierung](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) im Artikel [Übersicht über Synchronisierungs primitive](~/docs/standard/threading/overview-of-synchronization-primitives.md) .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> -Methoden Überladung verwendet, damit der Haupt Thread einen blockierten Thread signalisiert und dann wartet, bis der Thread eine Aufgabe abgeschlossen hat.  
  
 Im Beispiel werden fünf Threads gestartet und ermöglicht das Blockieren von für <xref:System.Threading.EventWaitHandle> eine, die <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> mit dem-Flag erstellt wurde, und gibt dann einen Thread frei, wenn der Benutzer die EINGABETASTE drückt. Im Beispiel werden dann weitere fünf Threads in die Warteschlange eingereiht <xref:System.Threading.EventWaitHandle> und mit dem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> mit dem-Flag erstellten freigegeben.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" />, wenn der anfängliche Zustand auf signalisiert festgelegt werden soll. <see langword="false" />, wenn er auf nicht signalisiert festgelegt werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse und gibt an, ob das WaitHandle anfänglich signalisiert ist und ob es automatisch oder manuell zurückgesetzt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre. Wenn der Anfangszustand signalisiert und das <xref:System.Threading.EventResetMode.ManualReset> -Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert. Wenn der Anfangszustand signalisiert wird und `mode` ist <xref:System.Threading.EventResetMode.AutoReset>, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> -Methoden Überladung verwendet, damit der Haupt Thread einen blockierten Thread signalisiert und dann wartet, bis der Thread eine Aufgabe abgeschlossen hat.  
  
 Im Beispiel werden fünf Threads gestartet und ermöglicht das Blockieren von für <xref:System.Threading.EventWaitHandle> eine, die <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> mit dem-Flag erstellt wurde, und gibt dann einen Thread frei, wenn der Benutzer die EINGABETASTE drückt. Im Beispiel werden dann weitere fünf Threads in die Warteschlange eingereiht <xref:System.Threading.EventWaitHandle> und mit dem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> mit dem-Flag erstellten freigegeben.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <param name="name">Der Name des systemweiten Synchronisierungsereignisses.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, gibt an, ob das WaitHandle anfänglich signalisiert ist, wenn es als Ergebnis dieses Aufrufs erstellt wurde, ob es automatisch oder manuell zurückgesetzt wird, und gibt den Namen eines Systemsynchronisierungsereignisses an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `name` oder `null` eine leere Zeichenfolge ist, wird <xref:System.Threading.EventWaitHandle> eine lokale erstellt.  
  
 Wenn ein System Ereignis mit dem Namen, der für `name` den-Parameter angegeben ist `initialState` , bereits vorhanden ist, wird der-Parameter ignoriert.  
  
> [!IMPORTANT]
>  Wenn Sie diesen Konstruktor für benannte Systemereignisse verwenden, `false` geben `initialState`Sie für an. Dieser Konstruktor bietet keine Möglichkeit, zu bestimmen, ob ein benanntes System Ereignis erstellt wurde, sodass Sie keine Annahmen über den Status des benannten Ereignisses treffen können. Verwenden Sie den <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> -Konstruktor oder den <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> -Konstruktor, um zu bestimmen, ob ein benanntes Ereignis erstellt wurde.  
  
 Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre. Wenn der Anfangszustand signalisiert und das <xref:System.Threading.EventResetMode.ManualReset> -Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert. Wenn der Anfangszustand signalisiert wird und `mode` ist <xref:System.Threading.EventResetMode.AutoReset>, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <param name="name">Der Name des systemweiten Synchronisierungsereignisses.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Ereignis erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemereignis erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsereignis bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, die Folgendes angibt: ob das Wait-Handle anfänglich signalisiert wird, wenn es als Ergebnis dieses Aufrufs erstellt wird; ob es automatisch oder manuell zurückgesetzt wird; den Namen eines Systemsynchronisierungsereignisses und eine boolesche Variable, deren Wert nach dem Aufruf angibt, ob das benannte Systemereignis erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein System Ereignis mit dem Namen, der für `name` den-Parameter angegeben ist `initialState` , bereits vorhanden ist, wird der-Parameter ignoriert. Nachdem Sie diesen Konstruktor aufgerufen haben, verwenden Sie den Wert in der Variablen `ref` , die`ByRef` für den-Parameter`createdNew` angegeben wurde (Parameter in Visual Basic), um zu bestimmen, ob das benannte System Ereignis bereits vorhanden war oder erstellt wurde.  
  
 Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre. Wenn der Anfangszustand signalisiert und das <xref:System.Threading.EventResetMode.ManualReset> -Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert. Wenn der Anfangszustand signalisiert wird und `mode` ist <xref:System.Threading.EventResetMode.AutoReset>, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</param>
        <param name="mode">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
        <param name="name">Der Name des systemweiten Synchronisierungsereignisses.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Ereignis erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemereignis erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsereignis bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="eventSecurity">Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemereignis angewendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, die Folgendes angibt: ob das Wait-Handle anfänglich signalisiert wird, wenn es als Ergebnis dieses Aufrufs erstellt wird; ob es automatisch oder manuell zurückgesetzt wird; den Namen eines Systemsynchronisierungsereignisses, eine boolesche Variable, deren Wert nach dem Aufruf angibt, ob das benannte Systemereignis erstellt wurde, und die Zugriffssteuerungssicherheit, die auf das benannte Ereignis angewandt werden soll, falls es erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, um die Zugriffs Steuerungs Sicherheit auf ein benanntes System Ereignis anzuwenden, wenn es erstellt wird. Dadurch wird verhindert, dass anderer Code die Steuerung des Ereignisses übernimmt.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.EventWaitHandle> -Objekt, das ein System Ereignis darstellt. Sie können mehrere <xref:System.Threading.EventWaitHandle> -Objekte erstellen, die das gleiche System Ereignis darstellen.  
  
 Wenn das System Ereignis nicht vorhanden ist, wird es mit der angegebenen Zugriffs Steuerungs Sicherheit erstellt. Wenn das Ereignis vorhanden ist, wird die angegebene Zugriffs Steuerungs Sicherheit ignoriert.  
  
> [!NOTE]
>  Der Aufrufer hat die vollständige Kontrolle <xref:System.Threading.EventWaitHandle> über das neu `eventSecurity` erstellte Objekt, auch wenn er dem aktuellen Benutzer einige Zugriffsrechte gewährt oder ihm nicht zuweist. Wenn der aktuelle Benutzer jedoch versucht, ein anderes <xref:System.Threading.EventWaitHandle> Objekt zur Darstellung desselben benannten Ereignisses mit einem Konstruktor oder der <xref:System.Threading.EventWaitHandle.OpenExisting%2A> -Methode zu erhalten, wird die Windows-Zugriffs Steuerungs Sicherheit angewendet.  
  
 Wenn ein System Ereignis mit dem Namen, der für `name` den-Parameter angegeben ist `initialState` , bereits vorhanden ist, wird der-Parameter ignoriert. Nachdem Sie diesen Konstruktor aufgerufen haben, verwenden Sie den Wert in der Variablen `ref` , die`ByRef` für den-Parameter `createdNew` angegeben wurde (Parameter in Visual Basic), um zu bestimmen, ob das benannte System Ereignis bereits vorhanden war oder erstellt wurde.  
  
 Wenn der anfängliche Zustand des Ereignisses nicht signalisiert ist, blockieren Threads, die auf das Ereignis warten, eine Sperre. Wenn der Anfangszustand signalisiert und das <xref:System.Threading.EventResetMode.ManualReset> -Flag für `mode`angegeben ist, werden Threads, die auf das Ereignis warten, nicht blockiert. Wenn der Anfangszustand signalisiert wird und `mode` ist <xref:System.Threading.EventResetMode.AutoReset>, wird der erste Thread, der auf das Ereignis wartet, sofort freigegeben, nach dem das Ereignis zurückgesetzt wird und nachfolgende Threads blockiert werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> -Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>von eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt ab, das die Zugriffssteuerungssicherheit für das benannte Systemereignis darstellt, das durch das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt dargestellt wird.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit für das benannte Systemereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> -Methode verwendet die folgende Kombination von-Flags (kombiniert mithilfe des bitweisen OR-Vorgangs), um <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>nach Berechtigungen zu <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>suchen:, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>und.  
  
 Der Benutzer muss über <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> Rechte zum Abrufen dieser Methode verfügen, und das Ereignis muss mit dem <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> -Flag geöffnet worden sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> -Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>von eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen mithilfe der <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> -Methode gelesen und geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und zu signalisieren. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt ein benanntes Systemereignis dar, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
- oder - 
Das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt eine benanntes Systemereignis dar und wurde nicht mit <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /> geöffnet.</exception>
        <exception cref="T:System.NotSupportedException">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für dieses <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein bestimmtes benanntes Synchronisierungsereignis, wenn es bereits vorhanden ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <summary>Öffnet das bestimmte benannte Synchronisierungsereignis, wenn es bereits vorhanden ist.</summary>
        <returns>Ein Objekt, das das benannte Systemereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.EventWaitHandle.OpenExisting%2A> -Methode versucht, das angegebene benannte System Ereignis zu öffnen. Wenn das System Ereignis nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System Ereignis zu erstellen. Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie <xref:System.Threading.EventWaitHandle.%23ctor%2A> einen der-Konstruktoren `name` mit einem-Parameter.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -Methoden Überladung <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> der Angabe von-und-rechten in Kombination mit der bitweisen OR-Operation.  
  
 Wenn Sie <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> das Flag angeben, kann ein Thread auf das benannte System Ereignis warten, und <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> die Angabe des Flags ermöglicht einem Thread <xref:System.Threading.EventWaitHandle.Set%2A> , <xref:System.Threading.EventWaitHandle.Reset%2A> die-Methode und die-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> -Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>von eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Systemereignis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, der Benutzer verfügt jedoch nicht über den nötigen Sicherheitszugriff, um es zu verwenden.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <summary>Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</summary>
        <returns>Ein Objekt, das das benannte Systemereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `rights` -Parameter muss das <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> -Flag enthalten, damit Threads auf das Ereignis warten können, <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> und das-Flag, mit dem <xref:System.Threading.EventWaitHandle.Set%2A> Threads <xref:System.Threading.EventWaitHandle.Reset%2A> die-Methode und die-Methode aufrufen können.  
  
 Die <xref:System.Threading.EventWaitHandle.OpenExisting%2A> -Methode versucht, ein vorhandenes benanntes System Ereignis zu öffnen. Wenn das System Ereignis nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System Ereignis zu erstellen. Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie <xref:System.Threading.EventWaitHandle.%23ctor%2A> einen der-Konstruktoren `name` mit einem-Parameter.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> -Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>von eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Systemereignis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt den Zustand des Ereignisses auf nicht signalisiert fest, sodass Threads blockiert werden.</summary>
        <returns><see langword="true" />, wenn die Operation erfolgreich ausgeführt wird, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für dieses <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt den Zustand des Ereignisses auf signalisiert fest und ermöglicht so einem oder mehreren wartenden Threads fortzufahren.</summary>
        <returns><see langword="true" />, wenn die Operation erfolgreich ausgeführt wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einem <xref:System.Threading.EventWaitHandle> mit <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (einschließlich <xref:System.Threading.AutoResetEvent>) gibt die <xref:System.Threading.EventWaitHandle.Set%2A> -Methode einen einzelnen Thread frei. Wenn keine wartenden Threads vorhanden sind, bleibt das Wait-Handle signalisiert, bis ein Thread versucht, darauf zu warten, oder <xref:System.Threading.EventWaitHandle.Reset%2A> bis seine-Methode aufgerufen wird.  
  
> [!IMPORTANT]
>  Es gibt keine Garantie, dass jeder Aufrufe der <xref:System.Threading.EventWaitHandle.Set%2A> -Methode einen Thread aus einem <xref:System.Threading.EventWaitHandle> freigibt, dessen Zurücksetzungs Modus ist <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Wenn zwei Aufrufe zu eng beieinander liegen, sodass der zweite Aufruf stattfindet, bevor ein Thread freigegeben wurde, wird nur ein Thread freigegeben. Dies ist der Fall, wenn der zweite-Vorgang nicht durchgeführt wurde. Wenn <xref:System.Threading.EventWaitHandle.Set%2A> auch aufgerufen wird, wenn keine Threads warten und der <xref:System.Threading.EventWaitHandle> bereits signalisiert ist, hat der Aufruf keine Auswirkung.  
  
 Bei einem <xref:System.Threading.EventWaitHandle> mit <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (einschließlich <xref:System.Threading.ManualResetEvent>) lässt das Aufrufen <xref:System.Threading.EventWaitHandle.Set%2A> der- <xref:System.Threading.EventWaitHandle.Reset%2A> Methode den Wait-Handle in einem signalisierten Zustand, bis die-Methode aufgerufen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> -Methoden Überladung verwendet, damit der Haupt Thread einen blockierten Thread signalisiert und dann wartet, bis der Thread eine Aufgabe abgeschlossen hat.  
  
 Im Beispiel werden fünf Threads gestartet und ermöglicht das Blockieren von für <xref:System.Threading.EventWaitHandle> eine, die <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> mit dem-Flag erstellt wurde, und gibt dann einen Thread frei, wenn der Benutzer die EINGABETASTE drückt. Im Beispiel werden dann weitere fünf Threads in die Warteschlange eingereiht <xref:System.Threading.EventWaitHandle> und mit dem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> mit dem-Flag erstellten freigegeben.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für dieses <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">Ein <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemereignis angewendet werden soll.</param>
        <summary>Legt die Zugriffssteuerungssicherheit für ein benanntes Systemereignis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss über <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> Rechte zum Abrufen dieser Methode verfügen, und das Ereignis muss mit dem <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> -Flag geöffnet worden sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten System Ereignisses mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> -Methoden Überladung verwendet, um zu testen, ob ein benanntes Ereignis vorhanden ist.  
  
 Wenn das Ereignis nicht vorhanden ist, wird es mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Ereignis zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für das Ereignis zu erteilen.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>von eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> -Methoden Überladung, um auf das Ereignis mit den rechten zu warten, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen mithilfe der <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> -Methode geändert wurden, wird das Ereignis mit den Rechten geöffnet, die erforderlich sind, um darauf zu warten und es zu signalisieren. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird das Beispiel mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="eventSecurity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
- oder - 
Das Ereignis wurde nicht mit <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /> geöffnet.</exception>
        <exception cref="T:System.SystemException">Das aktuelle <see cref="T:System.Threading.EventWaitHandle" />-Objekt stellt kein benanntes Systemereignis dar.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für dieses <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein bestimmtes benanntes Synchronisierungsereignis, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <param name="result">Enthält nach Rückgabe dieser Methode ein <see cref="T:System.Threading.EventWaitHandle" />-Objekt, das das benannte Synchronisierungsereignis darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn beim Aufruf ein Fehler aufgetreten ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn das benannte Synchronisierungsereignis erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Synchronisierungs Ereignis nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie <xref:System.Threading.EventWaitHandle.%23ctor%2A> einen der-Konstruktoren `name` mit einem-Parameter.  
  
 Wenn Sie unsicher sind, ob ein benanntes Synchronisierungs Ereignis vorhanden ist, verwenden Sie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> diese Methoden Überladung anstelle der-Methoden Überladung, die eine Ausnahme auslöst, wenn das Synchronisierungs Ereignis nicht vorhanden ist.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> -Methoden Überladung <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> der Angabe von-und-rechten in Kombination mit der bitweisen OR-Operation. Wenn Sie <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> das Flag angeben, kann ein Thread auf das benannte System Ereignis warten, und <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> die Angabe des Flags ermöglicht einem Thread <xref:System.Threading.EventWaitHandle.Set%2A> , <xref:System.Threading.EventWaitHandle.Reset%2A> die-Methode und die-Methode aufzurufen.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <param name="result">Enthält nach Rückgabe dieser Methode ein <see cref="T:System.Threading.EventWaitHandle" />-Objekt, das das benannte Synchronisierungsereignis darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn beim Aufruf ein Fehler aufgetreten ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits mit dem gewünschten Sicherheitszugriff vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn das benannte Synchronisierungsereignis erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Synchronisierungs Ereignis nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Um das System Ereignis zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie <xref:System.Threading.EventWaitHandle.%23ctor%2A> einen der-Konstruktoren `name` mit einem-Parameter.  
  
 Wenn Sie unsicher sind, ob ein benanntes Synchronisierungs Ereignis vorhanden ist, verwenden Sie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> diese Methoden Überladung anstelle der-Methoden Überladung, die eine Ausnahme auslöst, wenn das Synchronisierungs Ereignis nicht vorhanden ist.  
  
 Der `rights` -Parameter muss das <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> -Flag enthalten, damit Threads auf das Ereignis warten können, <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> und das-Flag, mit dem <xref:System.Threading.EventWaitHandle.Set%2A> Threads <xref:System.Threading.EventWaitHandle.Reset%2A> die-Methode und die-Methode aufrufen können.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.EventWaitHandle> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Ereignis darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
