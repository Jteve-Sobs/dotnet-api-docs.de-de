<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="75309784a7f2ba45e91d42b9f73bf62285725b43" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52200779" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ein Synchronisierungsprimitiver, der auch für die prozessübergreifende Synchronisierung verwendet werden kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn zwei oder mehr Threads zur selben Zeit eine freigegebene Ressource zugreifen müssen, benötigt das System einen Synchronisierungsmechanismus, um sicherzustellen, dass jeweils nur ein Thread die Ressource verwendet. <xref:System.Threading.Mutex> ist ein Synchronisierungsprimitiver, der exklusiven Zugriff auf die freigegebene Ressource nur ein Thread gewährt. Wenn ein Thread einen Mutex, wird der zweite Thread, der beim Abrufen von dieser Mutex möchte angehalten, bis der erste Thread das Mutex frei.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mit dem Typ haben, sollten Sie es entweder direkt oder indirekt freigeben. Damit des Typs direkt freigegeben werden, rufen Sie die <xref:System.IDisposable.Dispose%2A> -Methode in einer `try` / `catch` Block. Um sie indirekt löschen, verwenden Sie ein Sprachkonstrukt wie `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "mithilfe von ein-Objekt, das implementiert" IDisposable "" in der <xref:System.IDisposable> schnittstellenthema.  
  
 Sie können die <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode, um den Besitz des Mutex anfordert. Der aufrufende Thread blockiert, bis eines der folgenden Ereignisse eintritt:  
  
-   Mutex wird signalisiert, um anzugeben, dass er nicht gehört. In diesem Fall die <xref:System.Threading.WaitHandle.WaitOne%2A> Methodenrückgabe `true`, und der aufrufende Thread übernimmt den Besitz des Mutex und greift auf die vom Mutex geschützte Ressource. Wenn sie mit dem Zugriff auf die Ressource abgeschlossen ist, muss der Thread Aufrufen der <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode, um den Besitz des Mutex freizugeben. Im erste Beispiel im Abschnitt mit Beispielen veranschaulicht dieses Muster.  
  
-   Das Timeoutintervall, die im Aufruf angegeben ein <xref:System.Threading.WaitHandle.WaitOne%2A> Methode mit einem `millisecondsTimeout` oder `timeout` Parameter ist abgelaufen. In diesem Fall die <xref:System.Threading.WaitHandle.WaitOne%2A> Methodenrückgabe `false`, und der aufrufende Thread unternimmt keinen weiteren Versuch, den Besitz des Mutex abzurufen. In diesem Fall sollten Sie Ihren Code so strukturieren, dass an den aufrufenden Thread den Zugriff auf die vom Mutex geschützte Ressource verweigert wird. Da der Thread nie den Besitz des Mutex erworben haben, müssen sie nicht Aufrufen der <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode. Das zweite Beispiel im Abschnitt "Beispiele" veranschaulicht dieses Muster.  
  
 Die <xref:System.Threading.Mutex> Klasse erzwingt die Threadidentität, sodass ein Mutex nur von einem Thread freigegeben werden kann, die sie erworben haben. Im Gegensatz dazu die <xref:System.Threading.Semaphore> Klasse erzwingen keine Threadidentität. Ein Mutex kann auch über Anwendungsdomänen hinweg übergeben werden.  
  
 Der Thread, der einen Mutex besitzt kann anfordern, dass wiederholte Aufrufe derselben Mutex <xref:System.Threading.WaitHandle.WaitOne%2A> ohne dessen Ausführung zu blockieren. Allerdings muss der Thread Aufrufen der <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode die gleiche Anzahl an, wie oft, um den Besitz des Mutex freizugeben.  
  
 Da die <xref:System.Threading.Mutex> Klasse erbt von <xref:System.Threading.WaitHandle>, rufen Sie außerdem die statische <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> und <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> Methoden zum Synchronisieren des Zugriffs auf eine geschützte Ressource.  
  
 Wenn ein Thread beendet wird, während einen Mutex besitzt, wird der Mutex als abgebrochener Mutex bezeichnet. Der Status des Mutex wird auf signalisiert festgelegt, und der nächste wartenden Thread Ruft die Inhaberschaft ab. Ab Version 2.0 von .NET Framework ein <xref:System.Threading.AbandonedMutexException> wird ausgelöst, in der nächsten Thread, der den abgebrochenen Mutex verwendet. Vor Version 2.0 von .NET Framework wurde keine Ausnahme ausgelöst.  
  
> [!CAUTION]
>  Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code. Wenn ein Thread beendet, ohne das Mutex freizugeben, möglicherweise die Datenstrukturen, die vom Mutex geschützte nicht in einem konsistenten Zustand. Der nächste Thread, der Besitz des Mutex anfordert, kann diese Ausnahme behandeln und den Vorgang fortsetzen, wenn die Integrität der Datenstruktur überprüft werden kann.  
  
 Wenn es sich um einen systemweiten Mutex handelt, kann ein abgebrochener Mutex darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z.B. über den Windows Task-Manager).  
  
 Es gibt zwei Typen: Lokale Mutexe, die unbenannte und benannte Systemmutexe. Ein lokaler Mutex ist nur innerhalb des Prozesses vorhanden. Es kann verwendet werden, von jedem Thread im Prozess, die einen Verweis auf die <xref:System.Threading.Mutex> -Objekt, das den Mutex darstellt. Jeder unbenannte <xref:System.Threading.Mutex> Objekt darstellt, einen separaten lokalen Mutex.  
  
 Benannte Mutexe sind im gesamten Betriebssystem sichtbar und kann zum Synchronisieren der Aktivitäten von Prozessen verwendet werden. Sie erstellen eine <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt, mithilfe eines Konstruktors, der einen Namen akzeptiert. Das Betriebssystem-Objekt kann zur gleichen Zeit erstellt werden oder es kann vorhanden sein, bevor die Erstellung von der <xref:System.Threading.Mutex> Objekt. Sie können mehrere <xref:System.Threading.Mutex>-Objekte erstellen, die denselben benannten Systemmutex darstellen, und Sie können mithilfe der <xref:System.Threading.Mutex.OpenExisting%2A>-Methode einen vorhandenen benannten Systemmutex öffnen.  
  
> [!NOTE]
>  Auf einem Server, auf der Terminaldienste ausgeführt wird, haben ein benannten Systemmutex zwei Ebenen der Sichtbarkeit. Wenn der Name mit dem Präfix beginnt "Global\\", der Mutex ist in allen Sitzungen des Terminalservers sichtbar. Wenn der Name mit dem Präfix beginnt "lokale\\", der Mutex ist nur in der Terminalserver-Sitzung sichtbar, in dem es erstellt wurde. In diesem Fall kann ein separater Mutex mit dem gleichen Namen in den einzelnen von den anderen Terminalserver-Sitzungen auf dem Server vorhanden sein. Wenn Sie ein Präfix nicht angeben, wenn Sie einen benannten Mutex erstellen, dauert das Präfix "lokale\\". Klicken Sie in einer Terminalserver-Sitzung zwei Mutexe, deren Namen sich nur durch ihre Präfixe unterscheiden, sind separate Mutexe, und beide sind für alle Prozesse sichtbar, in der Terminalserver-Sitzung. D. h. den Präfixnamen "Global\\" und "lokale\\" des Bereichs der Mutex-Namen, relativ zum Sitzungen des Terminalservers, nicht in Bezug auf Prozesse zu beschreiben.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 Dieses Beispiel zeigt, wie eine lokale <xref:System.Threading.Mutex> Objekt wird zum Synchronisieren des Zugriffs auf eine geschützte Ressource verwendet. Da jeder aufrufenden Thread blockiert wird, bis er den Besitz des Mutex erhält, muss diese Aufrufen der <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode, um den Besitz des Threads freizugeben.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 Im folgenden Beispiel ist jeder Thread Ruft die <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> Methode, um den Mutex abrufen. Die Methode gibt zurück, wenn das Timeoutintervall abläuft, `false`, und der Thread das Mutex erhält weder erhält Zugriff auf die Ressource, die der Mutex geschützt. Die <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode wird aufgerufen, nur von einem Thread, der den Mutex verwendet.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit Standardeigenschaften.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen dieser Überladung des Konstruktors ist der gleiche wie das Aufrufen der <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> Überladung des Konstruktors und Angeben von `false` für den anfänglichen Besitz des Mutex. Der aufrufende Thread besitzt den Mutex, also nicht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine lokale <xref:System.Threading.Mutex> Objekt wird zum Synchronisieren des Zugriffs auf eine geschützte Ressource verwendet. Der Thread, der den Mutex erstellt besitzt es zunächst nicht.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des Mutex zuzuweisen, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine lokale <xref:System.Threading.Mutex> Objekt wird zum Synchronisieren des Zugriffs auf eine geschützte Ressource verwendet. Der Thread, erstellt die <xref:System.Threading.Mutex> zunächst der ihn besitzt.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <see langword="false" />.</param>
        <param name="name">Der Name des <see cref="T:System.Threading.Mutex" />. Bei einem Wert von <see langword="null" /> ist das <see cref="T:System.Threading.Mutex" /> unbenannt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, sowie mit einer Zeichenfolge, die den Namen des Mutex darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `name` nicht `null` und `initiallyOwned` ist `true`, nur dann, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wurde, besitzt der aufrufende Thread das Mutex. Da es keine Mechanismen zum bestimmen ist, ob der benannte Systemmutex erstellt wurde, ist es besser, geben Sie `false` für `initiallyOwned` beim Aufrufen dieser Überladung des Konstruktors. Sie können die <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> Konstruktor, wenn Sie den anfänglichen Besitz ermitteln müssen.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt. Sie können mehrere erstellen <xref:System.Threading.Mutex> gleich darstellende – Objekte benannten Systemmutex.  
  
 Wenn der benannte Mutex mit zugriffssteuerungssicherheit bereits erstellt wurde, und der Aufrufer verfügt nicht über <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, wird eine Ausnahme ausgelöst. Öffnen Sie einen vorhandenen benannten Mutex, mit nur den Berechtigungen, die zum Synchronisieren von Threadaktivitäten erforderlich sind, finden Sie unter den <xref:System.Threading.Mutex.OpenExisting%2A> Methode.  
  
 Bei Angabe von `null` oder eine leere Zeichenfolge für `name`, ein lokaler Mutex erstellt wird, wie bei einem Aufruf der <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> Konstruktor. In diesem Fall `createdNew` ist immer `true`.  
  
 Da sie systemweit sind, kann benannte Mutexe verwendet werden, um die Ressourcenverwendung über Prozessgrenzen hinweg koordiniert.  
  
> [!NOTE]
>  Auf einem Server, auf der Terminaldienste ausgeführt wird, haben ein benannten Systemmutex zwei Ebenen der Sichtbarkeit. Wenn der Name mit dem Präfix beginnt "Global\\", der Mutex ist in allen Sitzungen des Terminalservers sichtbar. Wenn der Name mit dem Präfix beginnt "lokale\\", der Mutex ist nur in der Terminalserver-Sitzung sichtbar, in dem es erstellt wurde. In diesem Fall kann ein separater Mutex mit dem gleichen Namen in den einzelnen von den anderen Terminalserver-Sitzungen auf dem Server vorhanden sein. Wenn Sie ein Präfix nicht angeben, wenn Sie einen benannten Mutex erstellen, dauert das Präfix "lokale\\". Klicken Sie in einer Terminalserver-Sitzung zwei Mutexe, deren Namen sich nur durch ihre Präfixe unterscheiden, sind separate Mutexe, und beide sind für alle Prozesse sichtbar, in der Terminalserver-Sitzung. D. h. den Präfixnamen "Global\\" und "lokale\\" des Bereichs der Mutex-Namen, relativ zum Sitzungen des Terminalservers, nicht in Bezug auf Prozesse zu beschreiben.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 Das folgende Beispiel zeigt, wie ein benannter Mutex verwendet wird, um zu signalisieren zwischen Threads, die in zwei separaten Prozessen ausgeführt.  
  
 Dieses Programm wird aus mindestens zwei Befehlsfenster ausführen. Jeder Prozess erstellt eine <xref:System.Threading.Mutex> -Objekt, das das benannte Mutex darstellt `MyMutex`. Der benannte Mutex ist ein Objekt, dessen Lebensdauer wird durch die Lebensdauer der begrenzt, die <xref:System.Threading.Mutex> Objekte, die diese darstellen. Der benannte Mutex ist erstellt, wenn der erste Prozess erstellt seine <xref:System.Threading.Mutex> Objekt; in diesem Beispiel das benannte Mutex ist im Besitz des ersten Prozesses, der das Programm ausgeführt wird. Der benannte Mutex wird zerstört, wenn alle der <xref:System.Threading.Mutex> es darstellende – Objekte veröffentlicht wurden.  
  
 Die Konstruktorüberladung, die in diesem Beispiel verwendeten kann nicht den aufrufenden Thread erkennen, ob der anfängliche Besitz des benannten Mutex gewährt wurde. Sie sollten diesen Konstruktor nicht verwenden, um den anfänglichen Besitz anzufordern, es sei denn, Sie sicher sein können, dass der Thread den benannten Mutex erstellen.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <see langword="false" />.</param>
        <param name="name">Der Name des <see cref="T:System.Threading.Mutex" />. Bei einem Wert von <see langword="null" /> ist das <see cref="T:System.Threading.Mutex" /> unbenannt.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode einen booleschen Wert, der <see langword="true" /> ist, wenn ein lokaler Mutex erstellt wurde (d. h. wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn der angegebene benannte Systemmutex erstellt wurde. Der Wert ist <see langword="false" />, wenn der angegebene benannte Systemmutex bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, mit einer Zeichenfolge mit dem Namen des Mutex sowie mit einem booleschen Wert, der beim Beenden der Methode angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex gewährt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `name` nicht `null` und `initiallyOwned` ist `true`, besitzt den benannten Mutex nur, wenn der aufrufende Thread `createdNew` ist `true` nach dem Aufruf. Andernfalls kann der Thread das Mutex anfordern, durch Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt. Sie können mehrere erstellen <xref:System.Threading.Mutex> gleich darstellende – Objekte benannten Systemmutex.  
  
 Wenn der benannte Mutex mit zugriffssteuerungssicherheit bereits erstellt wurde, und der Aufrufer verfügt nicht über <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> Rechte, es wird eine Ausnahme ausgelöst. Öffnen Sie einen vorhandenen benannten Mutex, mit nur den Berechtigungen, die zum Synchronisieren von Threadaktivitäten erforderlich sind, finden Sie unter den <xref:System.Threading.Mutex.OpenExisting%2A> Methode.  
  
 Bei Angabe von `null` oder eine leere Zeichenfolge für `name`, ein lokaler Mutex erstellt wird, wie bei einem Aufruf der <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> Konstruktor. In diesem Fall `createdNew` ist immer `true`.  
  
 Da sie systemweit sind, kann benannte Mutexe verwendet werden, um die Ressourcenverwendung über Prozessgrenzen hinweg koordiniert.  
  
> [!NOTE]
>  Auf einem Server, auf der Terminaldienste ausgeführt wird, haben ein benannten Systemmutex zwei Ebenen der Sichtbarkeit. Wenn der Name mit dem Präfix beginnt "Global\\", der Mutex ist in allen Sitzungen des Terminalservers sichtbar. Wenn der Name mit dem Präfix beginnt "lokale\\", der Mutex ist nur in der Terminalserver-Sitzung sichtbar, in dem es erstellt wurde. In diesem Fall kann ein separater Mutex mit dem gleichen Namen in den einzelnen von den anderen Terminalserver-Sitzungen auf dem Server vorhanden sein. Wenn Sie ein Präfix nicht angeben, wenn Sie einen benannten Mutex erstellen, dauert das Präfix "lokale\\". Klicken Sie in einer Terminalserver-Sitzung zwei Mutexe, deren Namen sich nur durch ihre Präfixe unterscheiden, sind separate Mutexe, und beide sind für alle Prozesse sichtbar, in der Terminalserver-Sitzung. D. h. den Präfixnamen "Global\\" und "lokale\\" des Bereichs der Mutex-Namen, relativ zum Sitzungen des Terminalservers, nicht in Bezug auf Prozesse zu beschreiben.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein benannter Mutex verwendet wird, um zwischen Prozesse oder Threads zu signalisieren. Dieses Programm wird aus mindestens zwei Befehlsfenster ausführen. Jeder Prozess erstellt eine <xref:System.Threading.Mutex> -Objekt, das das benannte Mutex "MyMutex" darstellt. Der benannte Mutex ist ein Systemobjekt ist. In diesem Beispiel ist seine Lebensdauer an die Lebensdauer der begrenzt die <xref:System.Threading.Mutex> Objekte, die diese darstellen. Der benannte Mutex ist erstellt, wenn der erste Prozess den lokalen erstellt <xref:System.Threading.Mutex> Objekt aus, und zerstört, wenn alle der <xref:System.Threading.Mutex> es darstellende – Objekte veröffentlicht wurden. Der benannte Mutex ist der erste Prozess anfänglich Besitz. Der zweite und alle nachfolgenden Prozesse warten von früheren Prozesse, das benannte Mutex freizugeben.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <see langword="false" />.</param>
        <param name="name">Der Name des Systemmutex. Bei einem Wert von <see langword="null" /> ist das <see cref="T:System.Threading.Mutex" /> unbenannt.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode einen booleschen Wert, der <see langword="true" /> ist, wenn ein lokaler Mutex erstellt wurde (d. h. wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn der angegebene benannte Systemmutex erstellt wurde. Der Wert ist <see langword="false" />, wenn der angegebene benannte Systemmutex bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="mutexSecurity">Ein <see cref="T:System.Security.AccessControl.MutexSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf den benannten Systemmutex angewendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, mit einer Zeichenfolge mit dem Namen des Mutex, mit einer booleschen Variable, die beim Beenden der Methode angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex gewährt wurde, und mit der Zugriffssteuerungssicherheit, die auf den benannten Mutex angewendet werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `name` nicht `null` und `initiallyOwned` ist `true`, besitzt den benannten Mutex nur, wenn der aufrufende Thread `createdNew` ist `true` nach dem Aufruf. Andernfalls kann der Thread das Mutex anfordern, durch Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode.  
  
 Verwenden Sie diesen Konstruktor, Steuerung des Zugriffs auf einen benannten Systemmutex angewendet wird, bei der Erstellung wird verhindert, dass anderer Code die Steuerung des Mutex.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt. Sie können mehrere erstellen <xref:System.Threading.Mutex> gleich darstellende – Objekte benannten Systemmutex.  
  
 Wenn der benannte Systemmutex nicht vorhanden ist, wird es mit der angegebenen zugriffssteuerungssicherheit erstellt. Wenn der benannte Mutex ist vorhanden, wird die angegebene zugriffssteuerungssicherheit ignoriert.  
  
> [!NOTE]
>  Der Aufrufer hat vollständige Kontrolle über die neu erstellte <xref:System.Threading.Mutex> Objekt, selbst wenn `mutexSecurity` verweigert, oder ein Fehler auftritt, um einige über die Zugriffsrechte für den aktuellen Benutzer zu gewähren. Allerdings, wenn der aktuelle Benutzer versucht, erhalten einen anderen <xref:System.Threading.Mutex> Objekt zur Darstellung der gleiche Mutex, entweder mit dem Namen eines Konstruktors oder der <xref:System.Threading.Mutex.OpenExisting%2A> Methode, die Windows-zugriffssteuerungssicherheit angewendet wird.  
  
 Wenn der benannte Mutex mit zugriffssteuerungssicherheit bereits erstellt wurde, und der Aufrufer verfügt nicht über <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, wird eine Ausnahme ausgelöst. Öffnen Sie einen vorhandenen benannten Mutex, mit nur den Berechtigungen, die zum Synchronisieren von Threadaktivitäten erforderlich sind, finden Sie unter den <xref:System.Threading.Mutex.OpenExisting%2A> Methode.  
  
 Bei Angabe von `null` oder eine leere Zeichenfolge für `name`, ein lokaler Mutex erstellt wird, wie bei einem Aufruf der <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> Konstruktor. In diesem Fall `createdNew` ist immer `true`.  
  
 Da sie systemweit sind, kann benannte Mutexe verwendet werden, um die Ressourcenverwendung über Prozessgrenzen hinweg koordiniert.  
  
> [!NOTE]
>  Auf einem Server, auf der Terminaldienste ausgeführt wird, haben ein benannten Systemmutex zwei Ebenen der Sichtbarkeit. Wenn der Name mit dem Präfix beginnt "Global\\", der Mutex ist in allen Sitzungen des Terminalservers sichtbar. Wenn der Name mit dem Präfix beginnt "lokale\\", der Mutex ist nur in der Terminalserver-Sitzung sichtbar, in dem es erstellt wurde. In diesem Fall kann ein separater Mutex mit dem gleichen Namen in den einzelnen von den anderen Terminalserver-Sitzungen auf dem Server vorhanden sein. Wenn Sie ein Präfix nicht angeben, wenn Sie einen benannten Mutex erstellen, dauert das Präfix "lokale\\". Klicken Sie in einer Terminalserver-Sitzung zwei Mutexe, deren Namen sich nur durch ihre Präfixe unterscheiden, sind separate Mutexe, und beide sind für alle Prozesse sichtbar, in der Terminalserver-Sitzung. D. h. den Präfixnamen "Global\\" und "lokale\\" des Bereichs der Mutex-Namen, relativ zum Sitzungen des Terminalservers, nicht in Bezug auf Prozesse zu beschreiben.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten eines benannten Mutex mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Mutex zu testen.  
  
 Wenn das Mutex nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und die zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, den Mutex zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für den Mutex.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> -methodenüberladung, um den Mutex mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.  
  
 Nachdem die Berechtigungen geändert werden, wird der Mutex mit den erforderlichen Benutzerrechten zum eingeben, und geben Sie es geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird es mit der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.MutexSecurity" />-Objekt ab, das die Zugriffssteuerungssicherheit für den benannten Mutex darstellt.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.MutexSecurity" />-Objekt, das die Zugriffssteuerungssicherheit für den benannten Mutex darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Mutex.GetAccessControl%2A> -Methode verwendet die folgende Kombination von Flags (bitweise OR-Operation) für Berechtigungen suchen: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Der Benutzer <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> zum Aufrufen dieser Methode, und der Mutex geöffnet worden sein müssen mit <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten eines benannten Mutex mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Mutex zu testen.  
  
 Wenn das Mutex nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und die zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, den Mutex zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für den Mutex.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> -methodenüberladung, um den Mutex zu öffnen, mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen, die mit der <xref:System.Threading.Mutex.GetAccessControl%2A> und <xref:System.Threading.Mutex.SetAccessControl%2A> Methoden.  
  
 Nachdem die Berechtigungen geändert werden, wird der Mutex mit den erforderlichen Benutzerrechten zum eingeben, und geben Sie es geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird es mit der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle <see cref="T:System.Threading.Mutex" />-Objekt stellt einen benannten Systemmutex dar. Der Benutzer verfügt jedoch nicht über <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
- oder -  
Das aktuelle <see cref="T:System.Threading.Mutex" />-Objekt stellt einen benannten Systemmutex dar und wurde nicht mit <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> geöffnet.</exception>
        <exception cref="T:System.NotSupportedException">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet einen bestimmten benannten Mutex, wenn er bereits vorhanden ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemmutex.</param>
        <summary>Öffnet den bestimmten benannten Mutex, wenn er bereits vorhanden ist.</summary>
        <returns>Ein Objekt, das den benannten Systemmutex darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Mutex.OpenExisting%2A> Methode versucht werden, öffnen Sie den angegebenen benannten Systemmutex. Wenn das Systemmutex nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System-Objekt. Um Systemmutex erstellen, wenn es nicht bereits vorhanden ist, gehen die <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` ist nicht unbedingt zurück, die gleiche <xref:System.Threading.Mutex> Objekt, auch wenn die Objekte, die zurückgegeben werden, die denselben benannten Systemmutex darstellen.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> -methodenüberladung, und geben <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Rechte, die mithilfe einer bitweise OR-Operation kombiniert.  
  
 Angeben der <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread wartet auf den Mutex, und geben Sie die <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread zum Aufrufen der <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode.  
  
 Diese Methode fordert nicht Besitz des Mutex.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten eines benannten Mutex mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Mutex zu testen.  
  
 Wenn das Mutex nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und die zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, den Mutex zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für den Mutex.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> -methodenüberladung, um den Mutex mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.  
  
 Nachdem die Berechtigungen geändert werden, wird der Mutex mit den erforderlichen Benutzerrechten zum eingeben, und geben Sie es geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird es mit der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Der benannte Mutex ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemmutex.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <summary>Öffnet den angegebenen benannten Mutex, wenn er bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</summary>
        <returns>Ein Objekt, das den benannten Systemmutex darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `rights` Parameter enthalten muss der <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> Flag zum Warten auf den Mutex, Threads zu ermöglichen und die <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flag, um Threads aufrufen, können die <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode.  
  
 Die <xref:System.Threading.Mutex.OpenExisting%2A> Methode versucht, einen vorhandenen benannten Mutex zu öffnen. Wenn das Systemmutex nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System-Objekt. Um Systemmutex erstellen, wenn es nicht bereits vorhanden ist, gehen die <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` ist nicht unbedingt zurück, die gleiche <xref:System.Threading.Mutex> Objekt, auch wenn die Objekte, die zurückgegeben werden, die denselben benannten Systemmutex darstellen.  
  
 Diese Methode fordert nicht Besitz des Mutex.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten eines benannten Mutex mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Mutex zu testen.  
  
 Wenn das Mutex nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und die zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, den Mutex zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für den Mutex.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> -methodenüberladung, um den Mutex mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.  
  
 Nachdem die Berechtigungen geändert werden, wird der Mutex mit den erforderlichen Benutzerrechten zum eingeben, und geben Sie es geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird es mit der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Der benannte Mutex ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Mutex ist vorhanden aber der Benutzer verfügt nicht über den gewünschten Sicherheitszugriff.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das <see cref="T:System.Threading.Mutex" /> einmal frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Mal, wenn ein Thread einen Mutex erhält (z. B. durch Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode), anschließend aufgerufen werden muss <xref:System.Threading.Mutex.ReleaseMutex%2A> zum abgeben von Besitz des Mutex, und Entsperren von anderen Threads, die versuchen, den Besitz des Mutex zu erhalten. Schlägt der Versuch zum Abrufen der Besitz des Mutex (z. B. wenn ein Aufruf von der <xref:System.Threading.WaitHandle.WaitOne%2A> -Methode mit einer `millisecondsTimeout` oder ein `timeout` gibt Parameter `false` , da das Zeitlimit der Anforderung), der Thread aufrufen, sollte nicht <xref:System.Threading.Mutex.ReleaseMutex%2A>, In diesem Fall sollte der Thread auch nicht zulässig sein Zugriff auf die Ressource, die durch den Mutex geschützt wird, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Ein Thread, der einen Mutex besitzt kann denselben Mutex in Funktionsaufrufen wiederholte Wait angeben, ohne dessen Ausführung zu blockieren. Die Anzahl der Aufrufe wird von der common Language Runtime gespeichert. Der Thread aufrufen, muss <xref:System.Threading.Mutex.ReleaseMutex%2A> die gleiche Anzahl an, wie oft, um den Besitz des Mutex freizugeben.  
  
 Wenn ein Thread beendet wird, während einen Mutex besitzt, wird der Mutex als abgebrochener Mutex bezeichnet. Der Status des Mutex auf signalisiert festgelegt ist, und der nächste wartenden Thread Ruft die Inhaberschaft ab. Wenn niemand den Mutex besitzt, wird der Status des Mutex signalisiert. Ab Version 2.0 von .NET Framework ein <xref:System.Threading.AbandonedMutexException> wird ausgelöst, in der nächsten Thread, der den Mutex verwendet. Vor Version 2.0 von .NET Framework wurde keine Ausnahme ausgelöst.  
  
> [!CAUTION]
>  Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code. Wenn ein Thread beendet, ohne das Mutex freizugeben, möglicherweise die Datenstrukturen, die vom Mutex geschützte nicht in einem konsistenten Zustand. Der nächste Thread, der Besitz des Mutex anfordert, kann diese Ausnahme behandeln und den Vorgang fortsetzen, wenn die Integrität der Datenstruktur überprüft werden kann.  
  
 Wenn es sich um einen systemweiten Mutex handelt, kann ein abgebrochener Mutex darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z.B. über den Windows Task-Manager).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie eine lokale <xref:System.Threading.Mutex> Objekt wird zum Synchronisieren des Zugriffs auf eine geschützte Ressource verwendet. Der Thread, der den Mutex erstellt besitzt es zunächst nicht. Die <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode wird verwendet, um das Mutex freizugeben, wenn es nicht mehr benötigt wird.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Der aufrufende Thread besitzt den Mutex nicht.</exception>
        <exception cref="T:System.ObjectDisposedException">Die aktuelle Instanz wurde bereits verworfen.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">Ein <see cref="T:System.Security.AccessControl.MutexSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf den benannten Systemmutex angewendet werden soll.</param>
        <summary>Legt die Zugriffssteuerungssicherheit für einen benannten Systemmutex fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> Rechte zum Aufrufen dieser Methode, und der Mutex geöffnet worden sein müssen mit <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten eines benannten Mutex mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Mutex zu testen.  
  
 Wenn das Mutex nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und die zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, den Mutex zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für den Mutex.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> -methodenüberladung, um den Mutex zu öffnen, mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen, die mit der <xref:System.Threading.Mutex.GetAccessControl%2A> und <xref:System.Threading.Mutex.SetAccessControl%2A> Methoden.  
  
 Nachdem die Berechtigungen geändert werden, wird der Mutex mit den erforderlichen Benutzerrechten zum eingeben, und geben Sie es geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird es mit der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mutexSecurity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
- oder -  
Der Mutex wurde nicht mit <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> geöffnet.</exception>
        <exception cref="T:System.SystemException">Das aktuelle <see cref="T:System.Threading.Mutex" />-Objekt stellt keinen benannten Systemmutex dar.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet einen bestimmten benannten Mutex, wenn er bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemmutex.</param>
        <param name="result">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Mutex" />-Objekt, das das benannte Mutex darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Öffnet den bestimmten benannten Mutex, wenn er bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn der benannte Mutex erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der benannte Mutex nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Um Systemmutex erstellen, wenn es nicht bereits vorhanden ist, gehen die <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Wenn Sie unsicher sind, ob ein benannter Mutex vorhanden ist, verwenden Sie die Überladung dieser Methode anstelle von der <xref:System.Threading.Mutex.OpenExisting%28System.String%29> methodenüberladung, die eine Ausnahme auslöst, wenn das Mutex nicht vorhanden ist.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` ist nicht unbedingt zurück, die gleiche <xref:System.Threading.Mutex> Objekt, auch wenn die Objekte, die zurückgegeben werden, die denselben benannten Systemmutex darstellen.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> -methodenüberladung, und geben <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Rechte, die mithilfe einer bitweise OR-Operation kombiniert. Angeben der <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread wartet auf den Mutex, und geben Sie die <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread zum Aufrufen der <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode.  
  
 Diese Methode fordert nicht Besitz des Mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemmutex.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <param name="result">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Mutex" />-Objekt, das das benannte Mutex darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Öffnet den angegebenen benannten Mutex, wenn er bereits mit dem gewünschten Sicherheitszugriff vorhanden ist und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn der benannte Mutex erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der benannte Mutex nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Um Systemmutex erstellen, wenn es nicht bereits vorhanden ist, gehen die <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Wenn Sie unsicher sind, ob ein benannter Mutex vorhanden ist, verwenden Sie die Überladung dieser Methode anstelle von der <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> methodenüberladung, die eine Ausnahme auslöst, wenn das Mutex nicht vorhanden ist.  
  
 Die `rights` Parameter enthalten muss der <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> Flag zum Warten auf den Mutex, Threads zu ermöglichen und die <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flag, um Threads aufrufen, können die <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` ist nicht unbedingt zurück, die gleiche <xref:System.Threading.Mutex> Objekt, auch wenn die Objekte, die zurückgegeben werden, die denselben benannten Systemmutex darstellen.  
  
 Diese Methode fordert nicht Besitz des Mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
  </Members>
</Type>