<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e1a0b418a2e2951e4941af0cc78868ae967612fa" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83544352" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="dd2b5-101">Ein Synchronisierungsprimitiver, der auch für die prozessübergreifende Synchronisierung verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-101">A synchronization primitive that can also be used for interprocess synchronization.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-102">Wenn mindestens zwei Threads gleichzeitig auf eine freigegebene Ressource zugreifen müssen, benötigt das System einen Synchronisierungs Mechanismus, um sicherzustellen, dass die Ressource jeweils nur von einem Thread verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-102">When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</span></span> <span data-ttu-id="dd2b5-103"><xref:System.Threading.Mutex> ist eine Synchronisierungs primitive, die exklusiven Zugriff auf die freigegebene Ressource nur auf einen Thread gewährt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-103"><xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</span></span> <span data-ttu-id="dd2b5-104">Wenn ein Thread einen Mutex erhält, wird der zweite Thread, der diesen Mutex erwerben möchte, angehalten, bis der erste Thread den Mutex freigibt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-104">If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="dd2b5-105">Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-105">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="dd2b5-106">Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-106">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="dd2b5-107">Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-107">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="dd2b5-108">Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dd2b5-108">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="dd2b5-109">Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-109">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="dd2b5-110">Sie können die <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>-Methode verwenden, um den Besitz eines Mutex anzufordern.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-110">You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method to request ownership of a mutex.</span></span> <span data-ttu-id="dd2b5-111">Der aufrufende Thread wird blockiert, bis eine der folgenden Aktionen auftritt:</span><span class="sxs-lookup"><span data-stu-id="dd2b5-111">The calling thread blocks until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="dd2b5-112">Der Mutex wird signalisiert, um anzugeben, dass er nicht im Besitz ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-112">The mutex is signaled to indicate that it is not owned.</span></span> <span data-ttu-id="dd2b5-113">In diesem Fall gibt die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode `true`zurück, und der aufrufenden Thread übernimmt den Besitz des Mutex und greift auf die durch den Mutex geschützte Ressource zu.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-113">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</span></span> <span data-ttu-id="dd2b5-114">Wenn der Zugriff auf die Ressource abgeschlossen ist, muss der Thread die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufrufen, um den Besitz des Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-114">When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex.</span></span> <span data-ttu-id="dd2b5-115">Dieses Muster wird im ersten Beispiel im Abschnitt "Beispiele" veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-115">The first example in the Examples section illustrates this pattern.</span></span>  
  
-   <span data-ttu-id="dd2b5-116">Das Timeout Intervall, das im Aufruf einer <xref:System.Threading.WaitHandle.WaitOne%2A> Methode mit einem `millisecondsTimeout`-oder `timeout`-Parameter angegeben wurde, ist abgelaufen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-116">The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed.</span></span> <span data-ttu-id="dd2b5-117">In diesem Fall gibt die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode `false`zurück, und der aufrufenden Thread versucht nicht, den Besitz des Mutex zu erwerben.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-117">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex.</span></span> <span data-ttu-id="dd2b5-118">In diesem Fall sollten Sie den Code so strukturieren, dass der Zugriff auf die Ressource, die durch den Mutex geschützt ist, dem aufrufenden Thread verweigert wird.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-118">In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</span></span> <span data-ttu-id="dd2b5-119">Da der Thread niemals den Besitz des Mutex erlangt hat, darf er die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode nicht aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-119">Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span> <span data-ttu-id="dd2b5-120">Das zweite Beispiel im Abschnitt "Beispiele" veranschaulicht dieses Muster.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-120">The second example in the Examples section illustrates this pattern.</span></span>  
  
 <span data-ttu-id="dd2b5-121">Die <xref:System.Threading.Mutex>-Klasse erzwingt die Thread Identität, sodass ein Mutex nur von dem Thread freigegeben werden kann, der ihn abgerufen hat.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-121">The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</span></span> <span data-ttu-id="dd2b5-122">Im Gegensatz dazu erzwingt die <xref:System.Threading.Semaphore>-Klasse keine Thread Identität.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-122">By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity.</span></span> <span data-ttu-id="dd2b5-123">Ein Mutex kann auch über Anwendungs Domänen Grenzen hinweg übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-123">A mutex can also be passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="dd2b5-124">Der Thread, der einen Mutex besitzt, kann denselben Mutex bei wiederholten Aufrufen an <xref:System.Threading.WaitHandle.WaitOne%2A> anfordern, ohne seine Ausführung zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-124">The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution.</span></span> <span data-ttu-id="dd2b5-125">Der Thread muss jedoch die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode gleich oft aufzurufen, um den Besitz des Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-125">However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-126">Da die <xref:System.Threading.Mutex> Klasse von <xref:System.Threading.WaitHandle>erbt, können Sie auch die statischen <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> und <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> Methoden aufrufen, um den Zugriff auf eine geschützte Ressource zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-126">Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods to synchronize access to a protected resource.</span></span>  
  
 <span data-ttu-id="dd2b5-127">Wenn ein Thread beendet wird, während er ein Mutex besitzt, wird der Mutex als abgebrochen bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-127">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="dd2b5-128">Der Mutex-Zustand wird auf "signalisiert" festgelegt, und der nächste wartende Thread erhält den Besitz.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-128">The state of the mutex is set to signaled, and the next waiting thread gets ownership.</span></span> <span data-ttu-id="dd2b5-129">Ab Version 2,0 des .NET Framework wird ein <xref:System.Threading.AbandonedMutexException> im nächsten Thread ausgelöst, der den abgebrochenen Mutex abruft.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-129">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex.</span></span> <span data-ttu-id="dd2b5-130">Vor Version 2,0 des .NET Framework wurde keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-130">Before version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="dd2b5-131">Ein abgebrochener Mutex weist häufig auf einen schwerwiegenden Fehler im Code hin.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-131">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="dd2b5-132">Wenn ein Thread beendet wird, ohne den Mutex freizugeben, befinden sich die vom Mutex geschützten Datenstrukturen möglicherweise nicht in einem konsistenten Zustand.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-132">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="dd2b5-133">Der nächste Thread, der den Besitz des Mutex anfordert, kann diese Ausnahme behandeln und fortfahren, wenn die Integrität der Datenstrukturen überprüft werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-133">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="dd2b5-134">Wenn es sich um einen systemweiten Mutex handelt, kann ein abgebrochener Mutex darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z.B. über den Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="dd2b5-134">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
 <span data-ttu-id="dd2b5-135">Mutexes gibt zwei Typen: lokale Mutexen, die unbenannt sind und benannte systemmutexen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-135">Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</span></span> <span data-ttu-id="dd2b5-136">Ein lokaler Mutex ist nur innerhalb des Prozesses vorhanden.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-136">A local mutex exists only within your process.</span></span> <span data-ttu-id="dd2b5-137">Sie kann von jedem Thread in Ihrem Prozess verwendet werden, der einen Verweis auf das <xref:System.Threading.Mutex> Objekt enthält, das den Mutex darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-137">It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex.</span></span> <span data-ttu-id="dd2b5-138">Jedes unbenannte <xref:System.Threading.Mutex>-Objekt stellt einen separaten lokalen Mutex dar.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-138">Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-139">Benannte systemmutexen sind im gesamten Betriebssystem sichtbar und können verwendet werden, um die Aktivitäten von Prozessen zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-139">Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="dd2b5-140">Sie können ein <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt, mithilfe eines Konstruktors erstellen, der einen Namen akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-140">You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name.</span></span> <span data-ttu-id="dd2b5-141">Das Betriebssystem Objekt kann gleichzeitig erstellt werden, oder es kann vor der Erstellung des <xref:System.Threading.Mutex> Objekts vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-141">The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object.</span></span> <span data-ttu-id="dd2b5-142">Sie können mehrere <xref:System.Threading.Mutex>-Objekte erstellen, die denselben benannten Systemmutex darstellen, und Sie können mithilfe der <xref:System.Threading.Mutex.OpenExisting%2A>-Methode einen vorhandenen benannten Systemmutex öffnen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-142">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd2b5-143">Auf einem Server, auf dem Terminal Dienste ausgeführt werden, kann ein benannter Systemmutex zwei Ebenen der Sichtbarkeit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-143">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="dd2b5-144">Wenn der Name mit dem Präfix "Global\\" beginnt, wird der Mutex in allen Terminal Server Sitzungen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-144">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="dd2b5-145">Wenn der Name mit dem Präfix "local\\" beginnt, ist der Mutex nur in der Terminal Server Sitzung sichtbar, in der er erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-145">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="dd2b5-146">In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder der anderen Terminal Server Sitzungen auf dem Server vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-146">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="dd2b5-147">Wenn Sie beim Erstellen eines benannten Mutex kein Präfix angeben, wird das Präfix "local\\" benötigt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-147">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="dd2b5-148">Innerhalb einer Terminal Server Sitzung sind zwei Mutexen, deren Namen sich nur durch Ihre Präfixe unterscheiden, separate Mutexen, und beide sind für alle Prozesse in der Terminal Server Sitzung sichtbar.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-148">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="dd2b5-149">Das heißt, die Präfix Namen "Global\\" und "local\\" beschreiben den Bereich des Mutex-namens in Bezug auf Terminal Server Sitzungen, nicht relativ zu Prozessen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-149">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 <span data-ttu-id="dd2b5-150">Dieses Beispiel zeigt, wie ein lokales <xref:System.Threading.Mutex> Objekt verwendet wird, um den Zugriff auf eine geschützte Ressource zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-150">This example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="dd2b5-151">Da jeder aufrufende Thread blockiert wird, bis er den Besitz des Mutex übernimmt, muss er die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufrufen, um den Besitz des Threads freizugeben.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-151">Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the thread.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="dd2b5-152">Im folgenden Beispiel ruft jeder Thread die <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29>-Methode auf, um den Mutex abzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-152">In the following example, each thread calls the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> method to acquire the mutex.</span></span> <span data-ttu-id="dd2b5-153">Wenn das Timeout Intervall abläuft, gibt die Methode `false`zurück, und der Thread erhält weder den Mutex noch den Zugriff auf die Ressource, die der Mutex schützt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-153">If the time-out interval elapses, the method returns `false`, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</span></span> <span data-ttu-id="dd2b5-154">Die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode wird nur von dem Thread aufgerufen, der den Mutex abruft.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-154">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is called only by the thread that acquires the mutex.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="dd2b5-155">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-155">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="dd2b5-156">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="dd2b5-156">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="dd2b5-157">Mutexe</span><span class="sxs-lookup"><span data-stu-id="dd2b5-157">Mutexes</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd2b5-158">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-158">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd2b5-159">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit Standardeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-159">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-160">Das Aufrufen dieser Konstruktorüberladung entspricht dem Aufrufen der <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>-Konstruktorüberladung und der Angabe `false` für den anfänglichen Besitz des Mutex.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-160">Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex.</span></span> <span data-ttu-id="dd2b5-161">Das heißt, der aufrufenden Thread ist nicht der Besitzer des Mutex.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-161">That is, the calling thread does not own the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd2b5-162">Im folgenden Codebeispiel wird gezeigt, wie ein lokales <xref:System.Threading.Mutex> Objekt verwendet wird, um den Zugriff auf eine geschützte Ressource zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-162">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="dd2b5-163">Der Thread, der den Mutex erstellt, ist nicht anfänglich.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-163">The thread that creates the mutex does not own it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="dd2b5-164">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="dd2b5-164">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="dd2b5-165">Mutexe</span><span class="sxs-lookup"><span data-stu-id="dd2b5-165">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="dd2b5-166"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des Mutex zuzuweisen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-166"><see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="dd2b5-167">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-167">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="dd2b5-168">Im folgenden Codebeispiel wird gezeigt, wie ein lokales <xref:System.Threading.Mutex> Objekt verwendet wird, um den Zugriff auf eine geschützte Ressource zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-168">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="dd2b5-169">Der Thread, der die <xref:System.Threading.Mutex> erstellt, ist ursprünglich der Besitzer.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-169">The thread that creates the <xref:System.Threading.Mutex> owns it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="dd2b5-170">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="dd2b5-170">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="dd2b5-171">Mutexe</span><span class="sxs-lookup"><span data-stu-id="dd2b5-171">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="dd2b5-172"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-172"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="dd2b5-173">Der Name des <see cref="T:System.Threading.Mutex" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-173">The name of the <see cref="T:System.Threading.Mutex" />.</span></span> <span data-ttu-id="dd2b5-174">Bei einem Wert von <see langword="null" /> ist das <see cref="T:System.Threading.Mutex" /> unbenannt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-174">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <summary><span data-ttu-id="dd2b5-175">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, sowie mit einer Zeichenfolge, die den Namen des Mutex darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-175">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-176">Wenn `name` nicht `null` und `initiallyOwned` `true`ist, besitzt der aufrufende Thread den Mutex nur dann, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-176">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</span></span> <span data-ttu-id="dd2b5-177">Da es keinen Mechanismus gibt, um zu bestimmen, ob der benannte Systemmutex erstellt wurde, ist es besser, `false` für `initiallyOwned` anzugeben, wenn diese Konstruktorüberladung aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-177">Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload.</span></span> <span data-ttu-id="dd2b5-178">Sie können den <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29>-Konstruktor verwenden, wenn Sie den anfänglichen Besitz bestimmen müssen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-178">You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.</span></span>  
  
 <span data-ttu-id="dd2b5-179">Dieser Konstruktor initialisiert ein <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-179">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="dd2b5-180">Sie können mehrere <xref:System.Threading.Mutex> Objekte erstellen, die denselben benannten Systemmutex darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-180">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-181">Wenn der benannte Mutex bereits mit der Zugriffs Steuerungs Sicherheit erstellt wurde und der Aufrufer nicht über <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>verfügt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-181">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="dd2b5-182">Informationen zum Öffnen eines vorhandenen benannten Mutex mit nur den Berechtigungen, die für die Synchronisierung von Thread Aktivitäten erforderlich sind, finden Sie unter <xref:System.Threading.Mutex.OpenExisting%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-182">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="dd2b5-183">Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokaler Mutex erstellt, als ob Sie den <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>-Konstruktor aufgerufen hätten.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-183">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="dd2b5-184">In diesem Fall wird `createdNew` immer `true`.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-184">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="dd2b5-185">Da Sie systemweit sind, können benannte Mutexen verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-185">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd2b5-186">Auf einem Server, auf dem Terminal Dienste ausgeführt werden, kann ein benannter Systemmutex zwei Ebenen der Sichtbarkeit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-186">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="dd2b5-187">Wenn der Name mit dem Präfix "Global\\" beginnt, wird der Mutex in allen Terminal Server Sitzungen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-187">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="dd2b5-188">Wenn der Name mit dem Präfix "local\\" beginnt, ist der Mutex nur in der Terminal Server Sitzung sichtbar, in der er erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-188">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="dd2b5-189">In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder der anderen Terminal Server Sitzungen auf dem Server vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-189">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="dd2b5-190">Wenn Sie beim Erstellen eines benannten Mutex kein Präfix angeben, wird das Präfix "local\\" benötigt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-190">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="dd2b5-191">Innerhalb einer Terminal Server Sitzung sind zwei Mutexen, deren Namen sich nur durch Ihre Präfixe unterscheiden, separate Mutexen, und beide sind für alle Prozesse in der Terminal Server Sitzung sichtbar.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-191">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="dd2b5-192">Das heißt, die Präfix Namen "Global\\" und "local\\" beschreiben den Bereich des Mutex-namens in Bezug auf Terminal Server Sitzungen, nicht relativ zu Prozessen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-192">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 <span data-ttu-id="dd2b5-193">Das folgende Beispiel zeigt, wie ein benannter Mutex verwendet wird, um zwischen Threads zu signalisieren, die in zwei separaten Prozessen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-193">The following example shows how a named mutex is used to signal between threads running in two separate processes.</span></span>  
  
 <span data-ttu-id="dd2b5-194">Führen Sie dieses Programm von mindestens zwei Befehls Fenstern aus.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-194">Run this program from two or more command windows.</span></span> <span data-ttu-id="dd2b5-195">Jeder Prozess erstellt ein <xref:System.Threading.Mutex> Objekt, das den benannten Mutex-`MyMutex`darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-195">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex `MyMutex`.</span></span> <span data-ttu-id="dd2b5-196">Der benannte Mutex ist ein Systemobjekt, dessen Lebensdauer von der Lebensdauer der <xref:System.Threading.Mutex> Objekte begrenzt ist, die es darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-196">The named mutex is a system object whose lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="dd2b5-197">Der benannte Mutex wird erstellt, wenn der erste Prozess das <xref:System.Threading.Mutex>-Objekt erstellt. in diesem Beispiel befindet sich der benannte Mutex im Besitz des ersten Prozesses, in dem das Programm ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-197">The named mutex is created when the first process creates its <xref:System.Threading.Mutex> object; in this example, the named mutex is owned by the first process that runs the program.</span></span> <span data-ttu-id="dd2b5-198">Der benannte Mutex wird zerstört, wenn alle <xref:System.Threading.Mutex> Objekte, die ihn darstellen, freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-198">The named mutex is destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span>  
  
 <span data-ttu-id="dd2b5-199">Die in diesem Beispiel verwendete Konstruktorüberladung kann dem aufrufenden Thread nicht mitteilen, ob der anfängliche Besitz des benannten Mutex gewährt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-199">The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</span></span> <span data-ttu-id="dd2b5-200">Sie sollten diesen Konstruktor nicht verwenden, um den anfänglichen Besitz anzufordern, es sei denn, Sie können sicher sein, dass der Thread den benannten Mutex erstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-200">You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="dd2b5-201">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-201">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="dd2b5-202">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-202">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="dd2b5-203">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-203">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd2b5-204"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-204"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="dd2b5-205">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="dd2b5-205">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="dd2b5-206">Mutexe</span><span class="sxs-lookup"><span data-stu-id="dd2b5-206">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="dd2b5-207"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-207"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="dd2b5-208">Der Name des <see cref="T:System.Threading.Mutex" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-208">The name of the <see cref="T:System.Threading.Mutex" />.</span></span> <span data-ttu-id="dd2b5-209">Bei einem Wert von <see langword="null" /> ist das <see cref="T:System.Threading.Mutex" /> unbenannt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-209">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <param name="createdNew"><span data-ttu-id="dd2b5-210">Enthält nach dem Beenden dieser Methode einen booleschen Wert, der <see langword="true" /> ist, wenn ein lokaler Mutex erstellt wurde (d. h. wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn der angegebene benannte Systemmutex erstellt wurde. Der Wert ist <see langword="false" />, wenn der angegebene benannte Systemmutex bereits vorhanden war.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-210">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="dd2b5-211">Dieser Parameter wird nicht initialisiert übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-211">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="dd2b5-212">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, mit einer Zeichenfolge mit dem Namen des Mutex sowie mit einem booleschen Wert, der beim Beenden der Methode angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex gewährt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-212">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-213">Wenn `name` nicht `null` und `initiallyOwned` `true`ist, besitzt der aufrufende Thread nur dann den benannten Mutex, wenn `createdNew` nach dem Aufruf `true` wird.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-213">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="dd2b5-214">Andernfalls kann der Thread den Mutex anfordern, indem er die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-214">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="dd2b5-215">Dieser Konstruktor initialisiert ein <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-215">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="dd2b5-216">Sie können mehrere <xref:System.Threading.Mutex> Objekte erstellen, die denselben benannten Systemmutex darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-216">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-217">Wenn der benannte Mutex bereits mit der Zugriffs Steuerungs Sicherheit erstellt wurde und der Aufrufer nicht über <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> Rechte verfügt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-217">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> rights, an exception is thrown.</span></span> <span data-ttu-id="dd2b5-218">Informationen zum Öffnen eines vorhandenen benannten Mutex mit nur den Berechtigungen, die für die Synchronisierung von Thread Aktivitäten erforderlich sind, finden Sie unter <xref:System.Threading.Mutex.OpenExisting%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-218">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="dd2b5-219">Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokaler Mutex erstellt, als ob Sie den <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>-Konstruktor aufgerufen hätten.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-219">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="dd2b5-220">In diesem Fall wird `createdNew` immer `true`.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-220">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="dd2b5-221">Da Sie systemweit sind, können benannte Mutexen verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-221">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd2b5-222">Auf einem Server, auf dem Terminal Dienste ausgeführt werden, kann ein benannter Systemmutex zwei Ebenen der Sichtbarkeit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-222">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="dd2b5-223">Wenn der Name mit dem Präfix "Global\\" beginnt, wird der Mutex in allen Terminal Server Sitzungen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-223">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="dd2b5-224">Wenn der Name mit dem Präfix "local\\" beginnt, ist der Mutex nur in der Terminal Server Sitzung sichtbar, in der er erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-224">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="dd2b5-225">In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder der anderen Terminal Server Sitzungen auf dem Server vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-225">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="dd2b5-226">Wenn Sie beim Erstellen eines benannten Mutex kein Präfix angeben, wird das Präfix "local\\" benötigt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-226">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="dd2b5-227">Innerhalb einer Terminal Server Sitzung sind zwei Mutexen, deren Namen sich nur durch Ihre Präfixe unterscheiden, separate Mutexen, und beide sind für alle Prozesse in der Terminal Server Sitzung sichtbar.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-227">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="dd2b5-228">Das heißt, die Präfix Namen "Global\\" und "local\\" beschreiben den Bereich des Mutex-namens in Bezug auf Terminal Server Sitzungen, nicht relativ zu Prozessen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-228">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 <span data-ttu-id="dd2b5-229">Das folgende Codebeispiel zeigt, wie ein benannter Mutex verwendet wird, um zwischen Prozessen oder Threads zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-229">The following code example shows how a named mutex is used to signal between processes or threads.</span></span> <span data-ttu-id="dd2b5-230">Führen Sie dieses Programm von mindestens zwei Befehls Fenstern aus.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-230">Run this program from two or more command windows.</span></span> <span data-ttu-id="dd2b5-231">Jeder Prozess erstellt ein <xref:System.Threading.Mutex> Objekt, das den benannten Mutex "MyMutex" darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-231">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex "MyMutex".</span></span> <span data-ttu-id="dd2b5-232">Der benannte Mutex ist ein Systemobjekt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-232">The named mutex is a system object.</span></span> <span data-ttu-id="dd2b5-233">In diesem Beispiel wird seine Lebensdauer von der Lebensdauer der <xref:System.Threading.Mutex> Objekte begrenzt, die es darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-233">In this example, its lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="dd2b5-234">Der benannte Mutex wird erstellt, wenn der erste Prozess das lokale <xref:System.Threading.Mutex> Objekt erstellt und zerstört wird, wenn alle <xref:System.Threading.Mutex> Objekte, die es darstellen, freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-234">The named mutex is created when the first process creates its local <xref:System.Threading.Mutex> object, and destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span> <span data-ttu-id="dd2b5-235">Der benannte Mutex gehört anfänglich dem ersten Prozess an.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-235">The named mutex is initially owned by the first process.</span></span> <span data-ttu-id="dd2b5-236">Der zweite Prozess und alle nachfolgenden Prozesse warten darauf, dass frühere Prozesse den benannten Mutex freigeben.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-236">The second process and any subsequent processes wait for earlier processes to release the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="dd2b5-237">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-237">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="dd2b5-238">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-238">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="dd2b5-239">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-239">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd2b5-240"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-240"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="dd2b5-241">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="dd2b5-241">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="dd2b5-242">Mutexe</span><span class="sxs-lookup"><span data-stu-id="dd2b5-242">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean, mutexSecurity As MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="dd2b5-243"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-243"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="dd2b5-244">Der Name des Systemmutex.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-244">The name of the system mutex.</span></span> <span data-ttu-id="dd2b5-245">Bei einem Wert von <see langword="null" /> ist das <see cref="T:System.Threading.Mutex" /> unbenannt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-245">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <param name="createdNew"><span data-ttu-id="dd2b5-246">Enthält nach dem Beenden dieser Methode einen booleschen Wert, der <see langword="true" /> ist, wenn ein lokaler Mutex erstellt wurde (d. h. wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn der angegebene benannte Systemmutex erstellt wurde. Der Wert ist <see langword="false" />, wenn der angegebene benannte Systemmutex bereits vorhanden war.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-246">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="dd2b5-247">Dieser Parameter wird nicht initialisiert übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-247">This parameter is passed uninitialized.</span></span></param>
        <param name="mutexSecurity"><span data-ttu-id="dd2b5-248">Ein <see cref="T:System.Security.AccessControl.MutexSecurity" /> -Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf den benannten Systemmutex angewendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-248">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="dd2b5-249">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, mit einer Zeichenfolge mit dem Namen des Mutex, mit einer booleschen Variable, die beim Beenden der Methode angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex gewährt wurde, und mit der Zugriffssteuerungssicherheit, die auf den benannten Mutex angewendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-249">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-250">Wenn `name` nicht `null` und `initiallyOwned` `true`ist, besitzt der aufrufende Thread nur dann den benannten Mutex, wenn `createdNew` nach dem Aufruf `true` wird.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-250">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="dd2b5-251">Andernfalls kann der Thread den Mutex anfordern, indem er die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-251">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="dd2b5-252">Verwenden Sie diesen Konstruktor, um die Zugriffs Steuerungs Sicherheit auf einen benannten Systemmutex anzuwenden, wenn er erstellt wird. Dadurch wird verhindert, dass der Mutex von anderen Code gesteuert wird.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-252">Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-253">Dieser Konstruktor initialisiert ein <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-253">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="dd2b5-254">Sie können mehrere <xref:System.Threading.Mutex> Objekte erstellen, die denselben benannten Systemmutex darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-254">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-255">Wenn das benannte Systemmutex nicht vorhanden ist, wird es mit der angegebenen Zugriffs Steuerungs Sicherheit erstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-255">If the named system mutex does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="dd2b5-256">Wenn der benannte Mutex vorhanden ist, wird die angegebene Zugriffs Steuerungs Sicherheit ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-256">If the named mutex exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd2b5-257">Der Aufrufer hat die vollständige Kontrolle über das neu erstellte <xref:System.Threading.Mutex> Objekt, auch wenn `mutexSecurity` dem aktuellen Benutzer einige Zugriffsrechte verweigert oder ihm nicht zuweist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-257">The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="dd2b5-258">Wenn der aktuelle Benutzer jedoch versucht, ein anderes <xref:System.Threading.Mutex> Objekt zu erhalten, das denselben benannten Mutex darstellt, wobei entweder ein Konstruktor oder die Methode <xref:System.Threading.Mutex.OpenExisting%2A> verwendet wird, wird die Windows-Zugriffs Steuerungs Sicherheit angewendet.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-258">However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="dd2b5-259">Wenn der benannte Mutex bereits mit der Zugriffs Steuerungs Sicherheit erstellt wurde und der Aufrufer nicht über <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>verfügt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-259">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="dd2b5-260">Informationen zum Öffnen eines vorhandenen benannten Mutex mit nur den Berechtigungen, die für die Synchronisierung von Thread Aktivitäten erforderlich sind, finden Sie unter <xref:System.Threading.Mutex.OpenExisting%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-260">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="dd2b5-261">Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokaler Mutex erstellt, als ob Sie den <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>-Konstruktor aufgerufen hätten.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-261">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="dd2b5-262">In diesem Fall wird `createdNew` immer `true`.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-262">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="dd2b5-263">Da Sie systemweit sind, können benannte Mutexen verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-263">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd2b5-264">Auf einem Server, auf dem Terminal Dienste ausgeführt werden, kann ein benannter Systemmutex zwei Ebenen der Sichtbarkeit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-264">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="dd2b5-265">Wenn der Name mit dem Präfix "Global\\" beginnt, wird der Mutex in allen Terminal Server Sitzungen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-265">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="dd2b5-266">Wenn der Name mit dem Präfix "local\\" beginnt, ist der Mutex nur in der Terminal Server Sitzung sichtbar, in der er erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-266">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="dd2b5-267">In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder der anderen Terminal Server Sitzungen auf dem Server vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-267">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="dd2b5-268">Wenn Sie beim Erstellen eines benannten Mutex kein Präfix angeben, wird das Präfix "local\\" benötigt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-268">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="dd2b5-269">Innerhalb einer Terminal Server Sitzung sind zwei Mutexen, deren Namen sich nur durch Ihre Präfixe unterscheiden, separate Mutexen, und beide sind für alle Prozesse in der Terminal Server Sitzung sichtbar.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-269">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="dd2b5-270">Das heißt, die Präfix Namen "Global\\" und "local\\" beschreiben den Bereich des Mutex-namens in Bezug auf Terminal Server Sitzungen, nicht relativ zu Prozessen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-270">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 <span data-ttu-id="dd2b5-271">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Mutex mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-271">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="dd2b5-272">Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benannter Mutex vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-272">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-273">Wenn der Mutex nicht vorhanden ist, wird er mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, der dem aktuellen Benutzer das Recht verweigert, den Mutex zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für den Mutex zu lesen und zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-273">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-274">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-274">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="dd2b5-275">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, um den Mutex mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-275">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="dd2b5-276">Nachdem die Berechtigungen geändert wurden, wird der Mutex mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-276">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="dd2b5-277">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-277">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="dd2b5-278">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-278">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="dd2b5-279">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-279">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="dd2b5-280">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-280">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd2b5-281"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-281"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd2b5-282">Ruft ein <see cref="T:System.Security.AccessControl.MutexSecurity" />-Objekt ab, das die Zugriffssteuerungssicherheit für den benannten Mutex darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-282">Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></summary>
        <returns><span data-ttu-id="dd2b5-283">Ein <see cref="T:System.Security.AccessControl.MutexSecurity" />-Objekt, das die Zugriffssteuerungssicherheit für den benannten Mutex darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-283">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-284">Die <xref:System.Threading.Mutex.GetAccessControl%2A>-Methode verwendet die folgende Kombination von-Flags (kombiniert mithilfe des bitweisen OR-Vorgangs), um nach Berechtigungen zu suchen: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-284">The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="dd2b5-285">Der Benutzer muss über <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> verfügen, um diese Methode aufzurufen, und der Mutex muss mit <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>geöffnet worden sein.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-285">The user must have <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd2b5-286">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Mutex mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-286">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="dd2b5-287">Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benannter Mutex vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-287">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-288">Wenn der Mutex nicht vorhanden ist, wird er mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, der dem aktuellen Benutzer das Recht verweigert, den Mutex zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für den Mutex zu lesen und zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-288">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-289">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-289">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="dd2b5-290">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, um den Mutex mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind, mithilfe der Methoden <xref:System.Threading.Mutex.GetAccessControl%2A> und <xref:System.Threading.Mutex.SetAccessControl%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-290">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="dd2b5-291">Nachdem die Berechtigungen geändert wurden, wird der Mutex mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-291">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="dd2b5-292">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-292">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="dd2b5-293">Das aktuelle <see cref="T:System.Threading.Mutex" />-Objekt stellt einen benannten Systemmutex dar. Der Benutzer verfügt jedoch nicht über <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-293">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span>  
  
<span data-ttu-id="dd2b5-294">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd2b5-294">-or-</span></span> 
<span data-ttu-id="dd2b5-295">Das aktuelle <see cref="T:System.Threading.Mutex" />-Objekt stellt einen benannten Systemmutex dar und wurde nicht mit <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> geöffnet.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-295">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd2b5-296">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-296">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd2b5-297">Öffnet einen bestimmten benannten Mutex, wenn er bereits vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-297">Opens a specified named mutex, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd2b5-298">Der Name des zu öffnenden Systemmutex.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-298">The name of the system mutex to open.</span></span></param>
        <summary><span data-ttu-id="dd2b5-299">Öffnet den bestimmten benannten Mutex, wenn er bereits vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-299">Opens the specified named mutex, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="dd2b5-300">Ein Objekt, das den benannten Systemmutex darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-300">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-301">Die <xref:System.Threading.Mutex.OpenExisting%2A>-Methode versucht, den angegebenen benannten Systemmutex zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-301">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex.</span></span> <span data-ttu-id="dd2b5-302">Wenn der Systemmutex nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemobjekt zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-302">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="dd2b5-303">Um den Systemmutex zu erstellen, wenn er noch nicht vorhanden ist, verwenden Sie einen der <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-303">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="dd2b5-304">Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Mutex> Objekt zurück, auch wenn die zurückgegebenen Objekte denselben benannten Systemmutex darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-304">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-305">Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-305">This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="dd2b5-306">Wenn Sie das <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>-Flag angeben, kann ein Thread auf den Mutex warten, und die Angabe des <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-306">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="dd2b5-307">Diese Methode fordert den Besitz des Mutex nicht an.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-307">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd2b5-308">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Mutex mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-308">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="dd2b5-309">Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benannter Mutex vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-309">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-310">Wenn der Mutex nicht vorhanden ist, wird er mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, der dem aktuellen Benutzer das Recht verweigert, den Mutex zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für den Mutex zu lesen und zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-310">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-311">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-311">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="dd2b5-312">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, um den Mutex mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-312">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="dd2b5-313">Nachdem die Berechtigungen geändert wurden, wird der Mutex mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-313">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="dd2b5-314">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-314">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd2b5-315"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-315"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="dd2b5-316">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd2b5-316">-or-</span></span> 
 <span data-ttu-id="dd2b5-317"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-317"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd2b5-318"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="dd2b5-318"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="dd2b5-319">Der benannte Mutex ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-319">The named mutex does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="dd2b5-320">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-320">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="dd2b5-321">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-321">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd2b5-322">Der Name des zu öffnenden Systemmutex.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-322">The name of the system mutex to open.</span></span></param>
        <param name="rights"><span data-ttu-id="dd2b5-323">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-323">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="dd2b5-324">Öffnet den angegebenen benannten Mutex, wenn er bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-324">Opens the specified named mutex, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="dd2b5-325">Ein Objekt, das den benannten Systemmutex darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-325">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-326">Der `rights`-Parameter muss das <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads auf den Mutex warten können, und das <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufrufen können.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-326">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="dd2b5-327">Die <xref:System.Threading.Mutex.OpenExisting%2A>-Methode versucht, einen vorhandenen benannten Mutex zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-327">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex.</span></span> <span data-ttu-id="dd2b5-328">Wenn der Systemmutex nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemobjekt zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-328">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="dd2b5-329">Um den Systemmutex zu erstellen, wenn er noch nicht vorhanden ist, verwenden Sie einen der <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-329">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="dd2b5-330">Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Mutex> Objekt zurück, auch wenn die zurückgegebenen Objekte denselben benannten Systemmutex darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-330">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-331">Diese Methode fordert den Besitz des Mutex nicht an.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-331">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd2b5-332">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Mutex mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-332">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="dd2b5-333">Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benannter Mutex vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-333">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-334">Wenn der Mutex nicht vorhanden ist, wird er mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, der dem aktuellen Benutzer das Recht verweigert, den Mutex zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für den Mutex zu lesen und zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-334">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-335">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-335">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="dd2b5-336">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, um den Mutex mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-336">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="dd2b5-337">Nachdem die Berechtigungen geändert wurden, wird der Mutex mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-337">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="dd2b5-338">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-338">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd2b5-339"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-339"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="dd2b5-340">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd2b5-340">-or-</span></span> 
 <span data-ttu-id="dd2b5-341"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-341"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd2b5-342"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="dd2b5-342"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="dd2b5-343">Der benannte Mutex ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-343">The named mutex does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="dd2b5-344">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-344">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="dd2b5-345">Der benannte Mutex ist vorhanden aber der Benutzer verfügt nicht über den gewünschten Sicherheitszugriff.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-345">The named mutex exists, but the user does not have the desired security access.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd2b5-346">Gibt das <see cref="T:System.Threading.Mutex" /> einmal frei.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-346">Releases the <see cref="T:System.Threading.Mutex" /> once.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-347">Wenn ein Thread einen Mutex erhält (z. b. durch Aufrufen seiner <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode), muss er anschließend <xref:System.Threading.Mutex.ReleaseMutex%2A> aufrufen, um den Besitz des Mutex zu übertragen und andere Threads zu blockieren, die versuchen, den Besitz des Mutex zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-347">Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</span></span> <span data-ttu-id="dd2b5-348">Wenn der Versuch, den Besitz des Mutex zu erhalten, fehlschlägt (z. b. Wenn ein Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode mit einem `millisecondsTimeout` oder einem `timeout`-Parameter `false` zurückgibt, weil die Anforderung ein Timeout hat), sollte der Thread <xref:System.Threading.Mutex.ReleaseMutex%2A>nicht aufrufen können, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-348">If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 <span data-ttu-id="dd2b5-349">Ein Thread, der einen Mutex besitzt, kann denselben Mutex in wiederholten Wait-Funktionsaufrufen angeben, ohne dessen Ausführung zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-349">A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</span></span> <span data-ttu-id="dd2b5-350">Die Anzahl der Aufrufe wird vom Common Language Runtime beibehalten.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-350">The number of calls is kept by the common language runtime.</span></span> <span data-ttu-id="dd2b5-351">Der Thread muss <xref:System.Threading.Mutex.ReleaseMutex%2A> gleichzeitig aufzurufen, um den Besitz des Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-351">The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-352">Wenn ein Thread beendet wird, während er ein Mutex besitzt, wird der Mutex als abgebrochen bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-352">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="dd2b5-353">Der Zustand des Mutex ist auf "signalisiert" festgelegt, und der nächste wartende Thread erhält den Besitz.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-353">The state of the mutex is set to signaled and the next waiting thread gets ownership.</span></span> <span data-ttu-id="dd2b5-354">Wenn keiner der Mutex gehört, wird der Zustand des Mutex signalisiert.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-354">If no one owns the mutex, the state of the mutex is signaled.</span></span> <span data-ttu-id="dd2b5-355">Ab Version 2,0 des .NET Framework wird ein <xref:System.Threading.AbandonedMutexException> im nächsten Thread ausgelöst, der den Mutex abruft.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-355">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex.</span></span> <span data-ttu-id="dd2b5-356">Vor Version 2,0 des .NET Framework wurde keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-356">Prior to version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="dd2b5-357">Ein abgebrochener Mutex weist häufig auf einen schwerwiegenden Fehler im Code hin.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-357">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="dd2b5-358">Wenn ein Thread beendet wird, ohne den Mutex freizugeben, befinden sich die vom Mutex geschützten Datenstrukturen möglicherweise nicht in einem konsistenten Zustand.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-358">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="dd2b5-359">Der nächste Thread, der den Besitz des Mutex anfordert, kann diese Ausnahme behandeln und fortfahren, wenn die Integrität der Datenstrukturen überprüft werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-359">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="dd2b5-360">Wenn es sich um einen systemweiten Mutex handelt, kann ein abgebrochener Mutex darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z.B. über den Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="dd2b5-360">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd2b5-361">Im folgenden Beispiel wird gezeigt, wie ein lokales <xref:System.Threading.Mutex> Objekt verwendet wird, um den Zugriff auf eine geschützte Ressource zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-361">The following example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="dd2b5-362">Der Thread, der den Mutex erstellt, ist nicht anfänglich.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-362">The thread that creates the mutex does not own it initially.</span></span> <span data-ttu-id="dd2b5-363">Die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode wird verwendet, um den Mutex freizugeben, wenn er nicht mehr benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-363">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is used to release the mutex when it is no longer needed.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="dd2b5-364">Der aufrufende Thread besitzt den Mutex nicht.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-364">The calling thread does not own the mutex.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd2b5-365">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-365">The current instance has already been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="dd2b5-366">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="dd2b5-366">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="dd2b5-367">Mutexe</span><span class="sxs-lookup"><span data-stu-id="dd2b5-367">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (mutexSecurity As MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity"><span data-ttu-id="dd2b5-368">Ein <see cref="T:System.Security.AccessControl.MutexSecurity" /> -Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf den benannten Systemmutex angewendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-368">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="dd2b5-369">Legt die Zugriffssteuerungssicherheit für einen benannten Systemmutex fest.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-369">Sets the access control security for a named system mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-370">Der Benutzer muss über <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> Rechte verfügen, um diese Methode aufzurufen, und der Mutex muss mit <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>geöffnet worden sein.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-370">The user must have <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd2b5-371">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Mutex mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-371">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="dd2b5-372">Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benannter Mutex vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-372">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-373">Wenn der Mutex nicht vorhanden ist, wird er mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, der dem aktuellen Benutzer das Recht verweigert, den Mutex zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für den Mutex zu lesen und zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-373">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-374">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-374">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="dd2b5-375">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, um den Mutex mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind, mithilfe der Methoden <xref:System.Threading.Mutex.GetAccessControl%2A> und <xref:System.Threading.Mutex.SetAccessControl%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-375">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="dd2b5-376">Nachdem die Berechtigungen geändert wurden, wird der Mutex mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-376">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="dd2b5-377">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-377">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd2b5-378"><paramref name="mutexSecurity" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="dd2b5-378"><paramref name="mutexSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="dd2b5-379">Der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-379">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span>  
  
<span data-ttu-id="dd2b5-380">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd2b5-380">-or-</span></span> 
<span data-ttu-id="dd2b5-381">Der Mutex wurde nicht mit <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> geöffnet.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-381">The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="dd2b5-382">Das aktuelle <see cref="T:System.Threading.Mutex" />-Objekt stellt keinen benannten Systemmutex dar.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-382">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd2b5-383">Öffnet einen bestimmten benannten Mutex, wenn er bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-383">Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd2b5-384">Der Name des zu öffnenden Systemmutex.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-384">The name of the system mutex to open.</span></span></param>
        <param name="result"><span data-ttu-id="dd2b5-385">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Mutex" />-Objekt, das das benannte Mutex darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-385">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="dd2b5-386">Dieser Parameter wird als nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-386">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="dd2b5-387">Öffnet den bestimmten benannten Mutex, wenn er bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-387">Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="dd2b5-388"><see langword="true" />, wenn der benannte Mutex erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-388"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-389">Wenn der benannte Mutex nicht vorhanden ist, wird er von dieser Methode nicht erstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-389">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="dd2b5-390">Um den Systemmutex zu erstellen, wenn er noch nicht vorhanden ist, verwenden Sie einen der <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-390">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="dd2b5-391">Wenn Sie unsicher sind, ob ein benannter Mutex vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn der Mutex nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-391">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="dd2b5-392">Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Mutex> Objekt zurück, auch wenn die zurückgegebenen Objekte denselben benannten Systemmutex darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-392">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-393">Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-393">This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="dd2b5-394">Wenn Sie das <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>-Flag angeben, kann ein Thread auf den Mutex warten, und die Angabe des <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-394">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="dd2b5-395">Diese Methode fordert den Besitz des Mutex nicht an.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-395">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd2b5-396"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-396"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="dd2b5-397">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd2b5-397">-or-</span></span> 
 <span data-ttu-id="dd2b5-398"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-398"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd2b5-399"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="dd2b5-399"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="dd2b5-400">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-400">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="dd2b5-401">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-401">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd2b5-402">Der Name des zu öffnenden Systemmutex.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-402">The name of the system mutex to open.</span></span></param>
        <param name="rights"><span data-ttu-id="dd2b5-403">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-403">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="dd2b5-404">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Mutex" />-Objekt, das das benannte Mutex darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-404">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="dd2b5-405">Dieser Parameter wird als nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-405">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="dd2b5-406">Öffnet den angegebenen benannten Mutex, wenn er bereits mit dem gewünschten Sicherheitszugriff vorhanden ist und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-406">Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="dd2b5-407"><see langword="true" />, wenn der benannte Mutex erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-407"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd2b5-408">Wenn der benannte Mutex nicht vorhanden ist, wird er von dieser Methode nicht erstellt.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-408">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="dd2b5-409">Um den Systemmutex zu erstellen, wenn er noch nicht vorhanden ist, verwenden Sie einen der <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-409">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="dd2b5-410">Wenn Sie unsicher sind, ob ein benannter Mutex vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn der Mutex nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-410">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="dd2b5-411">Der `rights`-Parameter muss das <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads auf den Mutex warten können, und das <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufrufen können.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-411">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="dd2b5-412">Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Mutex> Objekt zurück, auch wenn die zurückgegebenen Objekte denselben benannten Systemmutex darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-412">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="dd2b5-413">Diese Methode fordert den Besitz des Mutex nicht an.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-413">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd2b5-414"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-414"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="dd2b5-415">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd2b5-415">-or-</span></span> 
 <span data-ttu-id="dd2b5-416"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-416"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd2b5-417"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="dd2b5-417"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="dd2b5-418">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-418">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="dd2b5-419">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="dd2b5-419">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
