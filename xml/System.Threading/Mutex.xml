<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Mutex.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac56bce0feaf14f66f8608164cfa777620d7f3b329f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6bce0feaf14f66f8608164cfa777620d7f3b329f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>A synchronization primitive that can also be used for interprocess synchronization.</source>
          <target state="translated">Ein Synchronisierungsprimitiver, der auch für die prozessübergreifende Synchronisierung verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</source>
          <target state="translated">Wenn zwei oder mehr Threads zur gleichen Zeit eine freigegebene Ressource zugreifen müssen, benötigt das System einen Synchronisierungsmechanismus, um sicherzustellen, dass jeweils nur ein Thread auf die Ressource verwendet.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> ist ein Synchronisierungsprimitiver, der exklusiven Zugriff auf die freigegebene Ressource nur einem Thread gewährt.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</source>
          <target state="translated">Wenn ein Thread einen Mutex verwendet wird, wird vom zweite Thread, der an dieser Mutex abrufen möchte angehalten, bis der erste Thread das Mutex freigibt.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Dieser Typ implementiert die <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Wenn Sie mithilfe des Typs abgeschlossen haben, sollten Sie es entweder direkt oder indirekt freigeben.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Aufrufen, um den Typ direkt zu verwerfen, dessen <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> Methode in einer <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> Block.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Um es indirekt freizugeben, verwenden Sie ein Sprachkonstrukt z. B. <ph id="ph1">`using`</ph> (in c#) oder <ph id="ph2">`Using`</ph> (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, implementiert IDisposable" in der <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> Thema zur Schnittstelle.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method to request ownership of a mutex.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> Methode, um den Besitz des Mutex anfordert.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The calling thread blocks until one of the following occurs:</source>
          <target state="translated">Der aufrufende Thread blockiert, bis eines der folgenden Ereignisse eintritt:</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The mutex is signaled to indicate that it is not owned.</source>
          <target state="translated">Mutex wird signalisiert, um anzugeben, dass er nicht Besitzer ist.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`true`</ph>, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</source>
          <target state="translated">In diesem Fall die <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph>, und der aufrufende Thread übernimmt den Besitz des Mutex und auf die vom Mutex geschützte Ressource zugreift.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When it has finished accessing the resource, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the mutex.</source>
          <target state="translated">Beim Zugriff auf die Ressource abgeschlossen wurde, muss der Thread Aufrufen der <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Methode, um den Besitz des Mutex freizugeben.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The first example in the Examples section illustrates this pattern.</source>
          <target state="translated">Im erste Beispiel im Abschnitt "Beispiele" zeigt dieses Muster.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The time-out interval specified in the call to a <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method that has a <ph id="ph2">`millisecondsTimeout`</ph> or <ph id="ph3">`timeout`</ph> parameter has elapsed.</source>
          <target state="translated">Das Timeoutintervall, die im Aufruf angegebenen eine <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> Methode, die eine <ph id="ph2">`millisecondsTimeout`</ph> oder <ph id="ph3">`timeout`</ph> Parameter ist abgelaufen.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`false`</ph>, and the calling thread makes no further attempt to acquire ownership of the mutex.</source>
          <target state="translated">In diesem Fall die <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> -Methode zurückkehrt <ph id="ph2">`false`</ph>, und der aufrufende Thread unternimmt keinen weiteren Versuch, den Besitz des Mutex abzurufen.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</source>
          <target state="translated">In diesem Fall sollten Sie den Code so strukturieren, dass an den aufrufenden Thread den Zugriff auf die vom Mutex geschützte Ressource verweigert wird.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because the thread never acquired ownership of the mutex, it must not call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Da der Thread nie Besitz des Mutex zugewiesen wurde, müssen sie nicht Aufrufen der <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The second example in the Examples section illustrates this pattern.</source>
          <target state="translated">Das zweite Beispiel im Abschnitt "Beispiele" zeigt dieses Muster.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Klasse erzwingt Threadidentität, sodass ein Mutex nur von dem Thread freigegeben werden kann, die er abgerufen.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>By contrast, the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity.</source>
          <target state="translated">Im Gegensatz dazu, die <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> Klasse erzwingen keine Threadidentität.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>A mutex can also be passed across application domain boundaries.</source>
          <target state="translated">Ein Mutex kann auch über Anwendungsdomänen hinweg übergeben werden.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The thread that owns a mutex can request the same mutex in repeated calls to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> without blocking its execution.</source>
          <target state="translated">Der Thread, der einen Mutex besitzt denselben Mutex in wiederholte Aufrufe kann anfordern, <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> ohne Blockierung seiner Ausführung.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>However, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method the same number of times to release ownership of the mutex.</source>
          <target state="translated">Allerdings muss der Thread Aufrufen der <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> -Methode die gleiche Anzahl der Wiederholungsversuche im Besitz des Mutex freizugeben.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class inherits from <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>, you can also call the static <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> methods to synchronize access to a protected resource.</source>
          <target state="translated">Da die <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Klasse erbt von <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>, rufen Sie außerdem die statische <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> Methoden zum Synchronisieren des Zugriffs auf eine geschützte Ressource.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
          <target state="translated">Wenn ein Thread beendet wird, während einen Mutex besitzt, wird der Mutex abgebrochen wird.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The state of the mutex is set to signaled, and the next waiting thread gets ownership.</source>
          <target state="translated">Auf der Zustand des Mutex festgelegt ist, signalisiert, und der nächste wartende Thread Ruft die Inhaberschaft ab.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the abandoned mutex.</source>
          <target state="translated">Ab Version 2.0 von .NET Framework eine <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> wird ausgelöst, in der nächste Thread, der den abgebrochenen Mutex erhält.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Before version 2.0 of the .NET Framework, no exception was thrown.</source>
          <target state="translated">Vor Version 2.0 von .NET Framework wurde keine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
          <target state="translated">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
          <target state="translated">Wenn ein Thread beendet, ohne das Mutex, möglicherweise nicht die vom Mutex geschützte Datenstruktur in einem konsistenten Zustand.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
          <target state="translated">Der nächste Thread, der Besitz des Mutex anfordert, kann diese Ausnahme behandeln und fortgesetzt werden, wenn die Integrität der Datenstruktur überprüft werden kann.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">Wenn es sich um einen systemweiten Mutex handelt, kann ein abgebrochener Mutex darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z.B. über den Windows Task-Manager).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</source>
          <target state="translated">Es gibt zwei Typen: Lokale Mutexe stammen, die unbenannte und benannte Systemmutexe werden.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>A local mutex exists only within your process.</source>
          <target state="translated">Ein lokaler Mutex ist nur innerhalb des Prozesses vorhanden.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>It can be used by any thread in your process that has a reference to the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the mutex.</source>
          <target state="translated">Hiermit können von jedem Thread innerhalb des Prozesses, der einen Verweis auf die <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> -Objekt, das den Mutex darstellt.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Each unnamed <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object represents a separate local mutex.</source>
          <target state="translated">Jedes unbenannte <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> -Objekt stellt einen separaten lokalen Mutex dar.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</source>
          <target state="translated">Benannte Mutexe sind im gesamten Betriebssystem sichtbar und können verwendet werden, um die Aktivitäten von Prozessen zu synchronisieren.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can create a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex by using a constructor that accepts a name.</source>
          <target state="translated">Sie erstellen eine <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt, das einen benannten Systemmutex darstellt, über einen Konstruktor, der einen Namen akzeptiert.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The operating-system object can be created at the same time, or it can exist before the creation of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object.</source>
          <target state="translated">Das Betriebssystemobjekt kann zur gleichen Zeit erstellt werden oder es kann vorhanden sein, bevor die Erstellung von der <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex, and you can use the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method to open an existing named system mutex.</source>
          <target state="translated">Sie können mehrere <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph>-Objekte erstellen, die denselben benannten Systemmutex darstellen, und Sie können mithilfe der <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph>-Methode einen vorhandenen benannten Systemmutex öffnen.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">Auf einem Server, auf der Terminaldienste ausgeführt wird, kann ein benannten Systemmutex zwei Sichtbarkeitsebenen haben.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Wenn der Name mit dem Präfix beginnt "Global<ph id="ph1">\\</ph>", Mutex ist in allen Terminalserver Sitzungen sichtbar.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Wenn der Name mit dem Präfix beginnt "lokale<ph id="ph1">\\</ph>", der Mutex aufgehoben ist nur in der Terminalserver-Sitzung sichtbar, in dem es erstellt wurde.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder von den anderen Terminalserver-Sitzungen auf dem Server vorhanden sein.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Wenn Sie ein Präfix nicht angeben, wenn Sie einen benannten Mutex erstellen, dauert das Präfix "lokale<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">Innerhalb einer Sitzung Terminalserver zwei Mutexe, deren Namen sich nur durch ihre Präfixe unterscheiden, sind separate Mutexe, und beide sind für alle Prozesse sichtbar, in der Terminalserver-Sitzung.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">D. h. den Präfixnamen "Global<ph id="ph1">\\</ph>" und "lokale<ph id="ph2">\\</ph>" beschreiben den Gültigkeitsbereich des Namens Mutex relativ zum Terminalserver-Sitzungen, nicht relativ zur Prozesse.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">In diesem Beispiel wird gezeigt, wie mithilfe eines lokalen <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt wird zum Synchronisieren des Zugriffs auf eine geschützte Ressource verwendet.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the thread.</source>
          <target state="translated">Da jeder aufrufenden Thread blockiert wird, bis er den Besitz des Mutex erhält, rufen sie die <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Methode, um den Besitz des Threads freigibt.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In the following example, each thread calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29&gt;</ph> method to acquire the mutex.</source>
          <target state="translated">Im folgenden Beispiel jeder Thread Ruft die <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29&gt;</ph> Methode, um den Mutex abrufen.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If the time-out interval elapses, the method returns <ph id="ph1">`false`</ph>, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</source>
          <target state="translated">Wenn das Timeoutintervall abläuft, gibt die Methode <ph id="ph1">`false`</ph>, und der Thread Mutex erhält weder erhält Zugriff auf die Ressource Mutex schützt.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method is called only by the thread that acquires the mutex.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Methode wird aufgerufen, nur durch den Thread, der den Mutex verwendet.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This type is thread safe.</source>
          <target state="translated">Dieser Typ ist threadsicher.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with default properties.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>-Klasse mit Standardeigenschaften.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>Calling this constructor overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor overload and specifying <ph id="ph2">`false`</ph> for initial ownership of the mutex.</source>
          <target state="translated">Aufrufen dieser Überladung des Konstruktors ist der gleiche wie das Aufrufen der <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> Konstruktorüberladung und Angeben von <ph id="ph2">`false`</ph> für den anfänglichen Besitz des Mutex.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>That is, the calling thread does not own the mutex.</source>
          <target state="translated">D. h. besitzt der aufrufende Thread das Mutex nicht.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>The following code example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">Das folgende Codebeispiel zeigt, wie mithilfe eines lokalen <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt wird zum Synchronisieren des Zugriffs auf eine geschützte Ressource verwendet.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>The thread that creates the mutex does not own it initially.</source>
          <target state="translated">Der Thread, der den Mutex erstellt besitzt er ursprünglich nicht.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the mutex; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um dem aufrufenden Thread den anfänglichen Besitz des Mutex zuzuweisen, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>The following code example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">Das folgende Codebeispiel zeigt, wie mithilfe eines lokalen <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt wird zum Synchronisieren des Zugriffs auf eine geschützte Ressource verwendet.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>The thread that creates the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> owns it initially.</source>
          <target state="translated">Der Thread, erstellt die <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> besitzt es anfänglich.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</source>
          <target state="translated">Der Name des <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">Bei einem Wert von <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist das <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> unbenannt.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, sowie mit einer Zeichenfolge, die den Namen des Mutex darstellt.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</source>
          <target state="translated">Wenn <ph id="ph1">`name`</ph> nicht <ph id="ph2">`null`</ph> und <ph id="ph3">`initiallyOwned`</ph> ist <ph id="ph4">`true`</ph>, besitzt der aufrufende Thread das Mutex nur, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wurde.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Since there is no mechanism for determining whether the named system mutex was created, it is better to specify <ph id="ph1">`false`</ph> for <ph id="ph2">`initiallyOwned`</ph> when calling this constructor overload.</source>
          <target state="translated">Da es keinen Mechanismus gibt für die Bestimmung, ob der benannte Systemmutex erstellt wurde, ist es besser, geben Sie <ph id="ph1">`false`</ph> für <ph id="ph2">`initiallyOwned`</ph> beim Aufrufen dieser Überladung des Konstruktors.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor if you need to determine initial ownership.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> Konstruktor, wenn Sie den anfänglichen Besitz ermitteln müssen.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Dieser Konstruktor initialisiert ein <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt, das einen benannten Systemmutex darstellt.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Sie können mehrere erstellen <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> benannte Systemmutex Objekte, die die gleiche darstellen.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Wenn der benannte Mutex wurde bereits mit zugriffssteuerungssicherheit erstellt, und der Aufrufer verfügt nicht über <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, wird eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Zum Öffnen einer vorhandenen benannten Mutex mit nur den Berechtigungen, die zum Synchronisieren von Threadaktivitäten erforderlich sind, finden Sie unter der <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Bei Angabe von <ph id="ph1">`null`</ph> oder eine leere Zeichenfolge für <ph id="ph2">`name`</ph>, ein lokaler Mutex erstellt, wie bei einem Aufruf der <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">In diesem Fall <ph id="ph1">`createdNew`</ph> ist immer <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Da es sich um eine systemweite sind, können benannte Mutexe bezeichnet zum Koordinieren der Ressourcenverwendung über Prozessgrenzen hinweg verwendet werden.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">Auf einem Server, auf der Terminaldienste ausgeführt wird, kann ein benannten Systemmutex zwei Sichtbarkeitsebenen haben.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Wenn der Name mit dem Präfix beginnt "Global<ph id="ph1">\\</ph>", Mutex ist in allen Terminalserver Sitzungen sichtbar.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Wenn der Name mit dem Präfix beginnt "lokale<ph id="ph1">\\</ph>", der Mutex aufgehoben ist nur in der Terminalserver-Sitzung sichtbar, in dem es erstellt wurde.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder von den anderen Terminalserver-Sitzungen auf dem Server vorhanden sein.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Wenn Sie ein Präfix nicht angeben, wenn Sie einen benannten Mutex erstellen, dauert das Präfix "lokale<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">Innerhalb einer Sitzung Terminalserver zwei Mutexe, deren Namen sich nur durch ihre Präfixe unterscheiden, sind separate Mutexe, und beide sind für alle Prozesse sichtbar, in der Terminalserver-Sitzung.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">D. h. den Präfixnamen "Global<ph id="ph1">\\</ph>" und "lokale<ph id="ph2">\\</ph>" beschreiben den Gültigkeitsbereich des Namens Mutex relativ zum Terminalserver-Sitzungen, nicht relativ zur Prozesse.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The following example shows how a named mutex is used to signal between threads running in two separate processes.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie ein benannter Mutex verwendet wird, zu signalisieren zwischen Threads, die in zwei separate Vorgänge ausführen.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Run this program from two or more command windows.</source>
          <target state="translated">Dieses Programm wird aus mindestens zwei Befehlsfenstern ausführen.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Each process creates a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the named mutex <ph id="ph2">`MyMutex`</ph>.</source>
          <target state="translated">Jeder Prozess erstellt ein <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt, das den benannten Mutex darstellt <ph id="ph2">`MyMutex`</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is a system object whose lifetime is bounded by the lifetimes of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it.</source>
          <target state="translated">Der benannte Mutex ist ein Systemobjekt ist, deren Lebensdauer durch die Lebensdauer der begrenzt die <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekte, die sie darstellen.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is created when the first process creates its <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object; in this example, the named mutex is owned by the first process that runs the program.</source>
          <target state="translated">Der benannte Mutex wird erstellt, wenn der erste Prozess erstellt seine <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt; in diesem Beispiel wird der benannte Mutex ist im Besitz des ersten Prozesses, der das Programm ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is destroyed when all the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it have been released.</source>
          <target state="translated">Der benannte Mutex wird zerstört, wenn alle der <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekte, die diese darstellen veröffentlicht wurden.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</source>
          <target state="translated">Die Konstruktorüberladung, die in diesem Beispiel verwendet feststellen nicht den aufrufenden Thread, ob der anfängliche Besitz des benannten Mutex gewährt wurde.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</source>
          <target state="translated">Dieser Konstruktor sollte nicht verwendet werden, um den anfänglichen Besitz anzufordern, es sei denn, Sie sicher sein können, dass der Thread den benannten Mutex erstellt wird.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</source>
          <target state="translated">Der Name des <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">Bei einem Wert von <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist das <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> unbenannt.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system mutex already existed.</source>
          <target state="translated">Enthält nach dem Beenden dieser Methode einen booleschen Wert, der <ph id="ph1">&lt;see langword="true" /&gt;</ph> ist, wenn ein lokaler Mutex erstellt wurde (d. h. wenn <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> gleich <ph id="ph2">&lt;see langword="null" /&gt;</ph> oder eine leere Zeichenfolge ist) oder wenn der angegebene benannte Systemmutex erstellt wurde. Der Wert ist <ph id="ph3">&lt;see langword="false" /&gt;</ph>, wenn der angegebene benannte Systemmutex bereits vorhanden war.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Dieser Parameter wird nicht initialisiert übergeben.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, mit einer Zeichenfolge mit dem Namen des Mutex sowie mit einem booleschen Wert, der beim Beenden der Methode angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex gewährt wurde.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
          <target state="translated">Wenn <ph id="ph1">`name`</ph> nicht <ph id="ph2">`null`</ph> und <ph id="ph3">`initiallyOwned`</ph> ist <ph id="ph4">`true`</ph>, besitzt der aufrufende Thread den benannten Mutex nur, wenn <ph id="ph5">`createdNew`</ph> ist <ph id="ph6">`true`</ph> nach dem Aufruf.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">Andernfalls kann der Thread das Mutex anfordern, durch Aufrufen der <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Dieser Konstruktor initialisiert ein <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt, das einen benannten Systemmutex darstellt.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Sie können mehrere erstellen <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> benannte Systemmutex Objekte, die die gleiche darstellen.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph> rights, an exception is thrown.</source>
          <target state="translated">Wenn der benannte Mutex wurde bereits mit zugriffssteuerungssicherheit erstellt, und der Aufrufer verfügt nicht über <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph> verfügt, wird eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Zum Öffnen einer vorhandenen benannten Mutex mit nur den Berechtigungen, die zum Synchronisieren von Threadaktivitäten erforderlich sind, finden Sie unter der <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Bei Angabe von <ph id="ph1">`null`</ph> oder eine leere Zeichenfolge für <ph id="ph2">`name`</ph>, ein lokaler Mutex erstellt, wie bei einem Aufruf der <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">In diesem Fall <ph id="ph1">`createdNew`</ph> ist immer <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Da es sich um eine systemweite sind, können benannte Mutexe bezeichnet zum Koordinieren der Ressourcenverwendung über Prozessgrenzen hinweg verwendet werden.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">Auf einem Server, auf der Terminaldienste ausgeführt wird, kann ein benannten Systemmutex zwei Sichtbarkeitsebenen haben.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Wenn der Name mit dem Präfix beginnt "Global<ph id="ph1">\\</ph>", Mutex ist in allen Terminalserver Sitzungen sichtbar.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Wenn der Name mit dem Präfix beginnt "lokale<ph id="ph1">\\</ph>", der Mutex aufgehoben ist nur in der Terminalserver-Sitzung sichtbar, in dem es erstellt wurde.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder von den anderen Terminalserver-Sitzungen auf dem Server vorhanden sein.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Wenn Sie ein Präfix nicht angeben, wenn Sie einen benannten Mutex erstellen, dauert das Präfix "lokale<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">Innerhalb einer Sitzung Terminalserver zwei Mutexe, deren Namen sich nur durch ihre Präfixe unterscheiden, sind separate Mutexe, und beide sind für alle Prozesse sichtbar, in der Terminalserver-Sitzung.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">D. h. den Präfixnamen "Global<ph id="ph1">\\</ph>" und "lokale<ph id="ph2">\\</ph>" beschreiben den Gültigkeitsbereich des Namens Mutex relativ zum Terminalserver-Sitzungen, nicht relativ zur Prozesse.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The following code example shows how a named mutex is used to signal between processes or threads.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie ein benannter Mutex verwendet wird, um zwischen Prozesse oder Threads zu signalisieren.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Run this program from two or more command windows.</source>
          <target state="translated">Dieses Programm wird aus mindestens zwei Befehlsfenstern ausführen.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Each process creates a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the named mutex "MyMutex".</source>
          <target state="translated">Jeder Prozess erstellt ein <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt, das den benannten Mutex "MyMutex" darstellt.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is a system object.</source>
          <target state="translated">Der benannte Mutex ist ein Systemobjekt ist.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In this example, its lifetime is bounded by the lifetimes of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it.</source>
          <target state="translated">In diesem Beispiel wird seine Lebensdauer durch die Lebensdauer der begrenzt die <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekte, die sie darstellen.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is created when the first process creates its local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object, and destroyed when all the <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it have been released.</source>
          <target state="translated">Der benannte Mutex wird erstellt, wenn der erste Prozess den lokalen erstellt <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt, und zerstört, wenn alle der <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> Objekte, die diese darstellen veröffentlicht wurden.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is initially owned by the first process.</source>
          <target state="translated">Der benannte Mutex ist anfänglich im Besitz des ersten Prozesses.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The second process and any subsequent processes wait for earlier processes to release the named mutex.</source>
          <target state="translated">Der zweite und alle nachfolgenden Prozesse warten von früheren Prozesse, um den benannten Mutex freizugeben.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The name of the system mutex.</source>
          <target state="translated">Der Name des Systemmutex.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">Bei einem Wert von <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist das <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> unbenannt.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system mutex already existed.</source>
          <target state="translated">Enthält nach dem Beenden dieser Methode einen booleschen Wert, der <ph id="ph1">&lt;see langword="true" /&gt;</ph> ist, wenn ein lokaler Mutex erstellt wurde (d. h. wenn <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> gleich <ph id="ph2">&lt;see langword="null" /&gt;</ph> oder eine leere Zeichenfolge ist) oder wenn der angegebene benannte Systemmutex erstellt wurde. Der Wert ist <ph id="ph3">&lt;see langword="false" /&gt;</ph>, wenn der angegebene benannte Systemmutex bereits vorhanden war.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Dieser Parameter wird nicht initialisiert übergeben.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph>-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf den benannten Systemmutex angewendet werden soll.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, mit einer Zeichenfolge mit dem Namen des Mutex, mit einer booleschen Variable, die beim Beenden der Methode angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex gewährt wurde, und mit der Zugriffssteuerungssicherheit, die auf den benannten Mutex angewendet werden soll.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
          <target state="translated">Wenn <ph id="ph1">`name`</ph> nicht <ph id="ph2">`null`</ph> und <ph id="ph3">`initiallyOwned`</ph> ist <ph id="ph4">`true`</ph>, besitzt der aufrufende Thread den benannten Mutex nur, wenn <ph id="ph5">`createdNew`</ph> ist <ph id="ph6">`true`</ph> nach dem Aufruf.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">Andernfalls kann der Thread das Mutex anfordern, durch Aufrufen der <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</source>
          <target state="translated">Verwenden Sie diesen Konstruktor, bei der Erstellung wird verhindert, dass anderer Code Kontrolle über die Mutex zugriffssteuerungssicherheit auf einen benannten Systemmutex anzuwenden.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Dieser Konstruktor initialisiert ein <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt, das einen benannten Systemmutex darstellt.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Sie können mehrere erstellen <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> benannte Systemmutex Objekte, die die gleiche darstellen.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named system mutex does not exist, it is created with the specified access control security.</source>
          <target state="translated">Wenn der benannte Systemmutex nicht vorhanden ist, wird er mit dem angegebenen zugriffssteuerungssicherheit erstellt.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named mutex exists, the specified access control security is ignored.</source>
          <target state="translated">Wenn der benannte Mutex ist vorhanden, wird die angegebene zugriffssteuerungssicherheit ignoriert.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object even if <ph id="ph2">`mutexSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">Der Aufrufer hat Vollzugriff auf das neu erstellte <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt erstellen, selbst wenn <ph id="ph2">`mutexSecurity`</ph> verweigert oder einige über die Zugriffsrechte für den aktuellen Benutzer zu erteilen.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object to represent the same named mutex, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">Jedoch wenn der aktuelle Benutzer versucht, erhalten eine andere <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt zur Darstellung der gleiche benannten Mutex, entweder einen Konstruktor oder die <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> -Methode, Windows-zugriffssteuerungssicherheit angewendet wird.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Wenn der benannte Mutex wurde bereits mit zugriffssteuerungssicherheit erstellt, und der Aufrufer verfügt nicht über <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, wird eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Zum Öffnen einer vorhandenen benannten Mutex mit nur den Berechtigungen, die zum Synchronisieren von Threadaktivitäten erforderlich sind, finden Sie unter der <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Bei Angabe von <ph id="ph1">`null`</ph> oder eine leere Zeichenfolge für <ph id="ph2">`name`</ph>, ein lokaler Mutex erstellt, wie bei einem Aufruf der <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">In diesem Fall <ph id="ph1">`createdNew`</ph> ist immer <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Da es sich um eine systemweite sind, können benannte Mutexe bezeichnet zum Koordinieren der Ressourcenverwendung über Prozessgrenzen hinweg verwendet werden.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">Auf einem Server, auf der Terminaldienste ausgeführt wird, kann ein benannten Systemmutex zwei Sichtbarkeitsebenen haben.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Wenn der Name mit dem Präfix beginnt "Global<ph id="ph1">\\</ph>", Mutex ist in allen Terminalserver Sitzungen sichtbar.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Wenn der Name mit dem Präfix beginnt "lokale<ph id="ph1">\\</ph>", der Mutex aufgehoben ist nur in der Terminalserver-Sitzung sichtbar, in dem es erstellt wurde.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder von den anderen Terminalserver-Sitzungen auf dem Server vorhanden sein.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Wenn Sie ein Präfix nicht angeben, wenn Sie einen benannten Mutex erstellen, dauert das Präfix "lokale<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">Innerhalb einer Sitzung Terminalserver zwei Mutexe, deren Namen sich nur durch ihre Präfixe unterscheiden, sind separate Mutexe, und beide sind für alle Prozesse sichtbar, in der Terminalserver-Sitzung.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">D. h. den Präfixnamen "Global<ph id="ph1">\\</ph>" und "lokale<ph id="ph2">\\</ph>" beschreiben den Gültigkeitsbereich des Namens Mutex relativ zum Terminalserver-Sitzungen, nicht relativ zur Prozesse.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Verhalten prozessübergreifend einen benannten Mutex mit zugriffssteuerungssicherheit veranschaulicht.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> -methodenüberladung, um das Vorhandensein einer benannten Mutex zu testen.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Wenn das Mutex nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des Rechts zum Verwenden der Mutex aufgehoben, aber das Recht zum Lesen und Ändern von Berechtigungen für den Mutex gewährt.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Die Ausnahme abgefangen wird, und im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> -methodenüberladung Mutex mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Nachdem die Berechtigungen geändert werden, wird der Mutex mit den erforderlichen Benutzerrechten zum eingeben und freigegeben werden, geöffnet.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security for the named mutex.</source>
          <target state="translated">Ruft ein <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph>-Objekt ab, das die Zugriffssteuerungssicherheit für den benannten Mutex darstellt.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security for the named mutex.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph>-Objekt, das die Zugriffssteuerungssicherheit für den benannten Mutex darstellt.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> Methode verwendet die folgende Kombination von Flags, die (mit dem bitweisen OR-Operation kombiniert) zu suchende Berechtigungen: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, und <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Benutzer benötigt <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> zum Aufrufen dieser Methode und der Mutex müssen geöffnet wurden mit <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Verhalten prozessübergreifend einen benannten Mutex mit zugriffssteuerungssicherheit veranschaulicht.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> -methodenüberladung, um das Vorhandensein einer benannten Mutex zu testen.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Wenn das Mutex nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des Rechts zum Verwenden der Mutex aufgehoben, aber das Recht zum Lesen und Ändern von Berechtigungen für den Mutex gewährt.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions, using the <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Die Ausnahme abgefangen wird, und im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> -methodenüberladung Mutex zu öffnen, mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen, die mit der <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> und <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Nachdem die Berechtigungen geändert werden, wird der Mutex mit den erforderlichen Benutzerrechten zum eingeben und freigegeben werden, geöffnet.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object represents a named system mutex, but the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>-Objekt stellt einen benannten Systemmutex dar. Der Benutzer verfügt jedoch nicht über <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object represents a named system mutex, and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>-Objekt stellt einen benannten Systemmutex dar und wurde nicht mit <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph> geöffnet.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Opens a specified named mutex, if it already exists.</source>
          <target state="translated">Öffnet einen bestimmten benannten Mutex, wenn er bereits vorhanden ist.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Der Name des zu öffnenden Systemmutex.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Opens the specified named mutex, if it already exists.</source>
          <target state="translated">Öffnet den bestimmten benannten Mutex, wenn er bereits vorhanden ist.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>An object that represents the named system mutex.</source>
          <target state="translated">Ein Objekt, das den benannten Systemmutex darstellt.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open the specified named system mutex.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> Methode versucht werden, öffnen Sie das angegebene benannte Systemmutex.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
          <target state="translated">Wenn das Systemmutex nicht vorhanden ist, löst diese Methode eine Ausnahme aus, anstatt das Systemobjekt erstellen.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Systemmutex erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> Konstruktoren, die verfügt über eine <ph id="ph2">`name`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Mehrere Aufrufe dieser Methode, die den gleichen Wert für <ph id="ph1">`name`</ph> nicht unbedingt zurück, die gleiche <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> -Objekt, auch wenn die Objekte, die zurückgegeben werden die gleichen benannten Systemmutex darstellen.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Überladung dieser Methode entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> methodenüberladung und Angeben von <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> und <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> Rechte, die mit dem bitweisen OR-Operation kombiniert.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Angeben der <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> Flag ermöglicht, dass einen Thread das Mutex warten und Angeben der <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> Flag ermöglicht, dass einen Thread aufrufen, die <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Diese Methode ist keine Besitz des Mutex anfordert.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Verhalten prozessübergreifend einen benannten Mutex mit zugriffssteuerungssicherheit veranschaulicht.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> -methodenüberladung, um das Vorhandensein einer benannten Mutex zu testen.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Wenn das Mutex nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des Rechts zum Verwenden der Mutex aufgehoben, aber das Recht zum Lesen und Ändern von Berechtigungen für den Mutex gewährt.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Die Ausnahme abgefangen wird, und im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> -methodenüberladung Mutex mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Nachdem die Berechtigungen geändert werden, wird der Mutex mit den erforderlichen Benutzerrechten zum eingeben und freigegeben werden, geöffnet.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The named mutex does not exist.</source>
          <target state="translated">Der benannte Mutex ist nicht vorhanden.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Der Name des zu öffnenden Systemmutex.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Opens the specified named mutex, if it already exists, with the desired security access.</source>
          <target state="translated">Öffnet den angegebenen benannten Mutex, wenn er bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>An object that represents the named system mutex.</source>
          <target state="translated">Ein Objekt, das den benannten Systemmutex darstellt.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">`rights`</ph> -Parameter enthalten muss die <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> Threads ermöglichen, warten Sie auf den Mutex-Flag und der <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> -Kennzeichen an die Threads ermöglichen, rufen Sie die <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open an existing named mutex.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> Methode versucht, öffnen Sie eine vorhandene benannte Mutex.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
          <target state="translated">Wenn das Systemmutex nicht vorhanden ist, löst diese Methode eine Ausnahme aus, anstatt das Systemobjekt erstellen.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Systemmutex erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> Konstruktoren, die verfügt über eine <ph id="ph2">`name`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Mehrere Aufrufe dieser Methode, die den gleichen Wert für <ph id="ph1">`name`</ph> nicht unbedingt zurück, die gleiche <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> -Objekt, auch wenn die Objekte, die zurückgegeben werden die gleichen benannten Systemmutex darstellen.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Diese Methode ist keine Besitz des Mutex anfordert.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Verhalten prozessübergreifend einen benannten Mutex mit zugriffssteuerungssicherheit veranschaulicht.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> -methodenüberladung, um das Vorhandensein einer benannten Mutex zu testen.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Wenn das Mutex nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des Rechts zum Verwenden der Mutex aufgehoben, aber das Recht zum Lesen und Ändern von Berechtigungen für den Mutex gewährt.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Die Ausnahme abgefangen wird, und im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> -methodenüberladung Mutex mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Nachdem die Berechtigungen geändert werden, wird der Mutex mit den erforderlichen Benutzerrechten zum eingeben und freigegeben werden, geöffnet.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The named mutex does not exist.</source>
          <target state="translated">Der benannte Mutex ist nicht vorhanden.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The named mutex exists, but the user does not have the desired security access.</source>
          <target state="translated">Der benannte Mutex ist vorhanden aber der Benutzer verfügt nicht über den gewünschten Sicherheitszugriff.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Releases the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> once.</source>
          <target state="translated">Gibt das <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> einmal frei.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Whenever a thread acquires a mutex (for example, by calling its <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method), it must subsequently call <ph id="ph2">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</source>
          <target state="translated">Wenn ein Thread einen Mutex erhält (z. B. durch Aufrufen seiner <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> Methode), anschließend aufgerufen werden muss <ph id="ph2">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> abgeben Besitz des Mutex und Entsperren von anderen Threads, die versuchen, den Besitz von Mutex zu erhalten.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If the attempt to get ownership of the mutex fails (for example, when a call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method with a <ph id="ph2">`millisecondsTimeout`</ph> or a <ph id="ph3">`timeout`</ph> parameter returns <ph id="ph4">`false`</ph> because the request times out), the thread shouldn't call <ph id="ph5">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</source>
          <target state="translated">Schlägt der Versuch zum Abrufen der Besitz des Mutex (z. B. bei einem Aufruf von der <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> Methode mit einer <ph id="ph2">`millisecondsTimeout`</ph> oder ein <ph id="ph3">`timeout`</ph> gibt Parameter <ph id="ph4">`false`</ph> , da die Anforderung ein Timeout eintritt), darf nicht der Thread Aufrufen <ph id="ph5">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>, In diesem Fall sollte der Thread ebenfalls nicht zulässig sein Zugriff auf die Ressource, die durch den Mutex geschützt werden, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</source>
          <target state="translated">Ein Thread, der einen Mutex besitzt kann denselben Mutex in Funktionsaufrufen wiederholte Wait angeben, ohne Blockierung seiner Ausführung.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The number of calls is kept by the common language runtime.</source>
          <target state="translated">Die Anzahl der Aufrufe wird durch die common Language Runtime beibehalten.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The thread must call <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> the same number of times to release ownership of the mutex.</source>
          <target state="translated">Der Thread aufrufen, muss <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> die gleiche Anzahl der Wiederholungsversuche im Besitz des Mutex freizugeben.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
          <target state="translated">Wenn ein Thread beendet wird, während einen Mutex besitzt, wird der Mutex abgebrochen wird.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The state of the mutex is set to signaled and the next waiting thread gets ownership.</source>
          <target state="translated">Der Status des Mutex auf signalisiert festgelegt ist, und der nächste wartende Thread Ruft die Inhaberschaft ab.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If no one owns the mutex, the state of the mutex is signaled.</source>
          <target state="translated">Wenn niemand Mutex besitzt, wird der Zustand des Mutex signalisiert.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the mutex.</source>
          <target state="translated">Ab Version 2.0 von .NET Framework eine <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> wird ausgelöst, in der nächste Thread, der den Mutex verwendet.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Prior to version 2.0 of the .NET Framework, no exception was thrown.</source>
          <target state="translated">Vor Version 2.0 von .NET Framework wurde keine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
          <target state="translated">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
          <target state="translated">Wenn ein Thread beendet, ohne das Mutex, möglicherweise nicht die vom Mutex geschützte Datenstruktur in einem konsistenten Zustand.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
          <target state="translated">Der nächste Thread, der Besitz des Mutex anfordert, kann diese Ausnahme behandeln und fortgesetzt werden, wenn die Integrität der Datenstruktur überprüft werden kann.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">Wenn es sich um einen systemweiten Mutex handelt, kann ein abgebrochener Mutex darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z.B. über den Windows Task-Manager).</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The following example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie mithilfe eines lokalen <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Objekt wird zum Synchronisieren des Zugriffs auf eine geschützte Ressource verwendet.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The thread that creates the mutex does not own it initially.</source>
          <target state="translated">Der Thread, der den Mutex erstellt besitzt er ursprünglich nicht.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method is used to release the mutex when it is no longer needed.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Methode wird verwendet, um das Mutex freizugeben, wenn er nicht mehr benötigt wird.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The calling thread does not own the mutex.</source>
          <target state="translated">Der aufrufende Thread besitzt den Mutex nicht.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The current instance has already been disposed.</source>
          <target state="translated">Die aktuelle Instanz wurde bereits verworfen.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph>-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf den benannten Systemmutex angewendet werden soll.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>Sets the access control security for a named system mutex.</source>
          <target state="translated">Legt die Zugriffssteuerungssicherheit für einen benannten Systemmutex fest.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Benutzer benötigt <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> Rechte für einen Aufruf dieser Methode und Mutex wurde müssen geöffnet <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Verhalten prozessübergreifend einen benannten Mutex mit zugriffssteuerungssicherheit veranschaulicht.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> -methodenüberladung, um das Vorhandensein einer benannten Mutex zu testen.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Wenn das Mutex nicht vorhanden ist, wird es erstellt, mit den anfänglichen Besitz und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des Rechts zum Verwenden der Mutex aufgehoben, aber das Recht zum Lesen und Ändern von Berechtigungen für den Mutex gewährt.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions, using the <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Die Ausnahme abgefangen wird, und im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> -methodenüberladung Mutex zu öffnen, mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen, die mit der <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> und <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Nachdem die Berechtigungen geändert werden, wird der Mutex mit den erforderlichen Benutzerrechten zum eingeben und freigegeben werden, geöffnet.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;paramref name="mutexSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mutexSecurity" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">Der Benutzer verfügt nicht über <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The mutex was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">Der Mutex wurde nicht mit <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph> geöffnet.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object does not represent a named system mutex.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>-Objekt stellt keinen benannten Systemmutex dar.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Öffnet einen bestimmten benannten Mutex, wenn er bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Der Name des zu öffnenden Systemmutex.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Enthält nach Beenden der Methode ein <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>-Objekt, das das benannte Mutex darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn der Aufruf fehlgeschlagen ist.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Dieser Parameter wird nicht initialisiert behandelt.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Öffnet den bestimmten benannten Mutex, wenn er bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der benannte Mutex erfolgreich geöffnet wurde; andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>If the named mutex does not exist, this method does not create it.</source>
          <target state="translated">Wenn der benannte Mutex nicht vorhanden ist, wird es von dieser Methode nicht erstellt.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Systemmutex erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> Konstruktoren, die verfügt über eine <ph id="ph2">`name`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
          <target state="translated">Wenn Sie unsicher sind, ob ein benannter Mutex vorhanden ist, verwenden Sie die Überladung dieser Methode anstelle von der <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> methodenüberladung, die eine Ausnahme auslöst, wenn das Mutex nicht vorhanden ist.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Mehrere Aufrufe dieser Methode, die den gleichen Wert für <ph id="ph1">`name`</ph> nicht unbedingt zurück, die gleiche <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> -Objekt, auch wenn die Objekte, die zurückgegeben werden die gleichen benannten Systemmutex darstellen.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Überladung dieser Methode entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> methodenüberladung und Angeben von <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> und <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> Rechte, die mit dem bitweisen OR-Operation kombiniert.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Angeben der <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> Flag ermöglicht, dass einen Thread das Mutex warten und Angeben der <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> Flag ermöglicht, dass einen Thread aufrufen, die <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Diese Methode ist keine Besitz des Mutex anfordert.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Der Name des zu öffnenden Systemmutex.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Enthält nach Beenden der Methode ein <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>-Objekt, das das benannte Mutex darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn der Aufruf fehlgeschlagen ist.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Dieser Parameter wird nicht initialisiert behandelt.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Öffnet den angegebenen benannten Mutex, wenn er bereits mit dem gewünschten Sicherheitszugriff vorhanden ist und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der benannte Mutex erfolgreich geöffnet wurde; andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>If the named mutex does not exist, this method does not create it.</source>
          <target state="translated">Wenn der benannte Mutex nicht vorhanden ist, wird es von dieser Methode nicht erstellt.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Systemmutex erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> Konstruktoren, die verfügt über eine <ph id="ph2">`name`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
          <target state="translated">Wenn Sie unsicher sind, ob ein benannter Mutex vorhanden ist, verwenden Sie die Überladung dieser Methode anstelle von der <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> methodenüberladung, die eine Ausnahme auslöst, wenn das Mutex nicht vorhanden ist.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">`rights`</ph> -Parameter enthalten muss die <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> Threads ermöglichen, warten Sie auf den Mutex-Flag und der <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> -Kennzeichen an die Threads ermöglichen, rufen Sie die <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Mehrere Aufrufe dieser Methode, die den gleichen Wert für <ph id="ph1">`name`</ph> nicht unbedingt zurück, die gleiche <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> -Objekt, auch wenn die Objekte, die zurückgegeben werden die gleichen benannten Systemmutex darstellen.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Diese Methode ist keine Besitz des Mutex anfordert.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>