<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e1a0b418a2e2951e4941af0cc78868ae967612fa" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83544352" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ein Synchronisierungsprimitiver, der auch für die prozessübergreifende Synchronisierung verwendet werden kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn mindestens zwei Threads gleichzeitig auf eine freigegebene Ressource zugreifen müssen, benötigt das System einen Synchronisierungs Mechanismus, um sicherzustellen, dass die Ressource jeweils nur von einem Thread verwendet wird. <xref:System.Threading.Mutex> ist eine Synchronisierungs primitive, die exklusiven Zugriff auf die freigegebene Ressource nur auf einen Thread gewährt. Wenn ein Thread einen Mutex erhält, wird der zweite Thread, der diesen Mutex erwerben möchte, angehalten, bis der erste Thread den Mutex freigibt.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
 Sie können die <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>-Methode verwenden, um den Besitz eines Mutex anzufordern. Der aufrufende Thread wird blockiert, bis eine der folgenden Aktionen auftritt:  
  
-   Der Mutex wird signalisiert, um anzugeben, dass er nicht im Besitz ist. In diesem Fall gibt die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode `true`zurück, und der aufrufenden Thread übernimmt den Besitz des Mutex und greift auf die durch den Mutex geschützte Ressource zu. Wenn der Zugriff auf die Ressource abgeschlossen ist, muss der Thread die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufrufen, um den Besitz des Mutex freizugeben. Dieses Muster wird im ersten Beispiel im Abschnitt "Beispiele" veranschaulicht.  
  
-   Das Timeout Intervall, das im Aufruf einer <xref:System.Threading.WaitHandle.WaitOne%2A> Methode mit einem `millisecondsTimeout`-oder `timeout`-Parameter angegeben wurde, ist abgelaufen. In diesem Fall gibt die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode `false`zurück, und der aufrufenden Thread versucht nicht, den Besitz des Mutex zu erwerben. In diesem Fall sollten Sie den Code so strukturieren, dass der Zugriff auf die Ressource, die durch den Mutex geschützt ist, dem aufrufenden Thread verweigert wird. Da der Thread niemals den Besitz des Mutex erlangt hat, darf er die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode nicht aufzurufen. Das zweite Beispiel im Abschnitt "Beispiele" veranschaulicht dieses Muster.  
  
 Die <xref:System.Threading.Mutex>-Klasse erzwingt die Thread Identität, sodass ein Mutex nur von dem Thread freigegeben werden kann, der ihn abgerufen hat. Im Gegensatz dazu erzwingt die <xref:System.Threading.Semaphore>-Klasse keine Thread Identität. Ein Mutex kann auch über Anwendungs Domänen Grenzen hinweg übermittelt werden.  
  
 Der Thread, der einen Mutex besitzt, kann denselben Mutex bei wiederholten Aufrufen an <xref:System.Threading.WaitHandle.WaitOne%2A> anfordern, ohne seine Ausführung zu blockieren. Der Thread muss jedoch die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode gleich oft aufzurufen, um den Besitz des Mutex freizugeben.  
  
 Da die <xref:System.Threading.Mutex> Klasse von <xref:System.Threading.WaitHandle>erbt, können Sie auch die statischen <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> und <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> Methoden aufrufen, um den Zugriff auf eine geschützte Ressource zu synchronisieren.  
  
 Wenn ein Thread beendet wird, während er ein Mutex besitzt, wird der Mutex als abgebrochen bezeichnet. Der Mutex-Zustand wird auf "signalisiert" festgelegt, und der nächste wartende Thread erhält den Besitz. Ab Version 2,0 des .NET Framework wird ein <xref:System.Threading.AbandonedMutexException> im nächsten Thread ausgelöst, der den abgebrochenen Mutex abruft. Vor Version 2,0 des .NET Framework wurde keine Ausnahme ausgelöst.  
  
> [!CAUTION]
>  Ein abgebrochener Mutex weist häufig auf einen schwerwiegenden Fehler im Code hin. Wenn ein Thread beendet wird, ohne den Mutex freizugeben, befinden sich die vom Mutex geschützten Datenstrukturen möglicherweise nicht in einem konsistenten Zustand. Der nächste Thread, der den Besitz des Mutex anfordert, kann diese Ausnahme behandeln und fortfahren, wenn die Integrität der Datenstrukturen überprüft werden kann.  
  
 Wenn es sich um einen systemweiten Mutex handelt, kann ein abgebrochener Mutex darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z.B. über den Windows Task-Manager).  
  
 Mutexes gibt zwei Typen: lokale Mutexen, die unbenannt sind und benannte systemmutexen. Ein lokaler Mutex ist nur innerhalb des Prozesses vorhanden. Sie kann von jedem Thread in Ihrem Prozess verwendet werden, der einen Verweis auf das <xref:System.Threading.Mutex> Objekt enthält, das den Mutex darstellt. Jedes unbenannte <xref:System.Threading.Mutex>-Objekt stellt einen separaten lokalen Mutex dar.  
  
 Benannte systemmutexen sind im gesamten Betriebssystem sichtbar und können verwendet werden, um die Aktivitäten von Prozessen zu synchronisieren. Sie können ein <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt, mithilfe eines Konstruktors erstellen, der einen Namen akzeptiert. Das Betriebssystem Objekt kann gleichzeitig erstellt werden, oder es kann vor der Erstellung des <xref:System.Threading.Mutex> Objekts vorhanden sein. Sie können mehrere <xref:System.Threading.Mutex>-Objekte erstellen, die denselben benannten Systemmutex darstellen, und Sie können mithilfe der <xref:System.Threading.Mutex.OpenExisting%2A>-Methode einen vorhandenen benannten Systemmutex öffnen.  
  
> [!NOTE]
>  Auf einem Server, auf dem Terminal Dienste ausgeführt werden, kann ein benannter Systemmutex zwei Ebenen der Sichtbarkeit aufweisen. Wenn der Name mit dem Präfix "Global\\" beginnt, wird der Mutex in allen Terminal Server Sitzungen angezeigt. Wenn der Name mit dem Präfix "local\\" beginnt, ist der Mutex nur in der Terminal Server Sitzung sichtbar, in der er erstellt wurde. In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder der anderen Terminal Server Sitzungen auf dem Server vorhanden sein. Wenn Sie beim Erstellen eines benannten Mutex kein Präfix angeben, wird das Präfix "local\\" benötigt. Innerhalb einer Terminal Server Sitzung sind zwei Mutexen, deren Namen sich nur durch Ihre Präfixe unterscheiden, separate Mutexen, und beide sind für alle Prozesse in der Terminal Server Sitzung sichtbar. Das heißt, die Präfix Namen "Global\\" und "local\\" beschreiben den Bereich des Mutex-namens in Bezug auf Terminal Server Sitzungen, nicht relativ zu Prozessen.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 Dieses Beispiel zeigt, wie ein lokales <xref:System.Threading.Mutex> Objekt verwendet wird, um den Zugriff auf eine geschützte Ressource zu synchronisieren. Da jeder aufrufende Thread blockiert wird, bis er den Besitz des Mutex übernimmt, muss er die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufrufen, um den Besitz des Threads freizugeben.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 Im folgenden Beispiel ruft jeder Thread die <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29>-Methode auf, um den Mutex abzurufen. Wenn das Timeout Intervall abläuft, gibt die Methode `false`zurück, und der Thread erhält weder den Mutex noch den Zugriff auf die Ressource, die der Mutex schützt. Die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode wird nur von dem Thread aufgerufen, der den Mutex abruft.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit Standardeigenschaften.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Konstruktorüberladung entspricht dem Aufrufen der <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>-Konstruktorüberladung und der Angabe `false` für den anfänglichen Besitz des Mutex. Das heißt, der aufrufenden Thread ist nicht der Besitzer des Mutex.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein lokales <xref:System.Threading.Mutex> Objekt verwendet wird, um den Zugriff auf eine geschützte Ressource zu synchronisieren. Der Thread, der den Mutex erstellt, ist nicht anfänglich.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des Mutex zuzuweisen, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein lokales <xref:System.Threading.Mutex> Objekt verwendet wird, um den Zugriff auf eine geschützte Ressource zu synchronisieren. Der Thread, der die <xref:System.Threading.Mutex> erstellt, ist ursprünglich der Besitzer.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <see langword="false" />.</param>
        <param name="name">Der Name des <see cref="T:System.Threading.Mutex" />-Objekts. Bei einem Wert von <see langword="null" /> ist das <see cref="T:System.Threading.Mutex" /> unbenannt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, sowie mit einer Zeichenfolge, die den Namen des Mutex darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `name` nicht `null` und `initiallyOwned` `true`ist, besitzt der aufrufende Thread den Mutex nur dann, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wurde. Da es keinen Mechanismus gibt, um zu bestimmen, ob der benannte Systemmutex erstellt wurde, ist es besser, `false` für `initiallyOwned` anzugeben, wenn diese Konstruktorüberladung aufgerufen wird. Sie können den <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29>-Konstruktor verwenden, wenn Sie den anfänglichen Besitz bestimmen müssen.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt. Sie können mehrere <xref:System.Threading.Mutex> Objekte erstellen, die denselben benannten Systemmutex darstellen.  
  
 Wenn der benannte Mutex bereits mit der Zugriffs Steuerungs Sicherheit erstellt wurde und der Aufrufer nicht über <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>verfügt, wird eine Ausnahme ausgelöst. Informationen zum Öffnen eines vorhandenen benannten Mutex mit nur den Berechtigungen, die für die Synchronisierung von Thread Aktivitäten erforderlich sind, finden Sie unter <xref:System.Threading.Mutex.OpenExisting%2A>-Methode.  
  
 Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokaler Mutex erstellt, als ob Sie den <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>-Konstruktor aufgerufen hätten. In diesem Fall wird `createdNew` immer `true`.  
  
 Da Sie systemweit sind, können benannte Mutexen verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.  
  
> [!NOTE]
>  Auf einem Server, auf dem Terminal Dienste ausgeführt werden, kann ein benannter Systemmutex zwei Ebenen der Sichtbarkeit aufweisen. Wenn der Name mit dem Präfix "Global\\" beginnt, wird der Mutex in allen Terminal Server Sitzungen angezeigt. Wenn der Name mit dem Präfix "local\\" beginnt, ist der Mutex nur in der Terminal Server Sitzung sichtbar, in der er erstellt wurde. In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder der anderen Terminal Server Sitzungen auf dem Server vorhanden sein. Wenn Sie beim Erstellen eines benannten Mutex kein Präfix angeben, wird das Präfix "local\\" benötigt. Innerhalb einer Terminal Server Sitzung sind zwei Mutexen, deren Namen sich nur durch Ihre Präfixe unterscheiden, separate Mutexen, und beide sind für alle Prozesse in der Terminal Server Sitzung sichtbar. Das heißt, die Präfix Namen "Global\\" und "local\\" beschreiben den Bereich des Mutex-namens in Bezug auf Terminal Server Sitzungen, nicht relativ zu Prozessen.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 Das folgende Beispiel zeigt, wie ein benannter Mutex verwendet wird, um zwischen Threads zu signalisieren, die in zwei separaten Prozessen ausgeführt werden.  
  
 Führen Sie dieses Programm von mindestens zwei Befehls Fenstern aus. Jeder Prozess erstellt ein <xref:System.Threading.Mutex> Objekt, das den benannten Mutex-`MyMutex`darstellt. Der benannte Mutex ist ein Systemobjekt, dessen Lebensdauer von der Lebensdauer der <xref:System.Threading.Mutex> Objekte begrenzt ist, die es darstellen. Der benannte Mutex wird erstellt, wenn der erste Prozess das <xref:System.Threading.Mutex>-Objekt erstellt. in diesem Beispiel befindet sich der benannte Mutex im Besitz des ersten Prozesses, in dem das Programm ausgeführt wird. Der benannte Mutex wird zerstört, wenn alle <xref:System.Threading.Mutex> Objekte, die ihn darstellen, freigegeben wurden.  
  
 Die in diesem Beispiel verwendete Konstruktorüberladung kann dem aufrufenden Thread nicht mitteilen, ob der anfängliche Besitz des benannten Mutex gewährt wurde. Sie sollten diesen Konstruktor nicht verwenden, um den anfänglichen Besitz anzufordern, es sei denn, Sie können sicher sein, dass der Thread den benannten Mutex erstellt.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <see langword="false" />.</param>
        <param name="name">Der Name des <see cref="T:System.Threading.Mutex" />-Objekts. Bei einem Wert von <see langword="null" /> ist das <see cref="T:System.Threading.Mutex" /> unbenannt.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode einen booleschen Wert, der <see langword="true" /> ist, wenn ein lokaler Mutex erstellt wurde (d. h. wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn der angegebene benannte Systemmutex erstellt wurde. Der Wert ist <see langword="false" />, wenn der angegebene benannte Systemmutex bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, mit einer Zeichenfolge mit dem Namen des Mutex sowie mit einem booleschen Wert, der beim Beenden der Methode angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex gewährt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `name` nicht `null` und `initiallyOwned` `true`ist, besitzt der aufrufende Thread nur dann den benannten Mutex, wenn `createdNew` nach dem Aufruf `true` wird. Andernfalls kann der Thread den Mutex anfordern, indem er die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aufrufen.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt. Sie können mehrere <xref:System.Threading.Mutex> Objekte erstellen, die denselben benannten Systemmutex darstellen.  
  
 Wenn der benannte Mutex bereits mit der Zugriffs Steuerungs Sicherheit erstellt wurde und der Aufrufer nicht über <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> Rechte verfügt, wird eine Ausnahme ausgelöst. Informationen zum Öffnen eines vorhandenen benannten Mutex mit nur den Berechtigungen, die für die Synchronisierung von Thread Aktivitäten erforderlich sind, finden Sie unter <xref:System.Threading.Mutex.OpenExisting%2A>-Methode.  
  
 Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokaler Mutex erstellt, als ob Sie den <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>-Konstruktor aufgerufen hätten. In diesem Fall wird `createdNew` immer `true`.  
  
 Da Sie systemweit sind, können benannte Mutexen verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.  
  
> [!NOTE]
>  Auf einem Server, auf dem Terminal Dienste ausgeführt werden, kann ein benannter Systemmutex zwei Ebenen der Sichtbarkeit aufweisen. Wenn der Name mit dem Präfix "Global\\" beginnt, wird der Mutex in allen Terminal Server Sitzungen angezeigt. Wenn der Name mit dem Präfix "local\\" beginnt, ist der Mutex nur in der Terminal Server Sitzung sichtbar, in der er erstellt wurde. In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder der anderen Terminal Server Sitzungen auf dem Server vorhanden sein. Wenn Sie beim Erstellen eines benannten Mutex kein Präfix angeben, wird das Präfix "local\\" benötigt. Innerhalb einer Terminal Server Sitzung sind zwei Mutexen, deren Namen sich nur durch Ihre Präfixe unterscheiden, separate Mutexen, und beide sind für alle Prozesse in der Terminal Server Sitzung sichtbar. Das heißt, die Präfix Namen "Global\\" und "local\\" beschreiben den Bereich des Mutex-namens in Bezug auf Terminal Server Sitzungen, nicht relativ zu Prozessen.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie ein benannter Mutex verwendet wird, um zwischen Prozessen oder Threads zu signalisieren. Führen Sie dieses Programm von mindestens zwei Befehls Fenstern aus. Jeder Prozess erstellt ein <xref:System.Threading.Mutex> Objekt, das den benannten Mutex "MyMutex" darstellt. Der benannte Mutex ist ein Systemobjekt. In diesem Beispiel wird seine Lebensdauer von der Lebensdauer der <xref:System.Threading.Mutex> Objekte begrenzt, die es darstellen. Der benannte Mutex wird erstellt, wenn der erste Prozess das lokale <xref:System.Threading.Mutex> Objekt erstellt und zerstört wird, wenn alle <xref:System.Threading.Mutex> Objekte, die es darstellen, freigegeben wurden. Der benannte Mutex gehört anfänglich dem ersten Prozess an. Der zweite Prozess und alle nachfolgenden Prozesse warten darauf, dass frühere Prozesse den benannten Mutex freigeben.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean, mutexSecurity As MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <see langword="false" />.</param>
        <param name="name">Der Name des Systemmutex. Bei einem Wert von <see langword="null" /> ist das <see cref="T:System.Threading.Mutex" /> unbenannt.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode einen booleschen Wert, der <see langword="true" /> ist, wenn ein lokaler Mutex erstellt wurde (d. h. wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn der angegebene benannte Systemmutex erstellt wurde. Der Wert ist <see langword="false" />, wenn der angegebene benannte Systemmutex bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="mutexSecurity">Ein <see cref="T:System.Security.AccessControl.MutexSecurity" /> -Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf den benannten Systemmutex angewendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, mit einer Zeichenfolge mit dem Namen des Mutex, mit einer booleschen Variable, die beim Beenden der Methode angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex gewährt wurde, und mit der Zugriffssteuerungssicherheit, die auf den benannten Mutex angewendet werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `name` nicht `null` und `initiallyOwned` `true`ist, besitzt der aufrufende Thread nur dann den benannten Mutex, wenn `createdNew` nach dem Aufruf `true` wird. Andernfalls kann der Thread den Mutex anfordern, indem er die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aufrufen.  
  
 Verwenden Sie diesen Konstruktor, um die Zugriffs Steuerungs Sicherheit auf einen benannten Systemmutex anzuwenden, wenn er erstellt wird. Dadurch wird verhindert, dass der Mutex von anderen Code gesteuert wird.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Mutex> Objekt, das einen benannten Systemmutex darstellt. Sie können mehrere <xref:System.Threading.Mutex> Objekte erstellen, die denselben benannten Systemmutex darstellen.  
  
 Wenn das benannte Systemmutex nicht vorhanden ist, wird es mit der angegebenen Zugriffs Steuerungs Sicherheit erstellt. Wenn der benannte Mutex vorhanden ist, wird die angegebene Zugriffs Steuerungs Sicherheit ignoriert.  
  
> [!NOTE]
>  Der Aufrufer hat die vollständige Kontrolle über das neu erstellte <xref:System.Threading.Mutex> Objekt, auch wenn `mutexSecurity` dem aktuellen Benutzer einige Zugriffsrechte verweigert oder ihm nicht zuweist. Wenn der aktuelle Benutzer jedoch versucht, ein anderes <xref:System.Threading.Mutex> Objekt zu erhalten, das denselben benannten Mutex darstellt, wobei entweder ein Konstruktor oder die Methode <xref:System.Threading.Mutex.OpenExisting%2A> verwendet wird, wird die Windows-Zugriffs Steuerungs Sicherheit angewendet.  
  
 Wenn der benannte Mutex bereits mit der Zugriffs Steuerungs Sicherheit erstellt wurde und der Aufrufer nicht über <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>verfügt, wird eine Ausnahme ausgelöst. Informationen zum Öffnen eines vorhandenen benannten Mutex mit nur den Berechtigungen, die für die Synchronisierung von Thread Aktivitäten erforderlich sind, finden Sie unter <xref:System.Threading.Mutex.OpenExisting%2A>-Methode.  
  
 Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokaler Mutex erstellt, als ob Sie den <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>-Konstruktor aufgerufen hätten. In diesem Fall wird `createdNew` immer `true`.  
  
 Da Sie systemweit sind, können benannte Mutexen verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.  
  
> [!NOTE]
>  Auf einem Server, auf dem Terminal Dienste ausgeführt werden, kann ein benannter Systemmutex zwei Ebenen der Sichtbarkeit aufweisen. Wenn der Name mit dem Präfix "Global\\" beginnt, wird der Mutex in allen Terminal Server Sitzungen angezeigt. Wenn der Name mit dem Präfix "local\\" beginnt, ist der Mutex nur in der Terminal Server Sitzung sichtbar, in der er erstellt wurde. In diesem Fall kann ein separater Mutex mit dem gleichen Namen in jeder der anderen Terminal Server Sitzungen auf dem Server vorhanden sein. Wenn Sie beim Erstellen eines benannten Mutex kein Präfix angeben, wird das Präfix "local\\" benötigt. Innerhalb einer Terminal Server Sitzung sind zwei Mutexen, deren Namen sich nur durch Ihre Präfixe unterscheiden, separate Mutexen, und beide sind für alle Prozesse in der Terminal Server Sitzung sichtbar. Das heißt, die Präfix Namen "Global\\" und "local\\" beschreiben den Bereich des Mutex-namens in Bezug auf Terminal Server Sitzungen, nicht relativ zu Prozessen.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Mutex mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benannter Mutex vorhanden ist.  
  
 Wenn der Mutex nicht vorhanden ist, wird er mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, der dem aktuellen Benutzer das Recht verweigert, den Mutex zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für den Mutex zu lesen und zu ändern.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, um den Mutex mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird der Mutex mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist länger als 260 Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.MutexSecurity" />-Objekt ab, das die Zugriffssteuerungssicherheit für den benannten Mutex darstellt.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.MutexSecurity" />-Objekt, das die Zugriffssteuerungssicherheit für den benannten Mutex darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Mutex.GetAccessControl%2A>-Methode verwendet die folgende Kombination von-Flags (kombiniert mithilfe des bitweisen OR-Vorgangs), um nach Berechtigungen zu suchen: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Der Benutzer muss über <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> verfügen, um diese Methode aufzurufen, und der Mutex muss mit <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>geöffnet worden sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Mutex mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benannter Mutex vorhanden ist.  
  
 Wenn der Mutex nicht vorhanden ist, wird er mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, der dem aktuellen Benutzer das Recht verweigert, den Mutex zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für den Mutex zu lesen und zu ändern.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, um den Mutex mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind, mithilfe der Methoden <xref:System.Threading.Mutex.GetAccessControl%2A> und <xref:System.Threading.Mutex.SetAccessControl%2A>.  
  
 Nachdem die Berechtigungen geändert wurden, wird der Mutex mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle <see cref="T:System.Threading.Mutex" />-Objekt stellt einen benannten Systemmutex dar. Der Benutzer verfügt jedoch nicht über <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
- oder - 
Das aktuelle <see cref="T:System.Threading.Mutex" />-Objekt stellt einen benannten Systemmutex dar und wurde nicht mit <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> geöffnet.</exception>
        <exception cref="T:System.NotSupportedException">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet einen bestimmten benannten Mutex, wenn er bereits vorhanden ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemmutex.</param>
        <summary>Öffnet den bestimmten benannten Mutex, wenn er bereits vorhanden ist.</summary>
        <returns>Ein Objekt, das den benannten Systemmutex darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Mutex.OpenExisting%2A>-Methode versucht, den angegebenen benannten Systemmutex zu öffnen. Wenn der Systemmutex nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemobjekt zu erstellen. Um den Systemmutex zu erstellen, wenn er noch nicht vorhanden ist, verwenden Sie einen der <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Mutex> Objekt zurück, auch wenn die zurückgegebenen Objekte denselben benannten Systemmutex darstellen.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs.  
  
 Wenn Sie das <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>-Flag angeben, kann ein Thread auf den Mutex warten, und die Angabe des <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufzurufen.  
  
 Diese Methode fordert den Besitz des Mutex nicht an.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Mutex mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benannter Mutex vorhanden ist.  
  
 Wenn der Mutex nicht vorhanden ist, wird er mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, der dem aktuellen Benutzer das Recht verweigert, den Mutex zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für den Mutex zu lesen und zu ändern.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, um den Mutex mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird der Mutex mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Der benannte Mutex ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemmutex.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <summary>Öffnet den angegebenen benannten Mutex, wenn er bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</summary>
        <returns>Ein Objekt, das den benannten Systemmutex darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `rights`-Parameter muss das <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads auf den Mutex warten können, und das <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufrufen können.  
  
 Die <xref:System.Threading.Mutex.OpenExisting%2A>-Methode versucht, einen vorhandenen benannten Mutex zu öffnen. Wenn der Systemmutex nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemobjekt zu erstellen. Um den Systemmutex zu erstellen, wenn er noch nicht vorhanden ist, verwenden Sie einen der <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Mutex> Objekt zurück, auch wenn die zurückgegebenen Objekte denselben benannten Systemmutex darstellen.  
  
 Diese Methode fordert den Besitz des Mutex nicht an.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Mutex mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benannter Mutex vorhanden ist.  
  
 Wenn der Mutex nicht vorhanden ist, wird er mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, der dem aktuellen Benutzer das Recht verweigert, den Mutex zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für den Mutex zu lesen und zu ändern.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, um den Mutex mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird der Mutex mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Der benannte Mutex ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Mutex ist vorhanden aber der Benutzer verfügt nicht über den gewünschten Sicherheitszugriff.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das <see cref="T:System.Threading.Mutex" /> einmal frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Thread einen Mutex erhält (z. b. durch Aufrufen seiner <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode), muss er anschließend <xref:System.Threading.Mutex.ReleaseMutex%2A> aufrufen, um den Besitz des Mutex zu übertragen und andere Threads zu blockieren, die versuchen, den Besitz des Mutex zu erhalten. Wenn der Versuch, den Besitz des Mutex zu erhalten, fehlschlägt (z. b. Wenn ein Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode mit einem `millisecondsTimeout` oder einem `timeout`-Parameter `false` zurückgibt, weil die Anforderung ein Timeout hat), sollte der Thread <xref:System.Threading.Mutex.ReleaseMutex%2A>nicht aufrufen können, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Ein Thread, der einen Mutex besitzt, kann denselben Mutex in wiederholten Wait-Funktionsaufrufen angeben, ohne dessen Ausführung zu blockieren. Die Anzahl der Aufrufe wird vom Common Language Runtime beibehalten. Der Thread muss <xref:System.Threading.Mutex.ReleaseMutex%2A> gleichzeitig aufzurufen, um den Besitz des Mutex freizugeben.  
  
 Wenn ein Thread beendet wird, während er ein Mutex besitzt, wird der Mutex als abgebrochen bezeichnet. Der Zustand des Mutex ist auf "signalisiert" festgelegt, und der nächste wartende Thread erhält den Besitz. Wenn keiner der Mutex gehört, wird der Zustand des Mutex signalisiert. Ab Version 2,0 des .NET Framework wird ein <xref:System.Threading.AbandonedMutexException> im nächsten Thread ausgelöst, der den Mutex abruft. Vor Version 2,0 des .NET Framework wurde keine Ausnahme ausgelöst.  
  
> [!CAUTION]
>  Ein abgebrochener Mutex weist häufig auf einen schwerwiegenden Fehler im Code hin. Wenn ein Thread beendet wird, ohne den Mutex freizugeben, befinden sich die vom Mutex geschützten Datenstrukturen möglicherweise nicht in einem konsistenten Zustand. Der nächste Thread, der den Besitz des Mutex anfordert, kann diese Ausnahme behandeln und fortfahren, wenn die Integrität der Datenstrukturen überprüft werden kann.  
  
 Wenn es sich um einen systemweiten Mutex handelt, kann ein abgebrochener Mutex darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z.B. über den Windows Task-Manager).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein lokales <xref:System.Threading.Mutex> Objekt verwendet wird, um den Zugriff auf eine geschützte Ressource zu synchronisieren. Der Thread, der den Mutex erstellt, ist nicht anfänglich. Die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode wird verwendet, um den Mutex freizugeben, wenn er nicht mehr benötigt wird.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Der aufrufende Thread besitzt den Mutex nicht.</exception>
        <exception cref="T:System.ObjectDisposedException">Die aktuelle Instanz wurde bereits verworfen.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (mutexSecurity As MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">Ein <see cref="T:System.Security.AccessControl.MutexSecurity" /> -Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf den benannten Systemmutex angewendet werden soll.</param>
        <summary>Legt die Zugriffssteuerungssicherheit für einen benannten Systemmutex fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss über <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> Rechte verfügen, um diese Methode aufzurufen, und der Mutex muss mit <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>geöffnet worden sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Mutex mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benannter Mutex vorhanden ist.  
  
 Wenn der Mutex nicht vorhanden ist, wird er mit dem anfänglichen Besitz und der Zugriffs Steuerungs Sicherheit erstellt, der dem aktuellen Benutzer das Recht verweigert, den Mutex zu verwenden, gewährt jedoch das Recht, Lese-und Änderungs Berechtigungen für den Mutex zu lesen und zu ändern.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen von <xref:System.Threading.Mutex.OpenExisting%28System.String%29>eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, um den Mutex mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind, mithilfe der Methoden <xref:System.Threading.Mutex.GetAccessControl%2A> und <xref:System.Threading.Mutex.SetAccessControl%2A>.  
  
 Nachdem die Berechtigungen geändert wurden, wird der Mutex mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mutexSecurity" /> ist <see langword="null" /></exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
- oder - 
Der Mutex wurde nicht mit <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> geöffnet.</exception>
        <exception cref="T:System.SystemException">Das aktuelle <see cref="T:System.Threading.Mutex" />-Objekt stellt keinen benannten Systemmutex dar.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet einen bestimmten benannten Mutex, wenn er bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemmutex.</param>
        <param name="result">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Mutex" />-Objekt, das das benannte Mutex darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist. Dieser Parameter wird als nicht initialisiert behandelt.</param>
        <summary>Öffnet den bestimmten benannten Mutex, wenn er bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn der benannte Mutex erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der benannte Mutex nicht vorhanden ist, wird er von dieser Methode nicht erstellt. Um den Systemmutex zu erstellen, wenn er noch nicht vorhanden ist, verwenden Sie einen der <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Wenn Sie unsicher sind, ob ein benannter Mutex vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.Mutex.OpenExisting%28System.String%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn der Mutex nicht vorhanden ist.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Mutex> Objekt zurück, auch wenn die zurückgegebenen Objekte denselben benannten Systemmutex darstellen.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs. Wenn Sie das <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>-Flag angeben, kann ein Thread auf den Mutex warten, und die Angabe des <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufzurufen.  
  
 Diese Methode fordert den Besitz des Mutex nicht an.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemmutex.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <param name="result">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Mutex" />-Objekt, das das benannte Mutex darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist. Dieser Parameter wird als nicht initialisiert behandelt.</param>
        <summary>Öffnet den angegebenen benannten Mutex, wenn er bereits mit dem gewünschten Sicherheitszugriff vorhanden ist und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn der benannte Mutex erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der benannte Mutex nicht vorhanden ist, wird er von dieser Methode nicht erstellt. Um den Systemmutex zu erstellen, wenn er noch nicht vorhanden ist, verwenden Sie einen der <xref:System.Threading.Mutex.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Wenn Sie unsicher sind, ob ein benannter Mutex vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn der Mutex nicht vorhanden ist.  
  
 Der `rights`-Parameter muss das <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads auf den Mutex warten können, und das <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode aufrufen können.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Mutex> Objekt zurück, auch wenn die zurückgegebenen Objekte denselben benannten Systemmutex darstellen.  
  
 Diese Methode fordert den Besitz des Mutex nicht an.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
