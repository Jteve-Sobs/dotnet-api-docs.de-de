<Type Name="Timer" FullName="System.Threading.Timer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="565a536e43f9a27fd9fc22449e23dcf0b112f8fa" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52213663" /></Metadata><TypeSignature Language="C#" Value="public sealed class Timer : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Timer extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Timer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Timer&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Timer</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Mechanismus zum Ausführen einer Methode für einen Threadpoolthread in angegebenen Intervallen bereit. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden einer <xref:System.Threading.TimerCallback> Delegaten an die Methode, Sie möchten, die <xref:System.Threading.Timer> ausgeführt. Die Signatur der <xref:System.Threading.TimerCallback> Delegat ist:  
  
```csharp  
void TimerCallback(Object state)  
```  
  
```cpp  
void TimerCallback(Object state)  
```  
  
```vb  
Sub TimerCallback(state As Object)  
```  
  
 Der Timer-Delegat wird angegeben, wenn der Zeitgeber wird erstellt, und kann nicht geändert werden. Die Methode wird nicht auf dem Thread ausgeführt, die den Timer erstellt; Sie führt auf einer <xref:System.Threading.ThreadPool> vom System bereitgestellten Thread.  
  
> [!TIP]
> .NET umfasst vier Klassen, die mit dem Namen `Timer`, die jeweils von der anderen Funktionen bietet:  
>
> - <xref:System.Timers.Timer?displayProperty=nameWithType>, der löst ein Ereignis aus, und führt den Code in eine oder mehrere Ereignissenken in regelmäßigen Abständen. Die Klasse dient zur Verwendung als ein serverbasiertes oder Dienstkomponente in einer Multithreadumgebung; Es hat keine Benutzeroberfläche und nicht zur Laufzeit sichtbar ist.
> - <xref:System.Threading.Timer?displayProperty=nameWithType>, der eine einzelne Callback-Methode auf einem Threadpoolthread in regelmäßigen Abständen ausgeführt wird. Die Rückrufmethode wird definiert, wenn der Zeitgeber instanziiert wird und kann nicht geändert werden. Wie die <xref:System.Timers.Timer?displayProperty=nameWithType> -Klasse, diese Klasse ist für die Verwendung als Server-basierten oder Service-Komponente in einer Multithreadumgebung vorgesehen, da es keine Benutzeroberfläche hat und nicht zur Laufzeit sichtbar ist.
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Nur .NET Framework), eine Windows Forms-Komponente, löst ein Ereignis aus und führt den Code in eine oder mehrere Ereignissenken in regelmäßigen Abständen. Die Komponente weist keine Benutzeroberfläche und dient zur Verwendung in einer Umgebung mit Singlethread; Sie führt die UI-Thread.
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (Nur .NET Framework), ein ASP.NET-Komponente, die Webseite für asynchrone oder synchrone Postbacks in regelmäßigen Intervallen ausführt.
  
 Wenn Sie einen Timer erstellen, können Sie eine Zeitspanne wartet, bevor die erste Ausführung der Methode angeben (Fälligkeitszeitpunkt), und eine Menge an Wartezeit zwischen nachfolgende Ausführungen (Punkt). Die <xref:System.Threading.Timer> -Klasse verfügt über die gleiche Auflösung wie der Systemuhr. Dies bedeutet, dass, wenn der Zeitraum weniger als die Auflösung der Systemuhr an, die <xref:System.Threading.TimerCallback> Delegat in Intervallen, definiert durch die Auflösung der Systemuhr, handelt es sich etwa 15 Millisekunden auf Systemen mit Windows 7 und Windows 8 ausgeführt wird. Sie können ändern, den Gesamtbetrag Zeit und Zeitraum oder deaktivieren Sie den Timer, mithilfe der <xref:System.Threading.Timer.Change%2A> Methode.  
  
> [!NOTE]
>  Solange Sie verwenden eine <xref:System.Threading.Timer>, Sie müssen einen Verweis darauf beibehalten. Wie bei der ein verwaltetes Objekt, ein <xref:System.Threading.Timer> Garbagecollection unterliegt, wenn keine Verweise darauf vorhanden sind. Die Tatsache, die eine <xref:System.Threading.Timer> ist noch aktiv verhindert nicht, dass es gesammelt werden.  
  
 Wenn ein Zeitgeber nicht mehr benötigt wird, verwenden Sie die <xref:System.Threading.Timer.Dispose%2A> -Methode zum Freigeben von Ressourcen frei, die den Timer. Beachten Sie, dass Rückrufe, nachdem auftreten können die <xref:System.Threading.Timer.Dispose> Überladung aufgerufen wurde, da der Timer-Rückrufe für die Ausführung von Threads im Threadpool Warteschlangen. Sie können die <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> -methodenüberladung, um zu warten, bis alle Rückrufe abgeschlossen haben.  
  
 Die Callback-Methode, die von der Zeitgeber ausgeführt werden sollte wiedereintrittsfähig, das sein, da der Aufruf für <xref:System.Threading.ThreadPool> Threads. Der Rückruf kann gleichzeitig auf zwei Threads im Threadpool ausgeführt werden, wenn das Zeitgeberintervall kleiner als der Zeitaufwand für den Rückruf ausgeführt wird oder alle Threads im Threadpool verwendet werden, und der Rückruf wird mehrere Male in der Warteschlange.  
  
> [!NOTE]
>  <xref:System.Threading.Timer?displayProperty=nameWithType> ist ein einfacher, Zeitgeber, der Rückrufmethoden verwendet und wird von Threads im Threadpool versorgt. Es wird nicht für die Verwendung mit Windows Forms, empfohlen, da die Rückrufe für den Benutzeroberflächenthread nicht auftreten. <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> ist eine bessere Wahl für die Verwendung mit Windows Forms. Für die serverbasierte timerfunktionalität, verwenden Sie ggf. <xref:System.Timers.Timer?displayProperty=nameWithType>, die Ereignisse auslöst, und verfügt über zusätzliche Funktionen.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `StatusChecker` -Klasse, enthält eine `CheckStatus` , deren Signatur der entspricht, Methode als die <xref:System.Threading.TimerCallback> delegieren. Die `state` Argument der `CheckStatus` Methode ist ein <xref:System.Threading.AutoResetEvent> -Objekt, das zum Synchronisieren von Threads der Anwendung und der Threadpool-Thread, der den Callback-Delegaten ausführt verwendet wird. Die `StatusChecker` -Klasse enthält auch zwei Zustandsvariablen:  
  
 `invokeCount`  
 Gibt die Anzahl der Häufigkeit, mit der die Rückrufmethode aufgerufen wurde.  
  
 `maxCount`  
 Bestimmt die maximale Anzahl der Häufigkeit, mit der die Rückrufmethode aufgerufen werden soll.  
  
 Thread der Anwendung erstellt, den Timer wartet eine Sekunde und führt dann die `CheckStatus` Callback-Methode alle 250 Millisekunden. Klicken Sie dann dem Thread der Anwendung blockiert, bis die <xref:System.Threading.AutoResetEvent> Objekts signalisiert wird. Wenn die `CheckStatus` Rückrufmethode `maxCount` -Mal ab, ruft der `AutoResetEvent.Set` Methode zum Festlegen des Status von der <xref:System.Threading.AutoResetEvent> Objekt, das signalisiert. Beim ersten in diesem Fall der Anwendungsthread Ruft die <xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29> Methode, damit die Callback-Methode jetzt jede halbe Sekunde ausgeführt wird. Er erneut blockiert, bis die <xref:System.Threading.AutoResetEvent> Objekts signalisiert wird. In diesem Fall wird der Timer durch Aufrufen von zerstört seine <xref:System.Threading.Timer.Dispose%2A> -Methode, und die Anwendung beendet wird.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.Threading.TimerCallback" />
    <related type="Article" href="~/docs/standard/threading/timers.md">Timer</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Verwalteter Threadpool</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see langword="Timer" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback -&gt; System.Threading.Timer" Usage="new System.Threading.Timer callback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Ein <see cref="T:System.Threading.TimerCallback" />-Delegat, der die auszuführende Methode darstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Timer" />-Klasse mit einem unendlichen Zeitraum und einer unendlichen Vorlaufzeit, wobei das neu erstellte <see cref="T:System.Threading.Timer" />-Objekt als Zustandsobjekt verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diesen Konstruktor, wenn Sie, verwenden möchten die <xref:System.Threading.Timer> Objekt selbst als Zustandsobjekt. Verwenden Sie nach dem Erstellen des Zeitgebers die <xref:System.Threading.Timer.Change%2A> Methode, um das Intervall und die Fälligkeitszeitpunkt festzulegen.  
  
 Dieser Konstruktor wird von einer unendlichen Vorlaufzeit vor dem ersten Rückruf und ein unendliches Intervall zwischen Rückrufen, um zu verhindern, dass den ersten Rückruf, der vor dem Auftreten der <xref:System.Threading.Timer> das Zustandsobjekt, das Objekt zugewiesen wird.  
  
 Für die angegebene Methode `callback` sollte wiedereintrittsfähig, das sein, da der Aufruf für <xref:System.Threading.ThreadPool> Threads. Die Methode kann für zwei Threads des Threadpools gleichzeitig ausgeführt werden, wenn das Zeitgeberintervall kleiner als die erforderliche Zeit zum Ausführen der Methode ist oder wenn alle Threads im Threadpool verwendet werden, und die-Methode mehrere Male in die Warteschlange eingereiht wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen neuen Timer mithilfe des Zeitgebers selbst als Zustandsobjekt. Die <xref:System.Threading.Timer.Change%2A> Methode wird verwendet, um den Timer zu starten. Tritt der Timer-Rückruf auf, wird das Zustandsobjekt, das verwendet, um den Timer zu deaktivieren.  
  
 [!code-csharp[TimerSelfCtor#1](~/samples/snippets/csharp/VS_Snippets_Misc/timerSelfCtor/CS/source.cs#1)]
 [!code-vb[TimerSelfCtor#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/timerSelfCtor/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Integer, period As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, int dueTime, int period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * int * int -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="callback">Ein <see cref="T:System.Threading.TimerCallback" />-Delegat, der die auszuführende Methode darstellt.</param>
        <param name="state">Ein Objekt, das die von der Rückrufmethode zu verwendenden Informationen enthält, oder <see langword="null" />.</param>
        <param name="dueTime">Die in Millisekunden angegebene Zeitspanne, die gewartet werden soll, bis <paramref name="callback" /> aufgerufen wird. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um das Starten des Zeitgebers zu verhindern. Geben Sie 0 (null) an, um den Timer sofort zu starten.</param>
        <param name="period">Das in Millisekunden angegebene Zeitintervall zwischen den Aufrufen von <paramref name="callback" />. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um periodisches Signalisieren zu deaktivieren.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="Timer" />-Klasse unter Verwendung einer 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die vom angegebenen Delegaten die `callback` -Parameter aufgerufen wird, nach `dueTime` abgelaufen ist, und anschließend jedes Mal die `period` Zeit Intervall abgelaufen ist.  
  
 Wenn `dueTime` ist 0 (null), `callback` sofort aufgerufen wird. Wenn `dueTime` ist <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` nicht aufgerufen; der Zeitgeber deaktiviert ist, aber kann wieder aktiviert werden, durch den Aufruf der <xref:System.Threading.Timer.Change%2A> Methode.  
  
 Da die <xref:System.Threading.Timer> -Klasse verfügt über die gleiche Auflösung wie der Systemuhr, handelt es sich etwa 15 Millisekunden auf Windows 7 und Windows 8-Systemen, die `callback` Delegaten ausführt, in Intervallen, die durch die Auflösung der Systemuhr definierten `period`ist kleiner als die Auflösung der Systemuhr. Wenn `period` ist 0 (null) oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> und `dueTime` nicht <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` wird aufgerufen, einmal an; das periodische Verhalten des Zeitgebers ist deaktiviert, aber können erneut aktiviert werden mithilfe der <xref:System.Threading.Timer.Change%2A> Methode.  
  
 Für die angegebene Methode `callback` sollte wiedereintrittsfähig, das sein, da der Aufruf für <xref:System.Threading.ThreadPool> Threads. Die Methode kann für zwei Threads des Threadpools gleichzeitig ausgeführt werden, wenn das Zeitgeberintervall kleiner als die erforderliche Zeit zum Ausführen der Methode ist oder wenn alle Threads im Threadpool verwendet werden, und die-Methode mehrere Male in die Warteschlange eingereiht wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen einer `TimerCallback` delegieren und initialisiert eine neue Instanz der dem `Timer` Klasse.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="dueTime" />-Parameter oder der <paramref name="period" />-Parameter ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="callback" />-Parameter ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Timer</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Long, period As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, long dueTime, long period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * int64 * int64 -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="callback">Ein <see cref="T:System.Threading.TimerCallback" />-Delegat, der die auszuführende Methode darstellt.</param>
        <param name="state">Ein Objekt, das die von der Rückrufmethode zu verwendenden Informationen enthält, oder <see langword="null" />.</param>
        <param name="dueTime">Die in Millisekunden angegebene Zeitspanne, die gewartet werden soll, bis <paramref name="callback" /> aufgerufen wird. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um das Starten des Zeitgebers zu verhindern. Geben Sie 0 (null) an, um den Timer sofort zu starten.</param>
        <param name="period">Das in Millisekunden angegebene Zeitintervall zwischen den Aufrufen von <paramref name="callback" />. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um periodisches Signalisieren zu deaktivieren.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="Timer" />-Klasse unter Verwendung von 64-Bit-Ganzzahlen mit Vorzeichen zum Messen von Zeitintervallen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die vom angegebenen Delegaten die `callback` -Parameter aufgerufen wird, nach `dueTime` abgelaufen ist, und anschließend jedes Mal die `period` Zeit Intervall abgelaufen ist.  
  
 Wenn `dueTime` ist 0 (null), `callback` sofort aufgerufen wird. Wenn `dueTime` ist <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` nicht aufgerufen; der Zeitgeber deaktiviert ist, aber kann wieder aktiviert werden, durch den Aufruf der <xref:System.Threading.Timer.Change%2A> Methode.  
  
 Da die <xref:System.Threading.Timer> -Klasse verfügt über die gleiche Auflösung wie der Systemuhr, handelt es sich etwa 15 Millisekunden auf Windows 7 und Windows 8-Systemen, die `callback` Delegaten ausführt, in Intervallen, die durch die Auflösung der Systemuhr definierten `period`ist kleiner als die Auflösung der Systemuhr. Wenn `period` ist 0 (null) oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> und `dueTime` nicht <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` wird aufgerufen, einmal an; das periodische Verhalten des Zeitgebers ist deaktiviert, aber können erneut aktiviert werden mithilfe der <xref:System.Threading.Timer.Change%2A> Methode.  
  
 Für die angegebene Methode `callback` sollte wiedereintrittsfähig, das sein, da der Aufruf für <xref:System.Threading.ThreadPool> Threads. Die Methode kann für zwei Threads des Threadpools gleichzeitig ausgeführt werden, wenn das Zeitgeberintervall kleiner als die erforderliche Zeit zum Ausführen der Methode ist oder wenn alle Threads im Threadpool verwendet werden, und die-Methode mehrere Male in die Warteschlange eingereiht wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="dueTime" />-Parameter oder der <paramref name="period" />-Parameter ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.NotSupportedException">Der <paramref name="dueTime" />-Parameter oder der <paramref name="period" />-Parameter ist größer als 4.294.967.294.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Timer</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As TimeSpan, period As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * TimeSpan * TimeSpan -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der eine auszuführende Methode darstellt.</param>
        <param name="state">Ein Objekt, das die von der Rückrufmethode zu verwendenden Informationen enthält, oder <see langword="null" />.</param>
        <param name="dueTime">Die Zeitspanne, die gewartet werden soll, bis der <paramref name="callback" />-Parameter die zugehörigen Methoden aufruft. Geben Sie „-1“ Millisekunde an, um das Starten des Timers zu verhindern. Geben Sie 0 (null) an, um den Timer sofort zu starten.</param>
        <param name="period">Das Zeitintervall zwischen Aufrufen der Methoden, auf die durch <paramref name="callback" /> verwiesen wird. Geben Sie -1 Millisekunde an, um periodisches Signalisieren zu deaktivieren.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="Timer" />-Klasse unter Verwendung von <see cref="T:System.TimeSpan" />-Werten zum Messen von Zeitintervallen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die vom angegebenen Delegaten die `callback` -Parameter aufgerufen wird, nach `dueTime` abgelaufen ist, und anschließend jedes Mal die `period` Zeit Intervall abgelaufen ist.  
  
 Wenn `dueTime` ist 0 (null), `callback` sofort aufgerufen wird. Wenn `dueTime` ist (1) Millisekunde, `callback` nicht aufgerufen; der Zeitgeber deaktiviert ist, aber kann wieder aktiviert werden, durch den Aufruf der <xref:System.Threading.Timer.Change%2A> Methode.  
  
 Da die <xref:System.Threading.Timer> -Klasse verfügt über die gleiche Auflösung wie der Systemuhr, handelt es sich etwa 15 Millisekunden auf Windows 7 und Windows 8-Systemen, die `callback` Delegaten ausführt, in Intervallen, die durch die Auflösung der Systemuhr definierten `period`ist kleiner als die Auflösung der Systemuhr. Wenn `period` ist 0 (null) oder negative Eins (1)-Millisekunden und `dueTime` positiv ist, werden `callback` wird aufgerufen, einmal an; das periodische Verhalten des Zeitgebers ist deaktiviert, aber können erneut aktiviert werden mithilfe der <xref:System.Threading.Timer.Change%2A> Methode.  
  
 Für die angegebene Methode `callback` sollte wiedereintrittsfähig, das sein, da der Aufruf für <xref:System.Threading.ThreadPool> Threads. Die Methode kann für zwei Threads des Threadpools gleichzeitig ausgeführt werden, wenn das Zeitgeberintervall kleiner als die erforderliche Zeit zum Ausführen der Methode ist oder wenn alle Threads im Threadpool verwendet werden, und die-Methode mehrere Male in die Warteschlange eingereiht wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen einer `TimerCallback` delegieren und initialisiert eine neue Instanz der dem `Timer` Klasse.  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Anzahl der Millisekunden im Wert von <paramref name="dueTime" /> oder <paramref name="period" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" /> oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="callback" />-Parameter ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Timer</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As UInteger, period As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, System::UInt32 dueTime, System::UInt32 period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * uint32 * uint32 -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der eine auszuführende Methode darstellt.</param>
        <param name="state">Ein Objekt, das die von der Rückrufmethode zu verwendenden Informationen enthält, oder <see langword="null" />.</param>
        <param name="dueTime">Die in Millisekunden angegebene Zeitspanne, die gewartet werden soll, bis <paramref name="callback" /> aufgerufen wird. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um das Starten des Zeitgebers zu verhindern. Geben Sie 0 (null) an, um den Timer sofort zu starten.</param>
        <param name="period">Das in Millisekunden angegebene Zeitintervall zwischen den Aufrufen von <paramref name="callback" />. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um periodisches Signalisieren zu deaktivieren.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="Timer" />-Klasse unter Verwendung von 32-Bit-Ganzzahlen ohne Vorzeichen zum Messen von Zeitintervallen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die vom angegebenen Delegaten die `callback` -Parameter aufgerufen wird, nach `dueTime` abgelaufen ist, und anschließend jedes Mal die `period` Zeit Intervall abgelaufen ist.  
  
 Wenn `dueTime` ist 0 (null), `callback` sofort aufgerufen wird. Wenn `dueTime` ist <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` nicht aufgerufen; der Zeitgeber deaktiviert ist, aber kann wieder aktiviert werden, durch den Aufruf der <xref:System.Threading.Timer.Change%2A> Methode.  
  
 Da die <xref:System.Threading.Timer> -Klasse verfügt über die gleiche Auflösung wie der Systemuhr, handelt es sich etwa 15 Millisekunden auf Windows 7 und Windows 8-Systemen, die `callback` Delegaten ausführt, in Intervallen, die durch die Auflösung der Systemuhr definierten `period`ist kleiner als die Auflösung der Systemuhr. Wenn `period` ist 0 (null) oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> und `dueTime` nicht <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` wird aufgerufen, einmal an; das periodische Verhalten des Zeitgebers ist deaktiviert, aber können erneut aktiviert werden mithilfe der <xref:System.Threading.Timer.Change%2A> Methode.  
  
 Für die angegebene Methode `callback` sollte wiedereintrittsfähig, das sein, da der Aufruf für <xref:System.Threading.ThreadPool> Threads. Die Methode kann für zwei Threads des Threadpools gleichzeitig ausgeführt werden, wenn das Zeitgeberintervall kleiner als die erforderliche Zeit zum Ausführen der Methode ist oder wenn alle Threads im Threadpool verwendet werden, und die-Methode mehrere Male in die Warteschlange eingereiht wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="dueTime" />-Parameter oder der <paramref name="period" />-Parameter ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="callback" />-Parameter ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Timer</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Change">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ändert die Startzeit und das Intervall zwischen Methodenaufrufen für einen Zeitgeber.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Integer, period As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(int dueTime, int period);" />
      <MemberSignature Language="F#" Value="member this.Change : int * int -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dueTime">Die in Millisekunden angegebene Zeitspanne, die gewartet werden soll, bis die beim Erstellen von <see cref="T:System.Threading.Timer" /> angegebene Rückrufmethode aufgerufen wird. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um den Neustart des Zeitgebers zu verhindern. Geben Sie 0 (null) an, um den Timer sofort neu zu starten.</param>
        <param name="period">Das Zeitintervall zwischen den Aufrufen der beim Erstellen von <see cref="T:System.Threading.Timer" /> angegebenen Rückrufmethode in Millisekunden. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um periodisches Signalisieren zu deaktivieren.</param>
        <summary>Ändert die Startzeit und das Intervall zwischen Methodenaufrufen für einen Timer unter Verwendung von 32-Bit-Ganzzahlen mit Vorzeichen zum Messen von Zeitintervallen.</summary>
        <returns><see langword="true" />, wenn der Timer erfolgreich aktualisiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Callback-Methode wird aufgerufen, einmal nach `dueTime` abgelaufen ist, und anschließend jedes Mal durch angegebene Zeitintervall `period` abgelaufen ist.  
  
 Wenn `dueTime` ist 0 (null), die Callback-Methode wird sofort aufgerufen. Wenn `dueTime` ist <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>wird die Rückrufmethode wird nie aufgerufen; der Zeitgeber deaktiviert ist, kann aber wieder aktiviert werden, durch den Aufruf <xref:System.Threading.Timer.Change%2A> und geben Sie einen positiven Wert für `dueTime`.  
  
 Wenn `period` ist 0 (null) oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, und `dueTime` nicht <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>wird die Callback-Methode wird einmal aufgerufen werden; das periodische Verhalten des Zeitgebers ist deaktiviert, kann aber wieder aktiviert werden, durch den Aufruf <xref:System.Threading.Timer.Change%2A> und geben Sie einen positiven Wert für `period`.  
  
 Die <xref:System.Threading.Timer.Change%2A> Methode kann aufgerufen werden, aus der <xref:System.Threading.TimerCallback> delegieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zu einem `Timer` und ändern Sie nach einer bestimmten Anzahl von aufrufen, die der Zeitraum.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Threading.Timer" /> wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="dueTime" />-Parameter oder der <paramref name="period" />-Parameter ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Timer</related>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Long, period As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(long dueTime, long period);" />
      <MemberSignature Language="F#" Value="member this.Change : int64 * int64 -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="dueTime">Die in Millisekunden angegebene Zeitspanne, die gewartet werden soll, bis die beim Erstellen von <see cref="T:System.Threading.Timer" /> angegebene Rückrufmethode aufgerufen wird. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um den Neustart des Zeitgebers zu verhindern. Geben Sie 0 (null) an, um den Timer sofort neu zu starten.</param>
        <param name="period">Das Zeitintervall zwischen den Aufrufen der beim Erstellen von <see cref="T:System.Threading.Timer" /> angegebenen Rückrufmethode in Millisekunden. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um periodisches Signalisieren zu deaktivieren.</param>
        <summary>Ändert die Startzeit und das Intervall zwischen Methodenaufrufen für einen Timer unter Verwendung von 64-Bit-Ganzzahlen mit Vorzeichen zum Messen von Zeitintervallen.</summary>
        <returns><see langword="true" />, wenn der Timer erfolgreich aktualisiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Callback-Methode wird aufgerufen, einmal nach `dueTime` abgelaufen ist, und anschließend jedes Mal durch angegebene Zeitintervall `period` abgelaufen ist.  
  
 Wenn `dueTime` ist 0 (null), die Callback-Methode wird sofort aufgerufen. Wenn `dueTime` ist <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>wird die Rückrufmethode wird nie aufgerufen; der Zeitgeber deaktiviert ist, kann aber wieder aktiviert werden, durch den Aufruf <xref:System.Threading.Timer.Change%2A> und geben Sie einen positiven Wert für `dueTime`.  
  
 Wenn `period` ist 0 (null) oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, und `dueTime` nicht <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>wird die Callback-Methode wird einmal aufgerufen werden; das periodische Verhalten des Zeitgebers ist deaktiviert, kann aber wieder aktiviert werden, durch den Aufruf <xref:System.Threading.Timer.Change%2A> und geben Sie einen positiven Wert für `period`.  
  
 Die <xref:System.Threading.Timer.Change%2A> Methode kann aufgerufen werden, aus der <xref:System.Threading.TimerCallback> delegieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Threading.Timer" /> wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="dueTime" />-Parameter oder der <paramref name="period" />-Parameter ist kleiner als -1.</exception>
        <exception cref="T:System.NotSupportedException">Der <paramref name="dueTime" />-Parameter oder der <paramref name="period" />-Parameter ist größer als 4.294.967.294.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Timer</related>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As TimeSpan, period As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="F#" Value="member this.Change : TimeSpan * TimeSpan -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="dueTime">Eine <see cref="T:System.TimeSpan" /> zum Darstellen der Zeitspanne, die gewartet werden soll, bis die beim Erstellen von <see cref="T:System.Threading.Timer" /> angegebene Rückrufmethode aufgerufen wird. Geben Sie „-1“ Millisekunde an, um das erneute Starten des Timers zu verhindern. Geben Sie 0 (null) an, um den Timer sofort neu zu starten.</param>
        <param name="period">Das Zeitintervall zwischen den Aufrufen der beim Erstellen von <see cref="T:System.Threading.Timer" /> angegebenen Rückrufmethode. Geben Sie -1 Millisekunde an, um periodisches Signalisieren zu deaktivieren.</param>
        <summary>Ändert die Startzeit und das Intervall zwischen Methodenaufrufen für einen Zeitgeber unter Verwendung von <see cref="T:System.TimeSpan" />-Werten zum Messen von Zeitintervallen.</summary>
        <returns><see langword="true" />, wenn der Timer erfolgreich aktualisiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Callback-Methode wird aufgerufen, einmal nach `dueTime` abgelaufen ist, und anschließend jedes Mal durch angegebene Zeitintervall `period` abgelaufen ist.  
  
 Wenn `dueTime` ist 0 (null), die Callback-Methode wird sofort aufgerufen. Wenn `dueTime` negative Eins (1) Millisekunden, die Callback-Methode nie aufgerufen; der Zeitgeber deaktiviert ist, aber können erneut aktiviert werden, durch den Aufruf <xref:System.Threading.Timer.Change%2A> und geben Sie einen positiven Wert für `dueTime`.  
  
 Wenn `period` ist 0 (null) oder negative Eins (1) Millisekunden und `dueTime` positiv ist, werden die Callback-Methode wird einmal aufgerufen, die periodische Verhalten des Zeitgebers ist deaktiviert, aber kann wieder aktiviert werden, durch den Aufruf <xref:System.Threading.Timer.Change%2A> und geben Sie einen Wert größer als NULL für die `period`.  
  
 Die <xref:System.Threading.Timer.Change%2A> Methode kann aufgerufen werden, aus der <xref:System.Threading.TimerCallback> delegieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zu einem `Timer` und ändern Sie nach einer bestimmten Anzahl von aufrufen, die der Zeitraum.  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Threading.Timer" /> wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="dueTime" />-Parameter oder der <paramref name="period" />-Parameter, angegeben in Millisekunden, ist kleiner als -1.</exception>
        <exception cref="T:System.NotSupportedException">Der <paramref name="dueTime" />-Parameter oder der <paramref name="period" />-Parameter, angegeben in Millisekunden, ist größer als 4294967294.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Timer</related>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As UInteger, period As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(System::UInt32 dueTime, System::UInt32 period);" />
      <MemberSignature Language="F#" Value="member this.Change : uint32 * uint32 -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="dueTime">Die in Millisekunden angegebene Zeitspanne, die gewartet werden soll, bis die beim Erstellen von <see cref="T:System.Threading.Timer" /> angegebene Rückrufmethode aufgerufen wird. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um den Neustart des Zeitgebers zu verhindern. Geben Sie 0 (null) an, um den Timer sofort neu zu starten.</param>
        <param name="period">Das Zeitintervall zwischen den Aufrufen der beim Erstellen von <see cref="T:System.Threading.Timer" /> angegebenen Rückrufmethode in Millisekunden. Geben Sie <see cref="F:System.Threading.Timeout.Infinite" /> an, um periodisches Signalisieren zu deaktivieren.</param>
        <summary>Ändert die Startzeit und das Intervall zwischen Methodenaufrufen für einen Timer unter Verwendung von 32-Bit-Ganzzahlen ohne Vorzeichen zum Messen von Zeitintervallen.</summary>
        <returns><see langword="true" />, wenn der Timer erfolgreich aktualisiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Callback-Methode wird aufgerufen, einmal nach `dueTime` abgelaufen ist, und anschließend jedes Mal durch angegebene Zeitintervall `period` abgelaufen ist.  
  
 Wenn `dueTime` ist 0 (null), die Callback-Methode wird sofort aufgerufen. Wenn `dueTime` ist <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>wird die Rückrufmethode wird nie aufgerufen; der Zeitgeber deaktiviert ist, kann aber wieder aktiviert werden, durch den Aufruf <xref:System.Threading.Timer.Change%2A> und geben Sie einen positiven Wert für `dueTime`.  
  
 Wenn `period` ist 0 (null) oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, und `dueTime` nicht <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>wird die Callback-Methode wird einmal aufgerufen werden; das periodische Verhalten des Zeitgebers ist deaktiviert, kann aber wieder aktiviert werden, durch den Aufruf <xref:System.Threading.Timer.Change%2A> und geben Sie einen positiven Wert für `period`.  
  
 Die <xref:System.Threading.Timer.Change%2A> Methode kann aufgerufen werden, aus der <xref:System.Threading.TimerCallback> delegieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Threading.Timer" /> wurde bereits freigegeben.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Timer</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz von <see cref="T:System.Threading.Timer" /> verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="timer.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz von <see cref="T:System.Threading.Timer" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von `Dispose` können die Ressourcen, die von verwendet die <xref:System.Threading.Timer> , für andere Zwecke verschoben werden. Weitere Informationen zu `Dispose`, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).  
  
> [!NOTE]
>  Rückrufe können nach dem Auftreten der <xref:System.Threading.Timer.Dispose> Überladung aufgerufen wurde, da der Timer-Rückrufe für die Ausführung von Threads im Threadpool Warteschlangen. Sie können die <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> -methodenüberladung, um zu warten, bis alle Rückrufe abgeschlossen haben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Freigeben von Ressourcen frei, die eine `Timer`.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/timers.md">Timer</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public bool Dispose (System.Threading.WaitHandle notifyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Dispose(class System.Threading.WaitHandle notifyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dispose (notifyObject As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Dispose(System::Threading::WaitHandle ^ notifyObject);" />
      <MemberSignature Language="F#" Value="member this.Dispose : System.Threading.WaitHandle -&gt; bool" Usage="timer.Dispose notifyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notifyObject" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="notifyObject">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />, wenn der <see langword="Timer" /> freigegeben wurde.</param>
        <summary>Gibt alle von der aktuellen Instanz von <see cref="T:System.Threading.Timer" /> verwendeten Ressourcen frei, und signalisiert das Freigeben des Zeitgebers.</summary>
        <returns><see langword="true" />, wenn die Funktion erfolgreich ausgeführt wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von `Dispose` können die Ressourcen, die von verwendet die <xref:System.Threading.Timer> , für andere Zwecke verschoben werden. Weitere Informationen zu `Dispose`, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).  
  
 Wenn diese Methode abgeschlossen ist, signalisiert die <xref:System.Threading.WaitHandle> gemäß der `notifyObject` Parameter. Verwenden Sie diese Überladung von der <xref:System.Threading.Timer.Dispose%2A> Methode, wenn Sie möchten in der Lage, blockiert, bis Sie sicher sind, dass der Zeitgeber freigegeben wurde. Der Zeitgeber wird nicht gelöscht werden, bis alle derzeit in der Warteschlange Rückrufe abgeschlossen sind.  
  
> [!NOTE]
>  Wenn der Rückruf verwendet die <xref:System.Threading.Timer.Change%2A> Methode zum Festlegen der `dueTime` Parameter 0 (null), die eine Racebedingung auftreten kann beim der <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> methodenüberladung wird aufgerufen,:, wenn der Zeitgeber einen neuen Rückruf vor Warteschlangen die <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> methodenüberladung erkennt, dass es sind keine Rückrufe in die Warteschlange eingereiht, <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> weiterhin blockieren; andernfalls wird der Zeitgeber freigegeben, während der neue Rückruf in die Warteschlange aufgenommen wird, und ein <xref:System.ObjectDisposedException> wird ausgelöst, wenn der neue Rückruf aufruft der <xref:System.Threading.Timer.Change%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="notifyObject" />-Parameter ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Timer</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Timer ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="timer.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>