<Type Name="CancellationToken" FullName="System.Threading.CancellationToken">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="aff861d633b172c0996e4351071b31629dbba628" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39804582" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct CancellationToken" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit CancellationToken extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Threading.CancellationToken" />
  <TypeSignature Language="VB.NET" Value="Public Structure CancellationToken" />
  <TypeSignature Language="C++ CLI" Value="public value class CancellationToken" />
  <TypeSignature Language="F#" Value="type CancellationToken = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("IsCancellationRequested = {IsCancellationRequested}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gibt eine Benachrichtigung darüber weiter, dass Vorgänge abgebrochen werden sollen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Threading.CancellationToken> ermöglicht einen kooperativen Abbruch zwischen Arbeitsaufgaben im Threadpool, Threads oder <xref:System.Threading.Tasks.Task> Objekte. Sie erstellen ein Abbruchtoken, das durch die Instanziierung einer <xref:System.Threading.CancellationTokenSource> -Objekt, das Abbruchtoken verwaltet abgerufen, von der <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> Eigenschaft. Übergeben Sie dann das Abbruchtoken, das auf eine beliebige Anzahl von Threads, Tasks oder Vorgänge, die über den Abbruch empfangen soll. Das Token kann nicht verwendet werden, um die Kündigung einzuleiten. Wenn das besitzende Objekt aufruft <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>, <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> auf jede Kopie des Abbruchtokens-Eigenschaftensatz auf `true`. Die Objekte, die die Benachrichtigung erhalten, können in jede beliebige Weise reagieren.  
  
 Weitere Informationen und Codebeispiele finden Sie unter [Abbruch in verwalteten Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen Zufallszahlen-Generator, um eine Anwendung zur Auflistung zu emulieren, die 10 ganzzahlige Werten aus elf Instrumente liest. Der Wert 0 (null) gibt an, dass die Maßeinheit für eine Instrumentierung fehlgeschlagen ist in diesem Fall der Vorgang abgebrochen werden soll und keine allgemeinen Mittelwert berechnet werden soll.  
  
 Um den möglichen Abbruch des Vorgangs zu behandeln, instanziiert das Beispiel ein <xref:System.Threading.CancellationTokenSource> -Objekt, das ein Abbruchtoken wird, die generiert an eine <xref:System.Threading.Tasks.TaskFactory> Objekt. Die <xref:System.Threading.Tasks.TaskFactory> Objekt wiederum übergibt das Abbruchtoken, das auf die einzelnen Aufgaben verantwortlich für das Sammeln von Messwerten für einen bestimmten instrumentieren. Die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%60%602%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2CSystem.Func%7BSystem.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2C%60%601%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methode wird aufgerufen, um sicherzustellen, dass der Mittelwert berechnet wird, nur, nachdem alle Messungen erfolgreich erfasst wurden. Wenn eine Aufgabe nicht abgebrochen wurde, dann löst der Aufruf an die Methode <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> eine Ausnahme aus.  
  
 [!code-csharp[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/cs/cancel1.cs#1)]
 [!code-vb[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/vb/cancel1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen und geschützten Member der <see cref="T:System.Threading.CancellationToken" /> sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CancellationToken (bool canceled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool canceled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (canceled As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CancellationToken(bool canceled);" />
      <MemberSignature Language="F#" Value="new System.Threading.CancellationToken : bool -&gt; System.Threading.CancellationToken" Usage="new System.Threading.CancellationToken canceled" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="canceled" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="canceled">Der Zustand "abgebrochen" für das Token.</param>
        <summary>Initialisiert das <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor erstellte Token verbleiben im Zustand "abgebrochen" gemäß der `canceled` Parameter. Wenn `canceled` ist `false`, beide <xref:System.Threading.CancellationToken.CanBeCanceled%2A> und <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> werden `false`.  
  
 Wenn `canceled` ist `true`, beide <xref:System.Threading.CancellationToken.CanBeCanceled%2A> und <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> werden `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBeCanceled">
      <MemberSignature Language="C#" Value="public bool CanBeCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanBeCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.CanBeCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanBeCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanBeCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanBeCanceled : bool" Usage="System.Threading.CancellationToken.CanBeCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zustand "abgebrochen" von diesem Token unterstützt wird.</summary>
        <value>
          <see langword="true" />, wenn sich dieses Token im abgebrochenen Zustand befinden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Threading.CancellationToken.CanBeCanceled%2A> gibt `false`, es ist sichergestellt, dass das Token nie in den Zustand "abgebrochen", was bedeutet, dass <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> wird nie zurückgegeben `true`. Ein Abbruchtoken, das nicht abgebrochen werden kann, wird von der statischen zurückgegeben <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Sie können diese Eigenschaft optional verwenden, um zu bestimmen, ob ein Abbruchtoken sein kann abgebrochen, bevor Examing den Wert des der <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> Eigenschaft, um zu bestimmen, ob er abgebrochen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob die aktuelle <see cref="T:System.Threading.CancellationToken" />-Instanz gleich dem angegebenen Token ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (other As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="cancellationToken.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="other">Das andere Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob die aktuelle <see cref="T:System.Threading.CancellationToken" />-Instanz und die angegebene <see cref="T:System.Object" />-Instanz gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="other" /> ein <see cref="T:System.Threading.CancellationToken" /> ist und die beiden Instanzen gleich sind, andernfalls <see langword="false" />. Weitere Informationen finden Sie im Abschnitt Hinweise.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Zwei Abbruchtoken sind gleich, wenn eine der folgenden Bedingungen zutrifft: 

- Sie sind mit dem gleichen zugeordneten <xref:System.Threading.CancellationTokenSource>.

- Beide aus öffentlichen erstellt wurden <xref:System.Threading.CancellationToken> Konstruktoren, und ihre <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> Werte gleich sind.

- Der Wert von beiden Abbruchtoken <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.

       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein zugeordnetes <see cref="T:System.Threading.CancellationTokenSource" /> wurde freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Threading.CancellationToken other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.Threading.CancellationToken other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Threading::CancellationToken other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Threading.CancellationToken -&gt; bool" Usage="cancellationToken.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="other">Das andere <see cref="T:System.Threading.CancellationToken" />, mit dem diese Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob die aktuelle <see cref="T:System.Threading.CancellationToken" />-Instanz gleich dem angegebenen Token ist.</summary>
        <returns>
          <see langword="true" />, wenn die Instanzen gleich sind, andernfalls <see langword="false" />. Weitere Informationen finden Sie im Abschnitt Hinweise.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Zwei Abbruchtoken sind gleich, wenn eine der folgenden Bedingungen zutrifft: 

- Sie sind mit dem gleichen zugeordneten <xref:System.Threading.CancellationTokenSource>.

- Beide aus öffentlichen erstellt wurden <xref:System.Threading.CancellationToken> Konstruktoren, und ihre <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> Werte gleich sind.

- Der Wert von beiden Abbruchtoken <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="cancellationToken.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fungiert als Hashfunktion für eine <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Ein Hashcode für die aktuelle <see cref="T:System.Threading.CancellationToken" />-Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCancellationRequested">
      <MemberSignature Language="C#" Value="public bool IsCancellationRequested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCancellationRequested" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.IsCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCancellationRequested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCancellationRequested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCancellationRequested : bool" Usage="System.Threading.CancellationToken.IsCancellationRequested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für dieses Token ein Abbruch angefordert wurde.</summary>
        <value>
          <see langword="true" /> Wenn der Abbruch ist wurde für dieses Token angefordert; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt an, ob ein Abbruch angefordert wurde für dieses Token, entweder über das Token, die anfänglich in einem abgebrochenen Zustand erstellt wird oder durch den Aufruf <xref:System.Threading.CancellationTokenSource.Cancel%2A> auf das Token zugeordnete <xref:System.Threading.CancellationTokenSource>.  
  
 Wenn diese Eigenschaft `true`, es wird lediglich sichergestellt, dass der Abbruch angefordert wurde. Dies garantiert nicht, dass alle registrierter Handler für die Ausführung beendet hat, noch die abbruchanforderungen weitergegeben, die an alle registrierten Handler abgeschlossen haben. Zusätzliche Synchronisierung erforderlich, insbesondere in Situationen möglicherweise, in dem verwandte Objekte gleichzeitig abgebrochen werden.  
  
   
  
## Examples  
 Im folgenden ist ein einfaches Beispiel, die einen Serverprozess erst ausgeführt wird. die <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> -Eigenschaft gibt `true`.  
  
 [!code-csharp[System.Threading.Tasks.CancellationToken.IsCancellationRequested#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.CancellationToken.IsCancellationRequested/cs/cancellation.cs#12)]
 [!code-vb[System.Threading.Tasks.CancellationToken.IsCancellationRequested#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.CancellationToken.IsCancellationRequested/vb/cancelthreads.vb#12)]  
  
 Das Beispiel instanziiert ein <xref:System.Threading.CancellationTokenSource> -Objekt, das Zugriff auf das Abbruchtoken, das steuert. Klicken Sie dann definiert zwei Threadprozeduren. Die erste wird als Lambda-Ausdruck, der pools der Tastaturfokus und, wenn die "C"-Taste gedrückt wird, ruft definiert <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> das Abbruchtoken, das auf den Status "abgebrochen" festgelegt. Die zweite ist eine Methode parametrisierte `ServerClass.StaticMethod`, das ausführt, einer Schleife, bis die <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> -Eigenschaft ist `true`.  
  
 Der Hauptthread startet dann der zwei Threads und blockiert bis der Thread, der ausgeführt wird die `ServerClass.StaticMethod` Methode beendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static System.Threading.CancellationToken None { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Threading.CancellationToken None" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property None As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::CancellationToken None { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.None : System.Threading.CancellationToken" Usage="System.Threading.CancellationToken.None" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen leeren <see cref="T:System.Threading.CancellationToken" />-Wert zurück.</summary>
        <value>Ein leeres Abbruchtoken.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abbruchtoken, das von dieser Eigenschaft zurückgegebene kann nicht abgebrochen werden; d. h. die <xref:System.Threading.CancellationToken.CanBeCanceled%2A> Eigenschaft `false`.  
  
 Sie können auch die C#- [default(CancellationToken)](~/docs/csharp/language-reference/keywords/default.md) Anweisung, um ein leeres Abbruchtoken zu erstellen. 

 Zwei leere Abbruchtoken sind immer gleich.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Threading.CancellationToken left, System.Threading.CancellationToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Threading.CancellationToken left, valuetype System.Threading.CancellationToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.op_Equality(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As CancellationToken, right As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Threading::CancellationToken left, System::Threading::CancellationToken right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Threading.CancellationToken * System.Threading.CancellationToken -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Threading.CancellationToken" />
        <Parameter Name="right" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="left">Die erste Instanz.</param>
        <param name="right">Die zweite Instanz.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Threading.CancellationToken" />-Instanzen gleich sind.</summary>
        <returns>Wenn die Instanzen identisch sind: <see langword="true" />, andernfalls <see langword="false" /> (Weitere Informationen finden Sie im Abschnitt „Hinweise“).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Zwei Abbruchtoken sind gleich, wenn eine der folgenden Bedingungen zutrifft: 

- Sie sind mit dem gleichen zugeordneten <xref:System.Threading.CancellationTokenSource>.

- Beide aus öffentlichen erstellt wurden <xref:System.Threading.CancellationToken> Konstruktoren, und ihre <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> Werte gleich sind.

- Der Wert von beiden Abbruchtoken <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.
       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein zugeordnetes <see cref="T:System.Threading.CancellationTokenSource" /> wurde freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Threading.CancellationToken left, System.Threading.CancellationToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Threading.CancellationToken left, valuetype System.Threading.CancellationToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.op_Inequality(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As CancellationToken, right As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Threading::CancellationToken left, System::Threading::CancellationToken right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Threading.CancellationToken * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.CancellationToken.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Threading.CancellationToken" />
        <Parameter Name="right" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="left">Die erste Instanz.</param>
        <param name="right">Die zweite Instanz.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Threading.CancellationToken" />-Instanzen ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn die Instanzen ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Die Definition der Gleichheit, finden Sie unter den <xref:System.Threading.CancellationToken.Equals%2A> Methode. 
       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein zugeordnetes <see cref="T:System.Threading.CancellationTokenSource" /> wurde freigegeben.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert einen Delegaten, der aufgerufen wird, wenn dieses <see cref="T:System.Threading.CancellationToken" /> abgebrochen wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Register : Action -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Der Delegat, der ausgeführt wird, wenn das <see cref="T:System.Threading.CancellationToken" />-Objekt abgebrochen wird.</param>
        <summary>Registriert einen Delegaten, der aufgerufen wird, wenn dieses <see cref="T:System.Threading.CancellationToken" /> abgebrochen wird.</summary>
        <returns>Die <see cref="T:System.Threading.CancellationTokenRegistration" />-Instanz, die verwendet werden kann, um die Registrierung des Rückrufs aufzuheben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Token bereits im Zustand "abgebrochen" ist, wird der Delegat sofort und synchron ausgeführt. Aus diesem Methodenaufruf wird eine Ausnahme, die der Delegat generiert weitergegeben.  
  
 Die aktuelle <xref:System.Threading.ExecutionContext> wird zusammen mit dem Delegaten erfasst und verwendet wird, wenn sie ausgeführt. 

 Die aktuelle <xref:System.Threading.SynchronizationContext> wird nicht erfasst.
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> hat den Wert null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action callback, bool useSynchronizationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action callback, bool useSynchronizationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action, useSynchronizationContext As Boolean) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action ^ callback, bool useSynchronizationContext);" />
      <MemberSignature Language="F#" Value="member this.Register : Action * bool -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register (callback, useSynchronizationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="useSynchronizationContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callback">Der Delegat, der ausgeführt wird, wenn das <see cref="T:System.Threading.CancellationToken" />-Objekt abgebrochen wird.</param>
        <param name="useSynchronizationContext">Ein Wert, der angibt, ob der aktuelle <see cref="T:System.Threading.SynchronizationContext" /> erfasst und beim Aufrufen von <c>callback</c> verwendet werden soll.</param>
        <summary>Registriert einen Delegaten, der aufgerufen wird, wenn dieses <see cref="T:System.Threading.CancellationToken" /> abgebrochen wird.</summary>
        <returns>Die <see cref="T:System.Threading.CancellationTokenRegistration" />-Instanz, die verwendet werden kann, um die Registrierung des Rückrufs aufzuheben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Token bereits im Zustand "abgebrochen" ist, wird der Delegat sofort und synchron ausgeführt. Aus diesem Methodenaufruf wird eine Ausnahme, die der Delegat generiert weitergegeben.  
  
 Die aktuelle <xref:System.Threading.ExecutionContext> wird zusammen mit dem Delegaten erfasst und verwendet wird, wenn sie ausgeführt. 

 Wenn `useSynchronizationContext` ist `true`, die aktuelle <xref:System.Threading.SynchronizationContext>, wenn eine vorhanden ist, zusammen mit dem Delegaten auch erfasst wird und verwendet wird, wenn sie ausgeführt. Andernfalls <xref:System.Threading.SynchronizationContext> wird nicht erfasst.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> hat den Wert null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action&lt;object&gt; callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action`1&lt;object&gt; callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action(Of Object), state As Object) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action&lt;System::Object ^&gt; ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.Register : Action&lt;obj&gt; * obj -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Der Delegat, der ausgeführt wird, wenn das <see cref="T:System.Threading.CancellationToken" />-Objekt abgebrochen wird.</param>
        <param name="state">Der Zustand, der beim Aufrufen des Delegaten an <c>callback</c> übergeben werden soll. Dies kann NULL sein.</param>
        <summary>Registriert einen Delegaten, der aufgerufen wird, wenn dieses <see cref="T:System.Threading.CancellationToken" /> abgebrochen wird.</summary>
        <returns>Die <see cref="T:System.Threading.CancellationTokenRegistration" />-Instanz, die verwendet werden kann, um die Registrierung des Rückrufs aufzuheben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Token bereits im Zustand "abgebrochen" ist, wird der Delegat sofort und synchron ausgeführt. Aus diesem Methodenaufruf wird eine Ausnahme, die der Delegat generiert weitergegeben.  
  
 Die aktuelle <xref:System.Threading.ExecutionContext> wird zusammen mit dem Delegaten erfasst und verwendet wird, wenn sie ausgeführt. 

 Die aktuelle <xref:System.Threading.SynchronizationContext> wird nicht erfasst.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> hat den Wert null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action&lt;object&gt; callback, object state, bool useSynchronizationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action`1&lt;object&gt; callback, object state, bool useSynchronizationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action(Of Object), state As Object, useSynchronizationContext As Boolean) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action&lt;System::Object ^&gt; ^ callback, System::Object ^ state, bool useSynchronizationContext);" />
      <MemberSignature Language="F#" Value="member this.Register : Action&lt;obj&gt; * obj * bool -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register (callback, state, useSynchronizationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="useSynchronizationContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callback">Der Delegat, der ausgeführt wird, wenn das <see cref="T:System.Threading.CancellationToken" />-Objekt abgebrochen wird.</param>
        <param name="state">Der Zustand, der beim Aufrufen des Delegaten an <c>callback</c> übergeben werden soll. Dies kann NULL sein.</param>
        <param name="useSynchronizationContext">Ein Wert, der angibt, ob der aktuelle <see cref="T:System.Threading.SynchronizationContext" /> erfasst und beim Aufrufen von <c>callback</c> verwendet werden soll.</param>
        <summary>Registriert einen Delegaten, der aufgerufen wird, wenn dieses <see cref="T:System.Threading.CancellationToken" /> abgebrochen wird.</summary>
        <returns>Die <see cref="T:System.Threading.CancellationTokenRegistration" />-Instanz, die verwendet werden kann, um die Registrierung des Rückrufs aufzuheben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Token bereits im Zustand "abgebrochen" ist, wird der Delegat sofort und synchron ausgeführt. Aus diesem Methodenaufruf wird eine Ausnahme, die der Delegat generiert weitergegeben.  
  
 Die aktuelle <xref:System.Threading.ExecutionContext> wird zusammen mit dem Delegaten erfasst und verwendet wird, wenn sie ausgeführt. 

 Wenn `useSynchronizationContext` ist `true`, die aktuelle <xref:System.Threading.SynchronizationContext>, wenn eine vorhanden ist, zusammen mit dem Delegaten auch erfasst wird und verwendet wird, wenn sie ausgeführt. Andernfalls <xref:System.Threading.SynchronizationContext> wird nicht erfasst.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> hat den Wert null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfCancellationRequested">
      <MemberSignature Language="C#" Value="public void ThrowIfCancellationRequested ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ThrowIfCancellationRequested() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.ThrowIfCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public Sub ThrowIfCancellationRequested ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ThrowIfCancellationRequested();" />
      <MemberSignature Language="F#" Value="member this.ThrowIfCancellationRequested : unit -&gt; unit" Usage="cancellationToken.ThrowIfCancellationRequested " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst ein <see cref="T:System.OperationCanceledException" /> aus, wenn für dieses Token ein Abbruch angefordert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet Funktionen, die äquivalent zu:  
  
 C#  
  
```csharp  
if (token.IsCancellationRequested)   
    throw new OperationCanceledException(token);  
```  
  
```vb  
If token.IsCancellationRequested Then  
    Throw New OperationCanceledException(token)  
End If  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Für das Token wurde ein Abbruch angefordert.</exception>
        <exception cref="T:System.ObjectDisposedException">Die zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle WaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle WaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.WaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ WaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitHandle : System.Threading.WaitHandle" Usage="System.Threading.CancellationToken.WaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.WaitHandle" /> ab, das signalisiert wird, wenn das Token abgebrochen wird.</summary>
        <value>Ein <see cref="T:System.Threading.WaitHandle" />, das signalisiert wird, wenn das Token abgebrochen wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zugriff auf diese Eigenschaft bewirkt, dass eine <xref:System.Threading.WaitHandle> instanziiert werden. Es wird empfohlen, diese Eigenschaft, die bei Bedarf nur verwenden, und klicken Sie dann die zugeordnete dispose <xref:System.Threading.CancellationTokenSource> Instanz bei nächstmöglicher Gelegenheit (disposing der Quelle dieses zugeordnete Handle freigegeben wird). Das Handle sollte nicht geschlossen oder direkt freigegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde freigegeben.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
