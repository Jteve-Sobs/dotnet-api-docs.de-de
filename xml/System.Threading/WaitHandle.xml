<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="270c2a502b040636f65807d18c2bf250df51525c" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58722359" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1313d-101">Kapselt betriebssystemspezifische Objekte, die auf exklusiven Zugriff auf gemeinsam genutzte Ressourcen warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-101">Encapsulates operating system-specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-102">Die <xref:System.Threading.WaitHandle> -Klasse kapselt ein Handle für die systemeigenen Betriebssystemhandles Synchronisierung und wird verwendet, um alle Synchronisierungsobjekte in der Runtime darstellen, die mehrere Wartevorgänge ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="1313d-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="1313d-103">Einen Vergleich der Wait-Handles mit anderen Synchronisierungsobjekte, finden Sie unter [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="1313d-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="1313d-104">Die <xref:System.Threading.WaitHandle> Klasse selbst abstrakt ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="1313d-105">Von abgeleiteten Klassen <xref:System.Threading.WaitHandle> definieren Sie einen signalisierenden Mechanismus, um anzugeben, aufnehmen oder den Zugriff auf eine freigegebene Ressource freigeben, aber sie verwenden die geerbte <xref:System.Threading.WaitHandle> Methoden zum Blockieren, bis für den Zugriff auf freigegebene Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="1313d-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="1313d-106">Von abgeleiteten Klassen <xref:System.Threading.WaitHandle> enthalten:</span><span class="sxs-lookup"><span data-stu-id="1313d-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="1313d-107">Der <xref:System.Threading.Mutex>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="1313d-108">Finden Sie unter [Mutexe](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="1313d-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="1313d-109">Die <xref:System.Threading.EventWaitHandle> -Klasse und die abgeleiteten Klassen <xref:System.Threading.AutoResetEvent> und <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="1313d-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span>  
  
-   <span data-ttu-id="1313d-110">Der <xref:System.Threading.Semaphore>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-110">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="1313d-111">Finden Sie unter [Semaphore und SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="1313d-111">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="1313d-112">Threads können auf einem einzelnen Wait-Handle durch Aufrufen der Instanzmethode blockieren <xref:System.Threading.WaitHandle.WaitOne%2A>, die von abgeleiteten Klassen geerbt wird <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="1313d-112">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="1313d-113">Die abgeleiteten Klassen von <xref:System.Threading.WaitHandle> unterscheiden sich in deren Threadaffinität.</span><span class="sxs-lookup"><span data-stu-id="1313d-113">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="1313d-114">Ereignis-wait-Handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, und <xref:System.Threading.ManualResetEvent>) und Semaphore keine Threadaffinität; einen beliebigen Thread kann eine Ereignis-Wait-Handle oder einen Semaphore zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="1313d-114">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="1313d-115">Mutexe weisen auf der anderen Seite Threadaffinität; der Thread, der einen Mutex besitzt, müssen sie freigeben und eine Ausnahme ausgelöst, wenn ein Thread Ruft die <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode einen Mutex, die er nicht besitzt.</span><span class="sxs-lookup"><span data-stu-id="1313d-115">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="1313d-116">Da die <xref:System.Threading.WaitHandle> Klasse leitet sich von <xref:System.MarshalByRefObject>, diese Klassen können zum Synchronisieren der Aktivitäten von Threads über Anwendungsdomänengrenzen hinweg verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1313d-116">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="1313d-117">Zusätzlich zu den davon abgeleiteten Klassen die <xref:System.Threading.WaitHandle> -Klasse verfügt über eine Reihe von statischen Methoden, die ein Thread, bis eine blockiert oder mehrere Synchronisierungsobjekte empfangen eines Signals.</span><span class="sxs-lookup"><span data-stu-id="1313d-117">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="1313d-118">Dazu gehören:</span><span class="sxs-lookup"><span data-stu-id="1313d-118">These include:</span></span>  
  
-   <span data-ttu-id="1313d-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, wodurch einen Thread ein Wait-Handle signalisiert und sofort auf einen anderen warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="1313d-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, wodurch einen Thread warten, bis die Wait-Handles in einem Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="1313d-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="1313d-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, wodurch einen Thread warten, bis eine von einem angegebenen Satz von Wait-Handles signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled.</span></span>  
  
 <span data-ttu-id="1313d-122">Die Überladungen dieser Methoden bereitstellen, zeitlimitintervallen für den Abbruch der Wartevorgang, und die Möglichkeit, einen Synchronisierungskontext zu beenden, vor dem Wartevorgang, verwenden Sie den Synchronisierungskontext anderer Threads zugelassen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-122">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1313d-123">Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="1313d-123">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="1313d-124">Wenn Sie mit dem Typ oder ein daraus abgeleiteter Typ haben, sollten Sie es entweder direkt oder indirekt freigeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-124">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="1313d-125">Zum direkten Löschen des Typs rufen Sie seine <xref:System.Threading.WaitHandle.Close%2A>-Methode in einem `try`/`catch`-Block auf.</span><span class="sxs-lookup"><span data-stu-id="1313d-125">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="1313d-126">Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="1313d-126">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="1313d-127">Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.</span><span class="sxs-lookup"><span data-stu-id="1313d-127">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="1313d-128"><xref:System.Threading.WaitHandle> implementiert die <xref:System.IDisposable.Dispose%2A> Muster.</span><span class="sxs-lookup"><span data-stu-id="1313d-128"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="1313d-129">Finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="1313d-129">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="1313d-130">Beim Ableiten von <xref:System.Threading.WaitHandle>, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Eigenschaft zum Speichern Ihrer systemeigenes Betriebssystemhandle.</span><span class="sxs-lookup"><span data-stu-id="1313d-130">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="1313d-131">Sie müssen nicht überschreiben, die geschützte <xref:System.Threading.WaitHandle.Dispose%2A> Methode, wenn Sie zusätzliche verwaltete Ressourcen verwenden.</span><span class="sxs-lookup"><span data-stu-id="1313d-131">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-132">Das folgende Codebeispiel zeigt wie zwei Threads werden Aufgaben im Hintergrund während der Hauptthread thread wartet darauf, die Aufgaben abgeschlossen wird, verwenden Sie die statische <xref:System.Threading.WaitHandle.WaitAny%2A> und <xref:System.Threading.WaitHandle.WaitAll%2A> Methoden der <xref:System.Threading.WaitHandle> Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-132">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="1313d-133">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="1313d-133">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="1313d-134">Threading</span><span class="sxs-lookup"><span data-stu-id="1313d-134">Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="1313d-135">Threadingobjekte und -funktionen</span><span class="sxs-lookup"><span data-stu-id="1313d-135">Threading Objects and Features</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="1313d-136">Mutexe</span><span class="sxs-lookup"><span data-stu-id="1313d-136">Mutexes</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d"><span data-ttu-id="1313d-137">EventWaitHandle, AutoResetEvent und ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="1313d-137">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="1313d-138">Semaphoren</span><span class="sxs-lookup"><span data-stu-id="1313d-138">Semaphores</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1313d-139">Initialisiert eine neue Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-139">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1313d-140">Gibt alle von der aktuellen <see cref="T:System.Threading.WaitHandle" />-Klasse reservierten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="1313d-140">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-141">Diese Methode ist die öffentliche Implementierung der <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> -Methode für die <xref:System.Threading.WaitHandle> -Klasse und ihrer abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="1313d-141">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="1313d-142">Es bietet eine Standardimplementierung, die aufruft, die `Dispose(Boolean)` -Überladung mit einer `true` Argument und ruft dann die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="1313d-142">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1313d-143">Rufen Sie diese Methode, um alle Ressourcen frei, die von einer Instanz von Version `WaitHandle` oder eine abgeleitete Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-143">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="1313d-144">Nachdem diese Methode aufgerufen wurde, dazu führen, dass Verweise auf die aktuelle Instanz nicht definiertem Verhalten.</span><span class="sxs-lookup"><span data-stu-id="1313d-144">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1313d-145">Rufen Sie immer <xref:System.Threading.WaitHandle.Close%2A> oder <xref:System.Threading.WaitHandle.Dispose> bereits vor der Veröffentlichung des letzten Verweis auf die <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="1313d-145">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="1313d-146">Andernfalls werden die verwendeten Ressourcen nicht freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1313d-146">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1313d-147">Sie sollten überschreiben die <see langword="Dispose(Boolean)" /> Methode zum Freigeben von Ressourcen zugeordnet, die abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="1313d-147">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="1313d-148">Implementieren einer Dispose-Methode</span><span class="sxs-lookup"><span data-stu-id="1313d-148">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1313d-149">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="1313d-149">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1313d-150">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="1313d-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-151">Diese Methode entspricht der <xref:System.Threading.WaitHandle.Close%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1313d-151">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1313d-152">Rufen Sie immer <xref:System.Threading.WaitHandle.Close%2A> oder <xref:System.Threading.WaitHandle.Dispose> bereits vor der Veröffentlichung des letzten Verweis auf die <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="1313d-152">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="1313d-153">Andernfalls werden die verwendeten Ressourcen nicht freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1313d-153">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="1313d-154">Bereinigen von nicht verwalteten Ressourcen</span><span class="sxs-lookup"><span data-stu-id="1313d-154">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><span data-ttu-id="1313d-155"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-155"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="1313d-156">Gibt beim Überschreiben in einer abgeleiteten Klasse die von <see cref="T:System.Threading.WaitHandle" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="1313d-156">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-157">Diese Methode wird aufgerufen, indem die <xref:System.Threading.WaitHandle.Close%2A> und <xref:System.Threading.WaitHandle.Dispose> Methoden mit dem `explicitDisposing` Parametersatz zu `true`.</span><span class="sxs-lookup"><span data-stu-id="1313d-157">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="1313d-158">Wenn die `explicitDisposing` -Parameter ist `true`, gibt diese Methode alle Ressourcen frei, die für verwaltete Objekte, die dieses <xref:System.Threading.WaitHandle> Objektverweise.</span><span class="sxs-lookup"><span data-stu-id="1313d-158">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1313d-159">Sie sollten überschreiben die <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> Methode zum Freigeben von Ressourcen zugeordnet, die abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="1313d-159">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
<span data-ttu-id="1313d-160">Die <see cref="M:System.Threading.WaitHandle.Close" /> oder <see cref="M:System.Threading.WaitHandle.Dispose" /> Methode kann von anderen Objekten mehrmals aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="1313d-160">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="1313d-161">Wenn Sie diese Methode überschreiben, werden nicht auf Objekte verweisen, die zuvor in einen früheren Aufruf von freigegeben wurden <see langword="Dispose" /> oder <see langword="Close" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-161">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="1313d-162">Implementieren einer Dispose-Methode</span><span class="sxs-lookup"><span data-stu-id="1313d-162">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1313d-163">Gibt die von der aktuellen Instanz reservierten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="1313d-163">Releases the resources held by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> <span data-ttu-id="1313d-164">Dieses Element wurde aus der .NET Framework, Version 2.0 und nachfolgenden Versionen entfernt.</span><span class="sxs-lookup"><span data-stu-id="1313d-164">This member has been removed from the .NET Framework version 2.0 and subsequent versions.</span></span> <span data-ttu-id="1313d-165">Dieses Thema gilt nur für die Versionen, die in "Informationen" weiter unten in diesem Thema aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="1313d-165">This topic applies only to the versions listed in "Version Information" later in this topic.</span></span>


<span data-ttu-id="1313d-166">Diese Methode wird von Anwendungscode nicht aufgerufen werden. Es wird automatisch während der Garbagecollection aufgerufen werden, es sei denn, durch den Garbage Collector-Finalisierung wurde deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="1313d-166">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="1313d-167">Weitere Informationen finden Sie unter <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> und <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="1313d-167">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="1313d-168">Diese Methode überschreibt <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="1313d-168">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1313d-169">Ruft das systemeigene Betriebssystemhandle auf oder legt dieses fest.</span><span class="sxs-lookup"><span data-stu-id="1313d-169">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="1313d-170">Ein <see langword="IntPtr" />, das das systemeigene Betriebssystemhandle darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-170">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="1313d-171">Der Standardwert ist der Wert des <see cref="F:System.Threading.WaitHandle.InvalidHandle" />-Felds.</span><span class="sxs-lookup"><span data-stu-id="1313d-171">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-172">Zuweisen eines neuen Werts, der <xref:System.Threading.WaitHandle.Handle%2A> Eigenschaft wird das vorherige Handle nicht geschlossen.</span><span class="sxs-lookup"><span data-stu-id="1313d-172">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="1313d-173">Dies kann zu einem unkontrollierten Handle führen.</span><span class="sxs-lookup"><span data-stu-id="1313d-173">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="1313d-174">Verwenden Sie diese Eigenschaft nicht in .NET Framework Version 2.0 oder höher. Verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Eigenschaft stattdessen.</span><span class="sxs-lookup"><span data-stu-id="1313d-174">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="1313d-175">Festlegen dieser Eigenschaft auf ein gültiges Handle, wird auch die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> -Eigenschaft, aber wenn diese Option auf <xref:System.Threading.WaitHandle.InvalidHandle> kann dazu führen, eine kompromittierte Handle.</span><span class="sxs-lookup"><span data-stu-id="1313d-175">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1313d-176">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer, den Eigenschaftswert festzulegen.</span><span class="sxs-lookup"><span data-stu-id="1313d-176">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="1313d-177">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="1313d-177">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="1313d-178">Abgeleitete Typen müssen <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> , den Eigenschaftswert festzulegen.</span><span class="sxs-lookup"><span data-stu-id="1313d-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1313d-179">Stellt ein ungültiges systemeigenes Betriebssystemhandle dar.</span><span class="sxs-lookup"><span data-stu-id="1313d-179">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="1313d-180">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="1313d-180">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-181">Intern verwendet, um das Initialisieren der <xref:System.Threading.WaitHandle.Handle%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="1313d-181">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1313d-182">Sie können diesen Wert verwenden, um zu bestimmen, ob die <see cref="P:System.Threading.WaitHandle.Handle" /> Eigenschaft enthält ein gültigen systemeigenes Betriebssystemhandle.</span><span class="sxs-lookup"><span data-stu-id="1313d-182">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1313d-183">Ruft das systemeigene Betriebssystemhandle auf oder legt dieses fest.</span><span class="sxs-lookup"><span data-stu-id="1313d-183">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="1313d-184">Ein <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />, das das systemeigene Betriebssystemhandle darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-184">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-185">Wenn Sie einen neuen Wert zuweisen der <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> -Eigenschaft, die vorherige Handle wird geschlossen, wenn die vorherige <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Objekt gesammelt.</span><span class="sxs-lookup"><span data-stu-id="1313d-185">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="1313d-186">Manuell schließen Sie das Handle nicht, da dadurch ein <xref:System.ObjectDisposedException> bei der <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> versucht, die das Handle zu schließen.</span><span class="sxs-lookup"><span data-stu-id="1313d-186">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="1313d-187"><xref:System.Threading.WaitHandle> implementiert die <xref:System.IDisposable.Dispose%2A> Muster.</span><span class="sxs-lookup"><span data-stu-id="1313d-187"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="1313d-188">Finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="1313d-188">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="1313d-189">Beim Ableiten von <xref:System.Threading.WaitHandle>, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Eigenschaft, um Ihre systemeigene Betriebssystemhandle zu speichern.</span><span class="sxs-lookup"><span data-stu-id="1313d-189">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="1313d-190">Sie müssen nicht überschreiben, die geschützte <xref:System.Threading.WaitHandle.Dispose%2A> Methode, wenn Sie zusätzliche verwaltete Ressourcen verwenden.</span><span class="sxs-lookup"><span data-stu-id="1313d-190">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1313d-191">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="1313d-191">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="1313d-192">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1313d-192">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="1313d-193">Abgeleitete Typen müssen <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> dieser Member aufrufen.</span><span class="sxs-lookup"><span data-stu-id="1313d-193">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1313d-194">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf einen anderen.</span><span class="sxs-lookup"><span data-stu-id="1313d-194">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="1313d-195">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-195">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="1313d-196">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="1313d-196">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="1313d-197">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf einen anderen.</span><span class="sxs-lookup"><span data-stu-id="1313d-197">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns><span data-ttu-id="1313d-198"><see langword="true" />, wenn das Signal und der Wartevorgang erfolgreich abgeschlossen wurden. Wenn der Wartevorgang nicht abgeschlossen wird, wird die Methode nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="1313d-198"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-199">Dieser Vorgang wird nicht unbedingt atomar sein.</span><span class="sxs-lookup"><span data-stu-id="1313d-199">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="1313d-200">Nachdem der aktuelle Thread Signale `toSignal` , aber bevor er wartet auf `toWaitOn`, ein Thread, der auf einem anderen Prozessor ausgeführt wird möglicherweise signalisiert `toWaitOn` oder darauf warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-200">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-201">Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> -methodenüberladung, um ermöglichen den Hauptthread auf einen blockierten Thread zu signalisieren und warten Sie, bis der Thread eine Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-201">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="1313d-202">Im Beispiel werden fünf Threads gestartet, können sie blockieren einen <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flag und dann Versionen einen Thread-Mal der Benutzer drückt die EINGABETASTE.</span><span class="sxs-lookup"><span data-stu-id="1313d-202">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="1313d-203">Im Beispiel wird dann fünf weitere Threads und mithilfe einer eine <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> Flag.</span><span class="sxs-lookup"><span data-stu-id="1313d-203">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-204"><paramref name="toSignal" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-204"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-205">- oder - </span><span class="sxs-lookup"><span data-stu-id="1313d-205">-or-</span></span> 
 <span data-ttu-id="1313d-206"><paramref name="toWaitOn" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-206"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-207">Die Methode wurde in einem Thread aufgerufen, der über ein <see cref="T:System.STAThreadAttribute" /> verfügt.</span><span class="sxs-lookup"><span data-stu-id="1313d-207">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="1313d-208">Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1313d-208">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-209"><paramref name="toSignal" /> ist ein Semaphor, und die maximale Anzahl ist bereits erreicht.</span><span class="sxs-lookup"><span data-stu-id="1313d-209"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-210">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-210">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-211">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-211">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="1313d-212">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-212">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="1313d-213">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="1313d-213">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1313d-214">Eine Ganzzahl, die das Wartezeitintervall darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-214">An integer that represents the interval to wait.</span></span> <span data-ttu-id="1313d-215">Wenn der Wert <see cref="F:System.Threading.Timeout.Infinite" /> (d. h. -1) ist, ist die Wartezeit unendlich.</span><span class="sxs-lookup"><span data-stu-id="1313d-215">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1313d-216"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-216"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1313d-217">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf ein weiteres, wobei ein Timeoutintervall als 32-Bit-Ganzzahl mit Vorzeichen angegeben und festgelegt wird, ob die Synchronisierungsdomäne des Kontexts vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1313d-217">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="1313d-218"><see langword="true" />, wenn das Signal und die Wartezeit erfolgreich abgeschlossen wurden, oder <see langword="false" />, wenn das Signal abgeschlossen wurde, für die Wartezeit jedoch ein Timeout aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-218"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-219">Dieser Vorgang wird nicht unbedingt atomar sein.</span><span class="sxs-lookup"><span data-stu-id="1313d-219">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="1313d-220">Nachdem der aktuelle Thread Signale `toSignal` , aber bevor er wartet auf `toWaitOn`, ein Thread, der auf einem anderen Prozessor ausgeführt wird möglicherweise signalisiert `toWaitOn` oder darauf warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-220">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="1313d-221">Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-221">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-222">Den Status der tests die `toWaitOn` und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-222">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1313d-223">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="1313d-223">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1313d-224">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-224">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1313d-225">Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1313d-225">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1313d-226">Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-226">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1313d-227">Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1313d-227">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="1313d-228">Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-228">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="1313d-229">Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-229">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1313d-230">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-230">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1313d-231">Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-231">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1313d-232">Wenn die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-232">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-233"><paramref name="toSignal" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-233"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-234">- oder - </span><span class="sxs-lookup"><span data-stu-id="1313d-234">-or-</span></span> 
 <span data-ttu-id="1313d-235"><paramref name="toWaitOn" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-235"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-236">Die Methode wird in einem Thread aufgerufen, der über ein <see cref="T:System.STAThreadAttribute" /> verfügt.</span><span class="sxs-lookup"><span data-stu-id="1313d-236">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="1313d-237">Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1313d-237">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-238">Das <see cref="T:System.Threading.WaitHandle" /> kann nicht signalisiert werden, da dies die maximale Anzahl übersteigen würde.</span><span class="sxs-lookup"><span data-stu-id="1313d-238">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-239"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-239"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-240">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-240">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-241">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-241">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="1313d-242">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-242">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="1313d-243">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="1313d-243">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="1313d-244">Ein <see cref="T:System.TimeSpan" />-Wert, der das Wartezeitintervall darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-244">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="1313d-245">Wenn der Wert -1 ist, ist die Wartezeit unendlich.</span><span class="sxs-lookup"><span data-stu-id="1313d-245">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1313d-246"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-246"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1313d-247">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf ein weiteres, wobei das Timeoutintervall als <see cref="T:System.TimeSpan" /> angegeben und festgelegt wird, ob die Synchronisierungsdomäne des Kontexts vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1313d-247">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="1313d-248"><see langword="true" />, wenn das Signal und die Wartezeit erfolgreich abgeschlossen wurden, oder <see langword="false" />, wenn das Signal abgeschlossen wurde, für die Wartezeit jedoch ein Timeout aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-248"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-249">Dieser Vorgang wird nicht unbedingt atomar sein.</span><span class="sxs-lookup"><span data-stu-id="1313d-249">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="1313d-250">Nachdem der aktuelle Thread Signale `toSignal` , aber bevor er wartet auf `toWaitOn`, ein Thread, der auf einem anderen Prozessor ausgeführt wird möglicherweise signalisiert `toWaitOn` oder darauf warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-250">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="1313d-251">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1313d-251">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1313d-252">Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-252">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-253">Den Status der tests die `toWaitOn` und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-253">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1313d-254">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="1313d-254">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1313d-255">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-255">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1313d-256">Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1313d-256">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1313d-257">Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-257">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1313d-258">Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1313d-258">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="1313d-259">Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-259">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="1313d-260">Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-260">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1313d-261">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-261">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1313d-262">Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-262">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1313d-263">Wenn die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-263">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-264"><paramref name="toSignal" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-264"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-265">- oder - </span><span class="sxs-lookup"><span data-stu-id="1313d-265">-or-</span></span> 
 <span data-ttu-id="1313d-266"><paramref name="toWaitOn" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-266"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-267">Die Methode wurde in einem Thread aufgerufen, der über ein <see cref="T:System.STAThreadAttribute" /> verfügt.</span><span class="sxs-lookup"><span data-stu-id="1313d-267">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="1313d-268">Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1313d-268">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-269"><paramref name="toSignal" /> ist ein Semaphor, und die maximale Anzahl ist bereits erreicht.</span><span class="sxs-lookup"><span data-stu-id="1313d-269"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-270"><paramref name="timeout" /> ergibt eine negative Anzahl von Millisekunden ungleich -1.</span><span class="sxs-lookup"><span data-stu-id="1313d-270"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
<span data-ttu-id="1313d-271">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-271">-or-</span></span> 
 <span data-ttu-id="1313d-272"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-272"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-273">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-273">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-274">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-274">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1313d-275">Gibt alle vom <see cref="T:System.Threading.WaitHandle" /> verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="1313d-275">Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="1313d-276">Aufrufen von `Dispose` können die Ressourcen, die von verwendet die <xref:System.Threading.WaitHandle> , für andere Zwecke verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="1313d-276">Calling `Dispose` allows the resources used by the <xref:System.Threading.WaitHandle> to be reallocated for other purposes.</span></span> <span data-ttu-id="1313d-277">Weitere Informationen zu `Dispose`, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="1313d-277">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1313d-278">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="1313d-278">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1313d-279">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="1313d-279">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1313d-280">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</span><span class="sxs-lookup"><span data-stu-id="1313d-280">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="1313d-281">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="1313d-281">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="1313d-282"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls wird die Methode nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="1313d-282"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-283"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="1313d-283"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1313d-284">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="1313d-284">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1313d-285">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="1313d-285">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1313d-286">Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="1313d-286">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1313d-287">Die Ausnahme enthält Informationen, die beim Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="1313d-287">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1313d-288">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn alle Handles signalisiert werden.</span><span class="sxs-lookup"><span data-stu-id="1313d-288">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="1313d-289">Für einige Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-289">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1313d-290">Wenn das Array Duplikate enthält, schlägt der Aufruf mit einem <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="1313d-290">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1313d-291">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf die Threads, die <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-291">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1313d-292">Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> -methodenüberladung, und geben-1 (oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) für `millisecondsTimeout` und `true` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1313d-292">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-293">Im folgenden Codebeispiel wird veranschaulicht, mit der Threadpool asynchron erstellungs- und Schreibberechtigungen für eine Gruppe von Dateien.</span><span class="sxs-lookup"><span data-stu-id="1313d-293">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="1313d-294">Jeden Schreibvorgang in die Warteschlange eingereiht als eine Arbeitsaufgabe und signalisiert, wenn er abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-294">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="1313d-295">Der Hauptthread wartet, bis alle Elemente um zu signalisieren und beendet.</span><span class="sxs-lookup"><span data-stu-id="1313d-295">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-296">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-296">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="1313d-297">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-297">-or-</span></span> 
<span data-ttu-id="1313d-298">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-298">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-299">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-299">-or-</span></span> 
 <span data-ttu-id="1313d-300"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="1313d-300"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="1313d-301">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="1313d-301">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="1313d-302">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-302">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-303">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="1313d-303">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="1313d-304">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-304">-or-</span></span> 
<span data-ttu-id="1313d-305">Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-305">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1313d-306"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="1313d-306"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-307">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-307">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-308">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-308">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-309">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-309">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1313d-310">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="1313d-310">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1313d-311">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt (Duplikate) enthalten.</span><span class="sxs-lookup"><span data-stu-id="1313d-311">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1313d-312">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="1313d-312">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1313d-313">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.Int32" />-Wert an.</span><span class="sxs-lookup"><span data-stu-id="1313d-313">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1313d-314"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-314"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-315">Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-315">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-316">Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-316">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-317">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Wartevorgang wird beendet, d. h., wenn alle Handles signalisiert werden oder wenn ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="1313d-317">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="1313d-318">Für einige Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-318">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1313d-319">Wenn Duplikate im Array vorhanden sind, schlägt der Aufruf mit einem <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="1313d-319">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1313d-320">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf die Threads, die <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-320">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1313d-321">Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1313d-321">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-322">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-322">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-323">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-323">-or-</span></span> 
<span data-ttu-id="1313d-324">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-324">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-325">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-325">-or-</span></span> 
 <span data-ttu-id="1313d-326"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-326"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="1313d-327">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="1313d-327">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="1313d-328">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-328">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-329">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="1313d-329">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="1313d-330">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-330">-or-</span></span> 
<span data-ttu-id="1313d-331">Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-331">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-332"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-332"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-333">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-333">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-334">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-334">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-335">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-335">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1313d-336">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="1313d-336">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1313d-337">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</span><span class="sxs-lookup"><span data-stu-id="1313d-337">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="1313d-338">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu Millisekunden für die Wartezeit angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden angibt, also eine unbeschränkte Wartezeit.</span><span class="sxs-lookup"><span data-stu-id="1313d-338">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1313d-339">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.TimeSpan" />-Wert an.</span><span class="sxs-lookup"><span data-stu-id="1313d-339">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1313d-340"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-340"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-341">Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-341">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-342">Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-342">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-343">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Wartevorgang beendet wird, d. h. alle Handles signalisiert werden, oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="1313d-343">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="1313d-344">Für einige Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-344">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1313d-345">Wenn das Array Duplikate enthält, schlägt der Aufruf fehl.</span><span class="sxs-lookup"><span data-stu-id="1313d-345">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1313d-346">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf die Threads, die <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-346">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1313d-347">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1313d-347">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1313d-348">Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1313d-348">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-349">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-349">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-350">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-350">-or-</span></span> 
<span data-ttu-id="1313d-351">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-351">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-352">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-352">-or-</span></span> 
 <span data-ttu-id="1313d-353"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-353"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="1313d-354">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="1313d-354">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="1313d-355">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-355">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-356">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="1313d-356">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="1313d-357">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-357">-or-</span></span> 
<span data-ttu-id="1313d-358">Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehr als ein Element.</span><span class="sxs-lookup"><span data-stu-id="1313d-358">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-359"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-359"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1313d-360">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-360">-or-</span></span> 
 <span data-ttu-id="1313d-361"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-361"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-362">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-362">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-363">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-363">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-364">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-364">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1313d-365">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="1313d-365">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1313d-366">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt (Duplikate) enthalten.</span><span class="sxs-lookup"><span data-stu-id="1313d-366">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1313d-367">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="1313d-367">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1313d-368"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-368"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1313d-369">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.Int32" />-Wert zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1313d-369">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1313d-370"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-370"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-371">Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-371">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-372">Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-372">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-373"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="1313d-373"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1313d-374">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="1313d-374">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1313d-375">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="1313d-375">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1313d-376">Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="1313d-376">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1313d-377">Die Ausnahme enthält Informationen, die beim Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="1313d-377">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1313d-378">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Wartevorgang wird beendet, d. h., wenn alle Handles signalisiert werden oder wenn ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="1313d-378">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="1313d-379">Für einige Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-379">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1313d-380">Wenn Duplikate im Array vorhanden sind, schlägt der Aufruf mit einem <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="1313d-380">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1313d-381">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf die Threads, die <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-381">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1313d-382">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="1313d-382">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1313d-383">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-383">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1313d-384">Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1313d-384">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1313d-385">Selbst wenn derzeit eine Methode einer Klasse ausgeführt wird, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-385">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1313d-386">Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1313d-386">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="1313d-387">Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-387">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="1313d-388">Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über die <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="1313d-388">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="1313d-389">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-389">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1313d-390">Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-390">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1313d-391">Wenn die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-391">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-392">Im folgenden Codebeispiel wird veranschaulicht, mit der Threadpool asynchron erstellungs- und Schreibberechtigungen für eine Gruppe von Dateien.</span><span class="sxs-lookup"><span data-stu-id="1313d-392">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="1313d-393">Jeden Schreibvorgang in die Warteschlange eingereiht als eine Arbeitsaufgabe und signalisiert, wenn er abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-393">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="1313d-394">Der Hauptthread wartet, bis alle Elemente um zu signalisieren und beendet.</span><span class="sxs-lookup"><span data-stu-id="1313d-394">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-395">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-395">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-396">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-396">-or-</span></span> 
<span data-ttu-id="1313d-397">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-397">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-398">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-398">-or-</span></span> 
 <span data-ttu-id="1313d-399"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="1313d-399"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="1313d-400">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-400">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-401">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="1313d-401">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="1313d-402">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-402">-or-</span></span> 
<span data-ttu-id="1313d-403">Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-403">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1313d-404"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="1313d-404"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-405"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-405"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-406">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-406">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-407">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-407">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-408">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-408">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1313d-409">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="1313d-409">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1313d-410">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</span><span class="sxs-lookup"><span data-stu-id="1313d-410">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="1313d-411">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu Millisekunden für die Wartezeit angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden angibt, also eine unbeschränkte Wartezeit.</span><span class="sxs-lookup"><span data-stu-id="1313d-411">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1313d-412"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-412"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1313d-413">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.TimeSpan" />-Wert zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1313d-413">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1313d-414"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-414"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-415">Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-415">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-416">Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-416">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-417"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="1313d-417"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1313d-418">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="1313d-418">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1313d-419">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="1313d-419">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1313d-420">Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="1313d-420">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1313d-421">Die Ausnahme enthält Informationen, die beim Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="1313d-421">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1313d-422">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Wartevorgang beendet wird, d. h. alle Handles signalisiert werden, oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="1313d-422">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="1313d-423">Für einige Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-423">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1313d-424">Wenn das Array Duplikate enthält, schlägt der Aufruf fehl.</span><span class="sxs-lookup"><span data-stu-id="1313d-424">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1313d-425">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf die Threads, die <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-425">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1313d-426">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1313d-426">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1313d-427">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="1313d-427">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1313d-428">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-428">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1313d-429">Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1313d-429">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1313d-430">Selbst wenn derzeit eine Methode einer Klasse ausgeführt wird, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-430">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1313d-431">Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1313d-431">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="1313d-432">Nach dem Aufruf des ursprünglichen Kontexts der vom Standard abweichenden gibt die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-432">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="1313d-433">Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-433">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1313d-434">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-434">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1313d-435">Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-435">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1313d-436">Wenn die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-436">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-437">Im folgenden Codebeispiel wird veranschaulicht, mit der Threadpool asynchron erstellungs- und Schreibberechtigungen für eine Gruppe von Dateien.</span><span class="sxs-lookup"><span data-stu-id="1313d-437">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="1313d-438">Jeden Schreibvorgang in die Warteschlange eingereiht als eine Arbeitsaufgabe und signalisiert, wenn er abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-438">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="1313d-439">Der Hauptthread wartet, bis alle Elemente um zu signalisieren und beendet.</span><span class="sxs-lookup"><span data-stu-id="1313d-439">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-440">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-440">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-441">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-441">-or-</span></span> 
<span data-ttu-id="1313d-442">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-442">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-443">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-443">-or-</span></span> 
 <span data-ttu-id="1313d-444"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="1313d-444"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="1313d-445">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-445">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-446">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="1313d-446">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="1313d-447">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-447">-or-</span></span> 
<span data-ttu-id="1313d-448">Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-448">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1313d-449"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="1313d-449"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-450"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-450"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1313d-451">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-451">-or-</span></span> 
 <span data-ttu-id="1313d-452"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-452"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-453">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-453">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-454">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-454">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-455">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-455">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1313d-456">Wartet, bis Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="1313d-456">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1313d-457">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="1313d-457">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="1313d-458">Wartet, bis Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="1313d-458">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="1313d-459">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat.</span><span class="sxs-lookup"><span data-stu-id="1313d-459">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-460"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="1313d-460"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1313d-461">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methodenrückgabe `true` , wenn der Wartevorgang abgeschlossen wird, da ein Mutex abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="1313d-461">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="1313d-462">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="1313d-462">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1313d-463">Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="1313d-463">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1313d-464">Die Ausnahme enthält Informationen, die beim Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="1313d-464">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1313d-465">Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn die Wartezeit aufgrund einer abgebrochenen Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-465">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1313d-466">Wenn `waitHandles` einen freigegebenen Mutex mit einer geringeren Anzahl von Index als den abgebrochenen Mutex, enthält die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode normal abgeschlossen und die Ausnahme nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-466">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1313d-467">In Versionen von .NET Framework-Versionen vor Version 2.0, wenn ein Thread beendet oder abgebrochen wird, ohne dass explizit freigegeben eine <xref:System.Threading.Mutex>, und dass `Mutex` befindet sich am Index 0 (null) in eine `WaitAny` Array auf einem anderen Thread, der von zurückgegebene Index `WaitAny` ist 128 statt 0.</span><span class="sxs-lookup"><span data-stu-id="1313d-467">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="1313d-468">Diese Methode gibt zurück, wenn alle Handles signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-468">This method returns when any handle is signaled.</span></span> <span data-ttu-id="1313d-469">Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts signalisiert mit dem kleinsten Indexwert aller signalisiert Objekte an.</span><span class="sxs-lookup"><span data-stu-id="1313d-469">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1313d-470">Für einige Implementierungen, wenn mehr, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-470">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1313d-471">Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> -methodenüberladung, und geben-1 (oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) für `millisecondsTimeout` und `true` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1313d-471">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-472">Im folgenden Codebeispiel wird das Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1313d-472">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-473">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-473">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-474">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-474">-or-</span></span> 
<span data-ttu-id="1313d-475">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-475">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-476">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="1313d-476">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1313d-477"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="1313d-477"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-478">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-478">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-479">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-479">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1313d-480"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="1313d-480"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-481">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-481">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1313d-482">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="1313d-482">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1313d-483">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="1313d-483">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1313d-484">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einer 32-Bit-Ganzzahl mit Vorzeichen an.</span><span class="sxs-lookup"><span data-stu-id="1313d-484">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1313d-485">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="millisecondsTimeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-485">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-486">Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-486">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-487">Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-487">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-488">Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn die Wartezeit aufgrund einer abgebrochenen Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-488">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1313d-489">Wenn `waitHandles` einen freigegebenen Mutex mit einer geringeren Anzahl von Index als den abgebrochenen Mutex, enthält die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode normal abgeschlossen und die Ausnahme nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-489">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="1313d-490">Wenn der Wartevorgang wird beendet, wenn eines der Handles signalisiert werden oder wenn ein Timeout auftritt, gibt diese Methode zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-490">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="1313d-491">Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts signalisiert mit dem kleinsten Indexwert aller signalisiert Objekte an.</span><span class="sxs-lookup"><span data-stu-id="1313d-491">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1313d-492">Für einige Implementierungen, wenn mehr, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-492">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1313d-493">Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1313d-493">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-494">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-494">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-495">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-495">-or-</span></span> 
<span data-ttu-id="1313d-496">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-496">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-497">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="1313d-497">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-498"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-498"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-499">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-499">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-500">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-500">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1313d-501"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-501"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-502">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-502">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1313d-503">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="1313d-503">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="1313d-504">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="1313d-504">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1313d-505">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.TimeSpan" />-Wert an.</span><span class="sxs-lookup"><span data-stu-id="1313d-505">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1313d-506">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="timeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-506">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-507">Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-507">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-508">Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-508">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-509">Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn die Wartezeit aufgrund einer abgebrochenen Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-509">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1313d-510">Wenn `waitHandles` einen freigegebenen Mutex mit einer geringeren Anzahl von Index als den abgebrochenen Mutex, enthält die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode normal abgeschlossen und die Ausnahme nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-510">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="1313d-511">Wenn der Wartevorgang wird beendet, wenn Handles signalisiert werden oder wenn ein Timeout auftritt, gibt diese Methode zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-511">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="1313d-512">Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts signalisiert mit dem kleinsten Indexwert aller signalisiert Objekte an.</span><span class="sxs-lookup"><span data-stu-id="1313d-512">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1313d-513">Für einige Implementierungen, wenn mehr, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-513">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1313d-514">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1313d-514">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1313d-515">Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1313d-515">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-516">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-516">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-517">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-517">-or-</span></span> 
<span data-ttu-id="1313d-518">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-518">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-519">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="1313d-519">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-520"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-520"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1313d-521">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-521">-or-</span></span> 
 <span data-ttu-id="1313d-522"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-522"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-523">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-523">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-524">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-524">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1313d-525"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="1313d-525"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-526">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-526">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1313d-527">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="1313d-527">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1313d-528">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="1313d-528">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1313d-529"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-529"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1313d-530">Wartet, bis Elemente im angegebenen Array ein Signal empfangen, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1313d-530">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1313d-531">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="millisecondsTimeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-531">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-532">Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-532">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-533">Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-533">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-534"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="1313d-534"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1313d-535">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methodenrückgabe `true` , wenn der Wartevorgang abgeschlossen wird, da ein Mutex abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="1313d-535">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="1313d-536">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="1313d-536">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1313d-537">Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="1313d-537">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1313d-538">Die Ausnahme enthält Informationen, die beim Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="1313d-538">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1313d-539">Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn die Wartezeit aufgrund einer abgebrochenen Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-539">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1313d-540">Wenn `waitHandles` einen freigegebenen Mutex mit einer geringeren Anzahl von Index als den abgebrochenen Mutex, enthält die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode normal abgeschlossen und die Ausnahme nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-540">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1313d-541">In Versionen von .NET Framework-Versionen vor Version 2.0, wenn ein Thread beendet oder abgebrochen wird, ohne dass explizit freigegeben eine <xref:System.Threading.Mutex>, und dass `Mutex` befindet sich am Index 0 (null) in eine `WaitAny` Array auf einem anderen Thread, der von zurückgegebene Index `WaitAny` ist 128 statt 0.</span><span class="sxs-lookup"><span data-stu-id="1313d-541">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="1313d-542">Wenn der Wartevorgang wird beendet, wenn eines der Handles signalisiert werden oder wenn ein Timeout auftritt, gibt diese Methode zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-542">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="1313d-543">Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts signalisiert mit dem kleinsten Indexwert aller signalisiert Objekte an.</span><span class="sxs-lookup"><span data-stu-id="1313d-543">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1313d-544">Für einige Implementierungen, wenn mehr, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-544">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1313d-545">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="1313d-545">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1313d-546">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-546">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1313d-547">Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1313d-547">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1313d-548">Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-548">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1313d-549">Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1313d-549">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="1313d-550">Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-550">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="1313d-551">Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-551">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1313d-552">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-552">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1313d-553">Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-553">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1313d-554">Wenn die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-554">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-555">Im folgenden Codebeispiel wird veranschaulicht, Threadpool zu verwenden, um gleichzeitig für eine Datei auf mehreren Datenträgern zu suchen.</span><span class="sxs-lookup"><span data-stu-id="1313d-555">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="1313d-556">Aus Platzgründen wird nur das Stammverzeichnis für die einzelnen Datenträger durchsucht.</span><span class="sxs-lookup"><span data-stu-id="1313d-556">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-557">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-557">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-558">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-558">-or-</span></span> 
<span data-ttu-id="1313d-559">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-559">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-560">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="1313d-560">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1313d-561"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="1313d-561"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-562"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-562"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-563">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-563">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-564">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-564">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1313d-565"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="1313d-565"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-566">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-566">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1313d-567">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="1313d-567">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="1313d-568">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="1313d-568">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1313d-569"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-569"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1313d-570">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1313d-570">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1313d-571">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="timeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-571">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-572">Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-572">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-573">Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-573">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-574"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="1313d-574"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1313d-575">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methodenrückgabe `true` , wenn der Wartevorgang abgeschlossen wird, da ein Mutex abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="1313d-575">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="1313d-576">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="1313d-576">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1313d-577">Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="1313d-577">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1313d-578">Die Ausnahme enthält Informationen, die beim Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="1313d-578">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1313d-579">Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn die Wartezeit aufgrund einer abgebrochenen Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-579">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1313d-580">Wenn `waitHandles` einen freigegebenen Mutex mit einer geringeren Anzahl von Index als den abgebrochenen Mutex, enthält die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode normal abgeschlossen und die Ausnahme nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-580">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1313d-581">In Versionen von .NET Framework-Versionen vor Version 2.0, wenn ein Thread beendet oder abgebrochen wird, ohne dass explizit freigegeben eine <xref:System.Threading.Mutex>, und dass `Mutex` befindet sich am Index 0 (null) in eine `WaitAny` Array auf einem anderen Thread, der von zurückgegebene Index `WaitAny` ist 128 statt 0.</span><span class="sxs-lookup"><span data-stu-id="1313d-581">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="1313d-582">Wenn der Wartevorgang wird beendet, wenn Handles signalisiert werden oder wenn ein Timeout auftritt, gibt diese Methode zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-582">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="1313d-583">Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts signalisiert mit dem kleinsten Indexwert aller signalisiert Objekte an.</span><span class="sxs-lookup"><span data-stu-id="1313d-583">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1313d-584">Für einige Implementierungen, wenn mehr, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-584">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1313d-585">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1313d-585">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1313d-586">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="1313d-586">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1313d-587">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-587">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1313d-588">Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1313d-588">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1313d-589">Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-589">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1313d-590">Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1313d-590">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="1313d-591">Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-591">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="1313d-592">Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-592">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1313d-593">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-593">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1313d-594">Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-594">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1313d-595">Wenn die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-595">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-596">Im folgenden Codebeispiel wird veranschaulicht, Threadpool zu verwenden, um gleichzeitig für eine Datei auf mehreren Datenträgern zu suchen.</span><span class="sxs-lookup"><span data-stu-id="1313d-596">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="1313d-597">Aus Platzgründen wird nur das Stammverzeichnis für die einzelnen Datenträger durchsucht.</span><span class="sxs-lookup"><span data-stu-id="1313d-597">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1313d-598">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-598">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1313d-599">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-599">-or-</span></span> 
<span data-ttu-id="1313d-600">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-600">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1313d-601">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="1313d-601">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1313d-602"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="1313d-602"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-603"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-603"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1313d-604">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-604">-or-</span></span> 
 <span data-ttu-id="1313d-605"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-605"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-606">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-606">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-607">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-607">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1313d-608"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="1313d-608"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-609">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-609">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1313d-610">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="1313d-610">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1313d-611">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="1313d-611">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns><span data-ttu-id="1313d-612"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="1313d-612"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="1313d-613">Wenn die aktuelle Instanz kein Signal erhält, wird <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="1313d-613">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-614"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="1313d-614"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1313d-615">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="1313d-615">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1313d-616">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="1313d-616">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1313d-617">Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="1313d-617">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1313d-618">Die Ausnahme enthält Informationen, die beim Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="1313d-618">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1313d-619">Der Aufrufer dieser Methode blockiert, die auf unbestimmte Zeit, bis die aktuelle Instanz ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="1313d-619">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="1313d-620">Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> ein Signal empfängt, von einem anderen Thread, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-620">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1313d-621">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="1313d-621">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1313d-622">Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> -methodenüberladung, und geben-1 oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für den ersten Parameter und `false` für den zweiten Parameter.</span><span class="sxs-lookup"><span data-stu-id="1313d-622">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="1313d-623">Überschreiben Sie diese Methode, um das Verhalten von abgeleiteten Klassen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="1313d-623">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-624">Im folgenden Codebeispiel wird veranschaulicht, wie ein Wait-Handle verwenden, um zu verhindern, dass einen Prozess beendet wird, während auf einem Hintergrundthread Beenden der Ausführung gewartet wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-624">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1313d-625">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="1313d-625">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-626">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-627">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-628">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="1313d-629">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="1313d-629">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1313d-630">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls in Millisekunden verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-630">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="1313d-631"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-632">Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-632">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-633">Er testet den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-634">Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal oder ein Timeout empfängt auftritt.</span><span class="sxs-lookup"><span data-stu-id="1313d-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1313d-635">Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> ein Signal empfängt, von einem anderen Thread, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1313d-636">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="1313d-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1313d-637">Überschreiben Sie diese Methode, um das Verhalten von abgeleiteten Klassen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="1313d-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="1313d-638">Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1313d-638">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-639">Im folgenden Codebeispiel wird veranschaulicht, wie ein Wait-Handle verwenden, um zu verhindern, dass einen Prozess beendet wird, während auf einem Hintergrundthread Beenden der Ausführung gewartet wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-639">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1313d-640">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="1313d-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-641"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-641"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-642">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-642">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-643">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-643">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-644">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-644">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="1313d-645">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="1313d-645">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1313d-646">Blockiert den aktuellen Thread, bis die aktuelle Instanz ein Signal empfängt, wobei eine <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-646">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1313d-647"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-647"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-648">Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-648">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-649">Er testet den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-649">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-650">Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal oder ein Timeout empfängt auftritt.</span><span class="sxs-lookup"><span data-stu-id="1313d-650">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1313d-651">Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> ein Signal empfängt, von einem anderen Thread, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-651">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1313d-652">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="1313d-652">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1313d-653">Überschreiben Sie diese Methode, um das Verhalten von abgeleiteten Klassen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="1313d-653">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="1313d-654">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1313d-654">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1313d-655">Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1313d-655">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1313d-656">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="1313d-656">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-657"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-657"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1313d-658">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-658">-or-</span></span> 
 <span data-ttu-id="1313d-659"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-659"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-660">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-660">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-661">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-661">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-662">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-662">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="1313d-663">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="1313d-663">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1313d-664"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-664"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1313d-665">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls verwendet und angegeben wird, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1313d-665">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1313d-666"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-666"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-667">Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-667">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-668">Er testet den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-668">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-669"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="1313d-669"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1313d-670">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="1313d-670">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1313d-671">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="1313d-671">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1313d-672">Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="1313d-672">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1313d-673">Die Ausnahme enthält Informationen, die beim Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="1313d-673">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1313d-674">Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal oder ein Timeout empfängt auftritt.</span><span class="sxs-lookup"><span data-stu-id="1313d-674">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1313d-675">Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> ein Signal empfängt, von einem anderen Thread, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-675">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1313d-676">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="1313d-676">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1313d-677">Überschreiben Sie diese Methode, um das Verhalten von abgeleiteten Klassen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="1313d-677">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1313d-678">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="1313d-678">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1313d-679">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-679">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1313d-680">Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1313d-680">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1313d-681">Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-681">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1313d-682">Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1313d-682">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="1313d-683">Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-683">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="1313d-684">Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-684">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1313d-685">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-685">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1313d-686">Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-686">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1313d-687">Wenn die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-687">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-688">Das folgende Beispiel zeigt die <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> Überladung verhält sich, wenn sie innerhalb einer Synchronisierungsdomäne aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-688">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="1313d-689">Zunächst wartet ein Thread mit `exitContext` festgelegt `false` und blockiert, bis das Timeout für die Wartezeit abläuft.</span><span class="sxs-lookup"><span data-stu-id="1313d-689">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="1313d-690">Ein zweiter Thread ausgeführt wird, nachdem der erste Thread beendet und wartet mit `exitContext` festgelegt `true`.</span><span class="sxs-lookup"><span data-stu-id="1313d-690">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="1313d-691">Der Aufruf der Wait-Handle für diesen zweiten Thread signalisiert wird nicht blockiert, und der Thread abgeschlossen ist, bevor das Wartetimeout.</span><span class="sxs-lookup"><span data-stu-id="1313d-691">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1313d-692">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="1313d-692">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-693"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-693"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-694">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-694">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-695">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-695">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-696">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-696">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="1313d-697">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="1313d-697">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1313d-698"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-698"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1313d-699">Blockiert den aktuellen Thread, bis die aktuelle Instanz ein Signal empfängt, wobei eine <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet und angegeben wird, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1313d-699">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1313d-700"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-700"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-701">Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="1313d-701">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1313d-702">Er testet den Zustand des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="1313d-702">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1313d-703"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="1313d-703"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1313d-704">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="1313d-704">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1313d-705">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="1313d-705">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1313d-706">Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="1313d-706">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1313d-707">Die Ausnahme enthält Informationen, die beim Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="1313d-707">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1313d-708">Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal oder ein Timeout empfängt auftritt.</span><span class="sxs-lookup"><span data-stu-id="1313d-708">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1313d-709">Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> ein Signal empfängt, von einem anderen Thread, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1313d-709">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1313d-710">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="1313d-710">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1313d-711">Überschreiben Sie diese Methode, um das Verhalten von abgeleiteten Klassen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="1313d-711">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="1313d-712">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1313d-712">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1313d-713">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="1313d-713">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1313d-714">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-714">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1313d-715">Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1313d-715">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1313d-716">Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-716">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1313d-717">Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1313d-717">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="1313d-718">Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-718">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="1313d-719">Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1313d-719">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1313d-720">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="1313d-720">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1313d-721">Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-721">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1313d-722">Wenn die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.</span><span class="sxs-lookup"><span data-stu-id="1313d-722">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-723">Im folgenden Codebeispiel wird veranschaulicht, wie ein Wait-Handle verwenden, um zu verhindern, dass einen Prozess beendet wird, während auf einem Hintergrundthread Beenden der Ausführung gewartet wird.</span><span class="sxs-lookup"><span data-stu-id="1313d-723">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1313d-724">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="1313d-724">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1313d-725"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="1313d-725"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1313d-726">- oder -</span><span class="sxs-lookup"><span data-stu-id="1313d-726">-or-</span></span> 
 <span data-ttu-id="1313d-727"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1313d-727"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1313d-728">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="1313d-728">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1313d-729">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1313d-729">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1313d-730">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="1313d-730">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="1313d-731">Gibt an, dass ein Timeout für einen <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />-Vorgang überschritten wurde, bevor ein Signal an eines der WaitHandles gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="1313d-731">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="1313d-732">Dieses Feld ist konstant.</span><span class="sxs-lookup"><span data-stu-id="1313d-732">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1313d-733">Dieses Feld ist eine der die möglichen Rückgabewerte von `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="1313d-733">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1313d-734">Im folgenden Codebeispiel wird veranschaulicht, Threadpool zu verwenden, um gleichzeitig für eine Datei auf mehreren Datenträgern zu suchen.</span><span class="sxs-lookup"><span data-stu-id="1313d-734">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="1313d-735">Aus Platzgründen wird nur das Stammverzeichnis für die einzelnen Datenträger durchsucht.</span><span class="sxs-lookup"><span data-stu-id="1313d-735">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>