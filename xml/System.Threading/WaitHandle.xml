<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="107e6ef6e51385d5827461c353aa32b70f721838" /><Meta Name="ms.sourcegitcommit" Value="1403e40e1f487577d6846a42664d2e74b78a08b7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/29/2020" /><Meta Name="ms.locfileid" Value="76824753" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="d7680-101">Kapselt betriebssystemspezifische Objekte, die auf exklusiven Zugriff auf gemeinsam genutzte Ressourcen warten.</span><span class="sxs-lookup"><span data-stu-id="d7680-101">Encapsulates operating system-specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-102">Die <xref:System.Threading.WaitHandle>-Klasse kapselt ein System eigenes Synchronisierungs Handle für das Betriebssystem und dient zur Darstellung aller Synchronisierungs Objekte in der Laufzeit, die mehrere warte Vorgänge zulassen.</span><span class="sxs-lookup"><span data-stu-id="d7680-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="d7680-103">Einen Vergleich der Wait-Handles mit anderen Synchronisierungs Objekten finden Sie unter [Übersicht über Synchronisierungs primitive](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="d7680-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="d7680-104">Die <xref:System.Threading.WaitHandle> Klasse selbst ist abstrakt.</span><span class="sxs-lookup"><span data-stu-id="d7680-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="d7680-105">Von <xref:System.Threading.WaitHandle> abgeleitete Klassen definieren einen Signalisierungs Mechanismus, der angibt, dass der Zugriff auf eine freigegebene Ressource übernommen oder freigegeben wird. Sie verwenden jedoch die geerbten <xref:System.Threading.WaitHandle> Methoden, um den Zugriff auf freigegebene Ressourcen zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="d7680-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="d7680-106">Die von <xref:System.Threading.WaitHandle> abgeleiteten Klassen umfassen Folgendes:</span><span class="sxs-lookup"><span data-stu-id="d7680-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="d7680-107">Der <xref:System.Threading.Mutex>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d7680-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="d7680-108">Siehe [Mutexes](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="d7680-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="d7680-109">Die <xref:System.Threading.EventWaitHandle> Klasse und die abgeleiteten Klassen, <xref:System.Threading.AutoResetEvent> und <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="d7680-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span>  
  
-   <span data-ttu-id="d7680-110">Der <xref:System.Threading.Semaphore>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d7680-110">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="d7680-111">Weitere Informationen finden Sie unter [Semaphore und SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="d7680-111">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="d7680-112">Threads können einen einzelnen Wait-Handle blockieren, indem Sie die Instanzmethode <xref:System.Threading.WaitHandle.WaitOne%2A>aufrufen, die von Klassen geerbt wird, die von <xref:System.Threading.WaitHandle>abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="d7680-112">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="d7680-113">Die abgeleiteten Klassen von <xref:System.Threading.WaitHandle> unterscheiden sich in ihrer Thread Affinität.</span><span class="sxs-lookup"><span data-stu-id="d7680-113">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="d7680-114">Ereignis-Wait-Handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>und <xref:System.Threading.ManualResetEvent>) und Semaphoren haben keine Thread Affinität. Jeder Thread kann einem Ereignis-Wait-Handle oder Semaphore signalisieren.</span><span class="sxs-lookup"><span data-stu-id="d7680-114">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="d7680-115">Mutexes hingegen haben Thread Affinität. der Thread, der einen Mutex besitzt, muss ihn freigeben, und eine Ausnahme wird ausgelöst, wenn ein Thread die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode für einen Mutex aufruft, den er nicht besitzt.</span><span class="sxs-lookup"><span data-stu-id="d7680-115">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="d7680-116">Da die <xref:System.Threading.WaitHandle>-Klasse von <xref:System.MarshalByRefObject>abgeleitet ist, können diese Klassen verwendet werden, um die Aktivitäten von Threads über Anwendungs Domänen Grenzen hinweg zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="d7680-116">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="d7680-117">Zusätzlich zu den abgeleiteten Klassen verfügt die <xref:System.Threading.WaitHandle>-Klasse über eine Reihe statischer Methoden, die einen Thread blockieren, bis mindestens ein Synchronisierungs Objekt ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="d7680-117">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="d7680-118">Dazu gehören:</span><span class="sxs-lookup"><span data-stu-id="d7680-118">These include:</span></span>  
  
-   <span data-ttu-id="d7680-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, das einem Thread ermöglicht, ein Wait-Handle zu signalisieren und sofort auf einen anderen zu warten.</span><span class="sxs-lookup"><span data-stu-id="d7680-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="d7680-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, der es einem Thread ermöglicht, zu warten, bis alle Wait-Handles in einem Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="d7680-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="d7680-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, der es einem Thread ermöglicht, zu warten, bis eine angegebene Gruppe von Wait-Handles signalisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="d7680-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled.</span></span>  
  
 <span data-ttu-id="d7680-122">Die über Ladungen dieser Methoden stellen Timeout Intervalle für das Abbrechen des warte Vorgangs sowie die Möglichkeit zum Beenden eines Synchronisierungs Kontexts vor dem warte Vorgang bereit, sodass andere Threads den Synchronisierungs Kontext verwenden können.</span><span class="sxs-lookup"><span data-stu-id="d7680-122">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d7680-123">Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="d7680-123">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="d7680-124">Wenn Sie den Typ oder einen von ihm abgeleiteten Typ nicht mehr verwenden, sollten Sie ihn entweder direkt oder indirekt verwerfen.</span><span class="sxs-lookup"><span data-stu-id="d7680-124">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="d7680-125">Zum direkten Löschen des Typs rufen Sie seine <xref:System.Threading.WaitHandle.Close%2A>-Methode in einem `try`/`catch`-Block auf.</span><span class="sxs-lookup"><span data-stu-id="d7680-125">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="d7680-126">Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="d7680-126">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="d7680-127">Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.</span><span class="sxs-lookup"><span data-stu-id="d7680-127">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="d7680-128"><xref:System.Threading.WaitHandle> das <xref:System.IDisposable.Dispose%2A> Muster implementiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-128"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="d7680-129">Weitere Informationen finden Sie unter [Implementieren einer verwerfen-Methode] (~/docs/Standard/Garbage-Collection/Implementing-Dispose. MD).</span><span class="sxs-lookup"><span data-stu-id="d7680-129">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="d7680-130">Wenn Sie von <xref:System.Threading.WaitHandle>ableiten, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>-Eigenschaft, um das systemeigene Betriebssystem Handle zu speichern.</span><span class="sxs-lookup"><span data-stu-id="d7680-130">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="d7680-131">Sie müssen die geschützte <xref:System.Threading.WaitHandle.Dispose%2A> Methode nicht außer Kraft setzen, es sei denn, Sie verwenden zusätzliche nicht verwaltete Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="d7680-131">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-132">Im folgenden Codebeispiel wird gezeigt, wie zwei Threads Hintergrundaufgaben ausführen können, während der Haupt Thread auf den Abschluss der Aufgaben mithilfe der statischen <xref:System.Threading.WaitHandle.WaitAny%2A> und <xref:System.Threading.WaitHandle.WaitAll%2A> Methoden der <xref:System.Threading.WaitHandle>-Klasse wartet.</span><span class="sxs-lookup"><span data-stu-id="d7680-132">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="d7680-133">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="d7680-133">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="d7680-134">Threading</span><span class="sxs-lookup"><span data-stu-id="d7680-134">Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="d7680-135">Threadingobjekte und -funktionen</span><span class="sxs-lookup"><span data-stu-id="d7680-135">Threading Objects and Features</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="d7680-136">Mutexe</span><span class="sxs-lookup"><span data-stu-id="d7680-136">Mutexes</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d"><span data-ttu-id="d7680-137">EventWaitHandle, AutoResetEvent und ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="d7680-137">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="d7680-138">Semaphoren</span><span class="sxs-lookup"><span data-stu-id="d7680-138">Semaphores</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public WaitHandle ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WaitHandle();" FrameworkAlternate="netframework-1.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d7680-139">Initialisiert eine neue Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d7680-139">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d7680-140">Gibt alle von der aktuellen <see cref="T:System.Threading.WaitHandle" />-Klasse reservierten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d7680-140">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-141">Bei dieser Methode handelt es sich um die öffentliche Implementierung der <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Methode für die <xref:System.Threading.WaitHandle>-Klasse und die abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="d7680-141">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="d7680-142">Sie stellt eine Standard Implementierung bereit, die die `Dispose(Boolean)` Überladung mit einem `true`-Argument aufruft und dann die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>-Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="d7680-142">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d7680-143">Mit dieser Methode können Sie alle Ressourcen freigeben, die von einer Instanz von `WaitHandle` oder einer abgeleiteten Klasse aufbewahrt werden.</span><span class="sxs-lookup"><span data-stu-id="d7680-143">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="d7680-144">Nachdem diese Methode aufgerufen wurde, verursachen Verweise auf die aktuelle Instanz nicht definiertes Verhalten.</span><span class="sxs-lookup"><span data-stu-id="d7680-144">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7680-145">Vor dem Freigeben des letzten Verweises auf die <xref:System.Threading.WaitHandle>sollten Sie immer <xref:System.Threading.WaitHandle.Close%2A> oder <xref:System.Threading.WaitHandle.Dispose> abrufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-145">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="d7680-146">Andernfalls werden die von ihm verwendeten Ressourcen nicht freigegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-146">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d7680-147">Sie sollten die <see langword="Dispose(Boolean)" />-Methode außer Kraft setzen, um in abgeleiteten Klassen zugewiesene Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-147">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="d7680-148">Implementieren einer Dispose-Methode</span><span class="sxs-lookup"><span data-stu-id="d7680-148">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d7680-149">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d7680-149">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d7680-150">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d7680-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-151">Diese Methode entspricht der <xref:System.Threading.WaitHandle.Close%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="d7680-151">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7680-152">Vor dem Freigeben des letzten Verweises auf die <xref:System.Threading.WaitHandle>sollten Sie immer <xref:System.Threading.WaitHandle.Close%2A> oder <xref:System.Threading.WaitHandle.Dispose> abrufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-152">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="d7680-153">Andernfalls werden die von ihm verwendeten Ressourcen nicht freigegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-153">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="d7680-154">Bereinigen von nicht verwalteten Ressourcen</span><span class="sxs-lookup"><span data-stu-id="d7680-154">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><span data-ttu-id="d7680-155"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-155"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="d7680-156">Gibt beim Überschreiben in einer abgeleiteten Klasse die von <see cref="T:System.Threading.WaitHandle" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d7680-156">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-157">Diese Methode wird vom-<xref:System.Threading.WaitHandle.Close%2A> und den <xref:System.Threading.WaitHandle.Dispose>-Methoden aufgerufen, wobei der `explicitDisposing`-Parameter auf `true`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-157">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="d7680-158">Wenn der `explicitDisposing`-Parameter `true`ist, gibt diese Methode alle Ressourcen frei, die von verwalteten Objekten gehalten werden, auf die dieses <xref:System.Threading.WaitHandle> Objekt verweist.</span><span class="sxs-lookup"><span data-stu-id="d7680-158">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d7680-159">Sie sollten die <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />-Methode außer Kraft setzen, um in abgeleiteten Klassen zugewiesene Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-159">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
<span data-ttu-id="d7680-160">Die <see cref="M:System.Threading.WaitHandle.Close" />-oder <see cref="M:System.Threading.WaitHandle.Dispose" />-Methode kann von anderen Objekten mehrmals aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d7680-160">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="d7680-161">Wenn Sie diese Methode überschreiben, sollten Sie darauf achten, nicht auf Objekte zu verweisen, die zuvor in einem früheren <see langword="Dispose" /> oder <see langword="Close" />freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="d7680-161">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="d7680-162">Implementieren einer Dispose-Methode</span><span class="sxs-lookup"><span data-stu-id="d7680-162">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d7680-163">Gibt die von der aktuellen Instanz reservierten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d7680-163">Releases the resources held by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> <span data-ttu-id="d7680-164">Dieses Mitglied wurde aus den .NET Framework Version 2,0 und nachfolgenden Versionen entfernt.</span><span class="sxs-lookup"><span data-stu-id="d7680-164">This member has been removed from the .NET Framework version 2.0 and subsequent versions.</span></span> <span data-ttu-id="d7680-165">Dieses Thema gilt nur für die unter "Versionsinformationen" weiter unten in diesem Thema aufgeführten Versionen.</span><span class="sxs-lookup"><span data-stu-id="d7680-165">This topic applies only to the versions listed in "Version Information" later in this topic.</span></span>


<span data-ttu-id="d7680-166">Der Anwendungscode ruft diese Methode nicht auf. Sie wird automatisch während Garbage Collection aufgerufen, es sei denn, die Garbage Collector wurde deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="d7680-166">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="d7680-167">Weitere Informationen finden Sie unter <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> und <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="d7680-167">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="d7680-168">Diese Methode überschreibt <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="d7680-168">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d7680-169">Ruft das systemeigene Betriebssystemhandle auf oder legt dieses fest.</span><span class="sxs-lookup"><span data-stu-id="d7680-169">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="d7680-170">Ein <see langword="IntPtr" />, das das systemeigene Betriebssystemhandle darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-170">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="d7680-171">Der Standardwert ist der Wert des <see cref="F:System.Threading.WaitHandle.InvalidHandle" />-Felds.</span><span class="sxs-lookup"><span data-stu-id="d7680-171">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-172">Wenn Sie der <xref:System.Threading.WaitHandle.Handle%2A>-Eigenschaft einen neuen Wert zuweisen, wird das vorherige Handle nicht geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d7680-172">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="d7680-173">Dies kann zu einem kompromittierten Handle führen.</span><span class="sxs-lookup"><span data-stu-id="d7680-173">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="d7680-174">Verwenden Sie diese Eigenschaft nicht in der .NET Framework Version 2,0 oder höher. Verwenden Sie stattdessen die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="d7680-174">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="d7680-175">Wenn diese Eigenschaft auf ein gültiges Handle festgelegt wird, wird auch die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>-Eigenschaft festgelegt, aber das Festlegen auf <xref:System.Threading.WaitHandle.InvalidHandle> kann zu einem kompromittierten Handle führen.</span><span class="sxs-lookup"><span data-stu-id="d7680-175">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="d7680-176">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer, um den Eigenschafts Wert festzulegen.</span><span class="sxs-lookup"><span data-stu-id="d7680-176">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="d7680-177">Dieser Member kann nicht durch teilweise vertrauenswürdigen oder transparenten Code festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="d7680-177">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="d7680-178">Abgeleitete Typen müssen über <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> verfügen, um den Eigenschafts Wert festzulegen.</span><span class="sxs-lookup"><span data-stu-id="d7680-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d7680-179">Stellt ein ungültiges systemeigenes Betriebssystemhandle dar.</span><span class="sxs-lookup"><span data-stu-id="d7680-179">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="d7680-180">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="d7680-180">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-181">Wird intern verwendet, um die <xref:System.Threading.WaitHandle.Handle%2A>-Eigenschaft zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="d7680-181">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d7680-182">Sie können diesen Wert verwenden, um zu bestimmen, ob die <see cref="P:System.Threading.WaitHandle.Handle" />-Eigenschaft ein gültiges System eigenes Betriebssystem Handle enthält.</span><span class="sxs-lookup"><span data-stu-id="d7680-182">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d7680-183">Ruft das systemeigene Betriebssystemhandle auf oder legt dieses fest.</span><span class="sxs-lookup"><span data-stu-id="d7680-183">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="d7680-184">Ein <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />, das das systemeigene Betriebssystemhandle darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-184">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-185">Wenn Sie der <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>-Eigenschaft einen neuen Wert zuweisen, wird das vorherige Handle geschlossen, wenn das vorherige <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Objekt erfasst wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-185">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="d7680-186">Schließen Sie das Handle nicht manuell, da dies zu einer <xref:System.ObjectDisposedException> führt, wenn der <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> versucht, das Handle zu schließen.</span><span class="sxs-lookup"><span data-stu-id="d7680-186">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="d7680-187"><xref:System.Threading.WaitHandle> das <xref:System.IDisposable.Dispose%2A> Muster implementiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-187"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="d7680-188">Weitere Informationen finden Sie unter [Implementieren einer Löschmethode](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="d7680-188">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span> <span data-ttu-id="d7680-189">Wenn Sie von <xref:System.Threading.WaitHandle>ableiten, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>-Eigenschaft, um das systemeigene Handle-Betriebssystem Handle zu speichern.</span><span class="sxs-lookup"><span data-stu-id="d7680-189">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="d7680-190">Sie müssen die geschützte <xref:System.Threading.WaitHandle.Dispose%2A> Methode nicht außer Kraft setzen, es sei denn, Sie verwenden zusätzliche nicht verwaltete Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="d7680-190">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="d7680-191">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="d7680-191">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="d7680-192">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d7680-192">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="d7680-193">Abgeleitete Typen müssen über <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> verfügen, um diesen Member aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-193">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d7680-194">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf einen anderen.</span><span class="sxs-lookup"><span data-stu-id="d7680-194">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="d7680-195">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-195">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="d7680-196">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d7680-196">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="d7680-197">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf einen anderen.</span><span class="sxs-lookup"><span data-stu-id="d7680-197">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns><span data-ttu-id="d7680-198"><see langword="true" />, wenn das Signal und der Wartevorgang erfolgreich abgeschlossen wurden. Wenn der Wartevorgang nicht abgeschlossen wird, wird die Methode nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="d7680-198"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-199">Es ist nicht garantiert, dass dieser Vorgang atomarisch ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-199">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="d7680-200">Nachdem der aktuelle Thread `toSignal` signalisiert hat, aber bevor er auf `toWaitOn`wartet, könnte ein Thread, der auf einem anderen Prozessor ausgeführt wird, `toWaitOn` oder darauf warten.</span><span class="sxs-lookup"><span data-stu-id="d7680-200">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-201">Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>-Methoden Überladung verwendet, damit der Haupt Thread einen blockierten Thread signalisiert und dann wartet, bis der Thread eine Aufgabe abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="d7680-201">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="d7680-202">Im Beispiel werden fünf Threads gestartet, sodass Sie für ein <xref:System.Threading.EventWaitHandle> blockieren können, das mit dem <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>-Flag erstellt wurde, und dann bei jedem Drücken der EINGABETASTE einen Thread freigeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-202">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="d7680-203">Im Beispiel werden dann weitere fünf Threads in die Warteschlange eingereiht und mit einem <xref:System.Threading.EventWaitHandle> freigegeben, das mit dem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellt wurde</span><span class="sxs-lookup"><span data-stu-id="d7680-203">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-204"><paramref name="toSignal" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-204"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-205">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-205">-or-</span></span> 
 <span data-ttu-id="d7680-206"><paramref name="toWaitOn" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-206"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-207">Die Methode wurde in einem Thread im Status <see cref="F:System.Threading.ApartmentState.STA" /> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-207">The method was called on a thread in <see cref="F:System.Threading.ApartmentState.STA" /> state.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-208"><paramref name="toSignal" /> ist ein Semaphor, und die maximale Anzahl ist bereits erreicht.</span><span class="sxs-lookup"><span data-stu-id="d7680-208"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-209">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-209">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-210">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-210">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="d7680-211">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-211">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="d7680-212">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d7680-212">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="d7680-213">Eine Ganzzahl, die das Wartezeitintervall darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-213">An integer that represents the interval to wait.</span></span> <span data-ttu-id="d7680-214">Wenn der Wert <see cref="F:System.Threading.Timeout.Infinite" /> (d. h. -1) ist, ist die Wartezeit unendlich.</span><span class="sxs-lookup"><span data-stu-id="d7680-214">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d7680-215"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-215"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d7680-216">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf ein weiteres, wobei ein Timeoutintervall als 32-Bit-Ganzzahl mit Vorzeichen angegeben und festgelegt wird, ob die Synchronisierungsdomäne des Kontexts vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d7680-216">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="d7680-217"><see langword="true" />, wenn das Signal und die Wartezeit erfolgreich abgeschlossen wurden, oder <see langword="false" />, wenn das Signal abgeschlossen wurde, für die Wartezeit jedoch ein Timeout aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-217"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-218">Es ist nicht garantiert, dass dieser Vorgang atomarisch ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-218">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="d7680-219">Nachdem der aktuelle Thread `toSignal` signalisiert hat, aber bevor er auf `toWaitOn`wartet, könnte ein Thread, der auf einem anderen Prozessor ausgeführt wird, `toWaitOn` oder darauf warten.</span><span class="sxs-lookup"><span data-stu-id="d7680-219">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="d7680-220">Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-220">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-221">Er testet den Status des `toWaitOn` und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-221">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d7680-222">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="d7680-222">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d7680-223">Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-223">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d7680-224">Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-224">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d7680-225">Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-225">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d7680-226">Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-226">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="d7680-227">Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d7680-227">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="d7680-228">Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt.</span><span class="sxs-lookup"><span data-stu-id="d7680-228">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d7680-229">In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d7680-229">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d7680-230">Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d7680-230">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d7680-231">Wenn die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird</span><span class="sxs-lookup"><span data-stu-id="d7680-231">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-232"><paramref name="toSignal" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-232"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-233">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-233">-or-</span></span> 
 <span data-ttu-id="d7680-234"><paramref name="toWaitOn" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-234"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-235">Die Methode wird in einem Thread im Status <see cref="F:System.Threading.ApartmentState.STA" /> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-235">The method is called on a thread in <see cref="F:System.Threading.ApartmentState.STA" /> state.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-236">Das <see cref="T:System.Threading.WaitHandle" /> kann nicht signalisiert werden, da dies die maximale Anzahl übersteigen würde.</span><span class="sxs-lookup"><span data-stu-id="d7680-236">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-237"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-237"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-238">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-238">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-239">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-239">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="d7680-240">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-240">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="d7680-241">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d7680-241">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="d7680-242">Ein <see cref="T:System.TimeSpan" />-Wert, der das Wartezeitintervall darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-242">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="d7680-243">Wenn der Wert -1 ist, ist die Wartezeit unendlich.</span><span class="sxs-lookup"><span data-stu-id="d7680-243">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d7680-244"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-244"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d7680-245">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf ein weiteres, wobei das Timeoutintervall als <see cref="T:System.TimeSpan" /> angegeben und festgelegt wird, ob die Synchronisierungsdomäne des Kontexts vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d7680-245">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="d7680-246"><see langword="true" />, wenn das Signal und die Wartezeit erfolgreich abgeschlossen wurden, oder <see langword="false" />, wenn das Signal abgeschlossen wurde, für die Wartezeit jedoch ein Timeout aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-246"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-247">Es ist nicht garantiert, dass dieser Vorgang atomarisch ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-247">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="d7680-248">Nachdem der aktuelle Thread `toSignal` signalisiert hat, aber bevor er auf `toWaitOn`wartet, könnte ein Thread, der auf einem anderen Prozessor ausgeführt wird, `toWaitOn` oder darauf warten.</span><span class="sxs-lookup"><span data-stu-id="d7680-248">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="d7680-249">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d7680-249">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d7680-250">Wenn `timeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-250">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-251">Er testet den Status des `toWaitOn` und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-251">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d7680-252">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="d7680-252">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d7680-253">Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-253">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d7680-254">Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-254">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d7680-255">Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-255">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d7680-256">Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-256">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="d7680-257">Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d7680-257">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="d7680-258">Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt.</span><span class="sxs-lookup"><span data-stu-id="d7680-258">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d7680-259">In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d7680-259">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d7680-260">Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d7680-260">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d7680-261">Wenn die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird</span><span class="sxs-lookup"><span data-stu-id="d7680-261">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-262"><paramref name="toSignal" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-262"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-263">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-263">-or-</span></span> 
 <span data-ttu-id="d7680-264"><paramref name="toWaitOn" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-264"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-265">Die Methode wurde in einem Thread im Status <see cref="F:System.Threading.ApartmentState.STA" /> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-265">The method was called on a thread in <see cref="F:System.Threading.ApartmentState.STA" /> state.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-266"><paramref name="toSignal" /> ist ein Semaphor, und die maximale Anzahl ist bereits erreicht.</span><span class="sxs-lookup"><span data-stu-id="d7680-266"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-267"><paramref name="timeout" /> ergibt eine negative Anzahl von Millisekunden ungleich -1.</span><span class="sxs-lookup"><span data-stu-id="d7680-267"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
<span data-ttu-id="d7680-268">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-268">-or-</span></span> 
 <span data-ttu-id="d7680-269"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-269"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-270">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-270">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-271">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-271">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d7680-272">Gibt alle vom <see cref="T:System.Threading.WaitHandle" /> verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d7680-272">Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="d7680-273">Durch Aufrufen von `Dispose` können die Ressourcen, die vom <xref:System.Threading.WaitHandle> verwendet werden, für andere Zwecke neu zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="d7680-273">Calling `Dispose` allows the resources used by the <xref:System.Threading.WaitHandle> to be reallocated for other purposes.</span></span> <span data-ttu-id="d7680-274">Weitere Informationen zu `Dispose`finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="d7680-274">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d7680-275">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="d7680-275">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d7680-276">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="d7680-276">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="d7680-277">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</span><span class="sxs-lookup"><span data-stu-id="d7680-277">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="d7680-278">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="d7680-278">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="d7680-279"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls wird die Methode nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="d7680-279"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-280"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0.</span><span class="sxs-lookup"><span data-stu-id="d7680-280"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d7680-281">In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-281">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d7680-282">Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an.</span><span class="sxs-lookup"><span data-stu-id="d7680-282">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d7680-283">Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers).</span><span class="sxs-lookup"><span data-stu-id="d7680-283">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d7680-284">Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind</span><span class="sxs-lookup"><span data-stu-id="d7680-284">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d7680-285">Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode gibt zurück, wenn alle Handles signalisiert werden.</span><span class="sxs-lookup"><span data-stu-id="d7680-285">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="d7680-286">Wenn mehr als 64 Handles überschritten werden, wird eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-286">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="d7680-287">Wenn das Array Duplikate enthält, schlägt der-Befehl mit einem-<xref:System.DuplicateWaitObjectException>fehl.</span><span class="sxs-lookup"><span data-stu-id="d7680-287">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="d7680-288">Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird für Threads in <xref:System.Threading.ApartmentState.STA> Zustand nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d7680-288">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="d7680-289">Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>-Methoden Überladung und der Angabe von-1 (oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) für `millisecondsTimeout` und `true` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d7680-289">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-290">Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um asynchron eine Gruppe von Dateien zu erstellen und in diese zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d7680-290">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="d7680-291">Jeder Schreibvorgang wird als Arbeits Element in die Warteschlange eingereiht und signalisiert, wann er abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-291">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="d7680-292">Der Haupt Thread wartet darauf, dass alle Elemente signalisiert und dann beendet werden.</span><span class="sxs-lookup"><span data-stu-id="d7680-292">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-293">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-293">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="d7680-294">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-294">-or-</span></span> 
<span data-ttu-id="d7680-295">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-295">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-296">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-296">-or-</span></span> 
 <span data-ttu-id="d7680-297"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="d7680-297"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="d7680-298">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="d7680-298">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="d7680-299">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-299">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-300">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="d7680-300">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="d7680-301">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-301">-or-</span></span> 
<span data-ttu-id="d7680-302">Der aktuelle Thread ist im <see cref="F:System.Threading.ApartmentState.STA" />-Zustand, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-302">The current thread is <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d7680-303"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="d7680-303"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-304">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-304">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-305">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-305">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-306">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-306">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d7680-307">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="d7680-307">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="d7680-308">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt (Duplikate) enthalten.</span><span class="sxs-lookup"><span data-stu-id="d7680-308">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="d7680-309">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="d7680-309">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d7680-310">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.Int32" />-Wert an.</span><span class="sxs-lookup"><span data-stu-id="d7680-310">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="d7680-311"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-311"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-312">Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-312">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-313">Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-313">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-314">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Warte Vorgang beendet wird, was bedeutet, dass entweder alle Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-314">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="d7680-315">Wenn mehr als 64 Handles überschritten werden, wird eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-315">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="d7680-316">Wenn Duplikate im Array vorhanden sind, schlägt der-Befehl mit einem-<xref:System.DuplicateWaitObjectException>fehl.</span><span class="sxs-lookup"><span data-stu-id="d7680-316">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7680-317">Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird für Threads in <xref:System.Threading.ApartmentState.STA> Zustand nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d7680-317">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="d7680-318">Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d7680-318">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-319">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-319">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-320">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-320">-or-</span></span> 
<span data-ttu-id="d7680-321">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-321">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-322">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-322">-or-</span></span> 
 <span data-ttu-id="d7680-323"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-323"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="d7680-324">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="d7680-324">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="d7680-325">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-325">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-326">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="d7680-326">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="d7680-327">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-327">-or-</span></span> 
<span data-ttu-id="d7680-328">Der aktuelle Thread ist im <see cref="F:System.Threading.ApartmentState.STA" />-Zustand, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-328">The current thread is in <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-329"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-329"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-330">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-330">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-331">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-331">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-332">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-332">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d7680-333">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="d7680-333">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="d7680-334">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</span><span class="sxs-lookup"><span data-stu-id="d7680-334">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="d7680-335">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu Millisekunden für die Wartezeit angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden angibt, also eine unbeschränkte Wartezeit.</span><span class="sxs-lookup"><span data-stu-id="d7680-335">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d7680-336">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.TimeSpan" />-Wert an.</span><span class="sxs-lookup"><span data-stu-id="d7680-336">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="d7680-337"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-337"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-338">Wenn `timeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-338">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-339">Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-339">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-340">Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode gibt zurück, wenn der Warte Vorgang beendet wird, was bedeutet, dass entweder alle Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-340">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="d7680-341">Wenn mehr als 64 Handles überschritten werden, wird eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-341">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="d7680-342">Wenn das Array Duplikate enthält, schlägt der-Befehl fehl.</span><span class="sxs-lookup"><span data-stu-id="d7680-342">If the array contains duplicates, the call will fail.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="d7680-343">Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird für Threads in <xref:System.Threading.ApartmentState.STA> Zustand nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d7680-343">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="d7680-344">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d7680-344">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d7680-345">Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d7680-345">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-346">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-346">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-347">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-347">-or-</span></span> 
<span data-ttu-id="d7680-348">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-348">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-349">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-349">-or-</span></span> 
 <span data-ttu-id="d7680-350"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-350"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="d7680-351">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="d7680-351">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="d7680-352">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-352">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-353">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="d7680-353">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="d7680-354">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-354">-or-</span></span> 
<span data-ttu-id="d7680-355">Der aktuelle Thread ist im <see cref="F:System.Threading.ApartmentState.STA" />-Zustand, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-355">The current thread is in <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-356"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-356"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d7680-357">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-357">-or-</span></span> 
 <span data-ttu-id="d7680-358"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-358"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-359">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-359">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-360">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-360">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-361">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-361">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d7680-362">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="d7680-362">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="d7680-363">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt (Duplikate) enthalten.</span><span class="sxs-lookup"><span data-stu-id="d7680-363">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="d7680-364">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="d7680-364">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d7680-365"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-365"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d7680-366">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.Int32" />-Wert zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d7680-366">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d7680-367"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-367"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-368">Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-368">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-369">Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-369">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-370"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0.</span><span class="sxs-lookup"><span data-stu-id="d7680-370"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d7680-371">In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-371">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d7680-372">Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an.</span><span class="sxs-lookup"><span data-stu-id="d7680-372">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d7680-373">Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers).</span><span class="sxs-lookup"><span data-stu-id="d7680-373">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d7680-374">Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind</span><span class="sxs-lookup"><span data-stu-id="d7680-374">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d7680-375">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Warte Vorgang beendet wird, was bedeutet, dass entweder alle Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-375">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="d7680-376">Wenn mehr als 64 Handles überschritten werden, wird eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-376">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="d7680-377">Wenn Duplikate im Array vorhanden sind, schlägt der-Befehl mit einem-<xref:System.DuplicateWaitObjectException>fehl.</span><span class="sxs-lookup"><span data-stu-id="d7680-377">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="d7680-378">Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird für Threads in <xref:System.Threading.ApartmentState.STA> Zustand nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d7680-378">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d7680-379">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="d7680-379">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d7680-380">Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-380">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d7680-381">Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-381">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d7680-382">Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie z. b. <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-382">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d7680-383">Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-383">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="d7680-384">Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitAll%2A> Methode abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d7680-384">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="d7680-385">Dies kann hilfreich sein, wenn die Kontext gebundene Klasse über das <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>-Attribut verfügt.</span><span class="sxs-lookup"><span data-stu-id="d7680-385">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="d7680-386">In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d7680-386">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d7680-387">Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d7680-387">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d7680-388">Wenn die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird</span><span class="sxs-lookup"><span data-stu-id="d7680-388">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-389">Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um asynchron eine Gruppe von Dateien zu erstellen und in diese zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d7680-389">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="d7680-390">Jeder Schreibvorgang wird als Arbeits Element in die Warteschlange eingereiht und signalisiert, wann er abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-390">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="d7680-391">Der Haupt Thread wartet darauf, dass alle Elemente signalisiert und dann beendet werden.</span><span class="sxs-lookup"><span data-stu-id="d7680-391">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-392">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-392">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-393">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-393">-or-</span></span> 
<span data-ttu-id="d7680-394">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-394">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-395">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-395">-or-</span></span> 
 <span data-ttu-id="d7680-396"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="d7680-396"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="d7680-397">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-397">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-398">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="d7680-398">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="d7680-399">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-399">-or-</span></span> 
<span data-ttu-id="d7680-400">Der aktuelle Thread ist im <see cref="F:System.Threading.ApartmentState.STA" />-Zustand, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-400">The current thread is in <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d7680-401"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="d7680-401"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-402"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-402"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-403">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-403">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-404">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-404">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-405">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-405">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d7680-406">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="d7680-406">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="d7680-407">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</span><span class="sxs-lookup"><span data-stu-id="d7680-407">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="d7680-408">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu Millisekunden für die Wartezeit angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden angibt, also eine unbeschränkte Wartezeit.</span><span class="sxs-lookup"><span data-stu-id="d7680-408">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d7680-409"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-409"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d7680-410">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.TimeSpan" />-Wert zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d7680-410">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d7680-411"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-411"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-412">Wenn `timeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-412">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-413">Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-413">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-414"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0.</span><span class="sxs-lookup"><span data-stu-id="d7680-414"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d7680-415">In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-415">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d7680-416">Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an.</span><span class="sxs-lookup"><span data-stu-id="d7680-416">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d7680-417">Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers).</span><span class="sxs-lookup"><span data-stu-id="d7680-417">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d7680-418">Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind</span><span class="sxs-lookup"><span data-stu-id="d7680-418">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d7680-419">Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode gibt zurück, wenn der Warte Vorgang beendet wird, was bedeutet, dass entweder alle Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-419">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="d7680-420">Wenn mehr als 64 Handles überschritten werden, wird eine <xref:System.NotSupportedException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-420">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="d7680-421">Wenn das Array Duplikate enthält, schlägt der-Befehl fehl.</span><span class="sxs-lookup"><span data-stu-id="d7680-421">If the array contains duplicates, the call will fail.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="d7680-422">Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird für Threads in <xref:System.Threading.ApartmentState.STA> Zustand nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d7680-422">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="d7680-423">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d7680-423">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d7680-424">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="d7680-424">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d7680-425">Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-425">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d7680-426">Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-426">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d7680-427">Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie z. b. <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-427">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d7680-428">Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-428">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="d7680-429">Sie kehrt zum ursprünglichen, nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitAll%2A> Methode abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d7680-429">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="d7680-430">Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt.</span><span class="sxs-lookup"><span data-stu-id="d7680-430">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d7680-431">In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d7680-431">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d7680-432">Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d7680-432">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d7680-433">Wenn die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird</span><span class="sxs-lookup"><span data-stu-id="d7680-433">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-434">Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um asynchron eine Gruppe von Dateien zu erstellen und in diese zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d7680-434">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="d7680-435">Jeder Schreibvorgang wird als Arbeits Element in die Warteschlange eingereiht und signalisiert, wann er abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-435">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="d7680-436">Der Haupt Thread wartet darauf, dass alle Elemente signalisiert und dann beendet werden.</span><span class="sxs-lookup"><span data-stu-id="d7680-436">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-437">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-437">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-438">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-438">-or-</span></span> 
<span data-ttu-id="d7680-439">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-439">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-440">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-440">-or-</span></span> 
 <span data-ttu-id="d7680-441"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="d7680-441"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="d7680-442">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-442">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-443">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="d7680-443">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="d7680-444">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-444">-or-</span></span> 
<span data-ttu-id="d7680-445">Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-445">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d7680-446"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="d7680-446"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-447"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-447"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d7680-448">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-448">-or-</span></span> 
 <span data-ttu-id="d7680-449"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-449"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-450">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-450">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-451">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-451">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-452">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-452">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d7680-453">Wartet, bis Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="d7680-453">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d7680-454">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="d7680-454">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="d7680-455">Wartet, bis Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="d7680-455">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="d7680-456">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat.</span><span class="sxs-lookup"><span data-stu-id="d7680-456">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-457"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0.</span><span class="sxs-lookup"><span data-stu-id="d7680-457"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d7680-458">In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode `true` zurück, wenn der Warte Vorgang abgeschlossen ist, weil ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-458">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="d7680-459">Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an.</span><span class="sxs-lookup"><span data-stu-id="d7680-459">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d7680-460">Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers).</span><span class="sxs-lookup"><span data-stu-id="d7680-460">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d7680-461">Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind</span><span class="sxs-lookup"><span data-stu-id="d7680-461">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d7680-462">Die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode löst eine <xref:System.Threading.AbandonedMutexException> nur aus, wenn der Warte Vorgang aufgrund eines abgebrochen Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-462">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="d7680-463">Wenn `waitHandles` einen freigegebenen Mutex mit einer niedrigeren Indexnummer als der abgebrochene Mutex enthält, wird die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode normal abgeschlossen, und die Ausnahme wird nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-463">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7680-464">In Versionen des .NET Framework vor Version 2,0, wenn ein Thread beendet oder abgebrochen wird, ohne explizit eine <xref:System.Threading.Mutex>zu veröffentlichen, und dass `Mutex` in einem `WaitAny` Array in einem anderen Thread an Index 0 (null) liegt, ist der von `WaitAny` zurückgegebene Index 128 statt 0.</span><span class="sxs-lookup"><span data-stu-id="d7680-464">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="d7680-465">Diese Methode gibt zurück, wenn ein Handle signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-465">This method returns when any handle is signaled.</span></span> <span data-ttu-id="d7680-466">Wenn während des Aufrufes mehr als ein Objekt signalisiert wird, ist der Rückgabewert der Array Index des signalisierten Objekts mit dem kleinsten Indexwert aller signalisierten Objekte.</span><span class="sxs-lookup"><span data-stu-id="d7680-466">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="d7680-467">Die maximale Anzahl der Wait-Handles beträgt 64 und 63, wenn sich der aktuelle Thread in <xref:System.Threading.ApartmentState.STA> Zustand befindet.</span><span class="sxs-lookup"><span data-stu-id="d7680-467">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>

 <span data-ttu-id="d7680-468">Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>-Methoden Überladung und der Angabe von-1 (oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) für `millisecondsTimeout` und `true` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d7680-468">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-469">Im folgenden Beispiel wird das Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d7680-469">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-470">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-470">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-471">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-471">-or-</span></span> 
<span data-ttu-id="d7680-472">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-472">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-473">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="d7680-473">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d7680-474"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="d7680-474"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-475">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-475">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-476">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-476">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d7680-477"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="d7680-477"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-478">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-478">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d7680-479">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="d7680-479">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="d7680-480">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="d7680-480">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d7680-481">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einer 32-Bit-Ganzzahl mit Vorzeichen an.</span><span class="sxs-lookup"><span data-stu-id="d7680-481">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="d7680-482">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="millisecondsTimeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-482">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-483">Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-483">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-484">Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-484">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-485">Die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode löst eine <xref:System.Threading.AbandonedMutexException> nur aus, wenn der Warte Vorgang aufgrund eines abgebrochen Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-485">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="d7680-486">Wenn `waitHandles` einen freigegebenen Mutex mit einer niedrigeren Indexnummer als der abgebrochene Mutex enthält, wird die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode normal abgeschlossen, und die Ausnahme wird nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-486">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="d7680-487">Diese Methode gibt zurück, wenn der Warte Vorgang beendet wird, entweder wenn eines der Handles signalisiert wird oder wenn ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-487">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="d7680-488">Wenn während des Aufrufes mehr als ein Objekt signalisiert wird, ist der Rückgabewert der Array Index des signalisierten Objekts mit dem kleinsten Indexwert aller signalisierten Objekte.</span><span class="sxs-lookup"><span data-stu-id="d7680-488">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="d7680-489">Die maximale Anzahl der Wait-Handles beträgt 64 und 63, wenn sich der aktuelle Thread in <xref:System.Threading.ApartmentState.STA> Zustand befindet.</span><span class="sxs-lookup"><span data-stu-id="d7680-489">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="d7680-490">Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d7680-490">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-491">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-491">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-492">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-492">-or-</span></span> 
<span data-ttu-id="d7680-493">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-493">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-494">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="d7680-494">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-495"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-495"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-496">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-496">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-497">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-497">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d7680-498"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-498"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-499">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-499">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d7680-500">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="d7680-500">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="d7680-501">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="d7680-501">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d7680-502">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.TimeSpan" />-Wert an.</span><span class="sxs-lookup"><span data-stu-id="d7680-502">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="d7680-503">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="timeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-503">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-504">Wenn `timeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-504">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-505">Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-505">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-506">Die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode löst eine <xref:System.Threading.AbandonedMutexException> nur aus, wenn der Warte Vorgang aufgrund eines abgebrochen Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-506">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="d7680-507">Wenn `waitHandles` einen freigegebenen Mutex mit einer niedrigeren Indexnummer als der abgebrochene Mutex enthält, wird die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode normal abgeschlossen, und die Ausnahme wird nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-507">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="d7680-508">Diese Methode gibt zurück, wenn der Warte Vorgang beendet wird, entweder wenn eines der Handles signalisiert wird oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-508">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="d7680-509">Wenn während des Aufrufes mehr als ein Objekt signalisiert wird, ist der Rückgabewert der Array Index des signalisierten Objekts mit dem kleinsten Indexwert aller signalisierten Objekte.</span><span class="sxs-lookup"><span data-stu-id="d7680-509">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="d7680-510">Die maximale Anzahl der Wait-Handles beträgt 64 und 63, wenn sich der aktuelle Thread in <xref:System.Threading.ApartmentState.STA> Zustand befindet.</span><span class="sxs-lookup"><span data-stu-id="d7680-510">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>

 <span data-ttu-id="d7680-511">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d7680-511">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d7680-512">Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d7680-512">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-513">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-513">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-514">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-514">-or-</span></span> 
<span data-ttu-id="d7680-515">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-515">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-516">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="d7680-516">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-517"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-517"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d7680-518">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-518">-or-</span></span> 
 <span data-ttu-id="d7680-519"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-519"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-520">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-520">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-521">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-521">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d7680-522"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="d7680-522"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-523">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-523">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d7680-524">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="d7680-524">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="d7680-525">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="d7680-525">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d7680-526"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-526"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d7680-527">Wartet, bis Elemente im angegebenen Array ein Signal empfangen, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d7680-527">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d7680-528">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="millisecondsTimeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-528">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-529">Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-529">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-530">Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-530">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-531"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0.</span><span class="sxs-lookup"><span data-stu-id="d7680-531"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d7680-532">In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode `true` zurück, wenn der Warte Vorgang abgeschlossen ist, weil ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-532">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="d7680-533">Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an.</span><span class="sxs-lookup"><span data-stu-id="d7680-533">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d7680-534">Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers).</span><span class="sxs-lookup"><span data-stu-id="d7680-534">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d7680-535">Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind</span><span class="sxs-lookup"><span data-stu-id="d7680-535">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d7680-536">Die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode löst eine <xref:System.Threading.AbandonedMutexException> nur aus, wenn der Warte Vorgang aufgrund eines abgebrochen Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-536">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="d7680-537">Wenn `waitHandles` einen freigegebenen Mutex mit einer niedrigeren Indexnummer als der abgebrochene Mutex enthält, wird die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode normal abgeschlossen, und die Ausnahme wird nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-537">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7680-538">In Versionen des .NET Framework vor Version 2,0, wenn ein Thread beendet oder abgebrochen wird, ohne explizit eine <xref:System.Threading.Mutex>zu veröffentlichen, und dass `Mutex` in einem `WaitAny` Array in einem anderen Thread an Index 0 (null) liegt, ist der von `WaitAny` zurückgegebene Index 128 statt 0.</span><span class="sxs-lookup"><span data-stu-id="d7680-538">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="d7680-539">Diese Methode gibt zurück, wenn der Warte Vorgang beendet wird, entweder wenn eines der Handles signalisiert wird oder wenn ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-539">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="d7680-540">Wenn während des Aufrufes mehr als ein Objekt signalisiert wird, ist der Rückgabewert der Array Index des signalisierten Objekts mit dem kleinsten Indexwert aller signalisierten Objekte.</span><span class="sxs-lookup"><span data-stu-id="d7680-540">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="d7680-541">Die maximale Anzahl der Wait-Handles beträgt 64 und 63, wenn sich der aktuelle Thread in <xref:System.Threading.ApartmentState.STA> Zustand befindet.</span><span class="sxs-lookup"><span data-stu-id="d7680-541">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d7680-542">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="d7680-542">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d7680-543">Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-543">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d7680-544">Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-544">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d7680-545">Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-545">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d7680-546">Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-546">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="d7680-547">Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitAny%2A> Methode abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d7680-547">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="d7680-548">Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt.</span><span class="sxs-lookup"><span data-stu-id="d7680-548">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d7680-549">In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d7680-549">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d7680-550">Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d7680-550">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d7680-551">Wenn die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird</span><span class="sxs-lookup"><span data-stu-id="d7680-551">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-552">Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um gleichzeitig eine Datei auf mehreren Datenträgern zu suchen.</span><span class="sxs-lookup"><span data-stu-id="d7680-552">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="d7680-553">Aus Platzgründen wird nur das Stammverzeichnis der einzelnen Datenträger durchsucht.</span><span class="sxs-lookup"><span data-stu-id="d7680-553">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-554">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-554">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-555">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-555">-or-</span></span> 
<span data-ttu-id="d7680-556">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-556">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-557">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="d7680-557">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d7680-558"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="d7680-558"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-559"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-559"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-560">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-560">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-561">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-561">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d7680-562"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="d7680-562"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-563">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-563">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d7680-564">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="d7680-564">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="d7680-565">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="d7680-565">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d7680-566"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-566"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d7680-567">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d7680-567">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d7680-568">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="timeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-568">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-569">Wenn `timeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-569">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-570">Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-570">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-571"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0.</span><span class="sxs-lookup"><span data-stu-id="d7680-571"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d7680-572">In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode `true` zurück, wenn der Warte Vorgang abgeschlossen ist, weil ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-572">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="d7680-573">Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an.</span><span class="sxs-lookup"><span data-stu-id="d7680-573">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d7680-574">Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers).</span><span class="sxs-lookup"><span data-stu-id="d7680-574">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d7680-575">Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind</span><span class="sxs-lookup"><span data-stu-id="d7680-575">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d7680-576">Die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode löst eine <xref:System.Threading.AbandonedMutexException> nur aus, wenn der Warte Vorgang aufgrund eines abgebrochen Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-576">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="d7680-577">Wenn `waitHandles` einen freigegebenen Mutex mit einer niedrigeren Indexnummer als der abgebrochene Mutex enthält, wird die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode normal abgeschlossen, und die Ausnahme wird nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-577">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7680-578">In Versionen des .NET Framework vor Version 2,0, wenn ein Thread beendet oder abgebrochen wird, ohne explizit eine <xref:System.Threading.Mutex>zu veröffentlichen, und dass `Mutex` in einem `WaitAny` Array in einem anderen Thread an Index 0 (null) liegt, ist der von `WaitAny` zurückgegebene Index 128 statt 0.</span><span class="sxs-lookup"><span data-stu-id="d7680-578">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="d7680-579">Diese Methode gibt zurück, wenn der Warte Vorgang beendet wird, entweder wenn eines der Handles signalisiert wird oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-579">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="d7680-580">Wenn während des Aufrufes mehr als ein Objekt signalisiert wird, ist der Rückgabewert der Array Index des signalisierten Objekts mit dem kleinsten Indexwert aller signalisierten Objekte.</span><span class="sxs-lookup"><span data-stu-id="d7680-580">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="d7680-581">Die maximale Anzahl der Wait-Handles beträgt 64 und 63, wenn sich der aktuelle Thread in <xref:System.Threading.ApartmentState.STA> Zustand befindet.</span><span class="sxs-lookup"><span data-stu-id="d7680-581">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>

 <span data-ttu-id="d7680-582">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d7680-582">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d7680-583">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="d7680-583">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d7680-584">Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-584">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d7680-585">Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-585">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d7680-586">Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-586">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d7680-587">Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-587">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="d7680-588">Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitAny%2A> Methode abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d7680-588">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="d7680-589">Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt.</span><span class="sxs-lookup"><span data-stu-id="d7680-589">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d7680-590">In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d7680-590">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d7680-591">Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d7680-591">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d7680-592">Wenn die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird</span><span class="sxs-lookup"><span data-stu-id="d7680-592">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-593">Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um gleichzeitig eine Datei auf mehreren Datenträgern zu suchen.</span><span class="sxs-lookup"><span data-stu-id="d7680-593">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="d7680-594">Aus Platzgründen wird nur das Stammverzeichnis der einzelnen Datenträger durchsucht.</span><span class="sxs-lookup"><span data-stu-id="d7680-594">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d7680-595">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-595">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d7680-596">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-596">-or-</span></span> 
<span data-ttu-id="d7680-597">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-597">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d7680-598">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="d7680-598">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d7680-599"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="d7680-599"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-600"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-600"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d7680-601">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-601">-or-</span></span> 
 <span data-ttu-id="d7680-602"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-602"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-603">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-603">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-604">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-604">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d7680-605"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="d7680-605"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-606">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-606">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d7680-607">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="d7680-607">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d7680-608">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="d7680-608">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns><span data-ttu-id="d7680-609"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="d7680-609"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="d7680-610">Wenn die aktuelle Instanz kein Signal erhält, wird <see cref="M:System.Threading.WaitHandle.WaitOne" /> nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="d7680-610">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-611"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0.</span><span class="sxs-lookup"><span data-stu-id="d7680-611"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d7680-612">In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-612">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d7680-613">Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an.</span><span class="sxs-lookup"><span data-stu-id="d7680-613">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d7680-614">Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers).</span><span class="sxs-lookup"><span data-stu-id="d7680-614">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d7680-615">Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind</span><span class="sxs-lookup"><span data-stu-id="d7680-615">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d7680-616">Der Aufrufer dieser Methode blockiert unbegrenzt, bis die aktuelle Instanz ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="d7680-616">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="d7680-617">Verwenden Sie diese Methode, um zu blockieren, bis ein <xref:System.Threading.WaitHandle> ein Signal von einem anderen Thread empfängt, z. b. wird generiert, wenn ein asynchroner Vorgang abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-617">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="d7680-618">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="d7680-618">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="d7680-619">Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>-Methoden Überladung und der Angabe von "-1" oder "<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>" für den ersten Parameter und `false` für den zweiten Parameter.</span><span class="sxs-lookup"><span data-stu-id="d7680-619">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="d7680-620">Überschreiben Sie diese Methode, um das Verhalten abgeleiteter Klassen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="d7680-620">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-621">Im folgenden Codebeispiel wird gezeigt, wie ein Wait-Handle verwendet wird, um einen Prozess vom beenden beizubehalten, während er darauf wartet, dass ein Hintergrund Thread die Ausführung beendet.</span><span class="sxs-lookup"><span data-stu-id="d7680-621">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d7680-622">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="d7680-622">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-623">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-623">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-624">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-624">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-625">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-625">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="d7680-626">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="d7680-626">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d7680-627">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls in Millisekunden verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-627">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="d7680-628"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-628"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-629">Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-629">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-630">Es testet den Zustand des Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-630">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-631">Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal empfängt oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-631">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="d7680-632">Verwenden Sie diese Methode, um zu blockieren, bis ein <xref:System.Threading.WaitHandle> ein Signal von einem anderen Thread empfängt, z. b. wird generiert, wenn ein asynchroner Vorgang abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-632">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="d7680-633">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="d7680-633">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="d7680-634">Überschreiben Sie diese Methode, um das Verhalten abgeleiteter Klassen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="d7680-634">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="d7680-635">Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d7680-635">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-636">Im folgenden Codebeispiel wird gezeigt, wie ein Wait-Handle verwendet wird, um einen Prozess vom beenden beizubehalten, während er darauf wartet, dass ein Hintergrund Thread die Ausführung beendet.</span><span class="sxs-lookup"><span data-stu-id="d7680-636">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d7680-637">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="d7680-637">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-638"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-638"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-639">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-639">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-640">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-640">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-641">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-641">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="d7680-642">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="d7680-642">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d7680-643">Blockiert den aktuellen Thread, bis die aktuelle Instanz ein Signal empfängt, wobei eine <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-643">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="d7680-644"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-644"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-645">Wenn `timeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-645">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-646">Es testet den Zustand des Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-646">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-647">Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal empfängt oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-647">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="d7680-648">Verwenden Sie diese Methode, um zu blockieren, bis ein <xref:System.Threading.WaitHandle> ein Signal von einem anderen Thread empfängt, z. b. wird generiert, wenn ein asynchroner Vorgang abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-648">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="d7680-649">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="d7680-649">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="d7680-650">Überschreiben Sie diese Methode, um das Verhalten abgeleiteter Klassen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="d7680-650">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="d7680-651">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d7680-651">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d7680-652">Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d7680-652">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d7680-653">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="d7680-653">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-654"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-654"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d7680-655">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-655">-or-</span></span> 
 <span data-ttu-id="d7680-656"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-656"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-657">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-657">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-658">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-658">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-659">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-659">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="d7680-660">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="d7680-660">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d7680-661"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-661"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d7680-662">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls verwendet und angegeben wird, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d7680-662">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d7680-663"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-663"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-664">Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-664">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-665">Es testet den Zustand des Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-665">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-666"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0.</span><span class="sxs-lookup"><span data-stu-id="d7680-666"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d7680-667">In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-667">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d7680-668">Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an.</span><span class="sxs-lookup"><span data-stu-id="d7680-668">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d7680-669">Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers).</span><span class="sxs-lookup"><span data-stu-id="d7680-669">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d7680-670">Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind</span><span class="sxs-lookup"><span data-stu-id="d7680-670">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d7680-671">Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal empfängt oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-671">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="d7680-672">Verwenden Sie diese Methode, um zu blockieren, bis ein <xref:System.Threading.WaitHandle> ein Signal von einem anderen Thread empfängt, z. b. wird generiert, wenn ein asynchroner Vorgang abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-672">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="d7680-673">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="d7680-673">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="d7680-674">Überschreiben Sie diese Methode, um das Verhalten abgeleiteter Klassen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="d7680-674">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d7680-675">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="d7680-675">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d7680-676">Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-676">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d7680-677">Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-677">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d7680-678">Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-678">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d7680-679">Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-679">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="d7680-680">Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitOne%2A> Methode abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d7680-680">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="d7680-681">Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt.</span><span class="sxs-lookup"><span data-stu-id="d7680-681">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d7680-682">In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d7680-682">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d7680-683">Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d7680-683">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d7680-684">Wenn die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird</span><span class="sxs-lookup"><span data-stu-id="d7680-684">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-685">Das folgende Beispiel zeigt, wie sich die <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>-Methoden Überladung verhält, wenn Sie innerhalb einer Synchronisierungs Domäne aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-685">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="d7680-686">Zuerst wartet ein Thread, wenn `exitContext` auf `false` festgelegt ist, und wird blockiert, bis das warte Timeout abläuft.</span><span class="sxs-lookup"><span data-stu-id="d7680-686">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="d7680-687">Ein zweiter Thread wird ausgeführt, nachdem der erste Thread beendet wurde, und wartet, bis `exitContext` auf `true`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-687">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="d7680-688">Der-Befehl, der das Wait-Handle für diesen zweiten Thread signalisiert, wird nicht blockiert, und der Thread wird vor dem warte Timeout abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="d7680-688">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d7680-689">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="d7680-689">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-690"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-690"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-691">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-691">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-692">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-692">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-693">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-693">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="d7680-694">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="d7680-694">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d7680-695"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-695"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d7680-696">Blockiert den aktuellen Thread, bis die aktuelle Instanz ein Signal empfängt, wobei eine <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet und angegeben wird, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d7680-696">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d7680-697"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-697"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-698">Wenn `timeout` NULL ist, wird die-Methode nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d7680-698">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d7680-699">Es testet den Zustand des Wait-Handles und wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-699">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="d7680-700"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0.</span><span class="sxs-lookup"><span data-stu-id="d7680-700"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d7680-701">In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-701">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d7680-702">Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an.</span><span class="sxs-lookup"><span data-stu-id="d7680-702">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d7680-703">Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers).</span><span class="sxs-lookup"><span data-stu-id="d7680-703">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d7680-704">Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind</span><span class="sxs-lookup"><span data-stu-id="d7680-704">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d7680-705">Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal empfängt oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="d7680-705">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="d7680-706">Verwenden Sie diese Methode, um zu blockieren, bis ein <xref:System.Threading.WaitHandle> ein Signal von einem anderen Thread empfängt, z. b. wird generiert, wenn ein asynchroner Vorgang abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-706">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="d7680-707">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="d7680-707">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="d7680-708">Überschreiben Sie diese Methode, um das Verhalten abgeleiteter Klassen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="d7680-708">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="d7680-709">Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d7680-709">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d7680-710">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="d7680-710">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d7680-711">Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d7680-711">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d7680-712">Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-712">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d7680-713">Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.</span><span class="sxs-lookup"><span data-stu-id="d7680-713">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d7680-714">Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d7680-714">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="d7680-715">Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitOne%2A> Methode abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d7680-715">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="d7680-716">Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt.</span><span class="sxs-lookup"><span data-stu-id="d7680-716">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d7680-717">In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d7680-717">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d7680-718">Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d7680-718">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d7680-719">Wenn die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird</span><span class="sxs-lookup"><span data-stu-id="d7680-719">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-720">Im folgenden Codebeispiel wird gezeigt, wie ein Wait-Handle verwendet wird, um einen Prozess vom beenden beizubehalten, während er darauf wartet, dass ein Hintergrund Thread die Ausführung beendet.</span><span class="sxs-lookup"><span data-stu-id="d7680-720">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d7680-721">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="d7680-721">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d7680-722"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="d7680-722"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d7680-723">- oder -</span><span class="sxs-lookup"><span data-stu-id="d7680-723">-or-</span></span> 
 <span data-ttu-id="d7680-724"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d7680-724"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d7680-725">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d7680-725">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d7680-726">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d7680-726">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d7680-727">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d7680-727">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="d7680-728">Gibt an, dass ein Timeout für einen <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />-Vorgang überschritten wurde, bevor ein Signal an eines der WaitHandles gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d7680-728">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="d7680-729">Dieses Feld ist konstant.</span><span class="sxs-lookup"><span data-stu-id="d7680-729">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7680-730">Dieses Feld ist einer der möglichen Rückgabewerte `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="d7680-730">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7680-731">Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um gleichzeitig eine Datei auf mehreren Datenträgern zu suchen.</span><span class="sxs-lookup"><span data-stu-id="d7680-731">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="d7680-732">Aus Platzgründen wird nur das Stammverzeichnis der einzelnen Datenträger durchsucht.</span><span class="sxs-lookup"><span data-stu-id="d7680-732">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
