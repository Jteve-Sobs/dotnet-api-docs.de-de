<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a13a27594fa1d97d7387994076cdc3b3a30d735d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609273" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.WaitHandle> Klasse Win32-Synchronisierungshandles kapselt und wird verwendet, um alle Synchronisierungsobjekte in der Runtime darstellen, die mehrere Wartevorgänge ermöglichen. Einen Vergleich der Wait-Handles mit anderen Synchronisierungsobjekte, finden Sie unter [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 Die <xref:System.Threading.WaitHandle> Klasse selbst abstrakt ist. Von abgeleiteten Klassen <xref:System.Threading.WaitHandle> definieren Sie einen signalisierenden Mechanismus, um anzugeben, aufnehmen oder den Zugriff auf eine freigegebene Ressource freigeben, aber sie verwenden die geerbte <xref:System.Threading.WaitHandle> Methoden zum Blockieren, bis für den Zugriff auf freigegebene Ressourcen. Von abgeleiteten Klassen <xref:System.Threading.WaitHandle> enthalten:  
  
-   Der <xref:System.Threading.Mutex>-Klasse. Finden Sie unter [Mutexe](~/docs/standard/threading/mutexes.md).  
  
-   Die <xref:System.Threading.EventWaitHandle> -Klasse und die abgeleiteten Klassen <xref:System.Threading.AutoResetEvent> und <xref:System.Threading.ManualResetEvent>. Siehe [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   Der <xref:System.Threading.Semaphore>-Klasse. Finden Sie unter [Semaphore und SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Threads können auf einem einzelnen Wait-Handle durch Aufrufen der Instanzmethode blockieren <xref:System.Threading.WaitHandle.WaitOne%2A>, die von abgeleiteten Klassen geerbt wird <xref:System.Threading.WaitHandle>.  
  
 Die abgeleiteten Klassen von <xref:System.Threading.WaitHandle> unterscheiden sich in deren Threadaffinität. Ereignis-wait-Handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, und <xref:System.Threading.ManualResetEvent>) und Semaphore keine Threadaffinität; einen beliebigen Thread kann eine Ereignis-Wait-Handle oder einen Semaphore zu signalisieren. Mutexe weisen auf der anderen Seite Threadaffinität; der Thread, der einen Mutex besitzt, müssen sie freigeben und eine Ausnahme ausgelöst, wenn ein Thread Ruft die <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode einen Mutex, die er nicht besitzt.  
  
 Da die <xref:System.Threading.WaitHandle> Klasse leitet sich von <xref:System.MarshalByRefObject>, diese Klassen können zum Synchronisieren der Aktivitäten von Threads über Anwendungsdomänengrenzen hinweg verwendet werden.  
  
 Zusätzlich zu den davon abgeleiteten Klassen die <xref:System.Threading.WaitHandle> -Klasse verfügt über eine Reihe von statischen Methoden, die ein Thread, bis eine blockiert oder mehrere Synchronisierungsobjekte empfangen eines Signals... Dazu gehören:  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, wodurch einen Thread ein Wait-Handle signalisiert und sofort auf einen anderen warten.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, wodurch einen Thread warten, bis die Wait-Handles in einem Array ein Signal empfangen.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, wodurch einen Thread warten, bis eine von einem angegebenen Satz von Wait-Handles signalisiert wird.  
  
 Die Überladungen dieser Methoden bereitstellen, zeitlimitintervallen für den Abbruch der Wartevorgang, und die Möglichkeit, einen Synchronisierungskontext zu beenden, vor dem Wartevorgang, verwenden Sie den Synchronisierungskontext anderer Threads zugelassen wird.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mit dem Typ oder ein daraus abgeleiteter Typ haben, sollten Sie es entweder direkt oder indirekt freigeben. Damit des Typs direkt freigegeben werden, rufen Sie die <xref:System.Threading.WaitHandle.Close%2A> -Methode in einer `try` / `catch` Block. Um sie indirekt löschen, verwenden Sie ein Sprachkonstrukt wie `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "mithilfe von ein-Objekt, das implementiert" IDisposable "" in der <xref:System.IDisposable> schnittstellenthema.  
  
 <xref:System.Threading.WaitHandle> implementiert die <xref:System.IDisposable.Dispose%2A> Muster. Finden Sie unter [Dispose-Muster](~/docs/standard/design-guidelines/dispose-pattern.md). Beim Ableiten von <xref:System.Threading.WaitHandle>, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Eigenschaft, um Ihre systemeigene Betriebssystemhandle zu speichern. Sie müssen nicht überschreiben, die geschützte <xref:System.Threading.WaitHandle.Dispose%2A> Methode, wenn Sie zusätzliche verwaltete Ressourcen verwenden.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt wie zwei Threads werden Aufgaben im Hintergrund während der Hauptthread thread wartet darauf, die Aufgaben abgeschlossen wird, verwenden Sie die statische <xref:System.Threading.WaitHandle.WaitAny%2A> und <xref:System.Threading.WaitHandle.WaitAll%2A> Methoden der <xref:System.Threading.WaitHandle> Klasse.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist die öffentliche Implementierung der <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> -Methode für die <xref:System.Threading.WaitHandle> -Klasse und ihrer abgeleiteten Klassen. Es bietet eine Standardimplementierung, die aufruft, die `Dispose(Boolean)` -Überladung mit einer `true` Argument und ruft dann die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode. Rufen Sie diese Methode, um alle Ressourcen frei, die von einer Instanz von Version `WaitHandle` oder eine abgeleitete Klasse.  
  
 Nachdem diese Methode aufgerufen wurde, dazu führen, dass Verweise auf die aktuelle Instanz nicht definiertem Verhalten.  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.Threading.WaitHandle.Close%2A> oder <xref:System.Threading.WaitHandle.Dispose> bereits vor der Veröffentlichung des letzten Verweis auf die <xref:System.Threading.WaitHandle>. Andernfalls werden die verwendeten Ressourcen nicht freigegeben werden.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Sie sollten überschreiben die <see langword="Dispose(Boolean)" /> Methode zum Freigeben von Ressourcen zugeordnet, die abgeleiteten Klassen.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.Threading.WaitHandle.Close%2A> Methode.  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.Threading.WaitHandle.Close%2A> oder <xref:System.Threading.WaitHandle.Dispose> bereits vor der Veröffentlichung des letzten Verweis auf die <xref:System.Threading.WaitHandle>. Andernfalls werden die verwendeten Ressourcen nicht freigegeben werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, indem die <xref:System.Threading.WaitHandle.Close%2A> und <xref:System.Threading.WaitHandle.Dispose> Methoden mit dem `explicitDisposing` Parametersatz zu `true`.  Wenn die `explicitDisposing` -Parameter ist `true`, gibt diese Methode alle Ressourcen frei, die für verwaltete Objekte, die dieses <xref:System.Threading.WaitHandle> Objektverweise.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Sie sollten überschreiben die <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> Methode zum Freigeben von Ressourcen zugeordnet, die abgeleiteten Klassen.  Die <see cref="M:System.Threading.WaitHandle.Close" /> oder <see cref="M:System.Threading.WaitHandle.Dispose" /> Methode kann von anderen Objekten mehrmals aufgerufen werden. Wenn Sie diese Methode überschreiben, werden nicht auf Objekte verweisen, die zuvor in einen früheren Aufruf von freigegeben wurden <see langword="Dispose" /> oder <see langword="Close" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the native operating system handle.</summary>
        <value>Ein <see langword="IntPtr" />, das das systemeigene Betriebssystemhandle darstellt. Der Standardwert ist der Wert des <see cref="F:System.Threading.WaitHandle.InvalidHandle" />-Felds.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zuweisen eines neuen Werts, der <xref:System.Threading.WaitHandle.Handle%2A> Eigenschaft wird das vorherige Handle nicht geschlossen. Dies kann zu einem unkontrollierten Handle führen.  
  
 Verwenden Sie diese Eigenschaft nicht in .NET Framework Version 2.0 oder höher. Verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Eigenschaft stattdessen. Festlegen dieser Eigenschaft auf ein gültiges Handle, wird auch die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> -Eigenschaft, aber wenn diese Option auf <xref:System.Threading.WaitHandle.InvalidHandle> kann dazu führen, eine kompromittierte Handle.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer, den Eigenschaftswert festzulegen. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code festgelegt werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Abgeleitete Typen müssen <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> , den Eigenschaftswert festzulegen.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents an invalid native operating system handle. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Intern verwendet, um das Initialisieren der <xref:System.Threading.WaitHandle.Handle%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Sie können diesen Wert verwenden, um zu bestimmen, ob die <see cref="P:System.Threading.WaitHandle.Handle" /> Eigenschaft enthält ein gültigen systemeigenes Betriebssystemhandle.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the native operating system handle.</summary>
        <value>Ein <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />, das das systemeigene Betriebssystemhandle darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie einen neuen Wert zuweisen der <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> -Eigenschaft, die vorherige Handle wird geschlossen, wenn die vorherige <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Objekt gesammelt. Manuell schließen Sie das Handle nicht, da dadurch ein <xref:System.ObjectDisposedException> bei der <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> versucht, die das Handle zu schließen.  
  
 <xref:System.Threading.WaitHandle> implementiert die <xref:System.IDisposable.Dispose%2A> Muster. Finden Sie unter [Dispose-Muster](~/docs/standard/design-guidelines/dispose-pattern.md). Beim Ableiten von <xref:System.Threading.WaitHandle>, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Eigenschaft, um Ihre systemeigene Betriebssystemhandle zu speichern. Sie müssen nicht überschreiben, die geschützte <xref:System.Threading.WaitHandle.Dispose%2A> Methode, wenn Sie zusätzliche verwaltete Ressourcen verwenden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Abgeleitete Typen müssen <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> dieser Member aufrufen.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht unbedingt atomar sein. Nachdem der aktuelle Thread Signale `toSignal` , aber bevor er wartet auf `toWaitOn`, ein Thread, der auf einem anderen Prozessor ausgeführt wird möglicherweise signalisiert `toWaitOn` oder darauf warten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> -methodenüberladung, um ermöglichen den Hauptthread auf einen blockierten Thread zu signalisieren und warten Sie, bis der Thread eine Aufgabe abgeschlossen ist.  
  
 Im Beispiel werden fünf Threads gestartet, können sie blockieren einen <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flag und dann Versionen einen Thread-Mal der Benutzer drückt die EINGABETASTE. Im Beispiel wird dann fünf weitere Threads und mithilfe einer eine <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> Flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> is a semaphore, and it already has a full count.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <param name="millisecondsTimeout">An integer that represents the interval to wait. If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht unbedingt atomar sein. Nachdem der aktuelle Thread Signale `toSignal` , aber bevor er wartet auf `toWaitOn`, ein Thread, der auf einem anderen Prozessor ausgeführt wird möglicherweise signalisiert `toWaitOn` oder darauf warten.  
  
 Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert. Den Status der tests die `toWaitOn` und kehrt sofort zurück.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird. Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>. Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.  
  
 Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode. Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode abgeschlossen wird.  
  
 Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse. Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird. Wenn die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the interval to wait. If the value is -1, the wait is infinite.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht unbedingt atomar sein. Nachdem der aktuelle Thread Signale `toSignal` , aber bevor er wartet auf `toWaitOn`, ein Thread, der auf einem anderen Prozessor ausgeführt wird möglicherweise signalisiert `toWaitOn` oder darauf warten.  
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert. Den Status der tests die `toWaitOn` und kehrt sofort zurück.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird. Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>. Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.  
  
 Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode. Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode abgeschlossen wird.  
  
 Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse. Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird. Wenn die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> is a semaphore, and it already has a full count.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Waits for all the elements in the specified array to receive a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <summary>Waits for all the elements in the specified array to receive a signal.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0. In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen. Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code. Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager). Die Ausnahme enthält Informationen, die beim Debuggen nützlich.  
  
 Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn alle Handles signalisiert werden. Für einige Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst. Wenn das Array Duplikate enthält, schlägt der Aufruf mit einem <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf die Threads, die <xref:System.STAThreadAttribute>.  
  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> -methodenüberladung, und geben-1 (oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) für `millisecondsTimeout` und `true` für `exitContext`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, mit der Threadpool asynchron erstellungs- und Schreibberechtigungen für eine Gruppe von Dateien. Jeden Schreibvorgang in die Warteschlange eingereiht als eine Arbeitsaufgabe und signalisiert, wenn er abgeschlossen ist. Der Hauptthread wartet, bis alle Elemente um zu signalisieren und beendet.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />. -or-  One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert. Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Wartevorgang wird beendet, d. h., wenn alle Handles signalisiert werden oder wenn ein Timeout auftritt. Für einige Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst. Wenn Duplikate im Array vorhanden sind, schlägt der Aufruf mit einem <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf die Threads, die <xref:System.STAThreadAttribute>.  
  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert. Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Wartevorgang beendet wird, d. h. alle Handles signalisiert werden, oder ein Timeout auftritt. Für einige Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst. Wenn das Array Duplikate enthält, schlägt der Aufruf fehl.  
  
> [!NOTE]
>  Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf die Threads, die <xref:System.STAThreadAttribute>.  
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert. Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0. In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen. Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code. Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager). Die Ausnahme enthält Informationen, die beim Debuggen nützlich.  
  
 Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Wartevorgang wird beendet, d. h., wenn alle Handles signalisiert werden oder wenn ein Timeout auftritt. Für einige Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst. Wenn Duplikate im Array vorhanden sind, schlägt der Aufruf mit einem <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf die Threads, die <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird. Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>. Selbst wenn derzeit eine Methode einer Klasse ausgeführt wird, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.  
  
 Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode. Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode abgeschlossen wird.  
  
 Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über die <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> Attribut. In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse. Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird. Wenn die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, mit der Threadpool asynchron erstellungs- und Schreibberechtigungen für eine Gruppe von Dateien. Jeden Schreibvorgang in die Warteschlange eingereiht als eine Arbeitsaufgabe und signalisiert, wenn er abgeschlossen ist. Der Hauptthread wartet, bis alle Elemente um zu signalisieren und beendet.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert. Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0. In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen. Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code. Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager). Die Ausnahme enthält Informationen, die beim Debuggen nützlich.  
  
 Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Wartevorgang beendet wird, d. h. alle Handles signalisiert werden, oder ein Timeout auftritt. Für einige Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst. Wenn das Array Duplikate enthält, schlägt der Aufruf fehl.  
  
> [!NOTE]
>  Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf die Threads, die <xref:System.STAThreadAttribute>.  
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird. Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>. Selbst wenn derzeit eine Methode einer Klasse ausgeführt wird, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.  
  
 Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode. Nach dem Aufruf des ursprünglichen Kontexts der vom Standard abweichenden gibt die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode abgeschlossen wird.  
  
 Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse. Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird. Wenn die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, mit der Threadpool asynchron erstellungs- und Schreibberechtigungen für eine Gruppe von Dateien. Jeden Schreibvorgang in die Warteschlange eingereiht als eine Arbeitsaufgabe und signalisiert, wenn er abgeschlossen ist. Der Hauptthread wartet, bis alle Elemente um zu signalisieren und beendet.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Waits for any of the elements in the specified array to receive a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal.</summary>
        <returns>The array index of the object that satisfied the wait.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0. In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methodenrückgabe `true` , wenn der Wartevorgang abgeschlossen wird, da ein Mutex abgebrochen wurde. Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code. Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager). Die Ausnahme enthält Informationen, die beim Debuggen nützlich.  
  
 Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn die Wartezeit aufgrund einer abgebrochenen Mutex abgeschlossen ist. Wenn `waitHandles` einen freigegebenen Mutex mit einer geringeren Anzahl von Index als den abgebrochenen Mutex, enthält die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode normal abgeschlossen und die Ausnahme nicht ausgelöst.  
  
> [!NOTE]
>  In Versionen von .NET Framework-Versionen vor Version 2.0, wenn ein Thread beendet oder abgebrochen wird, ohne dass explizit freigegeben eine <xref:System.Threading.Mutex>, und dass `Mutex` befindet sich am Index 0 (null) in eine `WaitAny` Array auf einem anderen Thread, der von zurückgegebene Index `WaitAny` ist 128 statt 0.  
  
 Diese Methode gibt zurück, wenn alle Handles signalisiert wird. Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts signalisiert mit dem kleinsten Indexwert aller signalisiert Objekte an. Für einige Implementierungen, wenn mehr, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst.  
  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> -methodenüberladung, und geben-1 (oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) für `millisecondsTimeout` und `true` für `exitContext`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert. Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn die Wartezeit aufgrund einer abgebrochenen Mutex abgeschlossen ist. Wenn `waitHandles` einen freigegebenen Mutex mit einer geringeren Anzahl von Index als den abgebrochenen Mutex, enthält die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode normal abgeschlossen und die Ausnahme nicht ausgelöst.  
  
 Wenn der Wartevorgang wird beendet, wenn eines der Handles signalisiert werden oder wenn ein Timeout auftritt, gibt diese Methode zurück. Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts signalisiert mit dem kleinsten Indexwert aller signalisiert Objekte an. Für einige Implementierungen, wenn mehr, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst.  
  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert. Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn die Wartezeit aufgrund einer abgebrochenen Mutex abgeschlossen ist. Wenn `waitHandles` einen freigegebenen Mutex mit einer geringeren Anzahl von Index als den abgebrochenen Mutex, enthält die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode normal abgeschlossen und die Ausnahme nicht ausgelöst.  
  
 Wenn der Wartevorgang wird beendet, wenn Handles signalisiert werden oder wenn ein Timeout auftritt, gibt diese Methode zurück. Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts signalisiert mit dem kleinsten Indexwert aller signalisiert Objekte an. Für einige Implementierungen, wenn mehr, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst.  
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert. Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0. In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methodenrückgabe `true` , wenn der Wartevorgang abgeschlossen wird, da ein Mutex abgebrochen wurde. Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code. Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager). Die Ausnahme enthält Informationen, die beim Debuggen nützlich.  
  
 Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn die Wartezeit aufgrund einer abgebrochenen Mutex abgeschlossen ist. Wenn `waitHandles` einen freigegebenen Mutex mit einer geringeren Anzahl von Index als den abgebrochenen Mutex, enthält die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode normal abgeschlossen und die Ausnahme nicht ausgelöst.  
  
> [!NOTE]
>  In Versionen von .NET Framework-Versionen vor Version 2.0, wenn ein Thread beendet oder abgebrochen wird, ohne dass explizit freigegeben eine <xref:System.Threading.Mutex>, und dass `Mutex` befindet sich am Index 0 (null) in eine `WaitAny` Array auf einem anderen Thread, der von zurückgegebene Index `WaitAny` ist 128 statt 0.  
  
 Wenn der Wartevorgang wird beendet, wenn eines der Handles signalisiert werden oder wenn ein Timeout auftritt, gibt diese Methode zurück. Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts signalisiert mit dem kleinsten Indexwert aller signalisiert Objekte an. Für einige Implementierungen, wenn mehr, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird. Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>. Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.  
  
 Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode. Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode abgeschlossen wird.  
  
 Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse. Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird. Wenn die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Threadpool zu verwenden, um gleichzeitig für eine Datei auf mehreren Datenträgern zu suchen. Aus Platzgründen wird nur das Stammverzeichnis für die einzelnen Datenträger durchsucht.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert. Er überprüft den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0. In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methodenrückgabe `true` , wenn der Wartevorgang abgeschlossen wird, da ein Mutex abgebrochen wurde. Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code. Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager). Die Ausnahme enthält Informationen, die beim Debuggen nützlich.  
  
 Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn die Wartezeit aufgrund einer abgebrochenen Mutex abgeschlossen ist. Wenn `waitHandles` einen freigegebenen Mutex mit einer geringeren Anzahl von Index als den abgebrochenen Mutex, enthält die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode normal abgeschlossen und die Ausnahme nicht ausgelöst.  
  
> [!NOTE]
>  In Versionen von .NET Framework-Versionen vor Version 2.0, wenn ein Thread beendet oder abgebrochen wird, ohne dass explizit freigegeben eine <xref:System.Threading.Mutex>, und dass `Mutex` befindet sich am Index 0 (null) in eine `WaitAny` Array auf einem anderen Thread, der von zurückgegebene Index `WaitAny` ist 128 statt 0.  
  
 Wenn der Wartevorgang wird beendet, wenn Handles signalisiert werden oder wenn ein Timeout auftritt, gibt diese Methode zurück. Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts signalisiert mit dem kleinsten Indexwert aller signalisiert Objekte an. Für einige Implementierungen, wenn mehr, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst.  
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird. Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>. Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.  
  
 Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode. Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode abgeschlossen wird.  
  
 Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse. Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird. Wenn die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Threadpool zu verwenden, um gleichzeitig für eine Datei auf mehreren Datenträgern zu suchen. Aus Platzgründen wird nur das Stammverzeichnis für die einzelnen Datenträger durchsucht.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal. If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0. In früheren Versionen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen. Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code. Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager). Die Ausnahme enthält Informationen, die beim Debuggen nützlich.  
  
 Der Aufrufer dieser Methode blockiert, die auf unbestimmte Zeit, bis die aktuelle Instanz ein Signal empfängt. Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> ein Signal empfängt, von einem anderen Thread, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist. Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.  
  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> -methodenüberladung, und geben-1 oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für den ersten Parameter und `false` für den zweiten Parameter.  
  
 Überschreiben Sie diese Methode, um das Verhalten von abgeleiteten Klassen anzupassen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Wait-Handle verwenden, um zu verhindern, dass einen Prozess beendet wird, während auf einem Hintergrundthread Beenden der Ausführung gewartet wird.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert. Er testet den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal oder ein Timeout empfängt auftritt. Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> ein Signal empfängt, von einem anderen Thread, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist. Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.  
  
 Überschreiben Sie diese Methode, um das Verhalten von abgeleiteten Klassen anzupassen.  
  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Wait-Handle verwenden, um zu verhindern, dass einen Prozess beendet wird, während auf einem Hintergrundthread Beenden der Ausführung gewartet wird.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <summary>Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert. Er testet den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal oder ein Timeout empfängt auftritt. Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> ein Signal empfängt, von einem anderen Thread, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist. Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.  
  
 Überschreiben Sie diese Methode, um das Verhalten von abgeleiteten Klassen anzupassen.  
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` 0 (null), wird die Methode wird nicht blockiert. Er testet den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0. In früheren Versionen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen. Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code. Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager). Die Ausnahme enthält Informationen, die beim Debuggen nützlich.  
  
 Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal oder ein Timeout empfängt auftritt. Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> ein Signal empfängt, von einem anderen Thread, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist. Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.  
  
 Überschreiben Sie diese Methode, um das Verhalten von abgeleiteten Klassen anzupassen.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird. Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>. Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.  
  
 Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode. Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode abgeschlossen wird.  
  
 Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse. Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird. Wenn die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> Überladung verhält sich, wenn sie innerhalb einer Synchronisierungsdomäne aufgerufen wird. Zunächst wartet ein Thread mit `exitContext` festgelegt `false` und blockiert, bis das Timeout für die Wartezeit abläuft. Ein zweiter Thread ausgeführt wird, nachdem der erste Thread beendet und wartet mit `exitContext` festgelegt `true`. Der Aufruf der Wait-Handle für diesen zweiten Thread signalisiert wird nicht blockiert, und der Thread abgeschlossen ist, bevor das Wartetimeout.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` 0 (null), wird die Methode wird nicht blockiert. Er testet den Zustand des Wait-Handles und kehrt sofort zurück.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0. In früheren Versionen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methodenrückgabe `true` Wenn ein Mutex wird abgebrochen. Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code. Im Fall einer systemweiten Mutex handelt kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager). Die Ausnahme enthält Informationen, die beim Debuggen nützlich.  
  
 Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal oder ein Timeout empfängt auftritt. Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> ein Signal empfängt, von einem anderen Thread, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist. Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.  
  
 Überschreiben Sie diese Methode, um das Verhalten von abgeleiteten Klassen anzupassen.  
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird. Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>. Auch wenn Sie derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.  
  
 Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode. Der Thread zurück in den ursprünglich vom Standard abweichenden nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode abgeschlossen wird.  
  
 Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse. Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird. Wenn die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Wait-Handle verwenden, um zu verhindern, dass einen Prozess beendet wird, während auf einem Hintergrundthread Beenden der Ausführung gewartet wird.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled. This field is constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Feld ist eine der die möglichen Rückgabewerte von `WaitAny`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Threadpool zu verwenden, um gleichzeitig für eine Datei auf mehreren Datenträgern zu suchen. Aus Platzgründen wird nur das Stammverzeichnis für die einzelnen Datenträger durchsucht.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>