<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b7b49b128839346fd9022cb728b2fc8974b83dd1" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82303554" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WaitHandle extends System.Object implements class System.IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Implements IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    interface IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Kapselt betriebssystemspezifische Objekte, die auf exklusiven Zugriff auf gemeinsam genutzte Ressourcen warten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.WaitHandle>-Klasse kapselt ein System eigenes Synchronisierungs Handle für das Betriebssystem und dient zur Darstellung aller Synchronisierungs Objekte in der Laufzeit, die mehrere warte Vorgänge zulassen. Einen Vergleich der Wait-Handles mit anderen Synchronisierungs Objekten finden Sie unter [Übersicht über Synchronisierungs primitive](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 Die <xref:System.Threading.WaitHandle> Klasse selbst ist abstrakt. Von <xref:System.Threading.WaitHandle> abgeleitete Klassen definieren einen Signalisierungs Mechanismus, der angibt, dass der Zugriff auf eine freigegebene Ressource übernommen oder freigegeben wird. Sie verwenden jedoch die geerbten <xref:System.Threading.WaitHandle> Methoden, um den Zugriff auf freigegebene Ressourcen zu blockieren. Die von <xref:System.Threading.WaitHandle> abgeleiteten Klassen umfassen Folgendes:  
  
-   Der <xref:System.Threading.Mutex>-Klasse. Siehe [Mutexes](~/docs/standard/threading/mutexes.md).  
  
-   Die <xref:System.Threading.EventWaitHandle> Klasse und die abgeleiteten Klassen, <xref:System.Threading.AutoResetEvent> und <xref:System.Threading.ManualResetEvent>.  
  
-   Der <xref:System.Threading.Semaphore>-Klasse. Weitere Informationen finden Sie unter [Semaphore und SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Threads können einen einzelnen Wait-Handle blockieren, indem Sie die Instanzmethode <xref:System.Threading.WaitHandle.WaitOne%2A>aufrufen, die von Klassen geerbt wird, die von <xref:System.Threading.WaitHandle>abgeleitet werden.  
  
 Die abgeleiteten Klassen von <xref:System.Threading.WaitHandle> unterscheiden sich in ihrer Thread Affinität. Ereignis-Wait-Handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>und <xref:System.Threading.ManualResetEvent>) und Semaphoren haben keine Thread Affinität. Jeder Thread kann einem Ereignis-Wait-Handle oder Semaphore signalisieren. Mutexes hingegen haben Thread Affinität. der Thread, der einen Mutex besitzt, muss ihn freigeben, und eine Ausnahme wird ausgelöst, wenn ein Thread die <xref:System.Threading.Mutex.ReleaseMutex%2A>-Methode für einen Mutex aufruft, den er nicht besitzt.  
  
 Da die <xref:System.Threading.WaitHandle>-Klasse von <xref:System.MarshalByRefObject>abgeleitet ist, können diese Klassen verwendet werden, um die Aktivitäten von Threads über Anwendungs Domänen Grenzen hinweg zu synchronisieren.  
  
 Zusätzlich zu den abgeleiteten Klassen verfügt die <xref:System.Threading.WaitHandle>-Klasse über eine Reihe statischer Methoden, die einen Thread blockieren, bis mindestens ein Synchronisierungs Objekt ein Signal empfängt. Dazu gehören:  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, das einem Thread ermöglicht, ein Wait-Handle zu signalisieren und sofort auf einen anderen zu warten.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, der es einem Thread ermöglicht, zu warten, bis alle Wait-Handles in einem Array ein Signal empfangen.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, der es einem Thread ermöglicht, zu warten, bis eine angegebene Gruppe von Wait-Handles signalisiert wurde.  
  
 Die über Ladungen dieser Methoden stellen Timeout Intervalle für das Abbrechen des warte Vorgangs sowie die Möglichkeit zum Beenden eines Synchronisierungs Kontexts vor dem warte Vorgang bereit, sodass andere Threads den Synchronisierungs Kontext verwenden können.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Wenn Sie den Typ oder einen von ihm abgeleiteten Typ nicht mehr verwenden, sollten Sie ihn entweder direkt oder indirekt verwerfen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.Threading.WaitHandle.Close%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
 <xref:System.Threading.WaitHandle> das <xref:System.IDisposable.Dispose%2A> Muster implementiert. Weitere Informationen finden Sie unter [Implementieren einer verwerfen-Methode] (~/docs/Standard/Garbage-Collection/Implementing-Dispose. MD). Wenn Sie von <xref:System.Threading.WaitHandle>ableiten, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>-Eigenschaft, um das systemeigene Betriebssystem Handle zu speichern. Sie müssen die geschützte <xref:System.Threading.WaitHandle.Dispose%2A> Methode nicht außer Kraft setzen, es sei denn, Sie verwenden zusätzliche nicht verwaltete Ressourcen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie zwei Threads Hintergrundaufgaben ausführen können, während der Haupt Thread auf den Abschluss der Aufgaben mithilfe der statischen <xref:System.Threading.WaitHandle.WaitAny%2A> und <xref:System.Threading.WaitHandle.WaitAll%2A> Methoden der <xref:System.Threading.WaitHandle>-Klasse wartet.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Threading</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">Threadingobjekte und -funktionen</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexe</related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent und ManualResetEvent</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphoren</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public WaitHandle ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WaitHandle();" FrameworkAlternate="netframework-1.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen <see cref="T:System.Threading.WaitHandle" />-Klasse reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dieser Methode handelt es sich um die öffentliche Implementierung der <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Methode für die <xref:System.Threading.WaitHandle>-Klasse und die abgeleiteten Klassen. Sie stellt eine Standard Implementierung bereit, die die `Dispose(Boolean)` Überladung mit einem `true`-Argument aufruft und dann die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>-Methode aufruft. Mit dieser Methode können Sie alle Ressourcen freigeben, die von einer Instanz von `WaitHandle` oder einer abgeleiteten Klasse aufbewahrt werden.  
  
 Nachdem diese Methode aufgerufen wurde, verursachen Verweise auf die aktuelle Instanz nicht definiertes Verhalten.  
  
> [!NOTE]
>  Vor dem Freigeben des letzten Verweises auf die <xref:System.Threading.WaitHandle>sollten Sie immer <xref:System.Threading.WaitHandle.Close%2A> oder <xref:System.Threading.WaitHandle.Dispose> abrufen. Andernfalls werden die von ihm verwendeten Ressourcen nicht freigegeben.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Sie sollten die <see langword="Dispose(Boolean)" />-Methode außer Kraft setzen, um in abgeleiteten Klassen zugewiesene Ressourcen freizugeben.</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementieren einer Dispose-Methode</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.Threading.WaitHandle.Close%2A>-Methode.  
  
> [!NOTE]
>  Vor dem Freigeben des letzten Verweises auf die <xref:System.Threading.WaitHandle>sollten Sie immer <xref:System.Threading.WaitHandle.Close%2A> oder <xref:System.Threading.WaitHandle.Dispose> abrufen. Andernfalls werden die von ihm verwendeten Ressourcen nicht freigegeben.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Bereinigen von nicht verwalteten Ressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse die von <see cref="T:System.Threading.WaitHandle" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird vom-<xref:System.Threading.WaitHandle.Close%2A> und den <xref:System.Threading.WaitHandle.Dispose>-Methoden aufgerufen, wobei der `explicitDisposing`-Parameter auf `true`festgelegt ist.  Wenn der `explicitDisposing`-Parameter `true`ist, gibt diese Methode alle Ressourcen frei, die von verwalteten Objekten gehalten werden, auf die dieses <xref:System.Threading.WaitHandle> Objekt verweist.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Sie sollten die <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />-Methode außer Kraft setzen, um in abgeleiteten Klassen zugewiesene Ressourcen freizugeben.  
  
Die <see cref="M:System.Threading.WaitHandle.Close" />-oder <see cref="M:System.Threading.WaitHandle.Dispose" />-Methode kann von anderen Objekten mehrmals aufgerufen werden. Wenn Sie diese Methode überschreiben, sollten Sie darauf achten, nicht auf Objekte zu verweisen, die zuvor in einem früheren <see langword="Dispose" /> oder <see langword="Close" />freigegeben wurden.</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementieren einer Dispose-Methode</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von der aktuellen Instanz reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> Dieses Mitglied wurde aus den .NET Framework Version 2,0 und nachfolgenden Versionen entfernt. Dieses Thema gilt nur für die unter "Versionsinformationen" weiter unten in diesem Thema aufgeführten Versionen.


Der Anwendungscode ruft diese Methode nicht auf. Sie wird automatisch während Garbage Collection aufgerufen, es sei denn, die Garbage Collector wurde deaktiviert. Weitere Informationen finden Sie unter <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> und <xref:System.Object.Finalize>. Diese Methode überschreibt <xref:System.Object.Finalize>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Betriebssystemhandle auf oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.IntPtr" />, das das systemeigene Betriebssystemhandle darstellt. Der Standardwert ist der Wert des <see cref="F:System.Threading.WaitHandle.InvalidHandle" />-Felds.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie der <xref:System.Threading.WaitHandle.Handle%2A>-Eigenschaft einen neuen Wert zuweisen, wird das vorherige Handle nicht geschlossen. Dies kann zu einem kompromittierten Handle führen.  
  
 Verwenden Sie diese Eigenschaft nicht in der .NET Framework Version 2,0 oder höher. Verwenden Sie stattdessen die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>-Eigenschaft. Wenn diese Eigenschaft auf ein gültiges Handle festgelegt wird, wird auch die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>-Eigenschaft festgelegt, aber das Festlegen auf <xref:System.Threading.WaitHandle.InvalidHandle> kann zu einem kompromittierten Handle führen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein ungültiges systemeigenes Betriebssystemhandle dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird intern verwendet, um die <xref:System.Threading.WaitHandle.Handle%2A>-Eigenschaft zu initialisieren.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Sie können diesen Wert verwenden, um zu bestimmen, ob die <see cref="P:System.Threading.WaitHandle.Handle" />-Eigenschaft ein gültiges System eigenes Betriebssystem Handle enthält.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Betriebssystemhandle auf oder legt dieses fest.</summary>
        <value>Ein <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />, das das systemeigene Betriebssystemhandle darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie der <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>-Eigenschaft einen neuen Wert zuweisen, wird das vorherige Handle geschlossen, wenn das vorherige <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Objekt erfasst wird. Schließen Sie das Handle nicht manuell, da dies zu einer <xref:System.ObjectDisposedException> führt, wenn der <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> versucht, das Handle zu schließen.  
  
 <xref:System.Threading.WaitHandle> das <xref:System.IDisposable.Dispose%2A> Muster implementiert. Weitere Informationen finden Sie unter [Implementieren einer Löschmethode](~/docs/standard/garbage-collection/implementing-dispose.md). Wenn Sie von <xref:System.Threading.WaitHandle>ableiten, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>-Eigenschaft, um das systemeigene Handle-Betriebssystem Handle zu speichern. Sie müssen die geschützte <xref:System.Threading.WaitHandle.Dispose%2A> Methode nicht außer Kraft setzen, es sei denn, Sie verwenden zusätzliche nicht verwaltete Ressourcen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf einen anderen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="toSignal">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</param>
        <param name="toWaitOn">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</param>
        <summary>Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf einen anderen.</summary>
        <returns><see langword="true" />, wenn das Signal und der Wartevorgang erfolgreich abgeschlossen wurden. Wenn der Wartevorgang nicht abgeschlossen wird, wird die Methode nicht beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist nicht garantiert, dass dieser Vorgang atomarisch ist. Nachdem der aktuelle Thread `toSignal` signalisiert hat, aber bevor er auf `toWaitOn`wartet, könnte ein Thread, der auf einem anderen Prozessor ausgeführt wird, `toWaitOn` oder darauf warten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>-Methoden Überladung verwendet, damit der Haupt Thread einen blockierten Thread signalisiert und dann wartet, bis der Thread eine Aufgabe abgeschlossen hat.  
  
 Im Beispiel werden fünf Threads gestartet, sodass Sie für ein <xref:System.Threading.EventWaitHandle> blockieren können, das mit dem <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>-Flag erstellt wurde, und dann bei jedem Drücken der EINGABETASTE einen Thread freigeben. Im Beispiel werden dann weitere fünf Threads in die Warteschlange eingereiht und mit einem <xref:System.Threading.EventWaitHandle> freigegeben, das mit dem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellt wurde  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="toWaitOn" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Methode wurde in einem Thread im Status <see cref="F:System.Threading.ApartmentState.STA" /> aufgerufen.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="toSignal" /> ist ein Semaphor, und die maximale Anzahl ist bereits erreicht.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="toSignal">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</param>
        <param name="toWaitOn">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</param>
        <param name="millisecondsTimeout">Eine Ganzzahl, die das Wartezeitintervall darstellt. Wenn der Wert <see cref="F:System.Threading.Timeout.Infinite" /> (d. h. -1) ist, ist die Wartezeit unendlich.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</param>
        <summary>Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf ein weiteres, wobei ein Timeoutintervall als 32-Bit-Ganzzahl mit Vorzeichen angegeben und festgelegt wird, ob die Synchronisierungsdomäne des Kontexts vor dem Wartevorgang verlassen werden soll.</summary>
        <returns><see langword="true" />, wenn das Signal und die Wartezeit erfolgreich abgeschlossen wurden, oder <see langword="false" />, wenn das Signal abgeschlossen wurde, für die Wartezeit jedoch ein Timeout aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist nicht garantiert, dass dieser Vorgang atomarisch ist. Nachdem der aktuelle Thread `toSignal` signalisiert hat, aber bevor er auf `toWaitOn`wartet, könnte ein Thread, der auf einem anderen Prozessor ausgeführt wird, `toWaitOn` oder darauf warten.  
  
 Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert. Er testet den Status des `toWaitOn` und wird sofort zurückgegeben.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen. Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist. Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.  
  
 Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode ausgeführt wird. Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode abgeschlossen wurde.  
  
 Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt. In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse. Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann. Wenn die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="toWaitOn" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Methode wird in einem Thread im Status <see cref="F:System.Threading.ApartmentState.STA" /> aufgerufen.</exception>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Threading.WaitHandle" /> kann nicht signalisiert werden, da dies die maximale Anzahl übersteigen würde.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="toSignal">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</param>
        <param name="toWaitOn">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" />-Wert, der das Wartezeitintervall darstellt. Wenn der Wert -1 ist, ist die Wartezeit unendlich.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</param>
        <summary>Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf ein weiteres, wobei das Timeoutintervall als <see cref="T:System.TimeSpan" /> angegeben und festgelegt wird, ob die Synchronisierungsdomäne des Kontexts vor dem Wartevorgang verlassen werden soll.</summary>
        <returns><see langword="true" />, wenn das Signal und die Wartezeit erfolgreich abgeschlossen wurden, oder <see langword="false" />, wenn das Signal abgeschlossen wurde, für die Wartezeit jedoch ein Timeout aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist nicht garantiert, dass dieser Vorgang atomarisch ist. Nachdem der aktuelle Thread `toSignal` signalisiert hat, aber bevor er auf `toWaitOn`wartet, könnte ein Thread, der auf einem anderen Prozessor ausgeführt wird, `toWaitOn` oder darauf warten.  
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Wenn `timeout` NULL ist, wird die-Methode nicht blockiert. Er testet den Status des `toWaitOn` und wird sofort zurückgegeben.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen. Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist. Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.  
  
 Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode ausgeführt wird. Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode abgeschlossen wurde.  
  
 Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt. In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse. Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann. Wenn die <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="toWaitOn" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Methode wurde in einem Thread im Status <see cref="F:System.Threading.ApartmentState.STA" /> aufgerufen.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="toSignal" /> ist ein Semaphor, und die maximale Anzahl ist bereits erreicht.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ergibt eine negative Anzahl von Millisekunden ungleich -1.  
  
- oder - 
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member System.IDisposable.Dispose : unit -&gt; unit&#xA;override this.System.IDisposable.Dispose : unit -&gt; unit" Usage="waitHandle.System.IDisposable.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.Threading.WaitHandle" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Durch Aufrufen von `Dispose` können die Ressourcen, die vom <xref:System.Threading.WaitHandle> verwendet werden, für andere Zwecke neu zugeordnet werden. Weitere Informationen zu `Dispose`finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet. Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</param>
        <summary>Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen.</summary>
        <returns><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls wird die Methode nicht beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0. In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird. Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an. Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers). Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind  
  
 Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode gibt zurück, wenn alle Handles signalisiert werden. Wenn mehr als 64 Handles überschritten werden, wird eine <xref:System.NotSupportedException> ausgelöst. Wenn das Array Duplikate enthält, schlägt der-Befehl mit einem-<xref:System.DuplicateWaitObjectException>fehl.
  
> [!NOTE]
>  Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird für Threads in <xref:System.Threading.ApartmentState.STA> Zustand nicht unterstützt.
  
 Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>-Methoden Überladung und der Angabe von-1 (oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) für `millisecondsTimeout` und `true` für `exitContext`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um asynchron eine Gruppe von Dateien zu erstellen und in diese zu schreiben. Jeder Schreibvorgang wird als Arbeits Element in die Warteschlange eingereiht und signalisiert, wann er abgeschlossen ist. Der Haupt Thread wartet darauf, dass alle Elemente signalisiert und dann beendet werden.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />. - oder - 
Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.  
  
</para>
          </block>  
  
 Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</exception>
        <exception cref="T:System.NotSupportedException">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.  
  
- oder - 
Der aktuelle Thread ist im <see cref="F:System.Threading.ApartmentState.STA" />-Zustand, und <paramref name="waitHandles" /> enthält mehrere Elemente.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet. Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt (Duplikate) enthalten.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.Int32" />-Wert an.</summary>
        <returns><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.  
  
 Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Warte Vorgang beendet wird, was bedeutet, dass entweder alle Handles signalisiert werden oder ein Timeout auftritt. Wenn mehr als 64 Handles überschritten werden, wird eine <xref:System.NotSupportedException> ausgelöst. Wenn Duplikate im Array vorhanden sind, schlägt der-Befehl mit einem-<xref:System.DuplicateWaitObjectException>fehl.  
  
> [!NOTE]
>  Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird für Threads in <xref:System.Threading.ApartmentState.STA> Zustand nicht unterstützt.
  
 Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.  
  
- oder - 
Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="waitHandles" /> ist ein Array ohne Elemente.</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.  
  
</para>
          </block>  
  
 Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</exception>
        <exception cref="T:System.NotSupportedException">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.  
  
- oder - 
Der aktuelle Thread ist im <see cref="F:System.Threading.ApartmentState.STA" />-Zustand, und <paramref name="waitHandles" /> enthält mehrere Elemente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet. Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu Millisekunden für die Wartezeit angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden angibt, also eine unbeschränkte Wartezeit.</param>
        <summary>Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.TimeSpan" />-Wert an.</summary>
        <returns><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.  
  
 Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode gibt zurück, wenn der Warte Vorgang beendet wird, was bedeutet, dass entweder alle Handles signalisiert werden oder ein Timeout auftritt. Wenn mehr als 64 Handles überschritten werden, wird eine <xref:System.NotSupportedException> ausgelöst. Wenn das Array Duplikate enthält, schlägt der-Befehl fehl.
  
> [!NOTE]
>  Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird für Threads in <xref:System.Threading.ApartmentState.STA> Zustand nicht unterstützt.
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.  
  
- oder - 
Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="waitHandles" /> ist ein Array ohne Elemente.</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.  
  
</para>
          </block>  
  
 Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</exception>
        <exception cref="T:System.NotSupportedException">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.  
  
- oder - 
Der aktuelle Thread ist im <see cref="F:System.Threading.ApartmentState.STA" />-Zustand, und <paramref name="waitHandles" /> enthält mehrere Elemente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt. 
- oder - 
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet. Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt (Duplikate) enthalten.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</param>
        <summary>Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.Int32" />-Wert zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</summary>
        <returns><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0. In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird. Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an. Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers). Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind  
  
 Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode gibt zurück, wenn der Warte Vorgang beendet wird, was bedeutet, dass entweder alle Handles signalisiert werden oder ein Timeout auftritt. Wenn mehr als 64 Handles überschritten werden, wird eine <xref:System.NotSupportedException> ausgelöst. Wenn Duplikate im Array vorhanden sind, schlägt der-Befehl mit einem-<xref:System.DuplicateWaitObjectException>fehl.
  
> [!NOTE]
>  Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird für Threads in <xref:System.Threading.ApartmentState.STA> Zustand nicht unterstützt.
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen. Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist. Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie z. b. <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.  
  
 Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode ausgeführt wird. Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitAll%2A> Methode abgeschlossen wurde.  
  
 Dies kann hilfreich sein, wenn die Kontext gebundene Klasse über das <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>-Attribut verfügt. In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse. Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann. Wenn die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um asynchron eine Gruppe von Dateien zu erstellen und in diese zu schreiben. Jeder Schreibvorgang wird als Arbeits Element in die Warteschlange eingereiht und signalisiert, wann er abgeschlossen ist. Der Haupt Thread wartet darauf, dass alle Elemente signalisiert und dann beendet werden.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.  
  
- oder - 
Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</exception>
        <exception cref="T:System.NotSupportedException">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.  
  
- oder - 
Der aktuelle Thread ist im <see cref="F:System.Threading.ApartmentState.STA" />-Zustand, und <paramref name="waitHandles" /> enthält mehrere Elemente.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet. Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu Millisekunden für die Wartezeit angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden angibt, also eine unbeschränkte Wartezeit.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</param>
        <summary>Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.TimeSpan" />-Wert zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</summary>
        <returns><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0. In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird. Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an. Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers). Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind  
  
 Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode gibt zurück, wenn der Warte Vorgang beendet wird, was bedeutet, dass entweder alle Handles signalisiert werden oder ein Timeout auftritt. Wenn mehr als 64 Handles überschritten werden, wird eine <xref:System.NotSupportedException> ausgelöst. Wenn das Array Duplikate enthält, schlägt der-Befehl fehl.
  
> [!NOTE]
>  Die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird für Threads in <xref:System.Threading.ApartmentState.STA> Zustand nicht unterstützt.
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen. Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist. Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie z. b. <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.  
  
 Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode ausgeführt wird. Sie kehrt zum ursprünglichen, nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitAll%2A> Methode abgeschlossen wurde.  
  
 Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt. In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse. Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann. Wenn die <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um asynchron eine Gruppe von Dateien zu erstellen und in diese zu schreiben. Jeder Schreibvorgang wird als Arbeits Element in die Warteschlange eingereiht und signalisiert, wann er abgeschlossen ist. Der Haupt Thread wartet darauf, dass alle Elemente signalisiert und dann beendet werden.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.  
  
- oder - 
Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</exception>
        <exception cref="T:System.NotSupportedException">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.  
  
- oder - 
Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehrere Elemente.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt. 
- oder - 
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wartet, bis Elemente im angegebenen Array ein Signal empfangen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</param>
        <summary>Wartet, bis Elemente im angegebenen Array ein Signal empfangen.</summary>
        <returns>Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0. In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode `true` zurück, wenn der Warte Vorgang abgeschlossen ist, weil ein Mutex abgebrochen wird. Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an. Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers). Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind  
  
 Die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode löst eine <xref:System.Threading.AbandonedMutexException> nur aus, wenn der Warte Vorgang aufgrund eines abgebrochen Mutex abgeschlossen ist. Wenn `waitHandles` einen freigegebenen Mutex mit einer niedrigeren Indexnummer als der abgebrochene Mutex enthält, wird die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode normal abgeschlossen, und die Ausnahme wird nicht ausgelöst.  
  
> [!NOTE]
>  In Versionen des .NET Framework vor Version 2,0, wenn ein Thread beendet oder abgebrochen wird, ohne explizit eine <xref:System.Threading.Mutex>zu veröffentlichen, und dass `Mutex` in einem `WaitAny` Array in einem anderen Thread an Index 0 (null) liegt, ist der von `WaitAny` zurückgegebene Index 128 statt 0.  
  
 Diese Methode gibt zurück, wenn ein Handle signalisiert wird. Wenn während des Aufrufes mehr als ein Objekt signalisiert wird, ist der Rückgabewert der Array Index des signalisierten Objekts mit dem kleinsten Indexwert aller signalisierten Objekte.

 Die maximale Anzahl der Wait-Handles beträgt 64 und 63, wenn sich der aktuelle Thread in <xref:System.Threading.ApartmentState.STA> Zustand befindet.

 Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>-Methoden Überladung und der Angabe von-1 (oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) für `millisecondsTimeout` und `true` für `exitContext`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode veranschaulicht.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.  
  
- oder - 
Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einer 32-Bit-Ganzzahl mit Vorzeichen an.</summary>
        <returns>Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="millisecondsTimeout" /> vergangen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.  
  
 Die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode löst eine <xref:System.Threading.AbandonedMutexException> nur aus, wenn der Warte Vorgang aufgrund eines abgebrochen Mutex abgeschlossen ist. Wenn `waitHandles` einen freigegebenen Mutex mit einer niedrigeren Indexnummer als der abgebrochene Mutex enthält, wird die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode normal abgeschlossen, und die Ausnahme wird nicht ausgelöst.  
  
 Diese Methode gibt zurück, wenn der Warte Vorgang beendet wird, entweder wenn eines der Handles signalisiert wird oder wenn ein Timeout auftritt. Wenn während des Aufrufes mehr als ein Objekt signalisiert wird, ist der Rückgabewert der Array Index des signalisierten Objekts mit dem kleinsten Indexwert aller signalisierten Objekte.

 Die maximale Anzahl der Wait-Handles beträgt 64 und 63, wenn sich der aktuelle Thread in <xref:System.Threading.ApartmentState.STA> Zustand befindet.
  
 Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.  
  
- oder - 
Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.TimeSpan" />-Wert an.</summary>
        <returns>Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="timeout" /> vergangen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.  
  
 Die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode löst eine <xref:System.Threading.AbandonedMutexException> nur aus, wenn der Warte Vorgang aufgrund eines abgebrochen Mutex abgeschlossen ist. Wenn `waitHandles` einen freigegebenen Mutex mit einer niedrigeren Indexnummer als der abgebrochene Mutex enthält, wird die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode normal abgeschlossen, und die Ausnahme wird nicht ausgelöst.  
  
 Diese Methode gibt zurück, wenn der Warte Vorgang beendet wird, entweder wenn eines der Handles signalisiert wird oder ein Timeout auftritt. Wenn während des Aufrufes mehr als ein Objekt signalisiert wird, ist der Rückgabewert der Array Index des signalisierten Objekts mit dem kleinsten Indexwert aller signalisierten Objekte.

 Die maximale Anzahl der Wait-Handles beträgt 64 und 63, wenn sich der aktuelle Thread in <xref:System.Threading.ApartmentState.STA> Zustand befindet.

 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.  
  
- oder - 
Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt. 
- oder - 
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</param>
        <summary>Wartet, bis Elemente im angegebenen Array ein Signal empfangen, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</summary>
        <returns>Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="millisecondsTimeout" /> vergangen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0. In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode `true` zurück, wenn der Warte Vorgang abgeschlossen ist, weil ein Mutex abgebrochen wird. Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an. Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers). Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind  
  
 Die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode löst eine <xref:System.Threading.AbandonedMutexException> nur aus, wenn der Warte Vorgang aufgrund eines abgebrochen Mutex abgeschlossen ist. Wenn `waitHandles` einen freigegebenen Mutex mit einer niedrigeren Indexnummer als der abgebrochene Mutex enthält, wird die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode normal abgeschlossen, und die Ausnahme wird nicht ausgelöst.  
  
> [!NOTE]
>  In Versionen des .NET Framework vor Version 2,0, wenn ein Thread beendet oder abgebrochen wird, ohne explizit eine <xref:System.Threading.Mutex>zu veröffentlichen, und dass `Mutex` in einem `WaitAny` Array in einem anderen Thread an Index 0 (null) liegt, ist der von `WaitAny` zurückgegebene Index 128 statt 0.  
  
 Diese Methode gibt zurück, wenn der Warte Vorgang beendet wird, entweder wenn eines der Handles signalisiert wird oder wenn ein Timeout auftritt. Wenn während des Aufrufes mehr als ein Objekt signalisiert wird, ist der Rückgabewert der Array Index des signalisierten Objekts mit dem kleinsten Indexwert aller signalisierten Objekte.

 Die maximale Anzahl der Wait-Handles beträgt 64 und 63, wenn sich der aktuelle Thread in <xref:System.Threading.ApartmentState.STA> Zustand befindet.
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen. Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist. Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.  
  
 Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode ausgeführt wird. Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitAny%2A> Methode abgeschlossen wurde.  
  
 Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt. In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse. Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann. Wenn die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um gleichzeitig eine Datei auf mehreren Datenträgern zu suchen. Aus Platzgründen wird nur das Stammverzeichnis der einzelnen Datenträger durchsucht.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.  
  
- oder - 
Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</param>
        <summary>Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</summary>
        <returns>Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="timeout" /> vergangen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand der Wait-Handles und wird sofort zurückgegeben.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0. In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode `true` zurück, wenn der Warte Vorgang abgeschlossen ist, weil ein Mutex abgebrochen wird. Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an. Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers). Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind  
  
 Die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode löst eine <xref:System.Threading.AbandonedMutexException> nur aus, wenn der Warte Vorgang aufgrund eines abgebrochen Mutex abgeschlossen ist. Wenn `waitHandles` einen freigegebenen Mutex mit einer niedrigeren Indexnummer als der abgebrochene Mutex enthält, wird die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode normal abgeschlossen, und die Ausnahme wird nicht ausgelöst.  
  
> [!NOTE]
>  In Versionen des .NET Framework vor Version 2,0, wenn ein Thread beendet oder abgebrochen wird, ohne explizit eine <xref:System.Threading.Mutex>zu veröffentlichen, und dass `Mutex` in einem `WaitAny` Array in einem anderen Thread an Index 0 (null) liegt, ist der von `WaitAny` zurückgegebene Index 128 statt 0.  
  
 Diese Methode gibt zurück, wenn der Warte Vorgang beendet wird, entweder wenn eines der Handles signalisiert wird oder ein Timeout auftritt. Wenn während des Aufrufes mehr als ein Objekt signalisiert wird, ist der Rückgabewert der Array Index des signalisierten Objekts mit dem kleinsten Indexwert aller signalisierten Objekte.

 Die maximale Anzahl der Wait-Handles beträgt 64 und 63, wenn sich der aktuelle Thread in <xref:System.Threading.ApartmentState.STA> Zustand befindet.

 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen. Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist. Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.  
  
 Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode ausgeführt wird. Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitAny%2A> Methode abgeschlossen wurde.  
  
 Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt. In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse. Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann. Wenn die <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um gleichzeitig eine Datei auf mehreren Datenträgern zu suchen. Aus Platzgründen wird nur das Stammverzeichnis der einzelnen Datenträger durchsucht.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.  
  
- oder - 
Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt. 
- oder - 
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt.</summary>
        <returns><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt. Wenn die aktuelle Instanz kein Signal erhält, wird <see cref="M:System.Threading.WaitHandle.WaitOne" /> nicht beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0. In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird. Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an. Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers). Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind  
  
 Der Aufrufer dieser Methode blockiert unbegrenzt, bis die aktuelle Instanz ein Signal empfängt. Verwenden Sie diese Methode, um zu blockieren, bis ein <xref:System.Threading.WaitHandle> ein Signal von einem anderen Thread empfängt, z. b. wird generiert, wenn ein asynchroner Vorgang abgeschlossen wird. Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.  
  
 Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>-Methoden Überladung und der Angabe von "-1" oder "<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>" für den ersten Parameter und `false` für den zweiten Parameter.  
  
 Überschreiben Sie diese Methode, um das Verhalten abgeleiteter Klassen anzupassen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein Wait-Handle verwendet wird, um einen Prozess vom beenden beizubehalten, während er darauf wartet, dass ein Hintergrund Thread die Ausführung beendet.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die aktuelle Instanz wurde bereits verworfen.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.InvalidOperationException">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls in Millisekunden verwendet wird.</summary>
        <returns><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand des Wait-Handles und wird sofort zurückgegeben.  
  
 Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal empfängt oder ein Timeout auftritt. Verwenden Sie diese Methode, um zu blockieren, bis ein <xref:System.Threading.WaitHandle> ein Signal von einem anderen Thread empfängt, z. b. wird generiert, wenn ein asynchroner Vorgang abgeschlossen wird. Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.  
  
 Überschreiben Sie diese Methode, um das Verhalten abgeleiteter Klassen anzupassen.  
  
 Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein Wait-Handle verwendet wird, um einen Prozess vom beenden beizubehalten, während er darauf wartet, dass ein Hintergrund Thread die Ausführung beendet.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die aktuelle Instanz wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.InvalidOperationException">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Blockiert den aktuellen Thread, bis die aktuelle Instanz ein Signal empfängt, wobei eine <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet wird.</summary>
        <returns><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand des Wait-Handles und wird sofort zurückgegeben.  
  
 Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal empfängt oder ein Timeout auftritt. Verwenden Sie diese Methode, um zu blockieren, bis ein <xref:System.Threading.WaitHandle> ein Signal von einem anderen Thread empfängt, z. b. wird generiert, wenn ein asynchroner Vorgang abgeschlossen wird. Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.  
  
 Überschreiben Sie diese Methode, um das Verhalten abgeleiteter Klassen anzupassen.  
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> Überladung und der Angabe von `false` für `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die aktuelle Instanz wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt. 
- oder - 
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.InvalidOperationException">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</param>
        <summary>Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls verwendet und angegeben wird, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</summary>
        <returns><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `millisecondsTimeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand des Wait-Handles und wird sofort zurückgegeben.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0. In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird. Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an. Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers). Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind  
  
 Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal empfängt oder ein Timeout auftritt. Verwenden Sie diese Methode, um zu blockieren, bis ein <xref:System.Threading.WaitHandle> ein Signal von einem anderen Thread empfängt, z. b. wird generiert, wenn ein asynchroner Vorgang abgeschlossen wird. Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.  
  
 Überschreiben Sie diese Methode, um das Verhalten abgeleiteter Klassen anzupassen.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen. Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist. Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.  
  
 Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode ausgeführt wird. Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitOne%2A> Methode abgeschlossen wurde.  
  
 Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt. In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse. Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann. Wenn die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie sich die <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>-Methoden Überladung verhält, wenn Sie innerhalb einer Synchronisierungs Domäne aufgerufen wird. Zuerst wartet ein Thread, wenn `exitContext` auf `false` festgelegt ist, und wird blockiert, bis das warte Timeout abläuft. Ein zweiter Thread wird ausgeführt, nachdem der erste Thread beendet wurde, und wartet, bis `exitContext` auf `true`festgelegt ist. Der-Befehl, der das Wait-Handle für diesen zweiten Thread signalisiert, wird nicht blockiert, und der Thread wird vor dem warte Timeout abgeschlossen.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die aktuelle Instanz wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.InvalidOperationException">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</param>
        <summary>Blockiert den aktuellen Thread, bis die aktuelle Instanz ein Signal empfängt, wobei eine <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet und angegeben wird, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</summary>
        <returns><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `timeout` NULL ist, wird die-Methode nicht blockiert. Es testet den Zustand des Wait-Handles und wird sofort zurückgegeben.  
  
 <xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework Version 2,0. In früheren Versionen gibt die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode `true` zurück, wenn ein Mutex abgebrochen wird. Ein abgebrochener Mutex zeigt häufig einen schwerwiegenden Codierungsfehler an. Im Fall eines systemweiten Mutex kann dies darauf hindeuten, dass eine Anwendung abrupt beendet wurde (z. b. mithilfe des Windows Task-Managers). Die Ausnahme enthält Informationen, die beim Debuggen hilfreich sind  
  
 Der Aufrufer dieser Methode blockiert, bis die aktuelle Instanz ein Signal empfängt oder ein Timeout auftritt. Verwenden Sie diese Methode, um zu blockieren, bis ein <xref:System.Threading.WaitHandle> ein Signal von einem anderen Thread empfängt, z. b. wird generiert, wenn ein asynchroner Vorgang abgeschlossen wird. Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.  
  
 Überschreiben Sie diese Methode, um das Verhalten abgeleiteter Klassen anzupassen.  
  
 Der maximale Wert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Der `exitContext`-Parameter hat keine Auswirkung, es sei denn, die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode wird von einem nicht standardmäßigen verwalteten Kontext aus aufgerufen. Dies kann vorkommen, wenn sich der Thread innerhalb eines Aufrufes einer Instanz einer Klasse befindet, die von <xref:System.ContextBoundObject>abgeleitet ist. Auch wenn Sie derzeit eine Methode für eine Klasse ausführen, die nicht von <xref:System.ContextBoundObject>abgeleitet ist, wie <xref:System.String>, können Sie sich in einem nicht standardmäßigen Kontext befinden, wenn eine <xref:System.ContextBoundObject> in der aktuellen Anwendungsdomäne in Ihrem Stapel ist.  
  
 Wenn Ihr Code in einem nicht standardmäßigen Kontext ausgeführt wird, wird durch Angeben von `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext (d. h. den Übergang zum Standardkontext) beendet, bevor die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode ausgeführt wird. Der Thread kehrt in den ursprünglichen nicht standardmäßigen Kontext zurück, nachdem der aufzurufende <xref:System.Threading.WaitHandle.WaitOne%2A> Methode abgeschlossen wurde.  
  
 Dies kann nützlich sein, wenn die Kontext gebundene Klasse über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>verfügt. In diesem Fall werden alle Aufrufe an Member der-Klasse automatisch synchronisiert, und die Synchronisierungs Domäne ist der gesamte Code Körper für die-Klasse. Wenn Code in der Aufruf Stapel eines Members die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aufruft und `true` für `exitContext`angibt, beendet der Thread die Synchronisierungs Domäne, sodass ein Thread, der bei einem Aufruf von einem beliebigen Member des Objekts blockiert wird, fortgesetzt werden kann. Wenn die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode zurückgibt, muss der Thread, der den-Befehl erstellt hat, warten, bis die Synchronisierungs Domäne erneut eingegeben wird  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein Wait-Handle verwendet wird, um einen Prozess vom beenden beizubehalten, während er darauf wartet, dass ein Hintergrund Thread die Ausführung beendet.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die aktuelle Instanz wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt. 
- oder - 
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben. Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.InvalidOperationException">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Gibt an, dass ein Timeout für einen <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />-Vorgang überschritten wurde, bevor ein Signal an eines der WaitHandles gesendet wurde. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Feld ist einer der möglichen Rückgabewerte `WaitAny`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie der Thread Pool verwendet wird, um gleichzeitig eine Datei auf mehreren Datenträgern zu suchen. Aus Platzgründen wird nur das Stammverzeichnis der einzelnen Datenträger durchsucht.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
