<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="5ad66-101">Kapselt betriebssystemspezifische Objekte, die auf exklusiven Zugriff auf gemeinsam genutzte Ressourcen warten.</span><span class="sxs-lookup"><span data-stu-id="5ad66-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-102">Die <xref:System.Threading.WaitHandle> Klasse Win32-Synchronisierungshandles kapselt und wird verwendet, um alle Synchronisierungsobjekte in der Laufzeit darstellen, die mehrere Wartevorgänge ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-102">The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="5ad66-103">Einen Vergleich der Wait-Handles mit anderen Synchronisierungsobjekten, finden Sie unter [Übersicht über Synchronisierungsprimitiven](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="5ad66-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="5ad66-104">Die <xref:System.Threading.WaitHandle> Klasse selbst ist abstrakt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="5ad66-105">Abgeleitete Klassen von <xref:System.Threading.WaitHandle> definieren Sie einen signaling Mechanismus zum aufnehmen oder Freigeben von Zugriff auf eine freigegebene Ressource anzugeben, aber sie verwenden die geerbte <xref:System.Threading.WaitHandle> Methoden zu blockieren, bis für den Zugriff auf freigegebene Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="5ad66-106">Von abgeleiteten Klassen <xref:System.Threading.WaitHandle> enthalten:</span><span class="sxs-lookup"><span data-stu-id="5ad66-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="5ad66-107">Der <xref:System.Threading.Mutex>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="5ad66-108">Finden Sie unter [Mutexe](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="5ad66-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="5ad66-109">Die <xref:System.Threading.EventWaitHandle> Klasse und abgeleitete Klassen, <xref:System.Threading.AutoResetEvent> und <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="5ad66-110">Siehe [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="5ad66-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="5ad66-111">Der <xref:System.Threading.Semaphore>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="5ad66-112">Finden Sie unter [Semaphore und SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="5ad66-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="5ad66-113">Threads können auf einem einzelnen Wait-Handle durch Aufrufen der Instanzmethode blockieren <xref:System.Threading.WaitHandle.WaitOne%2A>, die von von abgeleiteten Klassen geerbt wird <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="5ad66-114">Die abgeleiteten Klassen von <xref:System.Threading.WaitHandle> unterscheiden sich in deren Threadaffinität.</span><span class="sxs-lookup"><span data-stu-id="5ad66-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="5ad66-115">Ereignis-wait-Handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, und <xref:System.Threading.ManualResetEvent>) und Semaphore keine Threadaffinität; einen beliebigen Thread kann ein Ereignis-Wait-Handle oder einen Semaphore zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="5ad66-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="5ad66-116">Mutexe bezeichnet, führen Sie auf der anderen Seite Threadaffinität; der Thread, der einen Mutex besitzt muss freigegeben werden, und eine Ausnahme wird ausgelöst, wenn ein Thread aufruft, die <xref:System.Threading.Mutex.ReleaseMutex%2A> Methode einen Mutex, deren Besitzer er nicht ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="5ad66-117">Da die <xref:System.Threading.WaitHandle> Klasse leitet sich von <xref:System.MarshalByRefObject>, diese Klassen können verwendet werden, um die Aktivitäten von Threads über Anwendungsdomänengrenzen hinweg zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="5ad66-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="5ad66-118">Zusätzlich zu den davon abgeleiteten Klassen die <xref:System.Threading.WaitHandle> -Klasse verfügt über eine Reihe von statischen Methoden, die einen Thread, bis eine blockiert oder mehrere Synchronisierungsobjekte empfangen eines Signals...</span><span class="sxs-lookup"><span data-stu-id="5ad66-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..</span></span> <span data-ttu-id="5ad66-119">Dazu gehören:</span><span class="sxs-lookup"><span data-stu-id="5ad66-119">These include:</span></span>  
  
-   <span data-ttu-id="5ad66-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, der ermöglicht es einem Thread ein Wait-Handle zu signalisieren und sofort auf einen anderen warten.</span><span class="sxs-lookup"><span data-stu-id="5ad66-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="5ad66-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, womit auf einen Thread zu warten, bis alle Wait-Handles in einem Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="5ad66-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, womit auf einen Thread zu warten, bis eine von einem angegebenen Satz von Wait-Handles signalisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="5ad66-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="5ad66-123">Die Überladungen dieser Methoden bereitstellen, befehlstimeoutintervalle zum Aufgeben der Warte- und die Möglichkeit, einen Synchronisierungskontext beenden Sie vor dem Wartevorgang, verwenden Sie den Synchronisierungskontext anderer Threads zugelassen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5ad66-124">Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="5ad66-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="5ad66-125">Wenn Sie mit den Typ oder eine davon abgeleitete Typ abgeschlossen haben, sollten Sie es entweder direkt oder indirekt freigeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="5ad66-126">Aufrufen, um den Typ direkt zu verwerfen, dessen <xref:System.Threading.WaitHandle.Close%2A> Methode in einer `try` / `catch` Block.</span><span class="sxs-lookup"><span data-stu-id="5ad66-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="5ad66-127">Um es indirekt freizugeben, verwenden Sie ein Sprachkonstrukt z. B. `using` (in c#) oder `Using` (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="5ad66-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="5ad66-128">Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, implementiert IDisposable" in der <xref:System.IDisposable> Thema zur Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="5ad66-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="5ad66-129"><xref:System.Threading.WaitHandle> implementiert die <xref:System.IDisposable.Dispose%2A> Muster.</span><span class="sxs-lookup"><span data-stu-id="5ad66-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="5ad66-130">Finden Sie unter [Dispose-Muster](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="5ad66-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="5ad66-131">Beim Ableiten von <xref:System.Threading.WaitHandle>, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Eigenschaft, um Ihre systemeigene Betriebssystemhandle zu speichern.</span><span class="sxs-lookup"><span data-stu-id="5ad66-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="5ad66-132">Sie müssen nicht den geschützten überschreiben <xref:System.Threading.WaitHandle.Dispose%2A> Methode, wenn Sie zusätzliche verwaltete Ressourcen verwenden.</span><span class="sxs-lookup"><span data-stu-id="5ad66-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-133">Das folgende Codebeispiel zeigt, wie zwei Threads können führen Hintergrundaufgaben während der Hauptthread thread wartet, bis die Aufgaben mithilfe der statischen <xref:System.Threading.WaitHandle.WaitAny%2A> und <xref:System.Threading.WaitHandle.WaitAll%2A> Methoden die <xref:System.Threading.WaitHandle> Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="5ad66-134">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="5ad66-134">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5ad66-135">Initialisiert eine neue Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-135">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5ad66-136">Gibt alle von der aktuellen <see cref="T:System.Threading.WaitHandle" />-Klasse reservierten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="5ad66-136">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-137">Diese Methode ist die öffentliche Implementierung der <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Methode für die <xref:System.Threading.WaitHandle> Klasse und abgeleitete Klassen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-137">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="5ad66-138">Es stellt eine Standardimplementierung, die aufruft der `Dispose(Boolean)` -Überladung mit einer `true` Argument und ruft dann die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="5ad66-138">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5ad66-139">Rufen Sie diese Methode sämtliche Ressourcen frei, die von einer Instanz von Version `WaitHandle` oder eine abgeleitete Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-139">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="5ad66-140">Sobald diese Methode aufgerufen wird, werden Verweise auf die aktuelle Instanz nicht definiertes Verhalten verursachen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-140">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ad66-141">Rufen Sie immer <xref:System.Threading.WaitHandle.Close%2A> oder <xref:System.Threading.WaitHandle.Dispose> , bevor Sie den letzten Verweis auf Freigeben der <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-141">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="5ad66-142">Andernfalls bleiben die verwendeten Ressourcen nicht reserviert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-142">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="5ad66-143">Sie sollten überschreiben die <see langword="Dispose(Boolean)" /> Methode zum Freigeben von Ressourcen, die abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-143">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5ad66-144">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="5ad66-144">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5ad66-145">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.WaitHandle" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="5ad66-145">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-146">Diese Methode entspricht der <xref:System.Threading.WaitHandle.Close%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="5ad66-146">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ad66-147">Rufen Sie immer <xref:System.Threading.WaitHandle.Close%2A> oder <xref:System.Threading.WaitHandle.Dispose> , bevor Sie den letzten Verweis auf Freigeben der <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-147">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="5ad66-148">Andernfalls bleiben die verwendeten Ressourcen nicht reserviert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-148">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="5ad66-149"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-149"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="5ad66-150">Gibt beim Überschreiben in einer abgeleiteten Klasse die von <see cref="T:System.Threading.WaitHandle" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="5ad66-150">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-151">Diese Methode wird aufgerufen, indem Sie die <xref:System.Threading.WaitHandle.Close%2A> und die <xref:System.Threading.WaitHandle.Dispose> Methoden mit der `explicitDisposing` Parametersatz auf `true`.</span><span class="sxs-lookup"><span data-stu-id="5ad66-151">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="5ad66-152">Wenn die `explicitDisposing` Parameter ist `true`, diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte frei, die von diesem <xref:System.Threading.WaitHandle> -Objekt verweist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-152">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="5ad66-153">Sie sollten überschreiben die <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> Methode zum Freigeben von Ressourcen, die abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-153">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
 <span data-ttu-id="5ad66-154">Die <see cref="M:System.Threading.WaitHandle.Close" /> oder <see cref="M:System.Threading.WaitHandle.Dispose" /> Methode kann von anderen Objekten mehrmals aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="5ad66-154">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="5ad66-155">Beim Überschreiben dieser Methode werden nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see langword="Dispose" /> oder <see langword="Close" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-155">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5ad66-156">Ruft das systemeigene Betriebssystemhandle auf oder legt dieses fest.</span><span class="sxs-lookup"><span data-stu-id="5ad66-156">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="5ad66-157">Ein <see langword="IntPtr" />, das das systemeigene Betriebssystemhandle darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-157">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="5ad66-158">Der Standardwert ist der Wert des <see cref="F:System.Threading.WaitHandle.InvalidHandle" />-Felds.</span><span class="sxs-lookup"><span data-stu-id="5ad66-158">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-159">Zuweisen eines neuen Werts auf die <xref:System.Threading.WaitHandle.Handle%2A> Eigenschaft wird das vorherige Handle nicht geschlossen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-159">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="5ad66-160">Dies kann zu einem unkontrollierten Handle führen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-160">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="5ad66-161">Verwenden Sie diese Eigenschaft nicht in .NET Framework, Version 2.0 oder höher. Verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Eigenschaft stattdessen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-161">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="5ad66-162">Festlegen dieser Eigenschaft auf ein gültiges Handle, wird auch die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> -Eigenschaft, aber bei der Einstellung <xref:System.Threading.WaitHandle.InvalidHandle> kann zu einem unkontrollierten Handle führen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-162">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5ad66-163">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer zum Festlegen des Werts der Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="5ad66-163">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="5ad66-164">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="5ad66-164">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="5ad66-165">Abgeleitete Typen müssen <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> zum Festlegen des Werts der Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="5ad66-165">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5ad66-166">Stellt ein ungültiges systemeigenes Betriebssystemhandle dar.</span><span class="sxs-lookup"><span data-stu-id="5ad66-166">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="5ad66-167">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-167">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-168">Intern verwendet, um das Initialisieren der <xref:System.Threading.WaitHandle.Handle%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="5ad66-168">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="5ad66-169">Sie können diesen Wert verwenden, um zu bestimmen, ob die <see cref="P:System.Threading.WaitHandle.Handle" /> Eigenschaft enthält ein gültigen systemeigenes Betriebssystemhandle.</span><span class="sxs-lookup"><span data-stu-id="5ad66-169">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5ad66-170">Ruft das systemeigene Betriebssystemhandle auf oder legt dieses fest.</span><span class="sxs-lookup"><span data-stu-id="5ad66-170">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="5ad66-171">Ein <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />, das das systemeigene Betriebssystemhandle darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-171">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-172">Wenn Sie einen neuen Wert zuweisen der <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> -Eigenschaft, die vorherige Handle wird geschlossen, wenn der vorherige <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Objekt gesammelt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-172">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="5ad66-173">Schließen Sie nicht manuell das Handle, da dadurch ein <xref:System.ObjectDisposedException> beim der <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> versucht, das Handle nicht geschlossen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-173">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="5ad66-174"><xref:System.Threading.WaitHandle> implementiert die <xref:System.IDisposable.Dispose%2A> Muster.</span><span class="sxs-lookup"><span data-stu-id="5ad66-174"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="5ad66-175">Finden Sie unter [Dispose-Muster](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="5ad66-175">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="5ad66-176">Beim Ableiten von <xref:System.Threading.WaitHandle>, verwenden Sie die <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Eigenschaft, um Ihre systemeigene Betriebssystemhandle zu speichern.</span><span class="sxs-lookup"><span data-stu-id="5ad66-176">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="5ad66-177">Sie müssen nicht den geschützten überschreiben <xref:System.Threading.WaitHandle.Dispose%2A> Methode, wenn Sie zusätzliche verwaltete Ressourcen verwenden.</span><span class="sxs-lookup"><span data-stu-id="5ad66-177">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5ad66-178">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="5ad66-178">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5ad66-179">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="5ad66-179">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="5ad66-180">Abgeleitete Typen müssen <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> bei diesem Member aufrufen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-180">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5ad66-181">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf einen anderen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-181">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="5ad66-182">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-182">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="5ad66-183">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="5ad66-183">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="5ad66-184">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf einen anderen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-184">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-185"><see langword="true" />, wenn das Signal und der Wartevorgang erfolgreich abgeschlossen wurden. Wenn der Wartevorgang nicht abgeschlossen wird, wird die Methode nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-185"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-186">Dieser Vorgang ist nicht garantiert, um atomar zu sein.</span><span class="sxs-lookup"><span data-stu-id="5ad66-186">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="5ad66-187">Nach dem aktuellen Thread Signale `toSignal` , aber bevor er wartet auf `toWaitOn`, ein Thread, der auf einem anderen Prozessor ausgeführt wird, möglicherweise signalisieren `toWaitOn` oder darauf zu warten.</span><span class="sxs-lookup"><span data-stu-id="5ad66-187">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-188">Im folgenden Codebeispiel wird mit der <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> -methodenüberladung ermöglichen den Hauptthread zu einen blockierten Thread zu signalisieren und warten Sie, bis der Thread eine Aufgabe beendet ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-188">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="5ad66-189">Im Beispiel werden fünf Threads gestartet, ermöglicht es ihnen, blockiert ein <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flag und dann Versionen nur ein Thread-Mal die EINGABETASTE drückt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-189">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="5ad66-190">Anschließend fünf weitere Threads und freigegeben, alle mit einem <xref:System.Threading.EventWaitHandle> erstellt, mit der <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> Flag.</span><span class="sxs-lookup"><span data-stu-id="5ad66-190">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5ad66-191"><paramref name="toSignal" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-191"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-192">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-192">-or-</span></span>  
  
 <span data-ttu-id="5ad66-193"><paramref name="toWaitOn" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-193"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-194">Die Methode wurde in einem Thread aufgerufen, der über ein <see cref="T:System.STAThreadAttribute" /> verfügt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-194">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="5ad66-195">Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-195">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="5ad66-196"><paramref name="toSignal" /> ist ein Semaphor, und die maximale Anzahl ist bereits erreicht.</span><span class="sxs-lookup"><span data-stu-id="5ad66-196"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-197">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-197">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-198">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-198">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="5ad66-199">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-199">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="5ad66-200">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="5ad66-200">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="5ad66-201">Eine Ganzzahl, die das Wartezeitintervall darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-201">An integer that represents the interval to wait.</span></span> <span data-ttu-id="5ad66-202">Wenn der Wert <see cref="F:System.Threading.Timeout.Infinite" /> (d. h. -1) ist, ist die Wartezeit unendlich.</span><span class="sxs-lookup"><span data-stu-id="5ad66-202">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="5ad66-203"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-203"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5ad66-204">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf ein weiteres, wobei ein Timeoutintervall als 32-Bit-Ganzzahl mit Vorzeichen angegeben und festgelegt wird, ob die Synchronisierungsdomäne des Kontexts vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="5ad66-204">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-205"><see langword="true" />, wenn das Signal und die Wartezeit erfolgreich abgeschlossen wurden, oder <see langword="false" />, wenn das Signal abgeschlossen wurde, für die Wartezeit jedoch ein Timeout aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-205"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-206">Dieser Vorgang ist nicht garantiert, um atomar zu sein.</span><span class="sxs-lookup"><span data-stu-id="5ad66-206">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="5ad66-207">Nach dem aktuellen Thread Signale `toSignal` , aber bevor er wartet auf `toWaitOn`, ein Thread, der auf einem anderen Prozessor ausgeführt wird, möglicherweise signalisieren `toWaitOn` oder darauf zu warten.</span><span class="sxs-lookup"><span data-stu-id="5ad66-207">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="5ad66-208">Wenn `millisecondsTimeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-208">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-209">Anhand eines tests den Zustand der `toWaitOn` und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-209">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5ad66-210">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="5ad66-210">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5ad66-211">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-211">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5ad66-212">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-212">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5ad66-213">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-213">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5ad66-214">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="5ad66-214">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="5ad66-215">Der Thread zurück in den ursprünglich nicht standardmäßige nach dem Aufruf der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-215">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="5ad66-216">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-216">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5ad66-217">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-217">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5ad66-218">Wenn Code in der Aufrufliste eines Members Ruft die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode und gibt an, `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-218">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5ad66-219">Wenn die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-219">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5ad66-220"><paramref name="toSignal" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-220"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-221">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-221">-or-</span></span>  
  
 <span data-ttu-id="5ad66-222"><paramref name="toWaitOn" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-222"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-223">Die Methode wird in einem Thread aufgerufen, der über ein <see cref="T:System.STAThreadAttribute" /> verfügt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-223">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="5ad66-224">Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-224">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-225">Das <see cref="T:System.Threading.WaitHandle" /> kann nicht signalisiert werden, da dies die maximale Anzahl übersteigen würde.</span><span class="sxs-lookup"><span data-stu-id="5ad66-225">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-226"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-226"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-227">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-227">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-228">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-228">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="5ad66-229">Das zu signalisierende <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-229">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="5ad66-230">Das <see cref="T:System.Threading.WaitHandle" />, auf das gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="5ad66-230">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="5ad66-231">Ein <see cref="T:System.TimeSpan" />-Wert, der das Wartezeitintervall darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-231">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="5ad66-232">Wenn der Wert -1 ist, ist die Wartezeit unendlich.</span><span class="sxs-lookup"><span data-stu-id="5ad66-232">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="5ad66-233"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-233"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5ad66-234">Signalisiert ein <see cref="T:System.Threading.WaitHandle" /> und wartet auf ein weiteres, wobei das Timeoutintervall als <see cref="T:System.TimeSpan" /> angegeben und festgelegt wird, ob die Synchronisierungsdomäne des Kontexts vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="5ad66-234">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-235"><see langword="true" />, wenn das Signal und die Wartezeit erfolgreich abgeschlossen wurden, oder <see langword="false" />, wenn das Signal abgeschlossen wurde, für die Wartezeit jedoch ein Timeout aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-235"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-236">Dieser Vorgang ist nicht garantiert, um atomar zu sein.</span><span class="sxs-lookup"><span data-stu-id="5ad66-236">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="5ad66-237">Nach dem aktuellen Thread Signale `toSignal` , aber bevor er wartet auf `toWaitOn`, ein Thread, der auf einem anderen Prozessor ausgeführt wird, möglicherweise signalisieren `toWaitOn` oder darauf zu warten.</span><span class="sxs-lookup"><span data-stu-id="5ad66-237">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="5ad66-238">Der Höchstwert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-238">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5ad66-239">Wenn `timeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-239">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-240">Anhand eines tests den Zustand der `toWaitOn` und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-240">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5ad66-241">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="5ad66-241">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5ad66-242">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-242">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5ad66-243">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-243">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5ad66-244">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-244">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5ad66-245">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="5ad66-245">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="5ad66-246">Der Thread zurück in den ursprünglich nicht standardmäßige nach dem Aufruf der <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-246">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="5ad66-247">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-247">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5ad66-248">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-248">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5ad66-249">Wenn Code in der Aufrufliste eines Members Ruft die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode und gibt an, `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-249">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5ad66-250">Wenn die <xref:System.Threading.WaitHandle.SignalAndWait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-250">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5ad66-251"><paramref name="toSignal" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-251"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-252">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-252">-or-</span></span>  
  
 <span data-ttu-id="5ad66-253"><paramref name="toWaitOn" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-253"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-254">Die Methode wurde in einem Thread aufgerufen, der über ein <see cref="T:System.STAThreadAttribute" /> verfügt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-254">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="5ad66-255">Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-255">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="5ad66-256"><paramref name="toSignal" /> ist ein Semaphor, und die maximale Anzahl ist bereits erreicht.</span><span class="sxs-lookup"><span data-stu-id="5ad66-256"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-257"><paramref name="timeout" /> ergibt eine negative Anzahl von Millisekunden ungleich -1.</span><span class="sxs-lookup"><span data-stu-id="5ad66-257"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
 <span data-ttu-id="5ad66-258">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-258">-or-</span></span>  
  
 <span data-ttu-id="5ad66-259"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-259"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-260">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-260">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-261">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-261">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5ad66-262">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-262">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5ad66-263">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-263">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="5ad66-264">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</span><span class="sxs-lookup"><span data-stu-id="5ad66-264">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="5ad66-265">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-265">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-266"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls wird die Methode nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-266"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-267"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-267"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5ad66-268">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAll%2A> -Methode zurückkehrt `true` Wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-268">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5ad66-269">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="5ad66-269">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5ad66-270">Im Fall einer systemweiten Mutex kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="5ad66-270">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5ad66-271">Die Ausnahme enthält Informationen zum Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="5ad66-271">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5ad66-272">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode zurückgegeben, wenn alle Handles signalisiert werden.</span><span class="sxs-lookup"><span data-stu-id="5ad66-272">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="5ad66-273">Auf einigen Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-273">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="5ad66-274">Wenn das Array Duplikate enthält, wird der Aufruf fehlschlägt, mit einem <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-274">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ad66-275">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf denen Threads <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-275">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="5ad66-276">Das Aufrufen dieser methodenüberladung entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> methodenüberladung und-1 angeben (oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) für `millisecondsTimeout` und `true` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5ad66-276">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-277">Im folgenden Codebeispiel wird veranschaulicht, wie auf den Threadpool verwenden, um asynchron erstellungs- und Schreibberechtigungen für eine Gruppe von Dateien.</span><span class="sxs-lookup"><span data-stu-id="5ad66-277">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="5ad66-278">Jeder Schreibvorgang wird als ein Arbeitselement und Signalen in die Warteschlange, wenn er abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-278">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="5ad66-279">Der Hauptthread wartet, bis alle Elemente, um zu signalisieren und wird dann beendet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-279">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5ad66-280">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-280">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="5ad66-281">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-281">-or-</span></span>  
  
 <span data-ttu-id="5ad66-282">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-282">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-283">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-283">-or-</span></span>  
  
 <span data-ttu-id="5ad66-284"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="5ad66-284"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="5ad66-285">Fangen Sie in [.NET für Windows Store-Apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder der [portablen Klassenbibliothek](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="5ad66-285">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="5ad66-286">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-286">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-287">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-287">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="5ad66-288">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-288">-or-</span></span>  
  
 <span data-ttu-id="5ad66-289">Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-289">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="5ad66-290"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="5ad66-290"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-291">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-291">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-292">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-292">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-293">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-293">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5ad66-294">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-294">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="5ad66-295">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt (Duplikate) enthalten.</span><span class="sxs-lookup"><span data-stu-id="5ad66-295">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="5ad66-296">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="5ad66-296">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5ad66-297">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.Int32" />-Wert an.</span><span class="sxs-lookup"><span data-stu-id="5ad66-297">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-298"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-298"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-299">Wenn `millisecondsTimeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-299">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-300">Er überprüft den Status des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-300">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-301">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode zurückgegeben, wenn der Wartevorgang wird beendet, d. h., wenn alle Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-301">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="5ad66-302">Auf einigen Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-302">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="5ad66-303">Wenn Duplikate im Array vorhanden sind, wird der Aufruf fehlschlägt, mit einem <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-303">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ad66-304">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf denen Threads <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-304">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="5ad66-305">Das Aufrufen dieser methodenüberladung ist der gleiche wie das Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5ad66-305">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5ad66-306">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-306">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-307">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-307">-or-</span></span>  
  
 <span data-ttu-id="5ad66-308">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-308">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-309">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-309">-or-</span></span>  
  
 <span data-ttu-id="5ad66-310"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-310"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="5ad66-311">Fangen Sie in [.NET für Windows Store-Apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder der [portablen Klassenbibliothek](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="5ad66-311">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="5ad66-312">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-312">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-313">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-313">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="5ad66-314">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-314">-or-</span></span>  
  
 <span data-ttu-id="5ad66-315">Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-315">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-316"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-316"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-317">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-317">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-318">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-318">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-319">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-319">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5ad66-320">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-320">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="5ad66-321">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</span><span class="sxs-lookup"><span data-stu-id="5ad66-321">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="5ad66-322">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu Millisekunden für die Wartezeit angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden angibt, also eine unbeschränkte Wartezeit.</span><span class="sxs-lookup"><span data-stu-id="5ad66-322">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5ad66-323">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.TimeSpan" />-Wert an.</span><span class="sxs-lookup"><span data-stu-id="5ad66-323">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-324"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-324"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-325">Wenn `timeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-325">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-326">Er überprüft den Status des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-326">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-327">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode zurückgegeben, wenn der Wartevorgang wird beendet, d. h. alle Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-327">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="5ad66-328">Auf einigen Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-328">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="5ad66-329">Wenn das Array Duplikate enthält, schlägt der Aufruf fehl.</span><span class="sxs-lookup"><span data-stu-id="5ad66-329">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ad66-330">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf denen Threads <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-330">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="5ad66-331">Der Höchstwert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-331">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5ad66-332">Das Aufrufen dieser methodenüberladung ist der gleiche wie das Aufrufen der <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5ad66-332">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5ad66-333">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-333">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-334">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-334">-or-</span></span>  
  
 <span data-ttu-id="5ad66-335">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-335">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-336">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-336">-or-</span></span>  
  
 <span data-ttu-id="5ad66-337"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-337"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="5ad66-338">Fangen Sie in [.NET für Windows Store-Apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder der [portablen Klassenbibliothek](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) stattdessen die Basisklassenausnahme <see cref="T:System.ArgumentException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="5ad66-338">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="5ad66-339">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-339">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-340">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-340">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="5ad66-341">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-341">-or-</span></span>  
  
 <span data-ttu-id="5ad66-342">Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehr als ein Element.</span><span class="sxs-lookup"><span data-stu-id="5ad66-342">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-343"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-343"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="5ad66-344">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-344">-or-</span></span>  
  
 <span data-ttu-id="5ad66-345"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-345"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-346">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-346">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-347">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-347">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-348">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-348">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5ad66-349">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-349">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="5ad66-350">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt (Duplikate) enthalten.</span><span class="sxs-lookup"><span data-stu-id="5ad66-350">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="5ad66-351">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="5ad66-351">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="5ad66-352"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-352"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5ad66-353">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.Int32" />-Wert zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="5ad66-353">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-354"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-354"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-355">Wenn `millisecondsTimeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-355">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-356">Er überprüft den Status des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-356">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-357"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-357"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5ad66-358">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAll%2A> -Methode zurückkehrt `true` Wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-358">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5ad66-359">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="5ad66-359">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5ad66-360">Im Fall einer systemweiten Mutex kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="5ad66-360">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5ad66-361">Die Ausnahme enthält Informationen zum Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="5ad66-361">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5ad66-362">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode zurückgegeben, wenn der Wartevorgang wird beendet, d. h., wenn alle Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-362">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="5ad66-363">Auf einigen Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-363">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="5ad66-364">Wenn Duplikate im Array vorhanden sind, wird der Aufruf fehlschlägt, mit einem <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-364">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ad66-365">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf denen Threads <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-365">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5ad66-366">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="5ad66-366">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5ad66-367">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-367">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5ad66-368">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-368">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5ad66-369">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-369">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5ad66-370">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="5ad66-370">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="5ad66-371">Der Thread zurück in den ursprünglich nicht standardmäßige nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-371">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="5ad66-372">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über die <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="5ad66-372">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="5ad66-373">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-373">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5ad66-374">Wenn Code in der Aufrufliste eines Members Ruft die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode und gibt an, `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-374">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5ad66-375">Wenn die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-375">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-376">Im folgenden Codebeispiel wird veranschaulicht, wie auf den Threadpool verwenden, um asynchron erstellungs- und Schreibberechtigungen für eine Gruppe von Dateien.</span><span class="sxs-lookup"><span data-stu-id="5ad66-376">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="5ad66-377">Jeder Schreibvorgang wird als ein Arbeitselement und Signalen in die Warteschlange, wenn er abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-377">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="5ad66-378">Der Hauptthread wartet, bis alle Elemente, um zu signalisieren und wird dann beendet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-378">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5ad66-379">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-379">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-380">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-380">-or-</span></span>  
  
 <span data-ttu-id="5ad66-381">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-381">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-382">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-382">-or-</span></span>  
  
 <span data-ttu-id="5ad66-383"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="5ad66-383"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="5ad66-384">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-384">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-385">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-385">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="5ad66-386">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-386">-or-</span></span>  
  
 <span data-ttu-id="5ad66-387">Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-387">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="5ad66-388"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="5ad66-388"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-389"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-389"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-390">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-390">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-391">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-391">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-392">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-392">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5ad66-393">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-393">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="5ad66-394">Dieses Array kann nicht mehrere Verweise auf dasselbe Objekt enthalten.</span><span class="sxs-lookup"><span data-stu-id="5ad66-394">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="5ad66-395">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu Millisekunden für die Wartezeit angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden angibt, also eine unbeschränkte Wartezeit.</span><span class="sxs-lookup"><span data-stu-id="5ad66-395">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="5ad66-396"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-396"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5ad66-397">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.TimeSpan" />-Wert zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="5ad66-397">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-398"><see langword="true" />, wenn jedes Element in <paramref name="waitHandles" /> ein Signal empfangen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-398"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-399">Wenn `timeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-399">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-400">Er überprüft den Status des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-400">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-401"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-401"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5ad66-402">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAll%2A> -Methode zurückkehrt `true` Wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-402">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5ad66-403">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="5ad66-403">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5ad66-404">Im Fall einer systemweiten Mutex kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="5ad66-404">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5ad66-405">Die Ausnahme enthält Informationen zum Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="5ad66-405">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5ad66-406">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode zurückgegeben, wenn der Wartevorgang wird beendet, d. h. alle Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-406">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="5ad66-407">Auf einigen Implementierungen, wenn mehr als 64 Handles übergeben werden eine <xref:System.NotSupportedException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-407">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="5ad66-408">Wenn das Array Duplikate enthält, schlägt der Aufruf fehl.</span><span class="sxs-lookup"><span data-stu-id="5ad66-408">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ad66-409">Die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode wird nicht unterstützt, auf denen Threads <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-409">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="5ad66-410">Der Höchstwert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-410">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5ad66-411">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="5ad66-411">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5ad66-412">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-412">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5ad66-413">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-413">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5ad66-414">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-414">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5ad66-415">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="5ad66-415">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="5ad66-416">Es gibt in den ursprünglich nicht standardmäßige nach dem Aufruf von der <xref:System.Threading.WaitHandle.WaitAll%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-416">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="5ad66-417">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-417">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5ad66-418">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-418">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5ad66-419">Wenn Code in der Aufrufliste eines Members Ruft die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode und gibt an, `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-419">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5ad66-420">Wenn die <xref:System.Threading.WaitHandle.WaitAll%2A> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-420">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-421">Im folgenden Codebeispiel wird veranschaulicht, wie auf den Threadpool verwenden, um asynchron erstellungs- und Schreibberechtigungen für eine Gruppe von Dateien.</span><span class="sxs-lookup"><span data-stu-id="5ad66-421">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="5ad66-422">Jeder Schreibvorgang wird als ein Arbeitselement und Signalen in die Warteschlange, wenn er abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-422">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="5ad66-423">Der Hauptthread wartet, bis alle Elemente, um zu signalisieren und wird dann beendet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-423">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5ad66-424">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-424">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-425">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-425">-or-</span></span>  
  
 <span data-ttu-id="5ad66-426">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-426">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-427">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-427">-or-</span></span>  
  
 <span data-ttu-id="5ad66-428"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="5ad66-428"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="5ad66-429">Das <paramref name="waitHandles" />-Array enthält doppelte Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-429">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-430">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-430">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="5ad66-431">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-431">-or-</span></span>  
  
 <span data-ttu-id="5ad66-432">Das <see cref="T:System.STAThreadAttribute" />-Attribut wird für den aktuellen Thread auf die Threadprozedur angewendet, und <paramref name="waitHandles" /> enthält mehrere Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-432">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="5ad66-433"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="5ad66-433"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-434"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-434"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="5ad66-435">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-435">-or-</span></span>  
  
 <span data-ttu-id="5ad66-436"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-436"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-437">Der Wartevorgang wird beendet, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-437">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-438">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-438">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-439">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-439">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5ad66-440">Wartet, bis Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-440">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5ad66-441">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-441">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="5ad66-442">Wartet, bis Elemente im angegebenen Array ein Signal empfangen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-442">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="5ad66-443">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat.</span><span class="sxs-lookup"><span data-stu-id="5ad66-443">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-444"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-444"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5ad66-445">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode zurückkehrt `true` , wenn der Wartevorgang abgeschlossen wird, weil ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-445">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="5ad66-446">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="5ad66-446">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5ad66-447">Im Fall einer systemweiten Mutex kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="5ad66-447">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5ad66-448">Die Ausnahme enthält Informationen zum Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="5ad66-448">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5ad66-449">Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn der Wartevorgang aufgrund ein abgebrochenes Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-449">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="5ad66-450">Wenn `waitHandles` enthält einen freigegebenen Mutex mit einer niedrigeren Indexnummer als die abgebrochenes Mutex der <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode normal abgeschlossen und die Ausnahme wird nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-450">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ad66-451">In Versionen von .NET Framework-Versionen vor Version 2.0, wenn ein Thread beendet oder abgebrochen, die nicht explizit freigegeben wird eine <xref:System.Threading.Mutex>, und dass `Mutex` ist bei Index 0 (null) in einer `WaitAny` Array auf einem anderen Thread, der von zurückgegebene Index `WaitAny` ist 128 statt 0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-451">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="5ad66-452">Diese Methode gibt zurück, wenn alle Handle signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-452">This method returns when any handle is signaled.</span></span> <span data-ttu-id="5ad66-453">Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts mit dem niedrigsten Indexwert aller signalisierten Objekte signalisiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-453">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="5ad66-454">Auf einigen Implementierungen, wenn weitere herunter, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-454">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="5ad66-455">Das Aufrufen dieser methodenüberladung entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> methodenüberladung und-1 angeben (oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) für `millisecondsTimeout` und `true` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5ad66-455">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-456">Im folgenden Codebeispiel wird das Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="5ad66-456">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5ad66-457">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-457">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-458">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-458">-or-</span></span>  
  
 <span data-ttu-id="5ad66-459">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-459">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-460">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-460">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="5ad66-461"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="5ad66-461"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-462">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-462">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-463">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-463">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5ad66-464"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="5ad66-464"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-465">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-465">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5ad66-466">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-466">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="5ad66-467">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="5ad66-467">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5ad66-468">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einer 32-Bit-Ganzzahl mit Vorzeichen an.</span><span class="sxs-lookup"><span data-stu-id="5ad66-468">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="5ad66-469">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="millisecondsTimeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-469">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-470">Wenn `millisecondsTimeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-470">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-471">Er überprüft den Status des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-471">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-472">Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn der Wartevorgang aufgrund ein abgebrochenes Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-472">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="5ad66-473">Wenn `waitHandles` enthält einen freigegebenen Mutex mit einer niedrigeren Indexnummer als die abgebrochenes Mutex der <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode normal abgeschlossen und die Ausnahme wird nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-473">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="5ad66-474">Diese Methode gibt zurück, wenn der Wartevorgang wird beendet, wenn eines der Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-474">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="5ad66-475">Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts mit dem niedrigsten Indexwert aller signalisierten Objekte signalisiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-475">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="5ad66-476">Auf einigen Implementierungen, wenn weitere herunter, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-476">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="5ad66-477">Das Aufrufen dieser methodenüberladung ist der gleiche wie das Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5ad66-477">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5ad66-478">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-478">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-479">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-479">-or-</span></span>  
  
 <span data-ttu-id="5ad66-480">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-480">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-481">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-481">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-482"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-482"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-483">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-483">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-484">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-484">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5ad66-485"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-485"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-486">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-486">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5ad66-487">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-487">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="5ad66-488">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-488">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5ad66-489">Wartet auf den Empfang eines Signals für alle Elemente im angegebenen Array und gibt das Zeitintervall mit einem <see cref="T:System.TimeSpan" />-Wert an.</span><span class="sxs-lookup"><span data-stu-id="5ad66-489">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="5ad66-490">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="timeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-490">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-491">Wenn `timeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-491">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-492">Er überprüft den Status des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-492">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-493">Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn der Wartevorgang aufgrund ein abgebrochenes Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-493">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="5ad66-494">Wenn `waitHandles` enthält einen freigegebenen Mutex mit einer niedrigeren Indexnummer als die abgebrochenes Mutex der <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode normal abgeschlossen und die Ausnahme wird nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-494">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="5ad66-495">Diese Methode gibt zurück, wenn der Wartevorgang wird beendet, wenn eines der Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-495">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="5ad66-496">Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts mit dem niedrigsten Indexwert aller signalisierten Objekte signalisiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-496">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="5ad66-497">Auf einigen Implementierungen, wenn weitere herunter, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-497">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="5ad66-498">Der Höchstwert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-498">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5ad66-499">Das Aufrufen dieser methodenüberladung ist der gleiche wie das Aufrufen der <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5ad66-499">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5ad66-500">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-500">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-501">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-501">-or-</span></span>  
  
 <span data-ttu-id="5ad66-502">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-502">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-503">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-503">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-504"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-504"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="5ad66-505">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-505">-or-</span></span>  
  
 <span data-ttu-id="5ad66-506"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-506"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-507">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-507">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-508">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-508">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5ad66-509"><paramref name="waitHandles" /> ist ein Array ohne Elemente.</span><span class="sxs-lookup"><span data-stu-id="5ad66-509"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-510">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-510">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5ad66-511">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-511">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="5ad66-512">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="5ad66-512">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="5ad66-513"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-513"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5ad66-514">Wartet, bis Elemente im angegebenen Array ein Signal empfangen, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="5ad66-514">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="5ad66-515">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="millisecondsTimeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-515">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-516">Wenn `millisecondsTimeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-516">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-517">Er überprüft den Status des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-517">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-518"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-518"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5ad66-519">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode zurückkehrt `true` , wenn der Wartevorgang abgeschlossen wird, weil ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-519">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="5ad66-520">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="5ad66-520">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5ad66-521">Im Fall einer systemweiten Mutex kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="5ad66-521">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5ad66-522">Die Ausnahme enthält Informationen zum Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="5ad66-522">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5ad66-523">Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn der Wartevorgang aufgrund ein abgebrochenes Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-523">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="5ad66-524">Wenn `waitHandles` enthält einen freigegebenen Mutex mit einer niedrigeren Indexnummer als die abgebrochenes Mutex der <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode normal abgeschlossen und die Ausnahme wird nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-524">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ad66-525">In Versionen von .NET Framework-Versionen vor Version 2.0, wenn ein Thread beendet oder abgebrochen, die nicht explizit freigegeben wird eine <xref:System.Threading.Mutex>, und dass `Mutex` ist bei Index 0 (null) in einer `WaitAny` Array auf einem anderen Thread, der von zurückgegebene Index `WaitAny` ist 128 statt 0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-525">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="5ad66-526">Diese Methode gibt zurück, wenn der Wartevorgang wird beendet, wenn eines der Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-526">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="5ad66-527">Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts mit dem niedrigsten Indexwert aller signalisierten Objekte signalisiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-527">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="5ad66-528">Auf einigen Implementierungen, wenn weitere herunter, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-528">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5ad66-529">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="5ad66-529">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5ad66-530">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-530">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5ad66-531">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-531">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5ad66-532">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-532">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5ad66-533">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="5ad66-533">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="5ad66-534">Der Thread zurück in den ursprünglich nicht standardmäßige nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-534">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="5ad66-535">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-535">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5ad66-536">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-536">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5ad66-537">Wenn Code in der Aufrufliste eines Members Ruft die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode und gibt an, `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-537">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5ad66-538">Wenn die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-538">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-539">Im folgenden Codebeispiel wird veranschaulicht, wie auf den Threadpool zu verwenden, um gleichzeitig für eine Datei auf mehreren Datenträgern zu suchen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-539">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="5ad66-540">Aus Platzgründen wird nur das Stammverzeichnis für die einzelnen Datenträger durchsucht.</span><span class="sxs-lookup"><span data-stu-id="5ad66-540">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5ad66-541">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-541">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-542">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-542">-or-</span></span>  
  
 <span data-ttu-id="5ad66-543">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-543">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-544">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-544">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="5ad66-545"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="5ad66-545"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-546"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-546"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-547">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-547">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-548">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-548">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5ad66-549"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="5ad66-549"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-550">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-550">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5ad66-551">Ein <see langword="WaitHandle" />-Array mit den Objekten, auf die die aktuelle Instanz wartet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-551">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="5ad66-552">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-552">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="5ad66-553"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-553"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5ad66-554">Wartet, bis alle Elemente im angegebenen Array ein Signal empfangen, wobei ein <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet wird, und gibt an, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="5ad66-554">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="5ad66-555">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat, oder <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, wenn keines der Objekte den Wartevorgang erfüllt hat und ein Zeitintervall äquivalent zu <paramref name="timeout" /> vergangen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-555">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-556">Wenn `timeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-556">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-557">Er überprüft den Status des Wait-Handles und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-557">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-558"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-558"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5ad66-559">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode zurückkehrt `true` , wenn der Wartevorgang abgeschlossen wird, weil ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-559">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="5ad66-560">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="5ad66-560">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5ad66-561">Im Fall einer systemweiten Mutex kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="5ad66-561">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5ad66-562">Die Ausnahme enthält Informationen zum Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="5ad66-562">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5ad66-563">Die <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode löst eine <xref:System.Threading.AbandonedMutexException> nur wenn der Wartevorgang aufgrund ein abgebrochenes Mutex abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-563">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="5ad66-564">Wenn `waitHandles` enthält einen freigegebenen Mutex mit einer niedrigeren Indexnummer als die abgebrochenes Mutex der <xref:System.Threading.WaitHandle.WaitAny%2A> -Methode normal abgeschlossen und die Ausnahme wird nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-564">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ad66-565">In Versionen von .NET Framework-Versionen vor Version 2.0, wenn ein Thread beendet oder abgebrochen, die nicht explizit freigegeben wird eine <xref:System.Threading.Mutex>, und dass `Mutex` ist bei Index 0 (null) in einer `WaitAny` Array auf einem anderen Thread, der von zurückgegebene Index `WaitAny` ist 128 statt 0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-565">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="5ad66-566">Diese Methode gibt zurück, wenn der Wartevorgang wird beendet, wenn eines der Handles signalisiert werden oder ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-566">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="5ad66-567">Wenn mehr als ein Objekt während des Aufrufs signalisiert wird, ist der Rückgabewert der Arrayindex des Objekts mit dem niedrigsten Indexwert aller signalisierten Objekte signalisiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-567">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="5ad66-568">Auf einigen Implementierungen, wenn weitere herunter, die 64-Handles übergeben werden, eine <xref:System.NotSupportedException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-568">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="5ad66-569">Der Höchstwert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-569">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5ad66-570">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="5ad66-570">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5ad66-571">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-571">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5ad66-572">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-572">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5ad66-573">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-573">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5ad66-574">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="5ad66-574">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="5ad66-575">Der Thread zurück in den ursprünglich nicht standardmäßige nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitAny%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-575">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="5ad66-576">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-576">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5ad66-577">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-577">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5ad66-578">Wenn Code in der Aufrufliste eines Members Ruft die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode und gibt an, `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-578">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5ad66-579">Wenn die <xref:System.Threading.WaitHandle.WaitAny%2A> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-579">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-580">Im folgenden Codebeispiel wird veranschaulicht, wie auf den Threadpool zu verwenden, um gleichzeitig für eine Datei auf mehreren Datenträgern zu suchen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-580">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="5ad66-581">Aus Platzgründen wird nur das Stammverzeichnis für die einzelnen Datenträger durchsucht.</span><span class="sxs-lookup"><span data-stu-id="5ad66-581">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5ad66-582">Der <paramref name="waitHandles" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-582">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="5ad66-583">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-583">-or-</span></span>  
  
 <span data-ttu-id="5ad66-584">Mindestens ein Objekt im <paramref name="waitHandles" />-Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-584">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5ad66-585">Die Anzahl von Objekten in <paramref name="waitHandles" /> ist größer, als das System erlaubt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-585">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="5ad66-586"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 1.0 oder 1.1.</span><span class="sxs-lookup"><span data-stu-id="5ad66-586"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-587"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-587"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="5ad66-588">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-588">-or-</span></span>  
  
 <span data-ttu-id="5ad66-589"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-589"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-590">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-590">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-591">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-591">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5ad66-592"><paramref name="waitHandles" /> ist ein Array ohne Elemente, und die .NET Framework-Version ist 2.0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="5ad66-592"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-593">Das <paramref name="waitHandles" />-Array enthält einen transparenten Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-593">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5ad66-594">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-594">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5ad66-595">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-595">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-596"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-596"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="5ad66-597">Wenn die aktuelle Instanz kein Signal erhält, wird <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="5ad66-597">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-598"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-598"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5ad66-599">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitOne%2A> -Methode zurückkehrt `true` Wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-599">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5ad66-600">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="5ad66-600">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5ad66-601">Im Fall einer systemweiten Mutex kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="5ad66-601">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5ad66-602">Die Ausnahme enthält Informationen zum Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="5ad66-602">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5ad66-603">Der Aufrufer diese Methode blockiert, unbegrenzt, bis die aktuelle Instanz ein Signal empfängt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-603">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="5ad66-604">Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> aus einem anderen Thread ein Signal empfängt, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-604">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="5ad66-605">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="5ad66-605">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="5ad66-606">Das Aufrufen dieser methodenüberladung entspricht dem Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> methodenüberladung und Angeben von-1 oder <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für den ersten Parameter und `false` für den zweiten Parameter.</span><span class="sxs-lookup"><span data-stu-id="5ad66-606">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="5ad66-607">Überschreiben Sie diese Methode zum Anpassen des Verhaltens von abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-607">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-608">Im folgenden Codebeispiel wird gezeigt, wie ein Wait-Handle, mit der verhindert, dass eines Prozess beendet wird, während er darauf wartet, dass einem Hintergrundthread ausführen abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-608">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5ad66-609">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-609">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-610">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-610">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-611">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-611">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-612">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-612">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="5ad66-613">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="5ad66-613">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5ad66-614">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls in Millisekunden verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-614">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-615"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-615"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-616">Wenn `millisecondsTimeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-616">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-617">Er überprüft den Status des Wait-Handle und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-617">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-618">Der Aufrufer diese Methode blockiert, bis die aktuelle Instanz ein Signal oder eines Timeouts empfängt auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-618">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="5ad66-619">Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> aus einem anderen Thread ein Signal empfängt, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-619">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="5ad66-620">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="5ad66-620">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="5ad66-621">Überschreiben Sie diese Methode zum Anpassen des Verhaltens von abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-621">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="5ad66-622">Das Aufrufen dieser methodenüberladung ist der gleiche wie das Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5ad66-622">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-623">Im folgenden Codebeispiel wird gezeigt, wie ein Wait-Handle, mit der verhindert, dass eines Prozess beendet wird, während er darauf wartet, dass einem Hintergrundthread ausführen abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-623">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5ad66-624">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-624">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-625"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-625"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-626">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-627">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-628">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="5ad66-629">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-629">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5ad66-630">Blockiert den aktuellen Thread, bis die aktuelle Instanz ein Signal empfängt, wobei eine <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-630">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-631"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-632">Wenn `timeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-632">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-633">Er überprüft den Status des Wait-Handle und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-634">Der Aufrufer diese Methode blockiert, bis die aktuelle Instanz ein Signal oder eines Timeouts empfängt auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="5ad66-635">Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> aus einem anderen Thread ein Signal empfängt, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="5ad66-636">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="5ad66-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="5ad66-637">Überschreiben Sie diese Methode zum Anpassen des Verhaltens von abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="5ad66-638">Der Höchstwert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-638">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5ad66-639">Das Aufrufen dieser methodenüberladung ist der gleiche wie das Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> Überladung und Angeben von `false` für `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5ad66-639">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5ad66-640">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-641"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-641"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="5ad66-642">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-642">-or-</span></span>  
  
 <span data-ttu-id="5ad66-643"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-643"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-644">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-644">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-645">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-645">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-646">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-646">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="5ad66-647">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="5ad66-647">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="5ad66-648"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-648"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5ad66-649">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.WaitHandle" /> ein Signal empfängt, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Zeitintervalls verwendet und angegeben wird, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="5ad66-649">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-650"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-650"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-651">Wenn `millisecondsTimeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-651">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-652">Er überprüft den Status des Wait-Handle und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-652">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-653"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-653"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5ad66-654">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitOne%2A> -Methode zurückkehrt `true` Wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-654">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5ad66-655">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="5ad66-655">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5ad66-656">Im Fall einer systemweiten Mutex kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="5ad66-656">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5ad66-657">Die Ausnahme enthält Informationen zum Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="5ad66-657">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5ad66-658">Der Aufrufer diese Methode blockiert, bis die aktuelle Instanz ein Signal oder eines Timeouts empfängt auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-658">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="5ad66-659">Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> aus einem anderen Thread ein Signal empfängt, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-659">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="5ad66-660">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="5ad66-660">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="5ad66-661">Überschreiben Sie diese Methode zum Anpassen des Verhaltens von abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-661">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5ad66-662">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="5ad66-662">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5ad66-663">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-663">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5ad66-664">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-664">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5ad66-665">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-665">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5ad66-666">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="5ad66-666">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="5ad66-667">Der Thread zurück in den ursprünglich nicht standardmäßige nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-667">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="5ad66-668">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-668">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5ad66-669">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-669">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5ad66-670">Wenn Code in der Aufrufliste eines Members Ruft die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode und gibt an, `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-670">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5ad66-671">Wenn die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-671">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-672">Das folgende Beispiel zeigt wie die <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> methodenüberladung verhält sich, wenn sie innerhalb einer Synchronisierungsdomäne aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-672">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="5ad66-673">Zunächst wartet ein Thread mit `exitContext` festgelegt `false` und blockiert, bis das Zeitlimit abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-673">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="5ad66-674">Ein zweiter Thread ausgeführt wird, nachdem der erste Thread beendet und wartet mit `exitContext` festgelegt `true`.</span><span class="sxs-lookup"><span data-stu-id="5ad66-674">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="5ad66-675">Der Aufruf von signalisieren das Wait-Handle für diesen zweiten Thread wird nicht blockiert, und der Thread abgeschlossen ist, bevor das Wartetimeout.</span><span class="sxs-lookup"><span data-stu-id="5ad66-675">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5ad66-676">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-676">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-677"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-677"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-678">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-678">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-679">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-679">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-680">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-680">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="5ad66-681">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-681">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="5ad66-682"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext vor dem Wartevorgang (sofern in einem synchronisierten Kontext) zu verlassen und diese anschließend erneut abzurufen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-682"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5ad66-683">Blockiert den aktuellen Thread, bis die aktuelle Instanz ein Signal empfängt, wobei eine <see cref="T:System.TimeSpan" /> zum Angeben des Zeitintervalls verwendet und angegeben wird, ob die Synchronisierungsdomäne vor dem Wartevorgang verlassen werden soll.</span><span class="sxs-lookup"><span data-stu-id="5ad66-683">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="5ad66-684"><see langword="true" />, wenn die aktuelle Instanz ein Signal empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-684"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-685">Wenn `timeout` NULL ist, wird die Methode wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="5ad66-685">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5ad66-686">Er überprüft den Status des Wait-Handle und kehrt sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="5ad66-686">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="5ad66-687"><xref:System.Threading.AbandonedMutexException> ist neu in .NET Framework, Version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5ad66-687"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5ad66-688">In früheren Versionen der <xref:System.Threading.WaitHandle.WaitOne%2A> -Methode zurückkehrt `true` Wenn ein Mutex abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-688">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5ad66-689">Ein abgebrochenes Mutex weist häufig einen schwerwiegenden Fehler im Code.</span><span class="sxs-lookup"><span data-stu-id="5ad66-689">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5ad66-690">Im Fall einer systemweiten Mutex kann dies darauf hinweisen, dass eine Anwendung plötzlich beendet wurde (z. B. mithilfe von Windows Task-Manager).</span><span class="sxs-lookup"><span data-stu-id="5ad66-690">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5ad66-691">Die Ausnahme enthält Informationen zum Debuggen nützlich.</span><span class="sxs-lookup"><span data-stu-id="5ad66-691">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5ad66-692">Der Aufrufer diese Methode blockiert, bis die aktuelle Instanz ein Signal oder eines Timeouts empfängt auftritt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-692">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="5ad66-693">Mit dieser Methode können Sie blockieren, bis eine <xref:System.Threading.WaitHandle> aus einem anderen Thread ein Signal empfängt, wie z. B. wird generiert, wenn ein asynchroner Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5ad66-693">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="5ad66-694">Weitere Informationen finden Sie unter der <xref:System.IAsyncResult>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="5ad66-694">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="5ad66-695">Überschreiben Sie diese Methode zum Anpassen des Verhaltens von abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-695">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="5ad66-696">Der Höchstwert für `timeout` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-696">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5ad66-697">Hinweise zum Beenden des Kontexts</span><span class="sxs-lookup"><span data-stu-id="5ad66-697">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5ad66-698">Die `exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-698">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5ad66-699">Dies kann geschehen, wenn der Thread in einem Aufruf mit einer Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-699">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5ad66-700">Selbst wenn derzeit eine Methode einer Klasse ausgeführt werden, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, Sie kann in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> befindet sich auf dem Stapel in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-700">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5ad66-701">Beim Code in einem nicht standardmäßigen Kontext und ausgeführt wird die Angabe `true` für `exitContext` bewirkt, dass der Thread den nicht standardmäßigen verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="5ad66-701">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="5ad66-702">Der Thread zurück in den ursprünglich nicht standardmäßige nach dem Aufruf der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-702">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="5ad66-703">Dies kann nützlich sein, wenn die kontextgebundene-Klasse verfügt über <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ad66-703">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5ad66-704">In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist der gesamte Text der Code für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="5ad66-704">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5ad66-705">Wenn Code in der Aufrufliste eines Members Ruft die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode und gibt an, `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne ermöglicht einen Thread, der bei einem Aufruf auf einen Member des Objekts zu fortfahren blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-705">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5ad66-706">Wenn die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode zurückgegeben wird, der Thread, der der Aufruf muss warten, um die Synchronisierungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-706">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-707">Im folgenden Codebeispiel wird gezeigt, wie ein Wait-Handle, mit der verhindert, dass eines Prozess beendet wird, während er darauf wartet, dass einem Hintergrundthread ausführen abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="5ad66-707">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5ad66-708">Die aktuelle Instanz wurde bereits verworfen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-708">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5ad66-709"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="5ad66-709"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="5ad66-710">- oder - </span><span class="sxs-lookup"><span data-stu-id="5ad66-710">-or-</span></span>  
  
 <span data-ttu-id="5ad66-711"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5ad66-711"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5ad66-712">Der Wartevorgang wird abgeschlossen, weil ein Thread beendet wurde, ohne ein Mutex freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5ad66-712">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5ad66-713">Diese Ausnahme wird unter Windows 98 oder Windows Millennium Edition nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5ad66-713">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5ad66-714">Die aktuelle Instanz ist ein transparenter Proxy für ein <see cref="T:System.Threading.WaitHandle" /> in einer anderen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="5ad66-714">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="5ad66-715">Gibt an, dass ein Timeout für einen <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />-Vorgang überschritten wurde, bevor ein Signal an eines der WaitHandles gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="5ad66-715">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="5ad66-716">Dieses Feld ist konstant.</span><span class="sxs-lookup"><span data-stu-id="5ad66-716">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ad66-717">Dieses Feld ist eine der möglichen Rückgabewerte von `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="5ad66-717">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ad66-718">Im folgenden Codebeispiel wird veranschaulicht, wie auf den Threadpool zu verwenden, um gleichzeitig für eine Datei auf mehreren Datenträgern zu suchen.</span><span class="sxs-lookup"><span data-stu-id="5ad66-718">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="5ad66-719">Aus Platzgründen wird nur das Stammverzeichnis für die einzelnen Datenträger durchsucht.</span><span class="sxs-lookup"><span data-stu-id="5ad66-719">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>