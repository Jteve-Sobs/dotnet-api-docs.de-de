<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7585981f1d2b4a6de6565de69bc69647b8ab76d1" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86848998" /></Metadata><TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock&#xA;Inherits CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type ReaderWriterLock = class&#xA;    inherit CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public sealed class ReaderWriterLock" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type ReaderWriterLock = class" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiert eine Sperre, die einen Writer und mehrere Reader unterstützt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] verfügt über zwei Lese-/Schreibsperren, <xref:System.Threading.ReaderWriterLockSlim> und <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> wird für alle Neuentwicklungen empfohlen. <xref:System.Threading.ReaderWriterLockSlim> ähnelt <xref:System.Threading.ReaderWriterLock>, verfügt aber über vereinfachte Regeln für Rekursion sowie für Upgrade und Downgrade des Sperrstatus. <xref:System.Threading.ReaderWriterLockSlim> vermeidet viele potenzielle Deadlocks. Darüber hinaus ist die Leistung von <xref:System.Threading.ReaderWriterLockSlim> wesentlich besser als die von <xref:System.Threading.ReaderWriterLock>.  
  
 <xref:System.Threading.ReaderWriterLock> wird zum Synchronisieren des Zugriffs auf eine Ressource verwendet. Es ermöglicht zu einem beliebigen Zeitpunkt entweder gleichzeitigen Lesezugriff auf mehrere Threads oder Schreibzugriff für einen einzelnen Thread. In einer Situation, in der eine Ressource nur selten geändert wird, bietet eine einen `ReaderWriterLock` besseren Durchsatz als eine einfache einmalige Sperre, z <xref:System.Threading.Monitor> . b..  
  
 `ReaderWriterLock` funktioniert am besten, wenn die meisten Zugriffe Lesevorgänge sind, während Schreibvorgänge seltener und von kurzer Dauer ausgeführt werden. Mehrere Leser wechseln mit einzelnen Writern, sodass weder Leser noch Writer für lange Zeiträume blockiert werden.  
  
> [!NOTE]
>  Wenn Sie Lese-und Schreib Sperren für lange Zeiträume halten, werden andere Threads nicht mehr verwendet. Um eine optimale Leistung zu erzielen, sollten Sie eine Umstrukturierung ihrer Anwendung in Erwägung gezogen haben  
  
 Ein Thread kann eine Lesesperre oder eine Writer-Sperre enthalten, jedoch nicht beides gleichzeitig. Anstatt eine Lesesperre freizugeben, um die Writer-Sperre zu erhalten, können Sie <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> und verwenden <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> .  
  
 Rekursive Sperr Anforderungen erhöhen die Sperrenanzahl für eine Sperre.  
  
 Reader und Writer werden separat in die Warteschlange eingereiht. Wenn ein Thread die Schreibsperre freigibt, erhalten alle Threads, die zu diesem Zeitpunkt in der Leser Warteschlange warten, Lese sperren. Wenn alle diese Leser Sperren freigegeben wurden, erhält der nächste Thread, der in der Writer-Warteschlange wartet, ggf. die Schreibsperre, usw. Anders ausgedrückt, `ReaderWriterLock` wechselt zwischen einer Auflistung von Lesern und einem Writer.  
  
 Während ein Thread in der Writer-Warteschlange darauf wartet, dass aktive Lese Sperren freigegeben werden, werden Threads, die neue Leser Sperren anfordern, in der Leser Warteschlange gesammelt. Ihre Anforderungen werden nicht erteilt, auch wenn Sie gleichzeitigen Zugriff auf vorhandene Reader-Lock-Inhaber haben können. Dies trägt dazu bei, Writer vor unbegrenzter Blockierung hin durch Leser zu schützen.  
  
 Die meisten Methoden zum Abrufen von Sperren für eine `ReaderWriterLock` Accept Timeout-Werte. Verwenden Sie Timeouts, um Deadlocks in der Anwendung zu vermeiden. Ein Thread kann z. b. die Schreibsperre für eine Ressource abrufen und dann eine Lesesperre für eine zweite Ressource anfordern. in der Zwischenzeit kann ein anderer Thread die Schreibsperre für die zweite Ressource abrufen und eine Lesesperre für die erste anfordern. Wenn Timeouts nicht verwendet werden, Deadlock der Threads.  
  
 Wenn das Timeout Intervall abläuft und die Sperranforderung nicht erteilt wurde, gibt die Methode die Steuerung an den aufrufenden Thread zurück, indem ein ausgelöst wird <xref:System.ApplicationException> . Ein Thread kann diese Ausnahme abfangen und ermitteln, welche Aktion als nächstes ausgeführt werden soll.  
  
 Timeouts werden in Millisekunden angegeben. Wenn Sie einen <xref:System.TimeSpan?displayProperty=nameWithType> zum Angeben des Timeouts verwenden, ist der verwendete Wert die Gesamtzahl ganzer Millisekunden, die durch dargestellt wird <xref:System.TimeSpan> . In der folgenden Tabelle werden die gültigen Timeout Werte in Millisekunden angezeigt.  
  
|Wert|BESCHREIBUNG|  
|-----------|-----------------|  
|-1|Der Thread wartet, bis die Sperre abgerufen wird, unabhängig davon, wie lange es dauert. Bei Methoden, die ganzzahlige Timeouts angeben, <xref:System.Threading.Timeout.Infinite> kann die Konstante verwendet werden.|  
|0|Der Thread wartet nicht darauf, die Sperre abzurufen. Wenn die Sperre nicht sofort abgerufen werden kann, gibt die Methode zurück.|  
|>0|Die Anzahl der Millisekunden, die gewartet werden soll.|  
  
 Mit der Ausnahme-1 sind keine negativen Timeout Werte zulässig. Wenn Sie eine negative ganze Zahl ungleich-1 angeben, wird stattdessen ein Timeout Wert von 0 (null) verwendet. (Das heißt, die Methode gibt zurück, ohne zu warten, wenn die Sperre nicht sofort abgerufen werden kann.) Wenn Sie eine angeben <xref:System.TimeSpan> , die eine negative Anzahl von Millisekunden darstellt, die nicht-1 ist, <xref:System.ArgumentOutOfRangeException> wird ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie <xref:System.Threading.ReaderWriterLock> Sie eine freigegebene Ressource (einen ganzzahligen Wert mit dem Namen) verwenden, der `resource` gleichzeitig gelesen und exklusiv von mehreren Threads geschrieben wird. Beachten Sie, dass <xref:System.Threading.ReaderWriterLock> auf Klassenebene deklariert wird, sodass Sie für alle Threads sichtbar ist.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
    <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.ReaderWriterLock" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie eine neue Instanz der <xref:System.Threading.ReaderWriterLock>-Klasse erstellt wird.  
  
 Dieser Code ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Threading.ReaderWriterLock> .  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireReaderLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erhält eine Lesesperre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : int -&gt; unit" Usage="readerWriterLock.AcquireReaderLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Das Timeout in Millisekunden.</param>
        <summary>Erhält eine Lesesperre unter Verwendung eines <see cref="T:System.Int32" />-Werts für das Timeout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blockiert, wenn ein anderer Thread die Schreibsperre aufweist oder wenn mindestens ein Thread auf die Schreibsperre wartet.  
  
> [!NOTE]
>  Wenn der aktuelle Thread bereits über die Schreibsperre verfügt, wird keine Lesesperre abgerufen. Stattdessen wird die Sperrenanzahl für die Schreibsperre inkrementiert. Dadurch wird verhindert, dass ein Thread seine eigene Schreibsperre blockiert. Das Ergebnis ist identisch mit dem Aufruf <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> von, und <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> bei der Freigabe der Schreibsperre ist ein zusätzlicher Aufruf von erforderlich.  
  
 `AcquireReaderLock` unterstützt rekursive Reader-Lock-Anforderungen. Das heißt, ein Thread kann "acquirrereaderlock" mehrmals aufrufen, wodurch die Sperrenanzahl jedes Mal erhöht wird. Sie müssen <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> für jedes Mal, wenn Sie aufzurufen, einmal aufgerufen werden `AcquireReaderLock` . Alternativ können Sie auch aufzurufen, <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> um die Sperrenanzahl sofort auf NULL zu verringern.  
  
 Rekursive Sperr Anforderungen werden immer sofort erteilt, ohne dass der anfordernde Thread in der Leser Warteschlange platziert wird. Verwenden Sie rekursive Sperren mit Vorsicht, um zu verhindern, dass Writer-Lock-Anforderungen lange Zeiträume blockiert werden.  
  
 Gültige Timeout Werte finden Sie unter <xref:System.Threading.ReaderWriterLock> .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine Lesesperre abgerufen und freigegeben wird und wie die Ausnahme behandelt wird, die ausgelöst wird, wenn für eine Anforderung ein Timeout auftritt.  
  
 Dieser Code ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Threading.ReaderWriterLock> .  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><paramref name="millisecondsTimeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireReaderLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see langword="TimeSpan" />, die den Timeoutzeitraum angibt.</param>
        <summary>Erhält eine Lesesperre unter Verwendung eines <see cref="T:System.TimeSpan" />-Werts für das Timeout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blockiert, wenn ein anderer Thread die Schreibsperre aufweist oder wenn mindestens ein Thread auf die Schreibsperre wartet.  
  
> [!NOTE]
>  Wenn der aktuelle Thread bereits über die Schreibsperre verfügt, wird keine Lesesperre abgerufen. Stattdessen wird die Sperrenanzahl für die Schreibsperre inkrementiert. Dadurch wird verhindert, dass ein Thread seine eigene Schreibsperre blockiert. Das Ergebnis ist identisch mit dem Aufruf <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> von, und <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> bei der Freigabe der Schreibsperre ist ein zusätzlicher Aufruf von erforderlich.  
  
 `AcquireReaderLock` unterstützt rekursive Reader-Lock-Anforderungen. Das heißt, ein Thread kann "acquirrereaderlock" mehrmals aufrufen, wodurch die Sperrenanzahl jedes Mal erhöht wird. Sie müssen <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> für jedes Mal, wenn Sie aufzurufen, einmal aufgerufen werden `AcquireReaderLock` . Alternativ können Sie auch aufzurufen, <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> um die Sperrenanzahl sofort auf NULL zu verringern.  
  
 Rekursive Sperr Anforderungen werden immer sofort erteilt, ohne dass der anfordernde Thread in der Leser Warteschlange platziert wird. Verwenden Sie rekursive Sperren mit Vorsicht, um zu verhindern, dass Writer-Lock-Anforderungen lange Zeiträume blockiert werden.  
  
 Gültige Timeout Werte finden Sie unter <xref:System.Threading.ReaderWriterLock> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><paramref name="timeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> gibt einen negativen Wert ungleich -1 Millisekunden an.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erhält die Schreibsperre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : int -&gt; unit" Usage="readerWriterLock.AcquireWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Das Timeout in Millisekunden.</param>
        <summary>Erhält die Schreibsperre unter Verwendung eines <see cref="T:System.Int32" />-Werts für das Timeout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, wenn ein anderer Thread über eine Lesesperre oder eine Schreibsperre verfügt. Eine Beschreibung der Art und Weise, wie die Writer-Sperre mit mehreren gleichzeitigen readersperren wechselt, finden Sie unter der- <xref:System.Threading.ReaderWriterLock> Klasse.  
  
 Ein Thread, der bereits über eine Lesesperre verfügt, kann die Schreibsperre auf zwei Arten abrufen: durch Freigeben der Lesesperre vor dem Aufrufen von <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> oder durch Aufrufen von <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> .  
  
> [!CAUTION]
>  Wenn ein Thread aufruft `AcquireWriterLock` , während er immer noch über eine Lesesperre verfügt, blockiert er seine eigene Readersperre. Wenn ein unendliches Timeout angegeben ist, wird der Thread in einen Deadlock geraten. Um solche Deadlocks zu vermeiden, verwenden <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> Sie, um zu bestimmen, ob der aktuelle Thread bereits über eine Lesesperre verfügt.  
  
 `AcquireWriterLock` unterstützt rekursive Writer-Lock-Anforderungen. Das heißt, ein Thread kann mehrmals aufgerufen `AcquireWriterLock` werden, wodurch die Anzahl der Sperren jedes Mal erhöht wird. Sie müssen <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> für jedes Mal, wenn Sie aufzurufen, einmal aufgerufen werden `AcquireWriterLock` . Alternativ können Sie auch aufzurufen, <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> um die Sperrenanzahl sofort auf NULL zu verringern.  
  
 Rekursive Sperr Anforderungen werden immer sofort erteilt, ohne dass der anfordernde Thread in der Writer-Warteschlange platziert wird.  
  
 Gültige Timeout Werte finden Sie unter <xref:System.Threading.ReaderWriterLock> .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine Writer-Sperre abgerufen und freigegeben wird und wie die Ausnahme behandelt wird, die ausgelöst wird, wenn für eine Anforderung ein Timeout auftritt.  
  
 Dieser Code ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Threading.ReaderWriterLock> .  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><paramref name="timeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Die <see langword="TimeSpan" />, die den Timeoutzeitraum angibt.</param>
        <summary>Erhält die Schreibsperre unter Verwendung eines <see cref="T:System.TimeSpan" />-Werts für das Timeout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, wenn ein anderer Thread über eine Lesesperre oder eine Schreibsperre verfügt. Eine Beschreibung der Art und Weise, wie die Writer-Sperre mit mehreren gleichzeitigen readersperren wechselt, finden Sie unter der- <xref:System.Threading.ReaderWriterLock> Klasse.  
  
 Ein Thread, der bereits über eine Lesesperre verfügt, kann die Schreibsperre auf zwei Arten abrufen: durch Freigeben der Lesesperre vor dem Aufrufen von <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> oder durch Aufrufen von <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> .  
  
> [!CAUTION]
>  Wenn ein Thread aufruft `AcquireWriterLock` , während er immer noch über eine Lesesperre verfügt, blockiert er seine eigene Readersperre. Wenn ein unendliches Timeout angegeben ist, wird der Thread in einen Deadlock geraten. Um solche Deadlocks zu vermeiden, verwenden <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> Sie, um zu bestimmen, ob der aktuelle Thread bereits über eine Lesesperre verfügt.  
  
 `AcquireWriterLock` unterstützt rekursive Writer-Lock-Anforderungen. Das heißt, ein Thread kann mehrmals aufgerufen `AcquireWriterLock` werden, wodurch die Anzahl der Sperren jedes Mal erhöht wird. Sie müssen <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> für jedes Mal, wenn Sie aufzurufen, einmal aufgerufen werden `AcquireWriterLock` . Alternativ können Sie auch aufzurufen, <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> um die Sperrenanzahl sofort auf NULL zu verringern.  
  
 Rekursive Sperr Anforderungen werden immer sofort erteilt, ohne dass der anfordernde Thread in der Writer-Warteschlange platziert wird.  
  
 Gültige Timeout Werte finden Sie unter <xref:System.Threading.ReaderWriterLock> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><paramref name="timeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> gibt einen negativen Wert ungleich -1 Millisekunden an.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AnyWritersSince (seqNum As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AnyWritersSince(int seqNum);" />
      <MemberSignature Language="F#" Value="member this.AnyWritersSince : int -&gt; bool" Usage="readerWriterLock.AnyWritersSince seqNum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum">Die Sequenznummer.</param>
        <summary>Gibt an, ob einem Thread die Schreibsperre erteilt wurde, seitdem die Sequenznummer erhalten wurde.</summary>
        <returns><see langword="true" />, wenn einem Thread die Schreibsperre erteilt wurde, seitdem die Sequenznummer erhalten wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> und verwenden `AnyWritersSince` , um die Anwendungsleistung zu verbessern. Ein Thread kann z. b. die Informationen zwischenspeichern, die er beim Aufrechterhalten einer Lesesperre erhält. Nach dem Freigeben und späteren erneuten Abrufen der Sperre kann der Thread verwenden, `AnyWritersSince` um zu bestimmen, ob andere Threads in der Zwischenzeit in die Ressource geschrieben haben. andernfalls können die zwischengespeicherten Informationen verwendet werden. Diese Technik ist hilfreich, wenn das Lesen der durch die Sperre geschützten Informationen teuer ist. beispielsweise das Ausführen einer Datenbankabfrage.  
  
 Der Aufrufer muss eine Lesesperre oder eine Writer-Sperre aufweisen, damit die Sequenznummer nützlich ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> -Methode und die-Eigenschaft verwendet werden <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> , um zu bestimmen, ob ein anderer Thread die Schreibsperre für die geschützte Ressource abgerufen hat, da der aktuelle Thread zuletzt die Schreibsperre aufrechterhalten hat  
  
 Dieser Code ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Threading.ReaderWriterLock> .  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DowngradeFromWriterLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DowngradeFromWriterLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.DowngradeFromWriterLock : LockCookie -&gt; unit" Usage="readerWriterLock.DowngradeFromWriterLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">Ein von <see cref="T:System.Threading.LockCookie" /> zurückgegebenes <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
        <summary>Stellt den Sperrstatus des Threads mit dem Status vor dem Aufruf von <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> wieder her.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Gibt die Schreibsperre unabhängig von der rekursiven Sperr Anzahl frei und stellt die Lesesperre wieder her, die vom Thread vor dem Upgrade auf die Schreibsperre gehalten wurde. Die Sperrenanzahl für die Lesesperre wird wieder hergestellt.  
  
> [!NOTE]
>  `DowngradeFromWriterLock` akzeptiert einen, <xref:System.Threading.LockCookie> der durch Aufrufen von abgerufen wird <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> . Verwenden Sie keine `LockCookie` von zurückgegebene <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> .  
  
 Ein Thread wird beim Downgrade von der Schreibsperre nicht blockiert, auch wenn andere Threads auf die Schreibsperre warten, weil alle Lese-/Sperranforderungen bei der Freigabe der Writer-Sperre erteilt werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie eine Lesesperre anfordern, die Lesesperre auf eine Writer-Sperre aktualisieren und erneut auf eine Lesesperre herabstufen.  
  
 Dieser Code ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Threading.ReaderWriterLock> .  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Der Thread verfügt nicht über die Schreibsperre.</exception>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="lockCookie" /> ist ein NULL-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReaderWriterLock ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="readerWriterLock.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt das Freigeben von Ressourcen und das Ausführen anderer Garbage Collector-Vorgänge sicher, wenn der Garbage Collector das <see cref="T:System.Threading.ReaderWriterLock" />-Objekt verarbeitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Garbage Collector der aufruft <xref:System.Threading.ReaderWriterLock.Finalize%2A> , wenn das aktuelle-Objekt für die Fertigstellung <xref:System.Threading.ReaderWriterLock> bereit ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReaderLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReaderLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReaderLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Thread eine Lesesperre besitzt.</summary>
        <value><see langword="true" />, wenn der aktuelle Thread eine Lesesperre aufweist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie verwendet wird, `IsReaderLockHeld` um Deadlocks zu vermeiden.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriterLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriterLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriterLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Thread die Schreibsperre enthält.</summary>
        <value><see langword="true" />, wenn der aktuelle Thread die Schreibsperre enthält, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dass beim Versuch, eine Lesesperre für einen Thread mit einer Writer-Sperre abzurufen, `ReaderWriterLock` nicht die Lesesperre erteilt, sondern stattdessen die Sperrenanzahl für die Schreibsperre erhöht wird.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseLock () As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie ReleaseLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseLock : unit -&gt; System.Threading.LockCookie" Usage="readerWriterLock.ReleaseLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hebt die Sperre unabhängig davon auf, wie oft dem Thread die Sperre zugewiesen wurde.</summary>
        <returns>Ein <see cref="T:System.Threading.LockCookie" />-Wert, der die aufgehobene Sperre darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Gibt die Lese-oder Schreibsperre unabhängig von der rekursiven Sperr Anzahl frei. Um den Zustand der Sperre wiederherzustellen, einschließlich der Sperrenanzahl, übergeben <xref:System.Threading.LockCookie> Sie den an <xref:System.Threading.ReaderWriterLock.RestoreLock%2A> .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die- <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Methode verwendet wird, um die Sperre freizugeben, unabhängig davon, wie oft Sie durch den Thread abgerufen wurde, und wie der Zustand der Sperre später wieder hergestellt wird.  
  
 Dieser Code ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Threading.ReaderWriterLock> .  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseReaderLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseReaderLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseReaderLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseReaderLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verringert die Sperrenanzahl.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> verringert die Sperrenanzahl. Wenn die Anzahl 0 (null) erreicht, wird die Sperre freigegeben.  
  
> [!NOTE]
>  Wenn ein Thread die Schreibsperre besitzt, `ReleaseReaderLock` hat der Aufruf von denselben Effekt wie das Aufrufen von <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> . Wenn ein Thread keine Sperren hat, löst der Aufruf von `ReleaseReaderLock` eine aus <xref:System.ApplicationException> .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine Lesesperre abgerufen und freigegeben wird und wie die Ausnahme behandelt wird, die ausgelöst wird, wenn für eine Anforderung ein Timeout auftritt.  
  
 Dieser Code ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Threading.ReaderWriterLock> .  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Der Thread verfügt weder über Lese- noch über Schreibsperren.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseWriterLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseWriterLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseWriterLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseWriterLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verringert die Sperrenanzahl für die Schreibsperre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> verringert die Anzahl der Schreib sperren. Wenn die Anzahl 0 (null) erreicht, wird die Writer-Sperre freigegeben.  
  
> [!NOTE]
>  Wenn ein Thread eine Lesesperre oder keine Sperren hat, löst der Aufruf von `ReleaseWriterLock` eine aus <xref:System.ApplicationException> .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine Writer-Sperre abgerufen und freigegeben wird und wie die Ausnahme behandelt wird, die ausgelöst wird, wenn für eine Anforderung ein Timeout auftritt.  
  
 Dieser Code ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Threading.ReaderWriterLock> .  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Der Thread verfügt nicht über die Schreibsperre.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RestoreLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RestoreLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.RestoreLock : LockCookie -&gt; unit" Usage="readerWriterLock.RestoreLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">Ein von <see cref="T:System.Threading.LockCookie" /> zurückgegebenes <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
        <summary>Stellt den Sperrstatus des Threads mit dem Status vor dem Aufruf von <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /> wieder her.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der durch wiederhergestellte Zustand `RestoreLock` schließt die rekursive Sperr Anzahl ein.  
  
 Ein Thread wird blockiert, wenn versucht wird, eine Lesesperre wiederherzustellen, nachdem ein anderer Thread die Schreibsperre abgerufen hat, oder wenn versucht wird, die Schreibsperre wiederherzustellen, nachdem ein anderer Thread eine Lesesperre oder eine Schreibsperre abgerufen hat. Da kein Timeout `RestoreLock` akzeptiert, sollten Sie darauf achten, mögliche Deadlocks zu vermeiden.  
  
> [!CAUTION]
>  Vergewissern `RestoreLock` Sie sich vor dem Aufrufen von, dass alle Sperren freigegeben wurden, die seit dem Aufruf von abgerufen wurden <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> . Beispielsweise wird ein Thread Deadlocks, wenn er eine Lesesperre erhält und dann versucht, eine frühere Schreibsperre wiederherzustellen. Verwenden <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> Sie und, um solche zusätzlichen Sperren zu erkennen.  
  
 Verwenden Sie keine <xref:System.Threading.LockCookie> von zurückgegebene <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die- <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Methode verwendet wird, um die Sperre freizugeben, unabhängig davon, wie oft Sie durch den Thread abgerufen wurde, und wie der Zustand der Sperre später wieder hergestellt wird.  
  
 Dieser Code ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Threading.ReaderWriterLock> .  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="lockCookie" /> ist ein NULL-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpgradeToWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wandelt eine Lesesperre in eine Schreibsperre um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (millisecondsTimeout As Integer) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : int -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Das Timeout in Millisekunden.</param>
        <summary>Wandelt eine Lesesperre unter Verwendung eines <see cref="T:System.Int32" />-Werts für das Timeout in eine Schreibsperre um.</summary>
        <returns>Ein <see cref="T:System.Threading.LockCookie" />-Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Thread aufruft, `UpgradeToWriterLock` wird die Lesesperre unabhängig von der Sperrenanzahl freigegeben, und der Thread wechselt zum Ende der Warteschlange für die Schreibsperre. Daher könnten andere Threads in die Ressource schreiben, bevor dem Thread, der das Upgrade angefordert hat, die Schreibsperre erteilt wird.  
  
> [!IMPORTANT]
>  Die Timeout Ausnahme wird erst ausgelöst, wenn der Thread, der die-Methode aufgerufen hat, <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> die Lesesperre erneut abrufen kann. Wenn keine anderen Threads auf die Schreibsperre warten, erfolgt dies sofort. Wenn jedoch ein anderer Thread für die Schreibsperre in die Warteschlange eingereiht wird, kann der Thread, der die-Methode aufgerufen hat, <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> die Lesesperre erst wieder abrufen, wenn alle aktuellen Reader ihre Sperren freigegeben haben und ein Thread die Schreibsperre abgerufen und freigegeben hat. Dies gilt auch, wenn der andere Thread, der die Writer-Sperre angefordert hat, ihn nach dem aktuellen Thread angefordert hat, der die-Methode aufgerufen hat <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> .  
  
 Zum Wiederherstellen des Sperr Zustands können <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Sie mit der <xref:System.Threading.LockCookie> von zurückgegebenen abrufen `UpgradeToWriterLock` . Verwenden Sie dies nicht `LockCookie` mit <xref:System.Threading.ReaderWriterLock.RestoreLock%2A> .  
  
 Wenn ein Thread keine Lesesperre aufweist, verwenden Sie nicht `UpgradeToWriterLock` . Verwenden Sie stattdessen <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.  
  
 Gültige Timeout Werte finden Sie unter <xref:System.Threading.ReaderWriterLock> .  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie eine Lesesperre anfordern, die Lesesperre auf eine Writer-Sperre aktualisieren und erneut auf eine Lesesperre herabstufen.  
  
 Dieser Code ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Threading.ReaderWriterLock> .  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><paramref name="millisecondsTimeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (timeout As TimeSpan) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : TimeSpan -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Die <see langword="TimeSpan" />, die den Timeoutzeitraum angibt.</param>
        <summary>Wandelt eine Lesesperre unter Verwendung eines <see langword="TimeSpan" />-Werts für das Timeout in eine Schreibsperre um.</summary>
        <returns>Ein <see cref="T:System.Threading.LockCookie" />-Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Thread aufruft, `UpgradeToWriterLock` wird die Lesesperre unabhängig von der Sperrenanzahl freigegeben, und der Thread wechselt zum Ende der Warteschlange für die Schreibsperre. Daher könnten andere Threads in die Ressource schreiben, bevor dem Thread, der das Upgrade angefordert hat, die Schreibsperre erteilt wird.  
  
> [!IMPORTANT]
>  Die Timeout Ausnahme wird erst ausgelöst, wenn der Thread, der die-Methode aufgerufen hat, <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> die Lesesperre erneut abrufen kann. Wenn keine anderen Threads auf die Schreibsperre warten, erfolgt dies sofort. Wenn jedoch ein anderer Thread für die Schreibsperre in die Warteschlange eingereiht wird, kann der Thread, der die-Methode aufgerufen hat, <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> die Lesesperre erst wieder abrufen, wenn alle aktuellen Reader ihre Sperren freigegeben haben und ein Thread die Schreibsperre abgerufen und freigegeben hat. Dies gilt auch, wenn der andere Thread, der die Writer-Sperre angefordert hat, ihn nach dem aktuellen Thread angefordert hat, der die-Methode aufgerufen hat <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> .  
  
 Zum Wiederherstellen des Sperr Zustands können <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Sie mit der <xref:System.Threading.LockCookie> von zurückgegebenen abrufen `UpgradeToWriterLock` . Verwenden Sie dies nicht `LockCookie` mit <xref:System.Threading.ReaderWriterLock.RestoreLock%2A> .  
  
 Wenn ein Thread keine Lesesperre aufweist, verwenden Sie nicht `UpgradeToWriterLock` . Verwenden Sie stattdessen <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.  
  
 Gültige Timeout Werte finden Sie unter <xref:System.Threading.ReaderWriterLock> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><paramref name="timeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> gibt einen negativen Wert ungleich -1 Millisekunden an.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriterSeqNum As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriterSeqNum { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WriterSeqNum : int" Usage="System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Sequenznummer ab.</summary>
        <value>Die aktuelle Sequenznummer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Sequenznummer erhöht sich, wenn ein Thread die Schreibsperre erhält. Sie können die Sequenznummer speichern und zu <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> einem späteren Zeitpunkt an übergeben, wenn Sie feststellen möchten, ob andere Threads die Schreibsperre in der Zwischenzeit erhalten haben.  
  
 Sie können verwenden `WriterSeqNum` , um die Anwendungsleistung zu verbessern. Ein Thread kann z. b. die Informationen zwischenspeichern, die er beim Aufrechterhalten einer Lesesperre erhält. Nach dem Freigeben und späteren erneuten Erwerb der Sperre kann der Thread ermitteln, ob andere Threads durch Aufrufen von in die Ressource geschrieben wurden `AnyWritersSince` . andernfalls können die zwischengespeicherten Informationen verwendet werden. Diese Technik ist hilfreich, wenn das Lesen der durch die Sperre geschützten Informationen teuer ist. beispielsweise das Ausführen einer Datenbankabfrage.  
  
 Der Aufrufer muss eine Lesesperre oder eine Writer-Sperre aufweisen, damit die Sequenznummer nützlich ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> -Eigenschaft und die-Methode verwendet werden <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> , um zu bestimmen, ob ein anderer Thread die Schreibsperre für die geschützte Ressource abgerufen hat, da der aktuelle Thread zuletzt die Schreibsperre aufrechterhalten hat  
  
 Dieser Code ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Threading.ReaderWriterLock> .  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks">ReaderWriterLock</related>
      </Docs>
    </Member>
  </Members>
</Type>
