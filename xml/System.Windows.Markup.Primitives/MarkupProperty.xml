<Type Name="MarkupProperty" FullName="System.Windows.Markup.Primitives.MarkupProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fe05df9cdd4cc5d5814ddf19c68c1677f48a6238" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69167832" /></Metadata><TypeSignature Language="C#" Value="public abstract class MarkupProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MarkupProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.Primitives.MarkupProperty" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MarkupProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class MarkupProperty abstract" />
  <TypeSignature Language="F#" Value="type MarkupProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Abstrakte Klasse, die eine Eigenschaftenbeschreibung bereitstellt, die beim Schreiben in Markup verwendet werden kann, das den Zugriff auf Eigenschaften und deren Werte kapselt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft wird entweder als Zeichenfolge oder als Liste von Elementen dargestellt.  
  
 Wenn die Eigenschaft als Zeichenfolge dargestellt werden kann, <xref:System.Windows.Markup.Primitives.MarkupProperty.IsComposite%2A> ist `false`.  
  
 Wenn <xref:System.Windows.Markup.Primitives.MarkupProperty.IsComposite%2A> ist`true`, ist die Eigenschaft eine Liste von Elementen.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.ComponentModel.AttributeCollection Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.AttributeCollection Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::ComponentModel::AttributeCollection ^ Attributes { System::ComponentModel::AttributeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.ComponentModel.AttributeCollection" Usage="System.Windows.Markup.Primitives.MarkupProperty.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die Attribute ab, die dieser <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> zugeordnet sind.</summary>
        <value>Die Auflistung der Attribute.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DependencyProperty As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::DependencyProperty ^ DependencyProperty { System::Windows::DependencyProperty ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den <see cref="T:System.Windows.DependencyProperty" />-Bezeichner für die Markupeigenschaft ab, wenn die Eigenschaft als Abhängigkeitseigenschaft implementiert wird.</summary>
        <value>Der Bezeichner der Abhängigkeitseigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardverhalten gibt `null`zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAttached">
      <MemberSignature Language="C#" Value="public virtual bool IsAttached { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttached" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsAttached" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAttached As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAttached { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttached : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsAttached" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob diese <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> eine angefügte <see cref="T:System.Windows.DependencyProperty" /> ist.</summary>
        <value><see langword="true" />, wenn die Eigenschaft eine angefügte <see cref="T:System.Windows.DependencyProperty" /> ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird `false` zurückgegeben.  
  
 <xref:System.Windows.Markup.Primitives.MarkupProperty.IsAttached%2A> <xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A> `null` Wenn den Wert<xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> hat, ist nicht und kann`null`sein, es muss jedoch nicht sein. `true`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsComposite">
      <MemberSignature Language="C#" Value="public virtual bool IsComposite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsComposite" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsComposite" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsComposite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsComposite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsComposite : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsComposite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob diese <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> eine zusammengesetzte Eigenschaft ist.</summary>
        <value><see langword="true" />, wenn diese Eigenschaft eine zusammengesetzte Eigenschaft ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird `false` zurückgegeben.  
  
 <xref:System.Windows.Markup.Primitives.MarkupProperty.IsComposite%2A> <xref:System.Windows.Markup.Primitives.MarkupProperty.Value%2A> Wenn den Wert <xref:System.Windows.Markup.Primitives.MarkupProperty.StringValue%2A> hat, kann die-Eigenschaft als Zeichenfolge dargestellt werden, und Sie können verwendet werden. `false`  
  
 Wenn <xref:System.Windows.Markup.Primitives.MarkupProperty.IsComposite%2A>den Wert <xref:System.Windows.Markup.Primitives.MarkupProperty.Items%2A> hat, ist die Eigenschaft ein oder mehrere Elemente und kann verwendet werden. `true`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructorArgument">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructorArgument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructorArgument" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsConstructorArgument" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructorArgument As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructorArgument { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructorArgument : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsConstructorArgument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob diese <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> ein Konstruktorargument darstellt.</summary>
        <value><see langword="true" />, wenn die Eigenschaft ein Konstruktorargument darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardverhalten ist Return `false`.  
  
 Wenn <xref:System.Windows.Markup.Primitives.MarkupProperty.IsConstructorArgument%2A> ist `true`, und<xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> sindbeide`null`. <xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A>  
  
 XAML verwendet <xref:System.Windows.Markup.Primitives.MarkupProperty.IsConstructorArgument%2A> nur für die Darstellung der Konstruktorargumente von Instanzen <xref:System.Windows.Markup.MarkupExtension>von. Weitere Informationen finden Sie unter [Markup Erweiterungen und WPF-XAML](~/docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContent">
      <MemberSignature Language="C#" Value="public virtual bool IsContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContent : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob diese <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> den direkten Inhalt einer Auflistung darstellt.</summary>
        <value><see langword="true" />, wenn die Eigenschaft direkten Inhalt darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird `false` zurückgegeben.  
  
 Wenn <xref:System.Windows.Markup.Primitives.MarkupProperty.IsContent%2A> ist `true`, und<xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> sindbeide`null`. <xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A>  
  
 Wörterbücher werden eingeschlossen, wenn bestimmt <xref:System.Windows.Markup.Primitives.MarkupProperty> wird, ob diese den direkten Inhalt darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKey">
      <MemberSignature Language="C#" Value="public virtual bool IsKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsKey As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsKey { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKey : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob diese <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> den Schlüssel darstellt, den das <see cref="T:System.Windows.Markup.Primitives.MarkupObject" /> zum Speichern des Elements in einem Wörterbuch verwendet.</summary>
        <value><see langword="true" />, wenn diese Eigenschaft einen Schlüssel darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird `false` zurückgegeben.  
  
 Wenn <xref:System.Windows.Markup.Primitives.MarkupProperty.IsKey%2A> ist `true`, <xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> und sind.<xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A> `null`  
  
 XAML verwendet die identifizierte Eigenschaft als `x:Key` Attribut.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueAsString">
      <MemberSignature Language="C#" Value="public virtual bool IsValueAsString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueAsString" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsValueAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsValueAsString As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsValueAsString { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueAsString : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsValueAsString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob diese <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> Text darstellt, der an einen Typkonverter übergeben wird, um eine Instanz der Eigenschaft zu erstellen, oder ob ein Konstruktor verwendet werden sollte.</summary>
        <value><see langword="true" />, wenn diese <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> eine Zeichenfolge darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardverhalten ist die Rückgabe von`false.`  
  
 Wenn <xref:System.Windows.Markup.Primitives.MarkupProperty.IsValueAsString%2A> ist `true`, und<xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> sindbeide`null`. <xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A>  
  
 Wenn die Eigenschaft über <xref:System.Windows.Markup.Primitives.MarkupObject.Properties%2A> bereitgestellt wird und `true` <xref:System.Windows.Markup.Primitives.MarkupProperty.IsValueAsString%2A> ist, ist Sie die einzige Eigenschaft, die der Typ bereitstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;System.Windows.Markup.Primitives.MarkupObject&gt; Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Markup.Primitives.MarkupObject&gt; Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.Items" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Items As IEnumerable(Of MarkupObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Collections::Generic::IEnumerable&lt;System::Windows::Markup::Primitives::MarkupObject ^&gt; ^ Items { System::Collections::Generic::IEnumerable&lt;System::Windows::Markup::Primitives::MarkupObject ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : seq&lt;System.Windows.Markup.Primitives.MarkupObject&gt;" Usage="System.Windows.Markup.Primitives.MarkupProperty.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Markup.Primitives.MarkupObject&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die Elemente ab, aus denen sich der Wert dieser Eigenschaft zusammensetzt.</summary>
        <value>Die Elemente, die den Wert dieser Eigenschaft bilden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Eigenschaft keine Enumeration ist, wird nur ein Element zurückgegeben.  
  
 Wenn die Eigenschaft eine Enumeration oder Enumerable ist, werden alle Elemente zurückgegeben.  
  
 Es wird immer mindestens ein Element zurückgegeben, <xref:System.Windows.Markup.Primitives.MarkupObject> da keine <xref:System.Windows.Markup.Primitives.MarkupProperty> für Eigenschaften ohne Elemente erstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.Markup.Primitives.MarkupProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Namen ab, der für Diagnosen und Fehlerberichte verwendet wird.</summary>
        <value>Der Eigenschaftenname des Bezeichners.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Serialisierungsprogramm sollte diesen Wert nicht verwenden. Stattdessen sollte <xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> und/oder <xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A> verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyDescriptor">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptor PropertyDescriptor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.PropertyDescriptor PropertyDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PropertyDescriptor As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::PropertyDescriptor ^ PropertyDescriptor { System::ComponentModel::PropertyDescriptor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyDescriptor : System.ComponentModel.PropertyDescriptor" Usage="System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den <see cref="T:System.ComponentModel.PropertyDescriptor" /> für die Markupeigenschaft ab.</summary>
        <value>Der Eigenschaftendeskriptor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardverhalten gibt `null`zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public abstract Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.Markup.Primitives.MarkupProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den CLR-Typ der Eigenschaft ab.</summary>
        <value>Der CLR-Typ.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringValue">
      <MemberSignature Language="C#" Value="public abstract string StringValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StringValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.StringValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property StringValue As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ StringValue { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StringValue : string" Usage="System.Windows.Markup.Primitives.MarkupProperty.StringValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Zeichenfolgenwert dieser <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> ab.</summary>
        <value>Der Zeichenfolgenwert.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.TypeReferences" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TypeReferences As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeReferences : seq&lt;Type&gt;" Usage="System.Windows.Markup.Primitives.MarkupProperty.TypeReferences" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Satz von Typen ab, auf den diese <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> beim Serialisieren des zugehörigen Werts als Zeichenfolge verweist.</summary>
        <value>Der Satz von Typen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.Primitives.MarkupProperty.TypeReferences%2A>ermöglicht einem Serialisierungsprogramm, sicherzustellen, dass das Deserialisierungsprogramm über ausreichende Informationen verfügt, um Verweise auf diesen Typ aus den Zeichen folgen Darstellungen zu konvertieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Windows.Markup.Primitives.MarkupProperty.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den aktuellen Wert dieses <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> ab.</summary>
        <value>Der aktuelle Wert.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
