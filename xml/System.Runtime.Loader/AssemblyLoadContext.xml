<Type Name="AssemblyLoadContext" FullName="System.Runtime.Loader.AssemblyLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="801872531e0eb293da1125c3135662c074b1ddbd" /><Meta Name="ms.sourcegitcommit" Value="f6fc130f7b9399b2b130a137d6b0b2b73c1d17b3" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/18/2019" /><Meta Name="ms.locfileid" Value="74154589" /></Metadata><TypeSignature Language="C#" Value="public abstract class AssemblyLoadContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AssemblyLoadContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Loader.AssemblyLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AssemblyLoadContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyLoadContext abstract" />
  <TypeSignature Language="F#" Value="type AssemblyLoadContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Loader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents the runtime's concept of a scope for assembly loading.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[
## Remarks

Der <xref:System.Runtime.Loader.AssemblyLoadContext> der einen Lade Kontext darstellt. Konzeptionell erstellt ein Load-Kontext einen Bereich zum Laden, auflösen und ggf. Entladen eines Assemblysatzes.
 
<xref:System.Runtime.Loader.AssemblyLoadContext> ist eine abstrakte Klasse. Die <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>-Methode muss implementiert werden, um eine konkrete Klasse zu erstellen.
 
Der <xref:System.Runtime.Loader.AssemblyLoadContext> ist primär zum Bereitstellen der Isolation von Assemblys vorhanden. Es ermöglicht, dass mehrere Versionen der gleichen Assembly innerhalb eines einzelnen Prozesses geladen werden. Es ersetzt die Isolations Mechanismen, die von mehreren <xref:System.AppDomain> Instanzen in der .NET Framework bereitgestellt werden.
 
> [!NOTE]
> <xref:System.Runtime.Loader.AssemblyLoadContext> bietet keine Sicherheitsfunktionen. Der gesamte Code verfügt über vollständige Berechtigungen für den Prozess.

### <a name="usage-in-the-runtime"></a>Verwendung in der Laufzeit

Die Laufzeit implementiert zwei assemblyladekontexte:

* <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> stellt den Standardkontext der Laufzeit dar, der für die Hauptassembly der Anwendung und die zugehörigen statischen Abhängigkeiten verwendet wird.
* Die <xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType>-Methode isoliert die Assemblys, die Sie lädt, indem die grundlegendsten <xref:System.Runtime.Loader.AssemblyLoadContext>instanziiert werden. Es verfügt über ein vereinfachtes Isolations Schema, das jede Assembly in ihrer eigenen <xref:System.Runtime.Loader.AssemblyLoadContext> ohne Abhängigkeitsauflösung lädt.
 
### <a name="application-usage"></a>Anwendungsnutzung

Eine Anwendung kann einen eigenen <xref:System.Runtime.Loader.AssemblyLoadContext> erstellen, um eine benutzerdefinierte Lösung für erweiterte Szenarios zu erstellen. Der Schwerpunkt liegt auf der Definition von Mechanismen zur Abhängigkeitsauflösung.
 
Der <xref:System.Runtime.Loader.AssemblyLoadContext> bietet zwei Erweiterungs Punkte zum Implementieren der Auflösung verwalteter Assemblys:

1. Die <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>-Methode bietet das erste Risiko, dass die <xref:System.Runtime.Loader.AssemblyLoadContext> die Assembly auflösen, laden und zurückgeben können. Wenn die <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>-Methode `null`zurückgibt, versucht das Lade Modul, die Assembly in die <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>zu laden.
2. Wenn das <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> die Assembly nicht auflösen kann, erhält der ursprüngliche <xref:System.Runtime.Loader.AssemblyLoadContext> eine zweite Möglichkeit, die Assembly aufzulösen. Die Laufzeit löst das <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving>-Ereignis aus.
 
Außerdem ermöglicht die virtuelle <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType>-Methode die Anpassung der standardmäßigen nicht verwalteten Assemblyauflösung. Die Standard Implementierung gibt `null`zurück, was dazu führt, dass die Runtime-Suche Ihre Standard Such Richtlinie verwendet. Die Standard Such Richtlinie ist für die meisten Szenarien ausreichend.

### <a name="technical-challenges"></a>Technische Herausforderungen

* Es ist nicht möglich, mehrere Versionen der Laufzeit in einem einzelnen Prozess zu laden.

     > [!CAUTION]
     > Das Laden mehrerer Kopien oder verschiedener Versionen von Frameworkassemblys kann zu unerwartetem und schwer zu diagnostizieren Verhalten führen.
     
     > [!TIP]
     > Verwenden Sie Prozess Grenzen mit Remoting oder prozessübergreifende Kommunikation, um dieses Isolations Problem zu lösen.
 
* Durch das Laden der Assembly kann das Testen und Debuggen erschwert werden. Assemblys werden normalerweise geladen, ohne dass ihre Abhängigkeiten sofort aufgelöst werden. Die Abhängigkeiten werden nach Bedarf geladen:

     * Wenn Code in eine abhängige Assembly verzweigt.
     * Wenn Code Ressourcen lädt.
     * Wenn Code Assemblys explizit lädt.
 
* Durch die Implementierung von <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> können neue Abhängigkeiten hinzugefügt werden, die möglicherweise isoliert werden müssen, damit verschiedene Versionen vorhanden sein müssen. Die natürlichste Implementierung würde diese Abhängigkeiten im Standardkontext platzieren. Der sorgfältige Entwurf kann die neuen Abhängigkeiten isolieren.
 
* Dieselbe Assembly wird mehrmals in verschiedene Kontexte geladen.
     * Dies kann zu verwirrenden Fehlermeldungen führen, z. b. "das Objekt des Typs" Sample. Plugin"kann nicht in den Typ" Sample. Plugin"umgewandelt werden.
     * Das Marshalling über Isolations Grenzen hinweg ist nicht trivial. Eine typische Lösung ist die Verwendung einer Schnittstelle, die in einer Assembly definiert ist, die nur in den standardmäßigen Load-Kontext geladen wird.
 
 ]]></format>
    </remarks>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/assemblyloadcontext.md">Assemblyloadcontext-CoreCLR-Entwurfsdokument</related>
    <related type="Article" href="~/docs/standard/assembly/unloadability.md">Verwenden und Debuggen von Assemblyentladbarkeit in .NET Core</related>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/unloadability.md">Assemblyloadcontext-Entwurfsdokument für unloadability</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Dieser Konstruktor ist geschützt. Sie kann nur von der <xref:System.Runtime.Loader.AssemblyLoadContext>-Klasse oder von den abgeleiteten Klassen aufgerufen werden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext (bool isCollectible);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (isCollectible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext(bool isCollectible);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext isCollectible" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isCollectible" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="isCollectible"><see langword="true" /> to enable <see cref="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />; otherwise, <see langword="false" />. The default value is <see langword="false" /> because there is a performance cost associated with enabling unloading.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class with a value that indicates whether unloading is enabled.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Dieser Konstruktor ist geschützt. Sie kann nur von der <xref:System.Runtime.Loader.AssemblyLoadContext>-Klasse oder von den abgeleiteten Klassen aufgerufen werden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyLoadContext (string name, bool isCollectible = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional isCollectible As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : string * bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext (name, isCollectible)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="isCollectible" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="name">The value for <see cref="P:System.Runtime.Loader.AssemblyLoadContext.Name" /> in the new instance. Its value can be <see langword="null" />.</param>
        <param name="isCollectible"><see langword="true" /> to enable <see cref="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />; otherwise, <see langword="false" />. The default value is <see langword="false" /> because there is a performance cost associated with enabling unloading.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class with a name and a value that indicates whether unloading is enabled.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Runtime.Loader.AssemblyLoadContext&gt; All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IEnumerable`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; All" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.All" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property All As IEnumerable(Of AssemblyLoadContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Generic::IEnumerable&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ All { System::Collections::Generic::IEnumerable&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : seq&lt;System.Runtime.Loader.AssemblyLoadContext&gt;" Usage="System.Runtime.Loader.AssemblyLoadContext.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a collection of all <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> instances.</summary>
        <value>Eine Auflistung aller <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> Instanzen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; Assemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; Assemblies" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Assemblies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Assemblies As IEnumerable(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ Assemblies { System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assemblies : seq&lt;System.Reflection.Assembly&gt;" Usage="System.Runtime.Loader.AssemblyLoadContext.Assemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a collection of the <see cref="T:System.Reflection.Assembly" /> instances loaded in the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</summary>
        <value>Eine Auflistung der <see cref="T:System.Reflection.Assembly" /> Instanzen, die in der <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />geladen werden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentContextualReflectionContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext CurrentContextualReflectionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext CurrentContextualReflectionContext" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContextualReflectionContext As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ CurrentContextualReflectionContext { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContextualReflectionContext : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> set by the most recent call to <see cref="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" />.</summary>
        <value>Der <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> der durch den letzten <see cref="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" />-Aufrufsatz festgelegt wird. Dieser Wert kann <see langword="null" /> sein. Der Wert wird in einem <see cref="T:System.Threading.AsyncLocal`1" />gespeichert, sodass der Wert für jeden asynchronen Kontext eindeutig ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Weitere Informationen finden Sie unter [assemblyloadcontext. currentcontextualreflectioncontext Design doc in .net Core](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ Default { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />. The default context contains the main application assembly and its static dependencies.</summary>
        <value>Der standardmäßige Assembly-Load-Kontext.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnterContextualReflection">
      <MemberSignature Language="C#" Value="public System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.Loader.AssemblyLoadContext/ContextualReflectionScope EnterContextualReflection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" />
      <MemberSignature Language="VB.NET" Value="Public Function EnterContextualReflection () As AssemblyLoadContext.ContextualReflectionScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Loader::AssemblyLoadContext::ContextualReflectionScope EnterContextualReflection();" />
      <MemberSignature Language="F#" Value="member this.EnterContextualReflection : unit -&gt; System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope" Usage="assemblyLoadContext.EnterContextualReflection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext+ContextualReflectionScope</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> to <see langword="this" /><see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</summary>
        <returns>An object to restore the previous value of <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />. It is intended to be used as an <see cref="T:System.IDisposable" /> in a <see langword="using" /> block.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Weitere Informationen finden Sie unter [assemblyloadcontext. currentcontextualreflectioncontext Design doc in .net Core](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnterContextualReflection">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection (System.Reflection.Assembly activating);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.Loader.AssemblyLoadContext/ContextualReflectionScope EnterContextualReflection(class System.Reflection.Assembly activating) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnterContextualReflection (activating As Assembly) As AssemblyLoadContext.ContextualReflectionScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext::ContextualReflectionScope EnterContextualReflection(System::Reflection::Assembly ^ activating);" />
      <MemberSignature Language="F#" Value="static member EnterContextualReflection : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope" Usage="System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection activating" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext+ContextualReflectionScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activating" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activating">The assembly that is used to determine the requested <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> instance.</param>
        <summary>Sets <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> to the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> which loaded the assembly.</summary>
        <returns>An object to restore the previous value of <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />. It is intended to be used as an <see cref="T:System.IDisposable" /> in a <see langword="using" /> block.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Weitere Informationen finden Sie unter [assemblyloadcontext. currentcontextualreflectioncontext Design doc in .net Core](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~AssemblyLoadContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!AssemblyLoadContext ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="assemblyLoadContext.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Allows the object to try to free resources and perform other cleanup operations before it's reclaimed by garbage collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAssemblyName (assemblyPath As String) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::AssemblyName ^ GetAssemblyName(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="static member GetAssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath">The path to the assembly.</param>
        <summary>Gets an <see cref="T:System.Reflection.AssemblyName" /> for an assembly path.</summary>
        <returns>An object that contains the fully parsed assembly name for the assembly at <paramref name="assemblyPath" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyPath" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The assembly cannot be found.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly is not a valid assembly.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLoadContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext GetLoadContext (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Loader.AssemblyLoadContext GetLoadContext(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext ^ GetLoadContext(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetLoadContext : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.GetLoadContext assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">An assembly.</param>
        <summary>Gets the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> containing the specified <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>The assembly load context containing the <paramref name="assembly" />. If the <paramref name="assembly" /> is not provided by the runtime, this method returns null.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is collectible.</summary>
        <value><see langword="true" />, wenn diese <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> entladbar ist. Andernfalls <see langword="false" />. Wenn im Konstruktor kein Wert angegeben ist, wird der Wert <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Weitere Informationen finden Sie unter [Verwenden und Debuggen der Entladbarkeit von Assemblys in .NET Core](~/docs/standard/assembly/unloadability.md).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyName);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyName);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.Load assemblyName" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyName);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyName);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.Load assemblyName" FrameworkAlternate="netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The object that describes the assembly to be loaded.</param>
        <summary>When overridden in a derived class, allows an assembly to be resolved and loaded based on its <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>The loaded assembly, or <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks
 Während der Assemblyauflösung hat die <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>-Methode die erste Möglichkeit, den Assemblynamen in eine geladene Assembly aufzulösen. Entweder kann eine Assembly geladen oder `null`zurückgegeben werden. Wenn `null`zurückgegeben wird, wird der Auflösungsprozess fortgesetzt. Die vollständige Prozessbeschreibung finden Sie unter <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)>.
 
 > [!IMPORTANT]
 > Um einen rekursiven Stapelüberlauf zu verhindern, müssen Sie die <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)>-Methode dieser Instanz nicht aus dieser Methode abrufen.
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The object that describes the assembly to load.</param>
        <summary>Resolves and loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>The loaded assembly, or throws.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> eine Assembly durch Auflösen des <xref:System.Reflection.AssemblyName>lädt. Dadurch wird eine vollständige Auflösung ausgelöst. Die Auflösungs Fall Back Sequenz folgt diesem Vorgang:

1. Die-Methode ruft <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>auf.

   > [!IMPORTANT]
   > <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> darf diese Methode nicht abrufen, um einen rekursiven Stapelüberlauf zu verhindern.

2. Wenn die Assembly nicht geladen oder eine Ausnahme ausgelöst wird, versucht die-Methode, die Assembly im Standard <xref:System.Runtime.Loader.AssemblyLoadContext>zu laden.
3. Wenn die Assembly nicht geladen oder eine Ausnahme ausgelöst wird, löst die-Methode das <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving>-Ereignis aus.
4. Wenn die Assembly nicht geladen oder eine Ausnahme ausgelöst wird, löst die-Methode das <xref:System.AppDomain.AssemblyResolve>-Ereignis aus.
 
> [!NOTE]
> <xref:System.IO.FileLoadException> wird ausgelöst, wenn `assemblyRef` den vollständigen Assemblynamen angibt und die erste Assembly, die mit dem einfachen Namen übereinstimmt, eine nicht kompatible Version oder Kultur aufweist. Der Ladevorgang wird nicht weiter für andere Assemblys fortgesetzt, die mit dem einfachen Namen identisch sind.
 
Jede <xref:System.Runtime.Loader.AssemblyLoadContext> kann nur geladen werden:
 
* Eine Version einer ausführbaren Assembly.
* Eine Version einer Satellitenassembly für jede Kultur.
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> is not a valid assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded which did not match the <paramref name="assemblyName" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath">The fully qualified path of the file to load.</param>
        <summary>Loads the contents of an assembly file on the specified path.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="assemblyPath" /> argument is not an absolute path.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="assemblyPath" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">A file that was found could not be loaded.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The <paramref name="assemblyPath" /> parameter is an empty string ("") or does not exist.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyPath" /> is not a valid assembly.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromNativeImagePath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromNativeImagePath (string nativeImagePath, string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromNativeImagePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromNativeImagePath (nativeImagePath As String, assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromNativeImagePath(System::String ^ nativeImagePath, System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromNativeImagePath : string * string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromNativeImagePath (nativeImagePath, assemblyPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeImagePath" Type="System.String" />
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nativeImagePath">The fully qualified path of the file to load.</param>
        <param name="assemblyPath">The fully qualified path of the IL version of the file to load, or <see langword="null" />.</param>
        <summary>Loads the contents of the native image of a managed assembly file on the specified path.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das systemeigene Image einer verwalteten Assembly wird vorab mit JIT kompiliert, um die Ausführung auf einer bestimmten Plattform zu optimieren.
 
 Der Assemblypfad verweist auf den Pfad zur Il-Version der Assembly. Dabei handelt es sich um ein optionales Argument, da die Il in der Regel im systemeigenen Image enthalten ist. Sie kann von der Laufzeit als Fall Back verwendet werden, wenn das systemeigene Image nicht gefunden wurde.
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="nativeImagePath" /> argument is not an absolute path.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="assemblyPath" /> argument is not an absolute path.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="nativeImagePath" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">A file that was found could not be loaded.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The <paramref name="nativeImagePath" /> parameter is an empty string ("") or does not exist.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyPath" /> is not a valid assembly.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly">A byte array that is a COFF-based image containing a managed assembly.</param>
        <summary>Loads the assembly with a common object file format (COFF)-based image containing a managed assembly.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> is <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assembly" /> is not a valid assembly.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly, System.IO.Stream assemblySymbols);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly, class System.IO.Stream assemblySymbols) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream,System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly, System::IO::Stream ^ assemblySymbols);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream * System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream (assembly, assemblySymbols)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
        <Parameter Name="assemblySymbols" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly">A byte array that is a COFF-based image containing a managed assembly.</param>
        <param name="assemblySymbols">A byte array that contains the raw bytes representing the symbols for the assembly.</param>
        <summary>Loads the assembly with a common object file format (COFF)-based image containing a managed assembly, optionally including symbols for the assembly.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> is <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assembly" /> is not a valid assembly.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDll">
      <MemberSignature Language="C#" Value="protected virtual IntPtr LoadUnmanagedDll (string unmanagedDllName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance native int LoadUnmanagedDll(string unmanagedDllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadUnmanagedDll (unmanagedDllName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IntPtr LoadUnmanagedDll(System::String ^ unmanagedDllName);" />
      <MemberSignature Language="F#" Value="abstract member LoadUnmanagedDll : string -&gt; nativeint&#xA;override this.LoadUnmanagedDll : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDll unmanagedDllName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllName">Name of the unmanaged library. Typically this is the filename without its path or extensions.</param>
        <summary>Allows derived class to load an unmanaged library by name.</summary>
        <returns>A handle to the loaded library, or <see cref="F:System.IntPtr.Zero" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die Standard Implementierung gibt immer <xref:System.IntPtr.Zero?displayProperty=nameWithType>zurück. Wenn <xref:System.IntPtr.Zero?displayProperty=nameWithType> zurückgegeben wird, lädt die Laufzeit die Bibliothek mit Ihrer Standard Richtlinie.
 
 Diese virtuelle Methode kann überschrieben werden, um den nicht verwalteten Bibliotheks Suchalgorithmus anzupassen. Beim Überschreiben kann der Name verwendet werden, um die Bibliothek zu identifizieren. Die geladene Bibliothek muss nicht mit dem angeforderten Namen identisch sein, kann jedoch nach Bedarf transformiert werden. Dies kann das Anpassen des Namens für die plattformspezifische Benennung einschließen.
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDllFromPath">
      <MemberSignature Language="C#" Value="protected IntPtr LoadUnmanagedDllFromPath (string unmanagedDllPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance native int LoadUnmanagedDllFromPath(string unmanagedDllPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDllFromPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function LoadUnmanagedDllFromPath (unmanagedDllPath As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IntPtr LoadUnmanagedDllFromPath(System::String ^ unmanagedDllPath);" />
      <MemberSignature Language="F#" Value="member this.LoadUnmanagedDllFromPath : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDllFromPath unmanagedDllPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllPath">The path to the unmanaged library.</param>
        <summary>Loads an unmanaged library from the specified path.</summary>
        <returns>The OS handle for the loaded native library.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Das von dieser Methode zurückgegebene Betriebssystem Handle kann mit Methoden der <xref:System.Runtime.InteropServices.NativeLibrary?displayProperty=nameWithType> Klasse verwendet werden.

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="unmanagedDllPath" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="unmanagedDllPath" /> argument is empty or not an absolute path.</exception>
        <exception cref="T:System.DllNotFoundException">The library can't be found.</exception>
        <exception cref="T:System.BadImageFormatException">The library is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Loader.AssemblyLoadContext.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get the name of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</summary>
        <value>Der Name des <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />. Ihr Wert kann <see langword="null" /> sein.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resolving">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt; Resolving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Runtime.Loader.AssemblyLoadContext, class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; Resolving" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Resolving" />
      <MemberSignature Language="VB.NET" Value="Public Event Resolving As Func(Of AssemblyLoadContext, AssemblyName, Assembly) " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Runtime::Loader::AssemblyLoadContext ^, System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ Resolving;" />
      <MemberSignature Language="F#" Value="member this.Resolving : Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " Usage="member this.Resolving : System.Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resolving As Func(Of AssemblyLoadContext, AssemblyName, Assembly) " FrameworkAlternate="netcore-3.0;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the resolution of an assembly fails when attempting to load into this assembly load context.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Es liegt in der Verantwortung des Handlers für dieses Ereignis, die angegebene Assembly zurückzugeben oder `null` zurückzugeben, wenn die Assembly nicht erkannt wird.
 
 > [!IMPORTANT]
 >  Wenn mehr als ein Ereignishandler für dieses Ereignis registriert ist, werden die Ereignishandler in der entsprechenden Reihenfolge aufgerufen, bis ein Ereignishandler einen Wert zurückgibt, der nicht `null`ist. Nachfolgende Ereignishandler werden ignoriert.
 
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).
 
 Es ist bemerkenswert, dass für dieses Ereignis ein Handler für jede <xref:System.Runtime.Loader.AssemblyLoadContext>hinzugefügt werden kann, einschließlich des Standard Kontexts.
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvingUnmanagedDll">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Reflection.Assembly,string,IntPtr&gt; ResolvingUnmanagedDll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Reflection.Assembly, string, native int&gt; ResolvingUnmanagedDll" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.ResolvingUnmanagedDll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolvingUnmanagedDll As Func(Of Assembly, String, IntPtr) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Reflection::Assembly ^, System::String ^, IntPtr&gt; ^ ResolvingUnmanagedDll;" />
      <MemberSignature Language="F#" Value="member this.ResolvingUnmanagedDll : Func&lt;System.Reflection.Assembly, string, nativeint&gt; " Usage="member this.ResolvingUnmanagedDll : System.Func&lt;System.Reflection.Assembly, System.string, System.nativeint&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Reflection.Assembly,System.String,System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the resolution of a native library fails.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Dieses Ereignis wird ausgelöst, wenn die native Bibliothek nicht durch die Standard Auflösungs Logik (einschließlich <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll%2A>) aufgelöst werden kann.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProfileOptimizationRoot">
      <MemberSignature Language="C#" Value="public void SetProfileOptimizationRoot (string directoryPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetProfileOptimizationRoot(string directoryPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.SetProfileOptimizationRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetProfileOptimizationRoot (directoryPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetProfileOptimizationRoot(System::String ^ directoryPath);" />
      <MemberSignature Language="F#" Value="member this.SetProfileOptimizationRoot : string -&gt; unit" Usage="assemblyLoadContext.SetProfileOptimizationRoot directoryPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directoryPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directoryPath">The full path to the directory where the optimization profiles are stored.</param>
        <summary>Sets the root path where the optimization profiles for this load context are stored.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[ 

## Remarks        

Durch die Profil Optimierung wird die Startleistung des Lade Kontexts auf Computern mit mehreren Kernen verbessert. dazu wird die Hintergrund Kompilierung von Methoden durchgeführt, die wahrscheinlich ausgeführt werden, basierend auf Profilen, die bei vorherigen Kompilierungen erstellt wurden. Weitere Informationen finden Sie unter <xref:System.Runtime.ProfileOptimization>.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProfileOptimization">
      <MemberSignature Language="C#" Value="public void StartProfileOptimization (string profile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartProfileOptimization(string profile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.StartProfileOptimization(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartProfileOptimization (profile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartProfileOptimization(System::String ^ profile);" />
      <MemberSignature Language="F#" Value="member this.StartProfileOptimization : string -&gt; unit" Usage="assemblyLoadContext.StartProfileOptimization profile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="profile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="profile">The name of the optimization profile.</param>
        <summary>Starts the profile optimization for the specified profile.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[ 

## Remarks        

Durch die Profil Optimierung wird die Startleistung des Lade Kontexts auf Computern mit mehreren Kernen verbessert. dazu wird die Hintergrund Kompilierung von Methoden durchgeführt, die wahrscheinlich ausgeführt werden, basierend auf Profilen, die bei vorherigen Kompilierungen erstellt wurden. Weitere Informationen finden Sie unter <xref:System.Runtime.ProfileOptimization>.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assemblyLoadContext.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the string representation of this load context.</summary>
        <returns>The string representation of this load context.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="assemblyLoadContext.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiates an unload of this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

+ Ein assemblyloadcontext kann nur entladen werden, wenn er entladbar ist.
+ Das Entladen erfolgt asynchron.
+ Das Entladen erfolgt nicht, während Verweise auf den assemblyloadcontext vorhanden sind.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Unloading is not allowed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; Unloading" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloading As Action(Of AssemblyLoadContext) " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Action&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " Usage="member this.Unloading : System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloading As Action(Of AssemblyLoadContext) " FrameworkAlternate="netcore-3.0;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is unloaded.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
