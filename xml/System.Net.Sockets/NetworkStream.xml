<Type Name="NetworkStream" FullName="System.Net.Sockets.NetworkStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a6c5a6b23f5324fbfb9d8ca5824eef4dd061a71a" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74385437" /></Metadata><TypeSignature Language="C#" Value="public class NetworkStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetworkStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.NetworkStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NetworkStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetworkStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type NetworkStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Docs>
    <summary>Provides the underlying stream of data for network access.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream>-Klasse stellt Methoden zum Senden und empfangen von Daten über <xref:System.Net.Sockets.SocketType.Stream> Sockets im Blockierungs Modus bereit. Weitere Informationen zu Blockierungen und nicht blockierenden <xref:System.Net.Sockets.Socket>s finden [Sie unter Verwenden eines asynchronen Client Sockets](~/docs/framework/network-programming/using-an-asynchronous-client-socket.md). Sie können die <xref:System.Net.Sockets.NetworkStream>-Klasse sowohl für synchrone als auch für asynchrone Datenübertragungen verwenden. Weitere Informationen zur synchronen und asynchronen Kommunikation finden Sie unter [Sockets](~/docs/framework/network-programming/sockets.md).  
  
 Um einen <xref:System.Net.Sockets.NetworkStream>zu erstellen, müssen Sie eine verbundene <xref:System.Net.Sockets.Socket>bereitstellen. Sie können auch angeben, welche <xref:System.IO.FileAccess> Berechtigung der <xref:System.Net.Sockets.NetworkStream> über die angegebene <xref:System.Net.Sockets.Socket>hat. Standardmäßig wird beim Schließen des <xref:System.Net.Sockets.NetworkStream> die angegebene <xref:System.Net.Sockets.Socket>nicht geschlossen. Wenn Sie möchten, dass die <xref:System.Net.Sockets.NetworkStream> über die Berechtigung zum Schließen des bereitgestellten <xref:System.Net.Sockets.Socket>verfügen, müssen Sie `true` für den Wert des `ownsSocket`-Parameters angeben.  
  
 Verwenden Sie die Methoden <xref:System.Net.Sockets.NetworkStream.Write%2A> und <xref:System.Net.Sockets.NetworkStream.Read%2A> für einfache synchrone blockierende e/As mit einem einzelnen Thread. Wenn Sie Ihre e/a-Vorgänge mit separaten Threads verarbeiten möchten, sollten Sie die Methoden <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> und <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> oder die Methoden <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> und <xref:System.Net.Sockets.NetworkStream.EndRead%2A> für die Kommunikation verwenden.  
  
 Der <xref:System.Net.Sockets.NetworkStream> unterstützt keinen zufälligen Zugriff auf den Netzwerkdaten Strom. Der Wert der <xref:System.Net.Sockets.NetworkStream.CanSeek%2A>-Eigenschaft, die angibt, ob der Stream Suchvorgänge unterstützt, immer `false`ist. Wenn Sie die <xref:System.Net.Sockets.NetworkStream.Position%2A>-Eigenschaft lesen, die <xref:System.Net.Sockets.NetworkStream.Length%2A>-Eigenschaft lesen oder die <xref:System.Net.Sockets.NetworkStream.Seek%2A>-Methode aufrufen, wird ein <xref:System.NotSupportedException>ausgelöst.  
  
 Lese-und Schreibvorgänge können gleichzeitig für eine Instanz der <xref:System.Net.Sockets.NetworkStream>-Klasse ausgeführt werden, ohne dass eine Synchronisierung erforderlich ist. Solange es einen eindeutigen Thread für die Schreibvorgänge und einen eindeutigen Thread für die Lesevorgänge gibt, gibt es keine übergreifenden Störungen zwischen Lese-und Schreib Threads, und es ist keine Synchronisierung erforderlich.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein <xref:System.Net.Sockets.NetworkStream> aus einem verbundenen <xref:System.Net.Sockets.SocketType.Stream><xref:System.Net.Sockets.Socket> erstellt und grundlegende synchrone blockierende e/a-Vorgänge durchgeführt werden.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream socket" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <param name="socket">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <summary>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird mit Lese-/Schreibzugriff auf die angegebene <xref:System.Net.Sockets.Socket>erstellt. Der <xref:System.Net.Sockets.NetworkStream> ist nicht der Besitzer der zugrunde liegenden <xref:System.Net.Sockets.Socket>, sodass das Aufrufen der <xref:System.Net.Sockets.NetworkStream.Close%2A>-Methode das <xref:System.Net.Sockets.Socket>nicht schließt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine <xref:System.Net.Sockets.NetworkStream> mit einem-<xref:System.Net.Sockets.Socket>erstellt wird.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  
  
-or- 
The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
-or- 
The <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
        <related type="Article" href="~/docs/framework/network-programming/using-streams-on-the-network.md">Verwenden von Streams im Netzwerk</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, bool ownsSocket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * bool -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, ownsSocket)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <param name="ownsSocket">Set to <see langword="true" /> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the <see cref="T:System.Net.Sockets.Socket" />; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified <see cref="T:System.Net.Sockets.Socket" /> ownership.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird mit Lese-/Schreibzugriff auf die angegebene <xref:System.Net.Sockets.Socket>erstellt. Wenn der Wert `ownsSocket`-Parameters `true`ist, übernimmt der <xref:System.Net.Sockets.NetworkStream> den Besitz des zugrunde liegenden <xref:System.Net.Sockets.Socket>, und beim Aufrufen der <xref:System.Net.Sockets.NetworkStream.Close%2A>-Methode wird auch der zugrunde liegende <xref:System.Net.Sockets.Socket>geschlossen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Net.Sockets.NetworkStream> erstellt, die den Besitz der <xref:System.Net.Sockets.Socket>hat.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  
  
-or- 
the value of the <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
-or- 
the <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * System.IO.FileAccess -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socket">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <param name="access">A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specify the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified access rights.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird mit dem angegebenen Zugriff auf die angegebene <xref:System.Net.Sockets.Socket>erstellt. Mit diesem Konstruktor ist der <xref:System.Net.Sockets.NetworkStream> nicht der Besitzer der zugrunde liegenden <xref:System.Net.Sockets.Socket>, sodass der Aufruf der <xref:System.Net.Sockets.NetworkStream.Close%2A>-Methode die zugrunde liegende <xref:System.Net.Sockets.Socket>nicht schließt.  
  
 Der `access`-Parameter legt die Eigenschaften <xref:System.Net.Sockets.NetworkStream.CanRead%2A> und <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> der <xref:System.Net.Sockets.NetworkStream>fest. Wenn Sie <xref:System.IO.FileAccess.Write>angeben, lässt der <xref:System.Net.Sockets.NetworkStream> Aufrufe der <xref:System.Net.Sockets.NetworkStream.Write%2A>-Methode zu. Wenn Sie <xref:System.IO.FileAccess.Read>angeben, lässt der <xref:System.Net.Sockets.NetworkStream> Aufrufe der <xref:System.Net.Sockets.NetworkStream.Read%2A>-Methode zu. Wenn Sie <xref:System.IO.FileAccess.ReadWrite>angeben, sind beide Methodenaufrufe zulässig.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Net.Sockets.NetworkStream> erstellt, die die Möglichkeit hat, Lese-und Schreibzugriff auf die <xref:System.Net.Sockets.Socket>zu erhalten.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  
  
-or- 
the <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
-or- 
the <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * System.IO.FileAccess * bool -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, access, ownsSocket)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ownsSocket" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socket">The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <param name="access">A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specifies the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided <see cref="T:System.Net.Sockets.Socket" />.</param>
        <param name="ownsSocket">Set to <see langword="true" /> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the <see cref="T:System.Net.Sockets.Socket" />; otherwise, <see langword="false" />.</param>
        <summary>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified access rights and the specified <see cref="T:System.Net.Sockets.Socket" /> ownership.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird mit Lese-/Schreibzugriff auf die angegebene <xref:System.Net.Sockets.Socket>erstellt. Wenn der Wert des `ownsSocket`-Parameters `true`ist, übernimmt der <xref:System.Net.Sockets.NetworkStream> den Besitz des zugrunde liegenden <xref:System.Net.Sockets.Socket>, und beim Aufrufen der <xref:System.Net.Sockets.NetworkStream.Close%2A>-Methode wird auch der zugrunde liegende <xref:System.Net.Sockets.Socket>geschlossen.  
  
 Der `access`-Parameter legt die Eigenschaften <xref:System.Net.Sockets.NetworkStream.CanRead%2A> und <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> der <xref:System.Net.Sockets.NetworkStream>fest. Wenn Sie <xref:System.IO.FileAccess.Write>angeben, lässt der <xref:System.Net.Sockets.NetworkStream> Aufrufe der <xref:System.Net.Sockets.NetworkStream.Write%2A>-Methode zu. Wenn Sie <xref:System.IO.FileAccess.Read>angeben, lässt der <xref:System.Net.Sockets.NetworkStream> Aufrufe der <xref:System.Net.Sockets.NetworkStream.Read%2A>-Methode zu. Wenn Sie <xref:System.IO.FileAccess.ReadWrite>angeben, sind beide Methodenaufrufe zulässig.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Net.Sockets.NetworkStream> erstellt, die die Möglichkeit hat, Lese-und Schreibzugriff auf die <xref:System.Net.Sockets.Socket>zu erhalten. Der Besitz des <xref:System.Net.Sockets.Socket> wird diesem <xref:System.Net.Sockets.NetworkStream> erteilt, indem `true` für den `ownsSocket` Parameter angegeben wird.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  
  
-or- 
The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
-or- 
The <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="networkStream.BeginRead (buffer, offset, size, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the location in memory to store data read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in <paramref name="buffer" /> to begin storing the data.</param>
        <param name="size">The number of bytes to read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate that is executed when <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> completes.</param>
        <param name="state">An object that contains any additional user-defined data.</param>
        <summary>Begins an asynchronous read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous call.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>-Methode startet das asynchrone Lesen von Daten aus den eingehenden Netzwerkpuffern. Wenn Sie die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>-Methode aufrufen, haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu empfangen.  
  
 Sie müssen eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>-Methode übergibt. Der `state` Parameter muss mindestens den <xref:System.Net.Sockets.NetworkStream>enthalten. Da Sie die empfangenen Daten innerhalb der Rückruf Methode abrufen möchten, sollten Sie eine kleine Klasse oder Struktur erstellen, die einen Lese Puffer und alle anderen nützlichen Informationen enthält. Übergeben Sie die-Struktur oder-Klasseninstanz mithilfe des `state`-Parameters an die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.NetworkStream.EndRead%2A>-Methode aufgerufen werden. Wenn die Anwendung <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>aufruft, wartet das System, bis die Daten empfangen werden, oder es tritt ein Fehler auf. das System verwendet dann einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert <xref:System.Net.Sockets.NetworkStream.EndRead%2A>, bis die bereitgestellte <xref:System.Net.Sockets.NetworkStream> Daten liest oder eine distanzieren. Wenn Sie möchten, dass der ursprüngliche Thread blockiert wird, nachdem Sie die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>-Methode aufgerufen haben, verwenden Sie die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode. Rufen Sie <xref:System.Threading.EventWaitHandle.Set%2A> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>-Methode liest so viele Daten wie verfügbar, bis zur Anzahl der Bytes, die durch den `size`-Parameter angegeben werden.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException%2A>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
 Lese-und Schreibvorgänge können gleichzeitig für eine Instanz der <xref:System.Net.Sockets.NetworkStream>-Klasse ausgeführt werden, ohne dass eine Synchronisierung erforderlich ist. Solange es einen eindeutigen Thread für die Schreibvorgänge und einen eindeutigen Thread für die Lesevorgänge gibt, gibt es keine übergreifenden Störungen zwischen Lese-und Schreib Threads, und es ist keine Synchronisierung erforderlich.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> verwendet, um Daten asynchron aus dem Netzwerkstream zu lesen. Die `myReadCallBack`-Methode implementiert den <xref:System.AsyncCallback> Delegaten und wird vom System aufgerufen, wenn <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> zurückgibt.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  
  
-or- 
The <paramref name="offset" /> parameter is greater than the length of the <paramref name="buffer" /> paramater.  
  
-or- 
The <paramref name="size" /> is less than 0.  
  
-or- 
The <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.IO.IOException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.  
  
-or- 
There was a failure while reading from the network.  
  
-or- 
An error occurred when accessing the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="networkStream.BeginWrite (buffer, offset, size, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in <paramref name="buffer" /> to begin sending the data.</param>
        <param name="size">The number of bytes to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate that is executed when <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> completes.</param>
        <param name="state">An object that contains any additional user-defined data.</param>
        <summary>Begins an asynchronous write to a stream.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous call.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>-Methode startet einen asynchronen Sendevorgang an den Remote Host. Wenn Sie die <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>-Methode aufrufen, haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.  
  
 Sie müssen eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>-Methode übergibt. Der `state` Parameter muss mindestens den <xref:System.Net.Sockets.NetworkStream>enthalten. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.NetworkStream> und die anderen erforderlichen Informationen enthält. Übergeben Sie die-Struktur oder-Klasseninstanz mithilfe des `state`-Parameters an die <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>-Methode implementieren. Wenn die Anwendung <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>aufruft, verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>, bis der <xref:System.Net.Sockets.NetworkStream> die Anzahl der angeforderten Bytes sendet oder eine Ausnahme auslöst. Wenn Sie möchten, dass der ursprüngliche Thread blockiert wird, nachdem Sie die <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>-Methode aufgerufen haben, verwenden Sie die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode. Rufen Sie <xref:System.Threading.EventWaitHandle.Set%2A> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException%2A>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
 Lese-und Schreibvorgänge können gleichzeitig für eine Instanz der <xref:System.Net.Sockets.NetworkStream>-Klasse ausgeführt werden, ohne dass eine Synchronisierung erforderlich ist. Solange es einen eindeutigen Thread für die Schreibvorgänge und einen eindeutigen Thread für die Lesevorgänge gibt, gibt es keine übergreifenden Störungen zwischen Lese-und Schreib Threads, und es ist keine Synchronisierung erforderlich.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> verwendet, um Daten asynchron in einen Netzwerkstream zu schreiben. Die `myWriteCallBack`-Methode implementiert den <xref:System.AsyncCallback> Delegaten und wird vom System aufgerufen, wenn <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> zurückgibt.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  
  
-or- 
The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.  
  
-or- 
The <paramref name="size" /> parameter is less than 0.  
  
-or- 
The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.IO.IOException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.  
  
-or- 
There was a failure while writing to the network.  
  
-or- 
An error occurred when accessing the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Sockets.NetworkStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> supports reading.</summary>
        <value><see langword="true" />, wenn Daten aus dem Stream gelesen werden können. Andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.Sockets.NetworkStream.CanRead%2A> `true`ist, ermöglicht <xref:System.Net.Sockets.NetworkStream> Aufrufe der <xref:System.Net.Sockets.NetworkStream.Read%2A>-Methode. Geben Sie den entsprechenden <xref:System.IO.FileAccess> Enumerationswert im Konstruktor an, um die Lesbarkeit und Schreib barkeit des <xref:System.Net.Sockets.NetworkStream>festzulegen. Die <xref:System.Net.Sockets.NetworkStream.CanRead%2A>-Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.NetworkStream.CanRead%2A> überprüft, um zu überprüfen, ob die <xref:System.Net.Sockets.NetworkStream> lesbar ist. Anschließend führt er einen Lesevorgang für die <xref:System.Net.Sockets.NetworkStream>aus.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Sockets.NetworkStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the stream supports seeking. This property is not currently supported.This property always returns <see langword="false" />.</summary>
        <value><see langword="false" /> in allen Fällen, um anzugeben, dass <see cref="T:System.Net.Sockets.NetworkStream" /> keine bestimmte Position im Datenstrom suchen kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Sockets.NetworkStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether timeout properties are usable for <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <value><see langword="true" /> in allen Fällen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist vorhanden, da Sie von <xref:System.IO.Stream>geerbt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Sockets.NetworkStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> supports writing.</summary>
        <value><see langword="true" />, wenn Daten in die <see cref="T:System.Net.Sockets.NetworkStream" />geschrieben werden können. Andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> `true`ist, ermöglicht <xref:System.Net.Sockets.NetworkStream> Aufrufe der <xref:System.Net.Sockets.NetworkStream.Write%2A>-Methode. Geben Sie den entsprechenden <xref:System.IO.FileAccess> Enumerationswert im Konstruktor an, um die Lesbarkeit und Schreib barkeit des <xref:System.Net.Sockets.NetworkStream>festzulegen. Die <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>-Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> überprüft, um zu überprüfen, ob der <xref:System.Net.Sockets.NetworkStream> beschreibbar ist. Anschließend führt er einen Schreibvorgang für die <xref:System.Net.Sockets.NetworkStream>aus.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="networkStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Die `Close`-Methode gibt sowohl nicht verwaltete als auch verwaltete Ressourcen frei, die der <xref:System.Net.Sockets.NetworkStream>zugeordnet sind. Wenn das <xref:System.Net.Sockets.NetworkStream> die zugrunde liegende <xref:System.Net.Sockets.Socket>besitzt, wird es ebenfalls geschlossen.

Wenn eine <xref:System.Net.Sockets.NetworkStream> einer <xref:System.Net.Sockets.TcpClient>zugeordnet war, wird die TCP-Verbindung von der `Close`-Methode geschlossen, aber die zugeordnete <xref:System.Net.Sockets.TcpClient>wird nicht verworfen.

## Examples  
Im folgenden Codebeispiel wird der <xref:System.Net.Sockets.NetworkStream>geschlossen.

```vb
' Example for closing the NetworkStream.
' Close the NetworkStream
myNetworkStream.Close()
```

```csharp
// Example for closing the NetworkStream.

// Close the NetworkStream
myNetworkStream.Close();
```

```cpp
// Example for closing the NetworkStream.
// Close the NetworkStream
myNetworkStream->Close();
```

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="override this.Close : int -&gt; unit" Usage="networkStream.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout">A 32-bit signed integer that specifies the number of milliseconds to wait to send any remaining data before closing.</param>
        <summary>Closes the <see cref="T:System.Net.Sockets.NetworkStream" /> after waiting the specified time to allow data to be sent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.Close%2A>-Methode gibt sowohl nicht verwaltete als auch verwaltete Ressourcen frei, die der <xref:System.Net.Sockets.NetworkStream>zugeordnet sind. Wenn das <xref:System.Net.Sockets.NetworkStream> die zugrunde liegende <xref:System.Net.Sockets.Socket>besitzt, wird es ebenfalls geschlossen.  
  
 Wenn eine <xref:System.Net.Sockets.NetworkStream> einer <xref:System.Net.Sockets.TcpClient>zugeordnet war, wird die TCP-Verbindung von der <xref:System.Net.Sockets.NetworkStream.Close%2A>-Methode geschlossen, aber die zugeordnete <xref:System.Net.Sockets.TcpClient>wird nicht verworfen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="timeout" /> parameter is less than -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataAvailable">
      <MemberSignature Language="C#" Value="public virtual bool DataAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DataAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.DataAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DataAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool DataAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DataAvailable : bool" Usage="System.Net.Sockets.NetworkStream.DataAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether data is available on the <see cref="T:System.Net.Sockets.NetworkStream" /> to be read.</summary>
        <value><see langword="true" />, wenn Daten auf dem zu lesenden Stream verfügbar sind. Andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A>-Eigenschaft, um zu bestimmen, ob Daten zum Lesen bereit sind. Wenn <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> `true`ist, wird ein-Rückruf <xref:System.Net.Sockets.NetworkStream.Read%2A> sofort zurückgegeben. Wenn die Verbindung vom Remote Host heruntergefahren oder geschlossen wird, kann <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> eine <xref:System.Net.Sockets.SocketException>auslösen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird aus dem <xref:System.Net.Sockets.NetworkStream> gelesen, solange Daten verfügbar sind.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <exception cref="T:System.IO.IOException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code and refer to the <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">Windows Sockets version 2 API error code</see> documentation for a detailed description of the error.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="networkStream.Dispose disposing" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="networkStream.Dispose disposing" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.NetworkStream" /> and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen `Dispose`-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen. `Dispose` Ruft die geschützte `Dispose(Boolean)` Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist. <xref:System.Object.Finalize%2A> ruft `Dispose` auf, bei dem `disposing` auf `false`festgelegt ist.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Net.Sockets.NetworkStream> verweist. Diese Methode ruft die `Dispose`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden. Weitere Informationen zum Implementieren von <see langword="Dispose(Boolean)" />finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.  
  
Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="networkStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that represents an asynchronous call.</param>
        <summary>Handles the end of an asynchronous read.</summary>
        <returns>The number of bytes read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.EndRead%2A>-Methode beendet den asynchronen Lesevorgang, der in der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>-Methode gestartet wurde.  
  
 Vor dem Aufrufen von <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>müssen Sie eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> zurückgegeben hat. Die Rückruf Methode muss die <xref:System.IAsyncResult> akzeptieren, die von der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>-Methode als Parameter zurückgegeben wird.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Eigenschaft des <xref:System.IAsyncResult> auf, um das State-Objekt abzurufen, das an die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>-Methode übermittelt wird. Extrahieren Sie das empfangende <xref:System.Net.Sockets.NetworkStream> aus diesem Zustands Objekt. Nachdem Sie die <xref:System.Net.Sockets.NetworkStream>erhalten haben, können Sie die <xref:System.Net.Sockets.NetworkStream.EndRead%2A>-Methode aufrufen, um den Lesevorgang erfolgreich abzuschließen und die Anzahl der gelesenen Bytes zurückzugeben.  
  
 Die <xref:System.Net.Sockets.NetworkStream.EndRead%2A>-Methode blockiert, bis Daten verfügbar sind. Die <xref:System.Net.Sockets.NetworkStream.EndRead%2A>-Methode liest so viele Daten, wie Sie bis zur Anzahl der Bytes verfügbar sind, die im `size`-Parameter der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>-Methode angegeben sind. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.NetworkStream.EndRead%2A>-Methode sofort abgeschlossen und gibt 0 (null) Bytes zurück.  
  
 Rufen Sie zum Abrufen der empfangenen Daten die <xref:System.IAsyncResult.AsyncState%2A>-Eigenschaft des <xref:System.IAsyncResult>auf, und extrahieren Sie den Puffer, der im resultierenden State-Objekt enthalten ist.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException%2A>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird `myReadCallback` für <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> als Rückruf Methode bereitgestellt. <xref:System.Net.Sockets.NetworkStream.EndRead%2A> wird in `myReadCallback` implementiert, um den asynchronen Lese-, von <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>gestarteten Lesevorgang abzuschließen.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#5)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#5)]
 [!code-vb[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.  
  
-or- 
An error occurred when accessing the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="networkStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The <see cref="T:System.IAsyncResult" /> that represents the asynchronous call.</param>
        <summary>Handles the end of an asynchronous write.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> schließt den asynchronen Sendevorgang ab, der in <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>gestartet wurde.  
  
 Vor dem Aufrufen von <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>müssen Sie eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> zurückgegeben hat. Die Rückruf Methode muss die <xref:System.IAsyncResult> akzeptieren, die von der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>-Methode als Parameter zurückgegeben wird.  
  
 Rufen Sie die <xref:System.IAsyncResult.AsyncState%2A>-Eigenschaft des `IAsyncResult`-Parameters innerhalb der Rückruf Methode auf, um die <xref:System.Net.Sockets.NetworkStream>zu erhalten. Nachdem Sie die <xref:System.Net.Sockets.NetworkStream>erhalten haben, können Sie die <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>-Methode aufrufen, um den Sendevorgang erfolgreich abzuschließen und die Anzahl der gesendeten Bytes zurückzugeben.  
  
 Die <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>-Methode blockiert, bis die angeforderte Anzahl von Bytes gesendet wird.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException%2A>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird `myWriteCallback` für <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> als Rückruf Methode bereitgestellt. <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> wird in `myWriteCallback` implementiert, um den asynchronen Schreibzugriff abzuschließen, der von <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>gestartet wurde.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is closed.  
  
-or- 
An error occurred while writing to the network.  
  
-or- 
An error occurred when accessing the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NetworkStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NetworkStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="networkStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Der Anwendungscode sollte diese Methode nicht aufzurufen. die <xref:System.Object.Finalize%2A>-Methode eines Objekts wird automatisch während des Garbage Collection aufgerufen, es sei denn, die Garbage Collector wurde durch einen Aufruf der <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>-Methode deaktiviert.  
  
 Weitere Informationen zum Verwenden der Finalize-Methode finden Sie unter [Finalize-Methoden und-debugtoren](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md)und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="networkStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Flushes data from the stream. This method is reserved for future use.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.Flush%2A>-Methode implementiert die <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>-Methode. Da <xref:System.Net.Sockets.NetworkStream> jedoch nicht gepuffert wird, hat dies keine Auswirkungen auf Netzwerkdaten Ströme. Wenn Sie die <xref:System.Net.Sockets.NetworkStream.Flush%2A>-Methode aufrufen, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="networkStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">A cancellation token used to propagate notification that this  operation should be canceled.</param>
        <summary>Flushes data from the stream as an asynchronous operation.</summary>
        <returns>The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurückgegebene <xref:System.Threading.Tasks.Task> Objekt wird abgeschlossen, nachdem Daten für die <xref:System.Net.Sockets.NetworkStream> Instanz aus dem Datenstrom gelöscht wurden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Sockets.NetworkStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the length of the data available on the stream. This property is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</summary>
        <value>Die Länge der Daten, die im Stream verfügbar sind.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Sockets.NetworkStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current position in the stream. This property is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</summary>
        <value>Die aktuelle Position in dem Stream.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="networkStream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">A region of memory to store data read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Reads data from the <see cref="T:System.Net.Sockets.NetworkStream" /> and stores it to a span of bytes in memory.</summary>
        <returns>The number of bytes read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest so viele Daten, wie Sie im `buffer`-Parameter verfügbar sind, und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.
  
> [!NOTE]
>  Überprüfen Sie, ob die <xref:System.Net.Sockets.NetworkStream> lesbar ist, indem Sie die <xref:System.Net.Sockets.NetworkStream.CanRead>-Eigenschaft aufrufen. Wenn Sie versuchen, aus einer <xref:System.Net.Sockets.NetworkStream> zu lesen, die nicht lesbar ist, erhalten Sie eine <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.NetworkStream" /> does not support reading.</exception>
        <exception cref="T:System.IO.IOException">An error occurred when accessing the socket.

-or-

There is a failure reading from the network.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 size) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, size As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="networkStream.Read (buffer, offset, size)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 size) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the location in memory to store data read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in <paramref name="buffer" /> to begin storing the data to.</param>
        <param name="size">The number of bytes to read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Reads data from the <see cref="T:System.Net.Sockets.NetworkStream" /> and stores it to a byte array.</summary>
        <returns>The number of bytes read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest Daten in `buffer` und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Der `Read` Vorgang liest so viele Daten wie verfügbar, bis zur Anzahl der Bytes, die durch den Parameter `size` angegeben werden.
  
> [!NOTE]
>  Überprüfen Sie, ob die <xref:System.Net.Sockets.NetworkStream> lesbar ist, indem Sie die <xref:System.Net.Sockets.NetworkStream.CanRead>-Eigenschaft aufrufen. Wenn Sie versuchen, aus einer <xref:System.Net.Sockets.NetworkStream> zu lesen, die nicht lesbar ist, erhalten Sie eine <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> verwendet, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn Daten verfügbar sind, liest Sie aus der <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus <paramref name="offset" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.NetworkStream" /> does not support reading.</exception>
        <exception cref="T:System.IO.IOException">An error occurred when accessing the socket.

-or-

There is a failure reading from the network.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <related type="Article" href="~/docs/framework/network-programming/using-streams-on-the-network.md">Verwenden von Streams im Netzwerk</related>
      </Docs>
    </Member>
    <Member MemberName="Readable">
      <MemberSignature Language="C#" Value="protected bool Readable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Readable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Readable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Readable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Readable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Readable : bool with get, set" Usage="System.Net.Sockets.NetworkStream.Readable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> can be read.</summary>
        <value><see langword="true" />, um anzugeben, dass die <see cref="T:System.Net.Sockets.NetworkStream" /> gelesen werden kann. Andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen von der <xref:System.Net.Sockets.NetworkStream>-Klasse ableiten, um die <xref:System.Net.Sockets.NetworkStream.Readable%2A>-Eigenschaft zu verwenden. Wenn <xref:System.Net.Sockets.NetworkStream.Readable%2A> `true`ist, ermöglicht <xref:System.Net.Sockets.NetworkStream> Aufrufe der <xref:System.Net.Sockets.NetworkStream.Read%2A>-Methode. Sie können auch bestimmen, ob ein <xref:System.Net.Sockets.NetworkStream> lesbar ist, indem Sie die öffentlich zugängliche <xref:System.Net.Sockets.NetworkStream.CanRead%2A>-Eigenschaft überprüfen.  
  
 Die <xref:System.Net.Sockets.NetworkStream.Readable%2A>-Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel überprüft die `CanCommunicate`-Eigenschaft die <xref:System.Net.Sockets.NetworkStream.Readable%2A>-Eigenschaft, um zu bestimmen, ob die <xref:System.Net.Sockets.NetworkStream> lesbar ist.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="networkStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to write the data to.</param>
        <param name="cancellationToken">The token to monitor for cancellation requests.</param>
        <summary>Reads data from the <see cref="T:System.Net.Sockets.NetworkStream" /> and stores it in a byte memory range as an asynchronous operation.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1" /> that represents the asynchronous read operation. The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into <paramref name="buffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Diese Methode liest so viele Daten, wie Sie in `buffer` verfügbar sind, und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.

> [!NOTE]
>  Überprüfen Sie, ob die <xref:System.Net.Sockets.NetworkStream> lesbar ist, indem Sie die <xref:System.Net.Sockets.NetworkStream.CanRead>-Eigenschaft aufrufen. Wenn Sie versuchen, aus einer <xref:System.Net.Sockets.NetworkStream> zu lesen, die nicht lesbar ist, erhalten Sie eine <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.NetworkStream" /> does not support reading.</exception>
        <exception cref="T:System.IO.IOException">An error occurred when accessing the socket.

-or-

There is a failure reading from the network.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="networkStream.ReadAsync (buffer, offset, size, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to write the data into.</param>
        <param name="offset">The location in <paramref name="buffer" /> to begin storing the data to.</param>
        <param name="size">The number of bytes to read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="cancellationToken">The token to monitor for cancellation requests.</param>
        <summary>Reads data from the <see cref="T:System.Net.Sockets.NetworkStream" /> and stores it to a specified range of a byte array as an asynchronous operation.</summary>
        <returns>A task that represents the asynchronous read operation. The value of its <see cref="P:System.Threading.Tasks.Task`1.Result" /> property contains the total number of bytes read into <paramref name="buffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest Daten in `buffer` und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Der `ReadAsync` Vorgang liest so viele Daten wie verfügbar, bis zur Anzahl der Bytes, die durch den Parameter `size` angegeben werden.

> [!NOTE]
>  Überprüfen Sie, ob die <xref:System.Net.Sockets.NetworkStream> lesbar ist, indem Sie die <xref:System.Net.Sockets.NetworkStream.CanRead>-Eigenschaft aufrufen. Wenn Sie versuchen, aus einer <xref:System.Net.Sockets.NetworkStream> zu lesen, die nicht lesbar ist, erhalten Sie eine <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.NetworkStream" /> does not support reading.</exception>
        <exception cref="T:System.IO.IOException">An error occurred when accessing the socket.

-or-

There is a failure reading from the network.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="networkStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reads a byte from the <see cref="T:System.Net.Sockets.NetworkStream" /> and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</summary>
        <returns>The unsigned byte cast to an <see langword="Int32" />, or -1 if at the end of the stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!NOTE]
>  Überprüfen Sie, ob die <xref:System.Net.Sockets.NetworkStream> lesbar ist, indem Sie die <xref:System.Net.Sockets.NetworkStream.CanRead>-Eigenschaft aufrufen. Wenn Sie versuchen, aus einer <xref:System.Net.Sockets.NetworkStream> zu lesen, die nicht lesbar ist, erhalten Sie eine <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.NetworkStream" /> does not support reading.</exception>
        <exception cref="T:System.IO.IOException">An error occurred when accessing the socket.

-or-

There is a failure reading from the network.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Sockets.NetworkStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the amount of time that a read operation blocks waiting for data.</summary>
        <value>Ein-<see cref="T:System.Int32" />, der die Zeitspanne in Millisekunden angibt, die verbleibt, bevor ein Lesevorgang fehlschlägt. Der Standardwert <see cref="F:System.Threading.Timeout.Infinite" />gibt an, dass für den Lesevorgang kein Timeout auftritt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Lesevorgang nicht innerhalb der von dieser Eigenschaft angegebenen Zeit ausgeführt wird, löst der Lesevorgang eine <xref:System.IO.IOException>aus.  
  
> [!NOTE]
>  Diese Eigenschaft wirkt sich nur auf synchrone Lesevorgänge aus, die durch Aufrufen der-Methode <xref:System.Net.Sockets.NetworkStream.Read%2A> Diese Eigenschaft wirkt sich nicht auf asynchrone Lesevorgänge aus, die durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>-Methode ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Lese Timeout für einen Netzwerkstream auf 10 Millisekunden festgelegt.  
  
 [!code-csharp[NCLTcpClientSync#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than or equal to zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="networkStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">This parameter is not used.</param>
        <param name="origin">This parameter is not used.</param>
        <summary>Sets the current position of the stream to the given value. This method is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</summary>
        <returns>The position in the stream.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="networkStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">This parameter is not used.</param>
        <summary>Sets the length of the stream. This method always throws a <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
      </Docs>
    </Member>
    <Member MemberName="Socket">
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Socket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Socket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Socket" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Socket As Socket" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Net::Sockets::Socket ^ Socket { System::Net::Sockets::Socket ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Socket : System.Net.Sockets.Socket" Usage="System.Net.Sockets.NetworkStream.Socket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the underlying <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Eine <see cref="T:System.Net.Sockets.Socket" />, die die zugrunde liegende Netzwerkverbindung darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von <xref:System.Net.Sockets.NetworkStream> abgeleitete Klassen können diese Eigenschaft verwenden, um die zugrunde liegende <xref:System.Net.Sockets.Socket>zu erhalten. Verwenden Sie die zugrunde liegende <xref:System.Net.Sockets.Socket>, die von der <xref:System.Net.Sockets.NetworkStream.Socket%2A>-Eigenschaft zurückgegeben wird, wenn Sie über die, die <xref:System.Net.Sockets.NetworkStream> bereitstellt,  
  
> [!NOTE]
>  Auf diese Eigenschaft kann nur über diese Klasse oder eine abgeleitete Klasse zugegriffen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die zugrunde liegende <xref:System.Net.Sockets.Socket> abgerufen, um eine aktive Verbindung zu überprüfen.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Rufen Sie `Dispose` auf, wenn Sie <xref:System.Net.Sockets.NetworkStream> nicht mehr benötigen. Die `Dispose`-Methode bewirkt, dass <xref:System.Net.Sockets.NetworkStream> nicht mehr verwendet werden kann. Nachdem Sie `Dispose`aufgerufen haben, müssen Sie alle Verweise auf die <xref:System.Net.Sockets.NetworkStream> freigeben, damit der Garbage Collector den Speicher freigeben kann, den der <xref:System.Net.Sockets.NetworkStream> belegt hat. Weitere Informationen zur Verwendung der verwerfen-Methode finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.

> [!NOTE]
> Rufen Sie immer `Dispose` auf, bevor Sie den letzten Verweis auf das <xref:System.Net.Sockets.NetworkStream> freigeben. Andernfalls werden die verwendeten Ressourcen nicht freigegeben, bis die Garbage Collector die Finalize-Methode des <xref:System.Net.Sockets.NetworkStream>-Objekts aufruft.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="networkStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">The data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Writes data to the <see cref="T:System.Net.Sockets.NetworkStream" />  from a read-only byte span.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Diese Methode sendet alle Bytes in `buffer` an das Netzwerk. Die `Write`-Methode blockiert, bis die angeforderte Anzahl von Bytes gesendet oder ein <xref:System.Net.Sockets.SocketException> ausgelöst wird.

> [!NOTE]
> Überprüfen Sie, ob der <xref:System.Net.Sockets.NetworkStream> beschreibbar ist, indem Sie die <xref:System.Net.Sockets.NetworkStream.CanWrite>-Eigenschaft aufrufen. Wenn Sie versuchen, in eine <xref:System.Net.Sockets.NetworkStream> zu schreiben, die nicht beschreibbar ist, erhalten Sie eine <xref:System.InvalidOperationException>.

> [!NOTE]
> Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der API-Fehlercode Dokumentation von Windows Sockets, Version 2.

]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.NetworkStream" /> does not support writing.</exception>
        <exception cref="T:System.IO.IOException">An error occurred when accessing the socket.

-or-

There was a failure while writing to the network.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="networkStream.Write (buffer, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in <paramref name="buffer" /> from which to start writing data.</param>
        <param name="size">The number of bytes to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Writes data to the <see cref="T:System.Net.Sockets.NetworkStream" /> from a specified range of a byte array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Diese Methode beginnt am angegebenen `offset` und sendet `size` Bytes aus dem Inhalt von `buffer` an das Netzwerk. Die `Write`-Methode blockiert, bis die angeforderte Anzahl von Bytes gesendet oder ein <xref:System.Net.Sockets.SocketException> ausgelöst wird. 
  
> [!NOTE]
> Überprüfen Sie, ob der <xref:System.Net.Sockets.NetworkStream> beschreibbar ist, indem Sie die <xref:System.Net.Sockets.NetworkStream.CanWrite>-Eigenschaft aufrufen. Wenn Sie versuchen, in eine <xref:System.Net.Sockets.NetworkStream> zu schreiben, die nicht beschreibbar ist, erhalten Sie eine <xref:System.InvalidOperationException>.

> [!NOTE]
> Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der API-Fehlercode Dokumentation von Windows Sockets, Version 2.

  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob die <xref:System.Net.Sockets.NetworkStream> beschreibbar ist. Wenn dies der Fall ist, wird <xref:System.Net.Sockets.NetworkStream.Write%2A> verwendet, um eine kleine Nachricht zu schreiben.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  
  
-or- 
The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.  
  
-or- 
The <paramref name="size" /> parameter is less than 0.  
  
-or- 
The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.NetworkStream" /> does not support writing.</exception>
        <exception cref="T:System.IO.IOException">An error occurred when accessing the socket.

-or-

There was a failure while writing to the network.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="Writeable">
      <MemberSignature Language="C#" Value="protected bool Writeable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Writeable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Writeable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Writeable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Writeable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Writeable : bool with get, set" Usage="System.Net.Sockets.NetworkStream.Writeable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> is writable.</summary>
        <value><see langword="true" />, wenn Daten in den Stream geschrieben werden können. Andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen von der <xref:System.Net.Sockets.NetworkStream>-Klasse ableiten, um die <xref:System.Net.Sockets.NetworkStream.Writeable%2A>-Eigenschaft zu verwenden. Wenn <xref:System.Net.Sockets.NetworkStream.Writeable%2A> `true`ist, ermöglicht <xref:System.Net.Sockets.NetworkStream> Aufrufe der <xref:System.Net.Sockets.NetworkStream.Write%2A>-Methode. Sie können auch bestimmen, ob ein <xref:System.Net.Sockets.NetworkStream> beschreibbar ist, indem Sie die öffentlich zugängliche <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>-Eigenschaft überprüfen.  
  
 Die <xref:System.Net.Sockets.NetworkStream.Writeable%2A>-Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel überprüft die `CanCommunicate`-Eigenschaft die <xref:System.Net.Sockets.NetworkStream.Writeable%2A>-Eigenschaft, um zu bestimmen, ob die <xref:System.Net.Sockets.NetworkStream> beschreibbar ist.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="networkStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">A region of memory that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="cancellationToken">The token to monitor for cancellation requests.</param>
        <summary>Writes data to the <see cref="T:System.Net.Sockets.NetworkStream" /> from a read-only memory byte memory range as an asynchronous operation.</summary>
        <returns>A task that represents the asynchronous write operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks 
Diese Methode sendet alle Bytes in `buffer` an das Netzwerk.

> [!NOTE]
> Überprüfen Sie, ob der <xref:System.Net.Sockets.NetworkStream> beschreibbar ist, indem Sie die <xref:System.Net.Sockets.NetworkStream.CanWrite>-Eigenschaft aufrufen. Wenn Sie versuchen, in eine <xref:System.Net.Sockets.NetworkStream> zu schreiben, die nicht beschreibbar ist, erhalten Sie eine <xref:System.InvalidOperationException>.

> [!NOTE]
> Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der API-Fehlercode Dokumentation von Windows Sockets, Version 2.

]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.NetworkStream" /> does not support writing.</exception>
        <exception cref="T:System.IO.IOException">An error occurred when accessing the socket.

-or-

There was a failure while writing to the network.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="networkStream.WriteAsync (buffer, offset, size, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">A byte array that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in <paramref name="buffer" /> from which to start writing data.</param>
        <param name="size">The number of bytes to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="cancellationToken">The token to monitor for cancellation requests.</param>
        <summary>Writes data to the <see cref="T:System.Net.Sockets.NetworkStream" /> from the specified range of a byte array as an asynchronous operation.</summary>
        <returns>A task that represents the asynchronous write operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks 
Diese Methode beginnt am angegebenen `offset` und sendet `size` Bytes aus dem Inhalt von `buffer` an das Netzwerk.

> [!NOTE]
> Überprüfen Sie, ob der <xref:System.Net.Sockets.NetworkStream> beschreibbar ist, indem Sie die <xref:System.Net.Sockets.NetworkStream.CanWrite>-Eigenschaft aufrufen. Wenn Sie versuchen, in eine <xref:System.Net.Sockets.NetworkStream> zu schreiben, die nicht beschreibbar ist, erhalten Sie eine <xref:System.InvalidOperationException>.

> [!NOTE]
> Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der API-Fehlercode Dokumentation von Windows Sockets, Version 2.

]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  
  
-or- 
The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.  
  
-or- 
The <paramref name="size" /> parameter is less than 0.  
  
-or- 
The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.NetworkStream" /> does not support writing.</exception>
        <exception cref="T:System.IO.IOException">There was a failure while writing to the network.  
  
 -or-  
  
 An error occurred when accessing the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="networkStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">The byte to write to the stream.</param>
        <summary>Writes a byte to the current position in the <see cref="T:System.Net.Sockets.NetworkStream" /> and advances the position within the stream by one byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

> [!NOTE]
> Überprüfen Sie, ob der <xref:System.Net.Sockets.NetworkStream> beschreibbar ist, indem Sie die <xref:System.Net.Sockets.NetworkStream.CanWrite>-Eigenschaft aufrufen. Wenn Sie versuchen, in eine <xref:System.Net.Sockets.NetworkStream> zu schreiben, die nicht beschreibbar ist, erhalten Sie eine <xref:System.InvalidOperationException>.

> [!NOTE]
> Wenn Sie eine <xref:System.IO.IOException>erhalten, überprüfen Sie die <xref:System.Exception.InnerException>-Eigenschaft, um festzustellen, ob Sie durch eine <xref:System.Net.Sockets.SocketException>verursacht wurde. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der API-Fehlercode Dokumentation von Windows Sockets, Version 2.

]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.NetworkStream" /> does not support writing.</exception>
        <exception cref="T:System.IO.IOException">An error occurred when accessing the socket.

-or-

There was a failure while writing to the network.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Sockets.NetworkStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the amount of time that a write operation blocks waiting for data.</summary>
        <value>Ein-<see cref="T:System.Int32" />, der die Zeitspanne in Millisekunden angibt, die verbleibt, bevor ein Schreibvorgang fehlschlägt. Der Standardwert <see cref="F:System.Threading.Timeout.Infinite" />gibt an, dass für den Schreibvorgang kein Timeout auftritt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schreibvorgang nicht innerhalb der von dieser Eigenschaft angegebenen Zeit ausgeführt wird, löst der Schreibvorgang eine <xref:System.IO.IOException>aus.  
  
> [!NOTE]
>  Diese Eigenschaft wirkt sich nur auf synchrone Schreibvorgänge aus, die durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode ausgeführt werden Diese Eigenschaft wirkt sich nicht auf asynchrone Schreibvorgänge aus, die durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>-Methode ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Schreib Timeout für einen Netzwerkstream auf 10 Millisekunden festgelegt.  
  
 [!code-cpp[NCLTcpServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclTcpServerSync/cpp/tcplistener.cpp#0)]
 [!code-csharp[NCLTcpServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclTcpServerSync/CS/tcplistener.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than or equal to zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
