<Type Name="NetworkStream" FullName="System.Net.Sockets.NetworkStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fb7fd37bdc38c655879b64066b25f8107d50eada" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52207669" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NetworkStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetworkStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.NetworkStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NetworkStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetworkStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type NetworkStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Docs>
    <summary>Stellt den zugrunde liegenden Datenstrom für den Netzwerkzugriff bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> -Klasse stellt Methoden zum Senden und Empfangen von Daten über <xref:System.Net.Sockets.SocketType.Stream> Sockets im blockierenden Modus befindet. Weitere Informationen zu blockierende und nicht blockierenden <xref:System.Net.Sockets.Socket>s, finden Sie unter [Verwenden von asynchronen Clientsockets](~/docs/framework/network-programming/using-an-asynchronous-client-socket.md). Sie können die <xref:System.Net.Sockets.NetworkStream> -Klasse für beide synchrone und asynchrone Datenübertragung. Weitere Informationen zu synchronen und asynchronen Kommunikation, finden Sie unter [Sockets](~/docs/framework/network-programming/sockets.md).  
  
 Zum Erstellen einer <xref:System.Net.Sockets.NetworkStream>, müssen Sie ein verbundenes bereitstellen <xref:System.Net.Sockets.Socket>. Sie können auch angeben, welche <xref:System.IO.FileAccess> Berechtigung der <xref:System.Net.Sockets.NetworkStream> verfügt über den angegebenen <xref:System.Net.Sockets.Socket>. Standardmäßig schließen die <xref:System.Net.Sockets.NetworkStream> schließt nicht die angegebene <xref:System.Net.Sockets.Socket>. Wenn Sie möchten die <xref:System.Net.Sockets.NetworkStream> Berechtigung zu der bereitgestellten schließen <xref:System.Net.Sockets.Socket>, müssen Sie angeben `true` für den Wert des der `ownsSocket` Parameter.  
  
 Verwenden der <xref:System.Net.Sockets.NetworkStream.Write%2A> und <xref:System.Net.Sockets.NetworkStream.Read%2A> Methoden für einfache einzelne thread synchron-blockierende e/a. Wenn Sie Ihre e/a mit separaten Threads verarbeiten möchten, sollten Sie verwenden die <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> und <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Methoden oder <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> und <xref:System.Net.Sockets.NetworkStream.EndRead%2A> Methoden für die Kommunikation.  
  
 Die <xref:System.Net.Sockets.NetworkStream> wahlfreien Zugriff auf den Netzwerk-Datenstrom nicht unterstützt. Der Wert des der <xref:System.Net.Sockets.NetworkStream.CanSeek%2A> -Eigenschaft, die angibt, ob der Stream Suchvorgänge unterstützt, ist immer `false`; Lesen der <xref:System.Net.Sockets.NetworkStream.Position%2A> Lesen-Eigenschaft der <xref:System.Net.Sockets.NetworkStream.Length%2A> Eigenschaft oder das Aufrufen der <xref:System.Net.Sockets.NetworkStream.Seek%2A> Methode löst eine <xref:System.NotSupportedException>.  
  
 Lesen und Schreiben Sie Vorgänge können gleichzeitig ausgeführt werden, auf einer Instanz von der <xref:System.Net.Sockets.NetworkStream> Klasse, ohne die Notwendigkeit einer Synchronisierung. Solange eine eindeutige Thread für die Write-Vorgänge und einem eindeutigen Thread für die Lesevorgänge vorhanden sind, es werden keine Cross-Störungen zwischen Lese- und Schreibzugriff Threads und keine Synchronisierung ist erforderlich.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen einer <xref:System.Net.Sockets.NetworkStream> aus einem verbundenen <xref:System.Net.Sockets.SocketType.Stream> <xref:System.Net.Sockets.Socket> und grundlegende synchrone blockierende e/a ausführen.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Net.Sockets.NetworkStream" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream socket" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <param name="socket">Der <see cref="T:System.Net.Sockets.Socket" />, den der <see cref="T:System.Net.Sockets.NetworkStream" /> zum Senden und Empfangen von Daten verwendet.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Net.Sockets.NetworkStream" />-Klasse für den angegebenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird mit Lese-/Schreibzugriff auf den angegebenen erstellt <xref:System.Net.Sockets.Socket>. Die <xref:System.Net.Sockets.NetworkStream> besitzt nicht die zugrunde liegende <xref:System.Net.Sockets.Socket>, daher wird durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.Close%2A> Methode schließt nicht die <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen einer <xref:System.Net.Sockets.NetworkStream> mit einem <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="socket" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der <paramref name="socket" />-Parameter ist nicht verbunden.  
  
- oder -  
Die <see cref="P:System.Net.Sockets.Socket.SocketType" />-Eigenschaft des <paramref name="socket" />-Parameters ist nicht <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
- oder -  
Der <paramref name="socket" />-Parameter befindet sich in einem nicht blockierenden Zustand.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
        <related type="Article" href="~/docs/framework/network-programming/using-streams-on-the-network.md">Verwenden von Streams im Netzwerk</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, bool ownsSocket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * bool -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, ownsSocket)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket">Der <see cref="T:System.Net.Sockets.Socket" />, den der <see cref="T:System.Net.Sockets.NetworkStream" /> zum Senden und Empfangen von Daten verwendet.</param>
        <param name="ownsSocket">Legen Sie den Wert <see langword="true" /> fest, um anzugeben, dass der <see cref="T:System.Net.Sockets.NetworkStream" /> den Besitz des <see cref="T:System.Net.Sockets.Socket" /> übernimmt, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.NetworkStream" />-Klasse für den angegebenen <see cref="T:System.Net.Sockets.Socket" /> mit dem angegebenen Besitz von <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird mit Lese-/Schreibzugriff auf den angegebenen erstellt <xref:System.Net.Sockets.Socket>. Wenn der Wert des `ownsSocket` -Parameter ist `true`, die <xref:System.Net.Sockets.NetworkStream> übernimmt den Besitz des zugrunde liegenden <xref:System.Net.Sockets.Socket>, und das Aufrufen der <xref:System.Net.Sockets.NetworkStream.Close%2A> auch Methode schließt den zugrunde liegenden <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.Sockets.NetworkStream> mit den Besitz der <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="socket" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der <paramref name="socket" />-Parameter ist nicht verbunden.  
  
- oder -  
Der Wert der <see cref="P:System.Net.Sockets.Socket.SocketType" />-Eigenschaft des <paramref name="socket" />-Parameters ist nicht <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
- oder -  
Der <paramref name="socket" />-Parameter befindet sich in einem nicht blockierenden Zustand.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * System.IO.FileAccess -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="socket">Der <see cref="T:System.Net.Sockets.Socket" />, den der <see cref="T:System.Net.Sockets.NetworkStream" /> zum Senden und Empfangen von Daten verwendet.</param>
        <param name="access">Eine bitweise Kombination der <see cref="T:System.IO.FileAccess" />-Werte, die den gewährten Zugriffstyp für <see cref="T:System.Net.Sockets.NetworkStream" /> über den angegebenen <see cref="T:System.Net.Sockets.Socket" /> angeben.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Net.Sockets.NetworkStream" />-Klasse für den angegebenen <see cref="T:System.Net.Sockets.Socket" /> mit den angegebenen Zugriffsrechten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird erstellt, mit dem angegebenen Zugriff auf den angegebenen <xref:System.Net.Sockets.Socket>. Mit diesem Konstruktor die <xref:System.Net.Sockets.NetworkStream> besitzt nicht die zugrunde liegende <xref:System.Net.Sockets.Socket>, daher wird durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.Close%2A> Methode schließt nicht die zugrunde liegende <xref:System.Net.Sockets.Socket>.  
  
 Die `access` Parametersätze der <xref:System.Net.Sockets.NetworkStream.CanRead%2A> und <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> Eigenschaften der <xref:System.Net.Sockets.NetworkStream>. Bei Angabe von <xref:System.IO.FileAccess.Write>, und klicken Sie dann die <xref:System.Net.Sockets.NetworkStream> ermöglicht Aufrufe der <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode. Bei Angabe von <xref:System.IO.FileAccess.Read>, und klicken Sie dann die <xref:System.Net.Sockets.NetworkStream> ermöglicht Aufrufe der <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode. Bei Angabe von <xref:System.IO.FileAccess.ReadWrite>, beide-Methodenaufrufe zulässig sind.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.Sockets.NetworkStream> mit der Möglichkeit zum Lesen und Schreiben in die <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="socket" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der <paramref name="socket" />-Parameter ist nicht verbunden.  
  
- oder -  
Die <see cref="P:System.Net.Sockets.Socket.SocketType" />-Eigenschaft des <paramref name="socket" />-Parameters ist nicht <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
- oder -  
Der <paramref name="socket" />-Parameter befindet sich in einem nicht blockierenden Zustand.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.NetworkStream : System.Net.Sockets.Socket * System.IO.FileAccess * bool -&gt; System.Net.Sockets.NetworkStream" Usage="new System.Net.Sockets.NetworkStream (socket, access, ownsSocket)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket">Der <see cref="T:System.Net.Sockets.Socket" />, den der <see cref="T:System.Net.Sockets.NetworkStream" /> zum Senden und Empfangen von Daten verwendet.</param>
        <param name="access">Eine bitweise Kombination der <see cref="T:System.IO.FileAccess" />-Werte, die den gewährten Zugriffstyp für <see cref="T:System.Net.Sockets.NetworkStream" /> über den bereitgestellten <see cref="T:System.Net.Sockets.Socket" /> angibt.</param>
        <param name="ownsSocket">Legen Sie den Wert <see langword="true" /> fest, um anzugeben, dass der <see cref="T:System.Net.Sockets.NetworkStream" /> den Besitz des <see cref="T:System.Net.Sockets.Socket" /> übernimmt, andernfalls <see langword="false" />.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Net.Sockets.NetworkStream" />-Klasse für den angegebenen <see cref="T:System.Net.Sockets.Socket" /> mit den angegebenen Zugriffsrechten und dem angegebenen Besitz von <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird mit Lese-/Schreibzugriff auf den angegebenen erstellt <xref:System.Net.Sockets.Socket>. Wenn der Wert des der `ownsSocket` -Parameter ist `true`, wird die <xref:System.Net.Sockets.NetworkStream> übernimmt den Besitz des zugrunde liegenden <xref:System.Net.Sockets.Socket>, und Aufrufen der <xref:System.Net.Sockets.NetworkStream.Close%2A> auch Methode schließt den zugrunde liegenden <xref:System.Net.Sockets.Socket>.  
  
 Die `access` Parametersätze der <xref:System.Net.Sockets.NetworkStream.CanRead%2A> und <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> Eigenschaften der <xref:System.Net.Sockets.NetworkStream>. Bei Angabe von <xref:System.IO.FileAccess.Write>, und klicken Sie dann die <xref:System.Net.Sockets.NetworkStream> ermöglicht Aufrufe der <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode. Bei Angabe von <xref:System.IO.FileAccess.Read>, und klicken Sie dann die <xref:System.Net.Sockets.NetworkStream> ermöglicht Aufrufe der <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode. Bei Angabe von <xref:System.IO.FileAccess.ReadWrite>, beide-Methodenaufrufe zulässig sind.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.Sockets.NetworkStream> mit der Möglichkeit zum Lesen und Schreiben in die <xref:System.Net.Sockets.Socket>. Den Besitz der <xref:System.Net.Sockets.Socket> erhält dieser <xref:System.Net.Sockets.NetworkStream> durch Angabe `true` für die `ownsSocket` Parameter.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="socket" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der <paramref name="socket" />-Parameter ist nicht verbunden.  
  
- oder -  
Die <see cref="P:System.Net.Sockets.Socket.SocketType" />-Eigenschaft des <paramref name="socket" />-Parameters ist nicht <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
- oder -  
Der <paramref name="socket" />-Parameter befindet sich in einem nicht blockierenden Zustand.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="networkStream.BeginRead (buffer, offset, size, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das dem Speicherort entspricht, an dem aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> gelesene Daten gespeichert werden.</param>
        <param name="offset">Die Position in <paramref name="buffer" />, an der mit dem Speichern der Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl der aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> zu lesenden Bytes.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der nach Abschluss von <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> ausgeführt wird.</param>
        <param name="state">Ein Objekt, das zusätzliche, benutzerdefinierte Daten enthält.</param>
        <summary>Beginnt einen asynchronen Lesevorgang aus dem <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Aufruf darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode mit dem asynchronen Lesen von Daten aus den eingehenden Netzwerkpuffern beginnt. Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode bietet Ihnen die Möglichkeit, Daten in einem separaten Ausführungsthread zu erhalten.  
  
 Sie müssen eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode. Zumindest Ihre `state` muss Parameter enthalten den <xref:System.Net.Sockets.NetworkStream>. Da Sie die empfangenen Daten in der Rückrufmethode abrufen möchten, sollten Sie eine kleine Klasse oder Struktur für einen Lesepuffer und andere nützliche Informationen erstellen. Übergeben Sie die Struktur oder Klasse, Instanz, die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, wartet das System, bis die Daten werden empfangen, oder ein Fehler auftritt, und klicken Sie dann das System verwendet einen separaten Thread Ausführungsberechtigungen für die angegebene Rückrufmethode und Blöcke auf <xref:System.Net.Sockets.NetworkStream.EndRead%2A> bis bereitgestellten <xref:System.Net.Sockets.NetworkStream> liest Daten oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode. Rufen Sie <xref:System.Threading.EventWaitHandle.Set%2A> in die Callback-Methode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode liest so viele Daten wie verfügbar ist, bis die Anzahl der Bytes, die gemäß der `size` Parameter.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.IO.IOException>, überprüfen die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob es durch verursacht wurde eine <xref:System.Net.Sockets.SocketException>. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode abzurufen, und finden Sie unter der [Fehlercode von Windows Sockets-Version 2-API](/windows/desktop/winsock/windows-sockets-error-codes-2) Dokumentation für eine ausführliche Beschreibung des Fehlers.  
  
 Lesen und Schreiben Sie Vorgänge können gleichzeitig ausgeführt werden, auf einer Instanz von der <xref:System.Net.Sockets.NetworkStream> Klasse, ohne die Notwendigkeit einer Synchronisierung. Solange eine eindeutige Thread für die Write-Vorgänge und einem eindeutigen Thread für die Lesevorgänge vorhanden sind, es werden keine Cross-Störungen zwischen Lese- und Schreibzugriff Threads und keine Synchronisierung ist erforderlich.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> zum asynchronen Lesen von Daten aus dem Netzwerkstream. Die `myReadCallBack` Methode implementiert die <xref:System.AsyncCallback> delegieren und wird vom System aufgerufen, wenn <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> zurückgibt.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter ist kleiner als 0.  
  
- oder -  
Der <paramref name="offset" />-Parameter ist größer als die Länge des <paramref name="buffer" />-Parameters.  
  
- oder -  
Die <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
Der <paramref name="size" />-Parameter ist größer als die Länge von <paramref name="buffer" /> abzüglich des Werts des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.  
  
- oder -  
Beim Lesen aus dem Netzwerk ist ein Fehler aufgetreten.  
  
- oder -  
Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="networkStream.BeginWrite (buffer, offset, size, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die Daten enthält, die in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden sollen.</param>
        <param name="offset">Die Position im <paramref name="buffer" />, an der mit dem Senden der Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl der Bytes, die in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden sollen.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der nach Abschluss von <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> ausgeführt wird.</param>
        <param name="state">Ein Objekt, das zusätzliche, benutzerdefinierte Daten enthält.</param>
        <summary>Beginnt einen asynchronen Schreibvorgang in einen Stream.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Aufruf darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost. Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Methode bietet Ihnen die Möglichkeit, Daten in einem separaten Ausführungsthread zu senden.  
  
 Sie müssen eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Methode. Zumindest Ihre `state` muss Parameter enthalten den <xref:System.Net.Sockets.NetworkStream>. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen, eine kleine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.NetworkStream> und die weiteren erforderlichen Informationen. Übergeben Sie die Struktur oder Klasse, Instanz, die <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode implementieren sollte die <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, das System verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert für <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> erst die <xref:System.Net.Sockets.NetworkStream> sendet die Anzahl der angeforderten Bytes, oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode. Rufen Sie <xref:System.Threading.EventWaitHandle.Set%2A> in die Callback-Methode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.IO.IOException>, überprüfen die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob es durch verursacht wurde eine <xref:System.Net.Sockets.SocketException>. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode abzurufen, und finden Sie unter der [Fehlercode von Windows Sockets-Version 2-API](/windows/desktop/winsock/windows-sockets-error-codes-2) Dokumentation für eine ausführliche Beschreibung des Fehlers.  
  
 Lesen und Schreiben Sie Vorgänge können gleichzeitig ausgeführt werden, auf einer Instanz von der <xref:System.Net.Sockets.NetworkStream> Klasse, ohne die Notwendigkeit einer Synchronisierung. Solange eine eindeutige Thread für die Write-Vorgänge und einem eindeutigen Thread für die Lesevorgänge vorhanden sind, es werden keine Cross-Störungen zwischen Lese- und Schreibzugriff Threads und keine Synchronisierung ist erforderlich.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Daten asynchron in einen Netzwerkdatenstrom geschrieben. Die `myWriteCallBack` Methode implementiert die <xref:System.AsyncCallback> delegieren und wird vom System aufgerufen, wenn <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> zurückgibt.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter ist kleiner als 0.  
  
- oder -  
Der <paramref name="offset" />-Parameter ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
Der <paramref name="size" />-Parameter ist kleiner als 0.  
  
- oder -  
Der <paramref name="size" />-Parameter ist größer als die Länge von <paramref name="buffer" /> abzüglich des Werts des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.  
  
- oder -  
Beim Schreiben in das Netzwerk ist ein Fehler aufgetreten.  
  
- oder -  
Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Sockets.NetworkStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.NetworkStream" /> Lesevorgänge unterstützt.</summary>
        <value>
          <see langword="true" />, wenn Daten aus dem Stream gelesen werden können, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.Sockets.NetworkStream.CanRead%2A> ist `true`, <xref:System.Net.Sockets.NetworkStream> ermöglicht Aufrufe der <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode. Geben Sie den entsprechenden <xref:System.IO.FileAccess> -Enumerationswert ab, die in den Konstruktor hinzu, legen Sie die Lese- und Schreibberechtigung für die <xref:System.Net.Sockets.NetworkStream>. Die <xref:System.Net.Sockets.NetworkStream.CanRead%2A> Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft <xref:System.Net.Sockets.NetworkStream.CanRead%2A> zu überprüfen, ob die <xref:System.Net.Sockets.NetworkStream> gelesen werden kann. Klicken Sie dann führt er einen Lesevorgang für die <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Sockets.NetworkStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Stream Suchvorgänge unterstützt. Diese Eigenschaft wird gegenwärtig nicht unterstützt. Sie gibt immer <see langword="false" /> zurück.</summary>
        <value>In allen Fällen <see langword="false" />, um anzugeben, dass <see cref="T:System.Net.Sockets.NetworkStream" /> nicht eine bestimmte Position im Stream suchen kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Sockets.NetworkStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob Timeouteigenschaften für <see cref="T:System.Net.Sockets.NetworkStream" /> verwendet werden können.</summary>
        <value>
          <see langword="true" /> in allen Fällen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft vorhanden ist, da es von der geerbt wird <xref:System.IO.Stream>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Sockets.NetworkStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.NetworkStream" /> Schreibvorgänge unterstützt.</summary>
        <value>
          <see langword="true" />, wenn Daten in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden können, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> ist `true`, <xref:System.Net.Sockets.NetworkStream> ermöglicht Aufrufe der <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode. Geben Sie den entsprechenden <xref:System.IO.FileAccess> -Enumerationswert ab, die in den Konstruktor hinzu, legen Sie die Lese- und Schreibberechtigung für die <xref:System.Net.Sockets.NetworkStream>. Die <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> zu überprüfen, ob die <xref:System.Net.Sockets.NetworkStream> geschrieben werden kann. Klicken Sie dann führt er einen Schreibvorgang für die <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="networkStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="override this.Close : int -&gt; unit" Usage="networkStream.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine 32-Bit-Ganzzahl mit Vorzeichen, mit der die Zeitspanne (Anzahl der Millisekunden) angegeben wird, in der ggf. restliche Daten vor dem Schließen gesendet werden können.</param>
        <summary>Schließt den <see cref="T:System.Net.Sockets.NetworkStream" /> nach der angegebenen Zeitspanne, in der Daten gesendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.Close%2A> Methode gibt nicht verwaltete und verwaltete der zugeordneten Ressourcen frei. die <xref:System.Net.Sockets.NetworkStream>. Wenn die <xref:System.Net.Sockets.NetworkStream> besitzt die zugrunde liegende <xref:System.Net.Sockets.Socket>, es wird ebenfalls geschlossen.  
  
 Wenn eine <xref:System.Net.Sockets.NetworkStream> zugeordnet wurde eine <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.NetworkStream.Close%2A> Methode schließen Sie die TCP-Verbindung wird jedoch nicht freigegeben, der zugeordneten <xref:System.Net.Sockets.TcpClient>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="timeout" />-Parameter ist kleiner als -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataAvailable">
      <MemberSignature Language="C#" Value="public virtual bool DataAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DataAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.DataAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DataAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool DataAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DataAvailable : bool" Usage="System.Net.Sockets.NetworkStream.DataAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob im <see cref="T:System.Net.Sockets.NetworkStream" /> Daten für einen Lesevorgang verfügbar sind.</summary>
        <value>
          <see langword="true" />, wenn im Stream Daten für den Lesevorgang verfügbar sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> Eigenschaft, um zu bestimmen, ob die Daten gelesen werden können. Wenn <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> ist `true`, einen Aufruf von <xref:System.Net.Sockets.NetworkStream.Read%2A> kehrt sofort zurück. Wenn der remote-Host beendet wird oder die Verbindung schließt, <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> Auslösen einer <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Das folgende Codebeispiel liest aus dem <xref:System.Net.Sockets.NetworkStream> so lange Daten verfügbar sind.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Verwenden Sie die <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />-Eigenschaft, um den spezifischen Fehlercode abzurufen. In der Dokumentation zu API-Fehlercodes unter <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">Windows Sockets, Version 2</see> finden Sie eine ausführliche Beschreibung des Fehlers.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="networkStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Net.Sockets.NetworkStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen `Dispose` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose` Ruft die geschützte `Dispose(Boolean)` -Methode mit dem `disposing` Parametersatz zu `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Net.Sockets.NetworkStream> verweist. Diese Methode ruft die `Dispose`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden. Weitere Informationen zur Implementierung <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="networkStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das einen asynchronen Aufruf darstellt.</param>
        <summary>Behandelt das Ende eines asynchronen Lesevorgangs.</summary>
        <returns>Die Anzahl der aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> gelesenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> Methode schließt den asynchronen Lesevorgang, die Schritte in der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegeben, die von der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode als Parameter.  
  
 Rufen Sie in der Rückrufmethode der <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft der <xref:System.IAsyncResult> abgerufen, die an das Zustandsobjekt, das die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode. Extrahieren Sie den Empfang <xref:System.Net.Sockets.NetworkStream> aus diesem Zustandsobjekt. Nach dem Abrufen der <xref:System.Net.Sockets.NetworkStream>, rufen Sie die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> Methode für die erfolgreiche Abschluss des Lesevorgangs und die Anzahl der gelesenen Bytes zurück.  
  
 Die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> Methode blockiert, bis Daten zur Verfügung steht. Die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> Methode liest so viele Daten wie die Anzahl von Bytes im angegebenen verfügbar ist die `size` Parameter, der die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> Verbindungs- und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> -Methode sofort abgeschlossen und gibt 0 (null) Bytes.  
  
 Um die empfangenen Daten zu erhalten, rufen Sie die <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft der <xref:System.IAsyncResult>, und extrahieren Sie den Puffer in das resultierende Statusobjekt enthalten.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.IO.IOException>, überprüfen die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob es durch verursacht wurde eine <xref:System.Net.Sockets.SocketException>. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode abzurufen, und finden Sie unter der [Fehlercode von Windows Sockets-Version 2-API](/windows/desktop/winsock/windows-sockets-error-codes-2) Dokumentation für eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt `myReadCallback` wird bereitgestellt, um <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> als die Callback-Methode. <xref:System.Net.Sockets.NetworkStream.EndRead%2A> wird in implementiert `myReadCallback` Lesen von gestartet wurde den asynchronen Abschluss <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#5)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#5)]
 [!code-vb[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.  
  
- oder -  
Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="networkStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das <see cref="T:System.IAsyncResult" />, das den asynchronen Aufruf darstellt.</param>
        <summary>Behandelt das Ende eines asynchronen Schreibvorgangs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Schließt den asynchronen Sendevorgang ab, die Schritte im <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegeben, die von der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Methode als Parameter.  
  
 Rufen Sie in die Callback-Methode, die <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft der `IAsyncResult` Parameter zum Abrufen der <xref:System.Net.Sockets.NetworkStream>. Nach dem Abrufen der <xref:System.Net.Sockets.NetworkStream>, rufen Sie die <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Methode für die erfolgreiche Abschluss des Sendevorgangs und die Anzahl der gesendeten Bytes zurück.  
  
 Die <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Methode blockiert, bis die angeforderte Anzahl von Bytes gesendet werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.IO.IOException>, überprüfen die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob es durch verursacht wurde eine <xref:System.Net.Sockets.SocketException>. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode abzurufen, und finden Sie unter der [Fehlercode von Windows Sockets-Version 2-API](/windows/desktop/winsock/windows-sockets-error-codes-2) Dokumentation für eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt `myWriteCallback` wird bereitgestellt, um <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> als die Callback-Methode. <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> wird in implementiert `myWriteCallback` um den asynchronen Schreibvorgang Schritte abzuschließen, <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.  
  
- oder -  
Beim Schreiben in das Netzwerk ist ein Fehler aufgetreten.  
  
- oder -  
Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NetworkStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NetworkStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="networkStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.Net.Sockets.NetworkStream" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Anwendungscode sollte diese Methode nicht aufgerufen. ein Objekt des <xref:System.Object.Finalize%2A> Methode wird automatisch während der Garbagecollection vom Garbage Collector durch einen Aufruf von Collection aufgerufen wurde hat die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode.  
  
 Weitere Informationen zur Verwendung der Finalize-Methode finden Sie unter [Finalize-Methoden und Destruktoren](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md), und [Überschreiben der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)) .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="networkStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schreibt Daten aus dem Stream weg. Diese Methode ist für eine spätere Verwendung vorgesehen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.Flush%2A> Methode implementiert die <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> Methode, aber da <xref:System.Net.Sockets.NetworkStream> ist nicht gepuffert werden, es hat keine Auswirkungen auf Netzwerk-Datenströme. Aufrufen der <xref:System.Net.Sockets.NetworkStream.Flush%2A> Methode löst keine Ausnahme.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="networkStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Ein Abbruchtoken, mit dem die Benachrichtigung verteilt wird, dass dieser Vorgang abgebrochen werden muss.</param>
        <summary>Leert Daten aus dem Stream als asynchroner Vorgang.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" />zurück.  
  
Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurückgegebene <xref:System.Threading.Tasks.Task> Objekt wird abgeschlossen, nachdem die Daten aus dem Datenstrom für den Übertragungsvorgang der <xref:System.Net.Sockets.NetworkStream> Instanz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Sockets.NetworkStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Länge der im Stream verfügbaren Daten an. Diese Eigenschaft wird gegenwärtig nicht unterstützt und löst immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <value>Die Länge der im Stream verfügbaren Daten.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Jede Verwendung dieser Eigenschaft.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Sockets.NetworkStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Position im Stream ab oder legt diese fest. Diese Eigenschaft wird gegenwärtig nicht unterstützt und löst immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <value>Die aktuelle Position in dem Stream.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Jede Verwendung dieser Eigenschaft.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, size As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="networkStream.Read (buffer, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das dem Speicherort entspricht, an dem aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> gelesene Daten gespeichert werden.</param>
        <param name="offset">Die Position im <paramref name="buffer" />, an der mit dem Speichern der Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl der aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> zu lesenden Bytes.</param>
        <summary>Liest Daten aus dem <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>Die Anzahl der aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> gelesenen Bytes – oder 0, wenn der Socket geschlossen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest die Daten in die `buffer` Parameter und gibt die Anzahl der erfolgreich Bytes gelesenen. Wenn der Socket geschlossen ist, die <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode gibt 0 zurück. Die <xref:System.Net.Sockets.NetworkStream.Read%2A> Vorgang liest so viele Daten wie verfügbar ist, bis die Anzahl der Bytes, die gemäß der `size` Parameter. Wenn die Verbindung der Remotehost schließt aus, und alle verfügbare Daten empfangen wurden, die <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode wird sofort beendet, und gibt 0 (null) Bytes zurück.  
  
> [!NOTE]
>  Prüfung, ob die <xref:System.Net.Sockets.NetworkStream> lesbar ist, durch den Aufruf der <xref:System.Net.Sockets.NetworkStream.CanRead%2A> Eigenschaft. Wenn Sie versuchen, das Lesen aus einer <xref:System.Net.Sockets.NetworkStream> , die nicht lesbar ist, erhalten Sie eine <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.IO.IOException>, überprüfen die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob es durch verursacht wurde eine <xref:System.Net.Sockets.SocketException>. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode abzurufen, und finden Sie unter der [Fehlercode von Windows Sockets-Version 2-API](/windows/desktop/winsock/windows-sockets-error-codes-2) Dokumentation für eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> zu bestimmen, ob die Daten gelesen werden können. Wenn Daten verfügbar ist, liest Sie aus der <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter ist kleiner als 0.  
  
- oder -  
Der <paramref name="offset" />-Parameter ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
Der <paramref name="size" />-Parameter ist kleiner als 0.  
  
- oder -  
Der <paramref name="size" />-Parameter ist größer als die Länge von <paramref name="buffer" /> abzüglich des Werts des <paramref name="offset" />-Parameters.  
  
- oder -  
Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.  
  
- oder -  
Beim Lesen aus dem Netzwerk tritt ein Fehler auf.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <related type="Article" href="~/docs/framework/network-programming/using-streams-on-the-network.md">Verwenden von Streams im Netzwerk</related>
      </Docs>
    </Member>
    <Member MemberName="Readable">
      <MemberSignature Language="C#" Value="protected bool Readable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Readable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Readable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Readable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Readable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Readable : bool with get, set" Usage="System.Net.Sockets.NetworkStream.Readable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.NetworkStream" /> gelesen werden kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, um anzugeben, dass der <see cref="T:System.Net.Sockets.NetworkStream" /> gelesen werden kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Ableiten von der <xref:System.Net.Sockets.NetworkStream> zu verwendende Klasse an die <xref:System.Net.Sockets.NetworkStream.Readable%2A> Eigenschaft. Wenn <xref:System.Net.Sockets.NetworkStream.Readable%2A> ist `true`, <xref:System.Net.Sockets.NetworkStream> ermöglicht Aufrufe der <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode. Sie können auch bestimmen, ob eine <xref:System.Net.Sockets.NetworkStream> lesbar ist, indem Sie überprüfen, die öffentlich zugängliche <xref:System.Net.Sockets.NetworkStream.CanRead%2A> Eigenschaft.  
  
 Die <xref:System.Net.Sockets.NetworkStream.Readable%2A> Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die `CanCommunicate` -Eigenschaft überprüft die <xref:System.Net.Sockets.NetworkStream.Readable%2A> Eigenschaft, um zu bestimmen, ob die <xref:System.Net.Sockets.NetworkStream> gelesen werden kann.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="networkStream.ReadAsync (buffer, offset, size, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Sockets.NetworkStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitspanne ab, in der ein Lesevorgang während des Wartens auf Daten blockiert wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, das die Zeitspanne in Millisekunden angibt, nach deren Ablauf ein Lesevorgang fehlschlägt. Der Standardwert <see cref="F:System.Threading.Timeout.Infinite" /> gibt an, dass der Lesevorgang über kein Timeout verfügt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Lesevorgang innerhalb der von dieser Eigenschaft angegebenen Zeit nicht abgeschlossen wird, löst eine <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Diese Eigenschaft wirkt sich nur auf synchrone Lesevorgänge, die durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode. Diese Eigenschaft wirkt sich nicht auf die asynchrone Lesevorgänge durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt das Lesetimeout für einen Netzwerkstream auf 10 Millisekunden fest.  
  
 [!code-csharp[NCLTcpClientSync#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der angegebene Wert ist kleiner oder gleich 0 (null) und nicht <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="networkStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Dieser Parameter wird nicht verwendet.</param>
        <param name="origin">Dieser Parameter wird nicht verwendet.</param>
        <summary>Legt die aktuelle Position des Streams auf den angegebenen Wert fest. Diese Methode wird gegenwärtig nicht unterstützt und löst immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Die Position im Stream.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Jede Verwendung dieser Eigenschaft.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="networkStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Dieser Parameter wird nicht verwendet.</param>
        <summary>Legt die Länge des Streams fest. Diese Methode löst immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Jede Verwendung dieser Eigenschaft.</exception>
      </Docs>
    </Member>
    <Member MemberName="Socket">
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Socket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Socket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Socket" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Socket As Socket" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Net::Sockets::Socket ^ Socket { System::Net::Sockets::Socket ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Socket : System.Net.Sockets.Socket" Usage="System.Net.Sockets.NetworkStream.Socket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Ein <see cref="T:System.Net.Sockets.Socket" />, der die zugrunde liegende Netzwerkverbindung darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen von <xref:System.Net.Sockets.NetworkStream> können diese Eigenschaft verwenden, um den zugrunde liegenden erhalten <xref:System.Net.Sockets.Socket>. Verwenden Sie das zugrunde liegende <xref:System.Net.Sockets.Socket> zurückgegeben, die von der <xref:System.Net.Sockets.NetworkStream.Socket%2A> Eigenschaft, wenn Sie benötigen Zugriff auf darüber hinaus die <xref:System.Net.Sockets.NetworkStream> bietet.  
  
> [!NOTE]
>  Diese Eigenschaft ist nur über diese Klasse oder einer abgeleiteten Klasse zugegriffen werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die zugrunde liegende <xref:System.Net.Sockets.Socket> um eine aktive Verbindung zu überprüfen.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="networkStream.Write (buffer, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die Daten enthält, die in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden sollen.</param>
        <param name="offset">Die Position im <paramref name="buffer" />, an der mit dem Schreiben von Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl der Bytes, die in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden sollen.</param>
        <summary>Schreibt Daten in den <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode beginnt an der angegebenen `offset` und sendet `size` Bytes aus dem Inhalt der `buffer` mit dem Netzwerk. Die <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode blockiert, bis die angeforderte Anzahl von Bytes gesendet wird oder eine <xref:System.Net.Sockets.SocketException> ausgelöst. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen, und finden in der [Fehlercode von Windows Sockets-Version 2-API](/windows/desktop/winsock/windows-sockets-error-codes-2) Dokumentation für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Prüfung, ob die <xref:System.Net.Sockets.NetworkStream> nicht schreibgeschützt ist, durch den Zugriff auf die <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> Eigenschaft. Wenn Sie versuchen, die zum Schreiben einer <xref:System.Net.Sockets.NetworkStream> , die nicht beschreibbar ist, erhalten Sie eine <xref:System.IO.IOException>. Wenn Sie erhalten eine <xref:System.IO.IOException>, überprüfen die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob es durch verursacht wurde eine <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob die <xref:System.Net.Sockets.NetworkStream> geschrieben werden kann. Wenn, dann ist <xref:System.Net.Sockets.NetworkStream.Write%2A> wird verwendet, um eine kleine Nachricht zu schreiben.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter ist kleiner als 0.  
  
- oder -  
Der <paramref name="offset" />-Parameter ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
Der <paramref name="size" />-Parameter ist kleiner als 0.  
  
- oder -  
Der <paramref name="size" />-Parameter ist größer als die Länge von <paramref name="buffer" /> abzüglich des Werts des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.IO.IOException">Beim Schreiben in das Netzwerk ist ein Fehler aufgetreten.  
  
- oder -  
Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.  
  
- oder -  
Beim Lesen aus dem Netzwerk ist ein Fehler aufgetreten.</exception>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="Writeable">
      <MemberSignature Language="C#" Value="protected bool Writeable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Writeable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Writeable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Writeable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Writeable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Writeable : bool with get, set" Usage="System.Net.Sockets.NetworkStream.Writeable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden kann.</summary>
        <value>
          <see langword="true" />, wenn Daten in den Stream geschrieben werden können, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Ableiten von der <xref:System.Net.Sockets.NetworkStream> zu verwendende Klasse an die <xref:System.Net.Sockets.NetworkStream.Writeable%2A> Eigenschaft. Wenn <xref:System.Net.Sockets.NetworkStream.Writeable%2A> ist `true`, <xref:System.Net.Sockets.NetworkStream> ermöglicht Aufrufe der <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode. Sie können auch bestimmen, ob eine <xref:System.Net.Sockets.NetworkStream> überschreibbar durch Überprüfen der öffentlich zugänglichen <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> Eigenschaft.  
  
 Die <xref:System.Net.Sockets.NetworkStream.Writeable%2A> Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die `CanCommunicate` -Eigenschaft überprüft die <xref:System.Net.Sockets.NetworkStream.Writeable%2A> Eigenschaft, um zu bestimmen, ob die <xref:System.Net.Sockets.NetworkStream> geschrieben werden kann.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="networkStream.WriteAsync (buffer, offset, size, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Sockets.NetworkStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitspanne ab, in der ein Schreibvorgang während des Wartens auf Daten blockiert wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, das die Zeitspanne in Millisekunden angibt, nach deren Ablauf ein Schreibvorgang fehlschlägt. Der Standardwert <see cref="F:System.Threading.Timeout.Infinite" /> gibt an, dass der Schreibvorgang über kein Timeout verfügt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schreibvorgang nicht innerhalb der von dieser Eigenschaft angegebenen Zeit abgeschlossen wird, löst eine <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Diese Eigenschaft wirkt sich nur auf synchrone Schreibvorgänge durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode. Diese Eigenschaft wirkt sich nicht auf die asynchrone Schreibvorgänge durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Write-Timeout für einen Netzwerkstream auf 10 Millisekunden.  
  
 [!code-cpp[NCLTcpServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclTcpServerSync/cpp/tcplistener.cpp#0)]
 [!code-csharp[NCLTcpServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclTcpServerSync/CS/tcplistener.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der angegebene Wert ist kleiner oder gleich 0 (null) und nicht <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>