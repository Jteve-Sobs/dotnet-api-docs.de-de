<Type Name="NetworkStream" FullName="System.Net.Sockets.NetworkStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0f9b3287ea8eafb8d3d2d9f207429a0f3d86eb49" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460984" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NetworkStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetworkStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.NetworkStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NetworkStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetworkStream : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt den zugrunde liegenden Datenstrom für den Netzwerkzugriff bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> -Klasse stellt Methoden zum Senden und Empfangen von Daten über <xref:System.Net.Sockets.SocketType.Stream> Sockets im blockierenden Modus. Weitere Informationen zu blockierende und nicht blockierende <xref:System.Net.Sockets.Socket>s, finden Sie unter [verwenden eine asynchrone Clientsockets](~/docs/framework/network-programming/using-an-asynchronous-client-socket.md). Sie können die <xref:System.Net.Sockets.NetworkStream> Klasse für beide synchrone und asynchrone Datenübertragung. Weitere Informationen über die synchrone und asynchrone Kommunikation finden Sie unter [Sockets](~/docs/framework/network-programming/sockets.md).  
  
 Zum Erstellen einer <xref:System.Net.Sockets.NetworkStream>, geben Sie einen verbundenen <xref:System.Net.Sockets.Socket>. Sie können auch angeben, welche <xref:System.IO.FileAccess> Berechtigung der <xref:System.Net.Sockets.NetworkStream> hat gegenüber der bereitgestellten <xref:System.Net.Sockets.Socket>. Standardmäßig wird beim Schließen der <xref:System.Net.Sockets.NetworkStream> schließt nicht bereitgestellten <xref:System.Net.Sockets.Socket>. Wenn Sie möchten die <xref:System.Net.Sockets.NetworkStream> bereitgestellten schließen-Berechtigung <xref:System.Net.Sockets.Socket>, müssen Sie angeben `true` für den Wert des der `ownsSocket` Parameter.  
  
 Verwenden der <xref:System.Net.Sockets.NetworkStream.Write%2A> und <xref:System.Net.Sockets.NetworkStream.Read%2A> Methoden für einfache Single thread synchrone blockierende e/a. Wenn Sie die e/a mit separaten Threads verarbeiten möchten, erwägen Sie die <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> und <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Methoden, oder die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> und <xref:System.Net.Sockets.NetworkStream.EndRead%2A> Methoden für die Kommunikation.  
  
 Die <xref:System.Net.Sockets.NetworkStream> wahlfreien Zugriff auf den Netzwerkdatenstrom nicht unterstützt. Der Wert des der <xref:System.Net.Sockets.NetworkStream.CanSeek%2A> -Eigenschaft, die angibt, ob der Stream Suchvorgänge unterstützt, ist immer `false`; Lesen der <xref:System.Net.Sockets.NetworkStream.Position%2A> Lesen-Eigenschaft der <xref:System.Net.Sockets.NetworkStream.Length%2A> Eigenschaft oder das Aufrufen der <xref:System.Net.Sockets.NetworkStream.Seek%2A> Methode löst eine <xref:System.NotSupportedException>.  
  
 Lesen und Schreiben von Vorgänge können gleichzeitig ausgeführt werden, in einer Instanz von der <xref:System.Net.Sockets.NetworkStream> Klasse ohne die Notwendigkeit einer Synchronisierung. Als vorhanden, einen eindeutigen Thread für die Schreibvorgänge und ein eindeutiger Thread für die Lesevorgänge ist, es werden keine Cross-Störungen zwischen Lese- und Schreibzugriff Threads und keine Synchronisierung ist erforderlich.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen einer <xref:System.Net.Sockets.NetworkStream> aus einer verbundenen <xref:System.Net.Sockets.SocketType.Stream> <xref:System.Net.Sockets.Socket> und grundlegende synchrone blockierende e/a auszuführen.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Net.Sockets.NetworkStream" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <param name="socket">Der <see cref="T:System.Net.Sockets.Socket" />, den der <see cref="T:System.Net.Sockets.NetworkStream" /> zum Senden und Empfangen von Daten verwendet.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Net.Sockets.NetworkStream" />-Klasse für den angegebenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird mit Lese-/Schreibzugriff auf den angegebenen erstellt <xref:System.Net.Sockets.Socket>. Die <xref:System.Net.Sockets.NetworkStream> besitzt nicht die zugrunde liegende <xref:System.Net.Sockets.Socket>daher durch das Aufrufen der <xref:System.Net.Sockets.NetworkStream.Close%2A> Methode wird nicht geschlossen. der <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen einer <xref:System.Net.Sockets.NetworkStream> mit einem <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="socket" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der <paramref name="socket" />-Parameter ist nicht verbunden.  
  
 - oder -   
  
 Die <see cref="P:System.Net.Sockets.Socket.SocketType" />-Eigenschaft des <paramref name="socket" />-Parameters ist nicht <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
 - oder -   
  
 Der <paramref name="socket" />-Parameter befindet sich in einem nicht blockierenden Zustand.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, bool ownsSocket);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket">Der <see cref="T:System.Net.Sockets.Socket" />, den der <see cref="T:System.Net.Sockets.NetworkStream" /> zum Senden und Empfangen von Daten verwendet.</param>
        <param name="ownsSocket">Legen Sie den Wert <see langword="true" /> fest, um anzugeben, dass der <see cref="T:System.Net.Sockets.NetworkStream" /> den Besitz des <see cref="T:System.Net.Sockets.Socket" /> übernimmt, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.NetworkStream" />-Klasse für den angegebenen <see cref="T:System.Net.Sockets.Socket" /> mit dem angegebenen Besitz von <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird mit Lese-/Schreibzugriff auf den angegebenen erstellt <xref:System.Net.Sockets.Socket>. Wenn der Wert der `ownsSocket` Parameter ist `true`, die <xref:System.Net.Sockets.NetworkStream> übernimmt den Besitz des zugrunde liegenden <xref:System.Net.Sockets.Socket>, und Aufrufen der <xref:System.Net.Sockets.NetworkStream.Close%2A> auch Methode schließt den zugrunde liegenden <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.Sockets.NetworkStream> mit den Besitz der <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="socket" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der <paramref name="socket" />-Parameter ist nicht verbunden.  
  
 - oder -   
  
 Der Wert der <see cref="P:System.Net.Sockets.Socket.SocketType" />-Eigenschaft des <paramref name="socket" />-Parameters ist nicht <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
 - oder -   
  
 Der <paramref name="socket" />-Parameter befindet sich in einem nicht blockierenden Zustand.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="socket">Der <see cref="T:System.Net.Sockets.Socket" />, den der <see cref="T:System.Net.Sockets.NetworkStream" /> zum Senden und Empfangen von Daten verwendet.</param>
        <param name="access">Eine bitweise Kombination der <see cref="T:System.IO.FileAccess" />-Werte, die den gewährten Zugriffstyp für <see cref="T:System.Net.Sockets.NetworkStream" /> über den angegebenen <see cref="T:System.Net.Sockets.Socket" /> angeben.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Net.Sockets.NetworkStream" />-Klasse für den angegebenen <see cref="T:System.Net.Sockets.Socket" /> mit den angegebenen Zugriffsrechten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird erstellt, mit dem angegebenen Zugriff auf den angegebenen <xref:System.Net.Sockets.Socket>. Mit diesem Konstruktor die <xref:System.Net.Sockets.NetworkStream> besitzt nicht die zugrunde liegende <xref:System.Net.Sockets.Socket>daher durch das Aufrufen der <xref:System.Net.Sockets.NetworkStream.Close%2A> Methode schließt nicht die zugrunde liegende <xref:System.Net.Sockets.Socket>.  
  
 Die `access` Parametersätze der <xref:System.Net.Sockets.NetworkStream.CanRead%2A> und <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> Eigenschaften der <xref:System.Net.Sockets.NetworkStream>. Bei Angabe von <xref:System.IO.FileAccess.Write>, und klicken Sie dann die <xref:System.Net.Sockets.NetworkStream> können Aufrufe an die <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode. Bei Angabe von <xref:System.IO.FileAccess.Read>, und klicken Sie dann die <xref:System.Net.Sockets.NetworkStream> können Aufrufe an die <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode. Bei Angabe von <xref:System.IO.FileAccess.ReadWrite>, beide-Methodenaufrufe zulässig sind.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.Sockets.NetworkStream> mit der Möglichkeit zum Lesen und Schreiben in die <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="socket" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der <paramref name="socket" />-Parameter ist nicht verbunden.  
  
 - oder -   
  
 Die <see cref="P:System.Net.Sockets.Socket.SocketType" />-Eigenschaft des <paramref name="socket" />-Parameters ist nicht <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
 - oder -   
  
 Der <paramref name="socket" />-Parameter befindet sich in einem nicht blockierenden Zustand.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access, bool ownsSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkStream(System::Net::Sockets::Socket ^ socket, System::IO::FileAccess access, bool ownsSocket);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket">Der <see cref="T:System.Net.Sockets.Socket" />, den der <see cref="T:System.Net.Sockets.NetworkStream" /> zum Senden und Empfangen von Daten verwendet.</param>
        <param name="access">Eine bitweise Kombination der <see cref="T:System.IO.FileAccess" />-Werte, die den gewährten Zugriffstyp für <see cref="T:System.Net.Sockets.NetworkStream" /> über den bereitgestellten <see cref="T:System.Net.Sockets.Socket" /> angibt.</param>
        <param name="ownsSocket">Legen Sie den Wert <see langword="true" /> fest, um anzugeben, dass der <see cref="T:System.Net.Sockets.NetworkStream" /> den Besitz des <see cref="T:System.Net.Sockets.Socket" /> übernimmt, andernfalls <see langword="false" />.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Net.Sockets.NetworkStream" />-Klasse für den angegebenen <see cref="T:System.Net.Sockets.Socket" /> mit den angegebenen Zugriffsrechten und dem angegebenen Besitz von <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream> wird mit Lese-/Schreibzugriff auf den angegebenen erstellt <xref:System.Net.Sockets.Socket>. Wenn der Wert des der `ownsSocket` Parameter ist `true`, die <xref:System.Net.Sockets.NetworkStream> übernimmt den Besitz des zugrunde liegenden <xref:System.Net.Sockets.Socket>, und Aufrufen der <xref:System.Net.Sockets.NetworkStream.Close%2A> auch Methode schließt den zugrunde liegenden <xref:System.Net.Sockets.Socket>.  
  
 Die `access` Parametersätze der <xref:System.Net.Sockets.NetworkStream.CanRead%2A> und <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> Eigenschaften der <xref:System.Net.Sockets.NetworkStream>. Bei Angabe von <xref:System.IO.FileAccess.Write>, und klicken Sie dann die <xref:System.Net.Sockets.NetworkStream> können Aufrufe an die <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode. Bei Angabe von <xref:System.IO.FileAccess.Read>, und klicken Sie dann die <xref:System.Net.Sockets.NetworkStream> können Aufrufe an die <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode. Bei Angabe von <xref:System.IO.FileAccess.ReadWrite>, beide-Methodenaufrufe zulässig sind.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.Sockets.NetworkStream> mit der Möglichkeit zum Lesen und Schreiben in die <xref:System.Net.Sockets.Socket>. Den Besitz von der <xref:System.Net.Sockets.Socket> erhält dieser <xref:System.Net.Sockets.NetworkStream> durch Angabe `true` für die `ownsSocket` Parameter.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#1)]
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="socket" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der <paramref name="socket" />-Parameter ist nicht verbunden.  
  
 - oder -   
  
 Die <see cref="P:System.Net.Sockets.Socket.SocketType" />-Eigenschaft des <paramref name="socket" />-Parameters ist nicht <see cref="F:System.Net.Sockets.SocketType.Stream" />.  
  
 - oder -   
  
 Der <paramref name="socket" />-Parameter befindet sich in einem nicht blockierenden Zustand.</exception>
        <altmember cref="T:System.IO.FileAccess" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das dem Speicherort entspricht, an dem aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> gelesene Daten gespeichert werden.</param>
        <param name="offset">Die Position in <c>buffer</c>, an der das Speichern der Daten beginnen soll.</param>
        <param name="size">Die Anzahl der aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> zu lesenden Bytes.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der nach Abschluss von <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> ausgeführt wird.</param>
        <param name="state">Ein Objekt, das zusätzliche, benutzerdefinierte Daten enthält.</param>
        <summary>Beginnt einen asynchronen Lesevorgang aus dem <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Aufruf darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode startet asynchron Lesen von Daten aus den eingehenden Netzwerkpuffern. Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread empfangen.  
  
 Müssen Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode. Zumindest Ihre `state` Parameter muss enthalten die <xref:System.Net.Sockets.NetworkStream>. Da Sie die empfangenen Daten in der Rückrufmethode abrufen möchten, sollten Sie eine kleine Klasse oder Struktur, die einen Lesepuffer und andere nützliche Informationen enthalten erstellen. Übergeben Sie die Struktur oder Klasse, Instanz, die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, das System wird gewartet, bis Daten empfangen werden oder ein Fehler auftritt, und verwenden dann einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und Blöcke auf <xref:System.Net.Sockets.NetworkStream.EndRead%2A> bis bereitgestellten <xref:System.Net.Sockets.NetworkStream> liest Daten oder eine Ausnahme auslöst. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode. Rufen Sie <xref:System.Threading.EventWaitHandle.Set%2A> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll. Weitere Informationen über das Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Die <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode liest so viele Daten wie verfügbar ist, bis zur Anzahl der Bytes, die gemäß der `size` Parameter.  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.IO.IOException>, überprüfen Sie die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob diese von verursacht wurde eine <xref:System.Net.Sockets.SocketException>. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode abzurufen, und verweisen in MSDN in der Dokumentation zu API-Code Windows Sockets, Version 2, eine ausführliche Beschreibung des Fehlers.  
  
 Lesen und Schreiben von Vorgänge können gleichzeitig ausgeführt werden, in einer Instanz von der <xref:System.Net.Sockets.NetworkStream> Klasse ohne die Notwendigkeit einer Synchronisierung. Als vorhanden, einen eindeutigen Thread für die Schreibvorgänge und ein eindeutiger Thread für die Lesevorgänge ist, es werden keine Cross-Störungen zwischen Lese- und Schreibzugriff Threads und keine Synchronisierung ist erforderlich.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Daten asynchron aus dem Netzwerkstream gelesen. Die `myReadCallBack` Methode implementiert die <xref:System.AsyncCallback> delegieren und vom System aufgerufen wird beim <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> zurückgegeben.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Async_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter ist kleiner als 0.  
  
 - oder -   
  
 Der <paramref name="offset" />-Parameter ist größer als die Länge des <paramref name="buffer" />-Parameters.  
  
 - oder -   
  
 Die <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 Der <paramref name="size" />-Parameter ist größer als die Länge von <paramref name="buffer" /> abzüglich des Werts des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.  
  
 - oder -   
  
 Beim Lesen aus dem Netzwerk ist ein Fehler aufgetreten.  
  
 - oder -   
  
 Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, size As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die Daten enthält, die in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden sollen.</param>
        <param name="offset">Die Position in <c>buffer</c>, an der das Senden der Daten beginnen soll.</param>
        <param name="size">Die Anzahl der Bytes, die in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden sollen.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der nach Abschluss von <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> ausgeführt wird.</param>
        <param name="state">Ein Objekt, das zusätzliche, benutzerdefinierte Daten enthält.</param>
        <summary>Beginnt einen asynchronen Schreibvorgang in einen Stream.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Aufruf darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Methode startet einen asynchronen Sendevorgang mit dem Remotehost. Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.  
  
 Müssen Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Methode. Zumindest Ihre `state` Parameter muss enthalten die <xref:System.Net.Sockets.NetworkStream>. Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine kleine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.NetworkStream> und andere erforderliche Informationen. Übergeben Sie die Struktur oder Klasse, Instanz, die <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode implementieren sollten die <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, das System verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> bis der <xref:System.Net.Sockets.NetworkStream> sendet die Anzahl der angeforderten Bytes oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode. Rufen Sie <xref:System.Threading.EventWaitHandle.Set%2A> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll. Weitere Informationen über das Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.IO.IOException>, überprüfen Sie die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob diese von verursacht wurde eine <xref:System.Net.Sockets.SocketException>. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode abzurufen, und verweisen in MSDN in der Dokumentation zu API-Code Windows Sockets, Version 2, eine ausführliche Beschreibung des Fehlers.  
  
 Lesen und Schreiben von Vorgänge können gleichzeitig ausgeführt werden, in einer Instanz von der <xref:System.Net.Sockets.NetworkStream> Klasse ohne die Notwendigkeit einer Synchronisierung. Als vorhanden, einen eindeutigen Thread für die Schreibvorgänge und ein eindeutiger Thread für die Lesevorgänge ist, es werden keine Cross-Störungen zwischen Lese- und Schreibzugriff Threads und keine Synchronisierung ist erforderlich.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Daten asynchron in einen Netzwerkstream zu schreiben. Die `myWriteCallBack` Methode implementiert die <xref:System.AsyncCallback> delegieren und vom System aufgerufen wird beim <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> zurückgegeben.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#2)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#2)]
 [!code-vb[NetworkStream_Async_SendAndReceive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter ist kleiner als 0.  
  
 - oder -   
  
 Der <paramref name="offset" />-Parameter ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 Der <paramref name="size" />-Parameter ist kleiner als 0.  
  
 - oder -   
  
 Der <paramref name="size" />-Parameter ist größer als die Länge von <paramref name="buffer" /> abzüglich des Werts des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.  
  
 - oder -   
  
 Beim Schreiben in das Netzwerk ist ein Fehler aufgetreten.  
  
 - oder -   
  
 Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.NetworkStream" /> Lesevorgänge unterstützt.</summary>
        <value>
          <see langword="true" />, wenn Daten aus dem Stream gelesen werden können, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.Sockets.NetworkStream.CanRead%2A> ist `true`, <xref:System.Net.Sockets.NetworkStream> können Aufrufe an die <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode. Geben Sie die entsprechende <xref:System.IO.FileAccess> Enumerationswert in den Konstruktor hinzu, legen Sie den Lese- und Schreibberechtigung für die <xref:System.Net.Sockets.NetworkStream>. Die <xref:System.Net.Sockets.NetworkStream.CanRead%2A> Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft <xref:System.Net.Sockets.NetworkStream.CanRead%2A> zu überprüfen, ob die <xref:System.Net.Sockets.NetworkStream> gelesen werden kann. Führt dann einen Lesevorgang für die <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Stream Suchvorgänge unterstützt. Diese Eigenschaft wird gegenwärtig nicht unterstützt. Sie gibt immer <see langword="false" /> zurück.</summary>
        <value>
          In allen Fällen <see langword="false" />, um anzugeben, dass <see cref="T:System.Net.Sockets.NetworkStream" /> nicht eine bestimmte Position im Stream suchen kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob Timeouteigenschaften für <see cref="T:System.Net.Sockets.NetworkStream" /> verwendet werden können.</summary>
        <value>
          <see langword="true" /> in allen Fällen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft vorhanden ist, da sie von geerbt wird <xref:System.IO.Stream>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.NetworkStream" /> Schreibvorgänge unterstützt.</summary>
        <value>
          <see langword="true" />, wenn Daten in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden können, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> ist `true`, <xref:System.Net.Sockets.NetworkStream> können Aufrufe an die <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode. Geben Sie die entsprechende <xref:System.IO.FileAccess> Enumerationswert in den Konstruktor hinzu, legen Sie den Lese- und Schreibberechtigung für die <xref:System.Net.Sockets.NetworkStream>. Die <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> zu überprüfen, ob die <xref:System.Net.Sockets.NetworkStream> geschrieben werden kann. Führt dann einen Schreibvorgang für die <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
        <altmember cref="T:System.IO.FileAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine 32-Bit-Ganzzahl mit Vorzeichen, mit der die Zeitspanne (Anzahl der Millisekunden) angegeben wird, in der ggf. restliche Daten vor dem Schließen gesendet werden können.</param>
        <summary>Schließt den <see cref="T:System.Net.Sockets.NetworkStream" /> nach der angegebenen Zeitspanne, in der Daten gesendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.Close%2A> Methode gibt sowohl verwaltete als auch nicht verwaltete Ressourcen, die für die <xref:System.Net.Sockets.NetworkStream>. Wenn die <xref:System.Net.Sockets.NetworkStream> besitzt den zugrunde liegenden <xref:System.Net.Sockets.Socket>, ist ebenfalls geschlossen.  
  
 Wenn eine <xref:System.Net.Sockets.NetworkStream> zugeordnet wurde eine <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.NetworkStream.Close%2A> -Methode schließen Sie die TCP-Verbindung wird, aber nicht der zugeordneten dispose <xref:System.Net.Sockets.TcpClient>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="timeout" />-Parameter ist kleiner als -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataAvailable">
      <MemberSignature Language="C#" Value="public virtual bool DataAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DataAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.DataAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DataAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool DataAvailable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob im <see cref="T:System.Net.Sockets.NetworkStream" /> Daten für einen Lesevorgang verfügbar sind.</summary>
        <value>
          <see langword="true" />, wenn im Stream Daten für den Lesevorgang verfügbar sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> Eigenschaft, um zu bestimmen, ob Daten gelesen werden können. Wenn <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> ist `true`, einen Aufruf von <xref:System.Net.Sockets.NetworkStream.Read%2A> wird sofort zurückgegeben. Wenn der remote-Host heruntergefahren oder die Verbindung schließt <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> Auslösen einer <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird liest aus dem <xref:System.Net.Sockets.NetworkStream> solange Daten verfügbar sind.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Verwenden Sie die <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />-Eigenschaft, um den spezifischen Fehlercode abzurufen. In MSDN finden Sie in der Dokumentation zu API-Fehlercodes unter Windows Sockets, Version 2, eine ausführliche Beschreibung des Fehlers.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Net.Sockets.NetworkStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose` Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Net.Sockets.NetworkStream> verweist. Diese Methode ruft die `Dispose`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden. Weitere Informationen zum Implementieren <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das einen asynchronen Aufruf darstellt.</param>
        <summary>Behandelt das Ende eines asynchronen Lesevorgangs.</summary>
        <returns>Die Anzahl der aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> gelesenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> Methode schließt den asynchronen Lesevorgang gestartet werden, der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegeben, die von der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode als Parameter.  
  
 Innerhalb der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft der <xref:System.IAsyncResult> übergebene, um das Zustandsobjekt, das Abrufen der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode. Extrahieren Sie den Empfang <xref:System.Net.Sockets.NetworkStream> aus dieses Zustandsobjekt. Nach dem Erhalt der <xref:System.Net.Sockets.NetworkStream>, rufen Sie die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> Methode für die erfolgreiche den Lesevorgang abgeschlossen und die Anzahl der gelesenen Bytes zurück.  
  
 Die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> Methode blockiert, bis Daten verfügbar sind. Die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> -Methode liest Daten ein, die bis zur Anzahl der Bytes im angegebenen verfügbar ist die `size` Parameter von der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode. Wenn dem Remotehost die <xref:System.Net.Sockets.Socket> Verbindungs- und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.NetworkStream.EndRead%2A> -Methode sofort abgeschlossen und gibt 0 (null) Bytes.  
  
 Aufrufen, um die empfangenen Daten zu erhalten, die <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft von der <xref:System.IAsyncResult>, und extrahieren Sie den im resultierenden Zustandsobjekt enthaltenen Puffer.  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.IO.IOException>, überprüfen Sie die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob diese von verursacht wurde eine <xref:System.Net.Sockets.SocketException>. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode abzurufen, und verweisen in MSDN in der Dokumentation zu API-Code Windows Sockets, Version 2, eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel `myReadCallback` wird bereitgestellt, um <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> als die Rückrufmethode. <xref:System.Net.Sockets.NetworkStream.EndRead%2A> die Implementierung in `myReadCallback` lesen Sie zum Abschließen der asynchrone Aufruf gestartet, indem <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#5)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#5)]
 [!code-vb[NetworkStream_Async_SendAndReceive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.  
  
 - oder -   
  
 Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das <see cref="T:System.IAsyncResult" />, das den asynchronen Aufruf darstellt.</param>
        <summary>Behandelt das Ende eines asynchronen Schreibvorgangs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Schließt den asynchronen Sendevorgang in gestartet <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegeben, die von der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Methode als Parameter.  
  
 Innerhalb der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft von der `IAsyncResult` Parameter zum Abrufen der <xref:System.Net.Sockets.NetworkStream>. Nach dem Erhalt der <xref:System.Net.Sockets.NetworkStream>, Sie erreichen die <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Methode für die erfolgreiche den Sendevorgang abgeschlossen und die Anzahl der gesendeten Bytes zurück.  
  
 Die <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Methode blockiert, bis die angeforderte Anzahl von Bytes gesendet werden.  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.IO.IOException>, überprüfen Sie die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob diese von verursacht wurde eine <xref:System.Net.Sockets.SocketException>. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode abzurufen, und verweisen in MSDN in der Dokumentation zu API-Code Windows Sockets, Version 2, eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel `myWriteCallback` wird bereitgestellt, um <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> als die Rückrufmethode. <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> die Implementierung in `myWriteCallback` um den asynchronen Schreibvorgang Aufruf gestartet, indem abzuschließen <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Async_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Async_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.  
  
 - oder -   
  
 Beim Schreiben in das Netzwerk ist ein Fehler aufgetreten.  
  
 - oder -   
  
 Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NetworkStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NetworkStream ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.Net.Sockets.NetworkStream" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Diese Methode sollte nicht von Anwendungscode aufgerufen werden. ein Objekt <xref:System.Object.Finalize%2A> Methode wird automatisch während der Garbagecollection aufgerufen, durch einen Aufruf von seiner Finalisierung verfolgt, durch den Garbage Collector deaktiviert wurde die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode.  
  
 Weitere Informationen zur Verwendung der Finalize-Methode finden Sie unter [Finalize-Methoden und Destruktoren](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md), und [Überschreiben der Finalize-Methode](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3) .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schreibt Daten aus dem Stream weg. Diese Methode ist für eine spätere Verwendung vorgesehen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.Flush%2A> Methode implementiert die <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> Methode, aber da <xref:System.Net.Sockets.NetworkStream> ist nicht gepuffert, er hat keine Auswirkung auf Netzwerkstreams. Aufrufen der <xref:System.Net.Sockets.NetworkStream.Flush%2A> Methode löst keine Ausnahme.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Ein Abbruchtoken, mit dem die Benachrichtigung verteilt wird, dass dieser Vorgang abgebrochen werden muss.</param>
        <summary>Leert Daten aus dem Stream als asynchroner Vorgang.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" />zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurückgegebene <xref:System.Threading.Tasks.Task> Objekt wird abgeschlossen, nachdem Daten aus dem Datenstrom für geleert wurde die <xref:System.Net.Sockets.NetworkStream> Instanz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Länge der im Stream verfügbaren Daten an. Diese Eigenschaft wird gegenwärtig nicht unterstützt und löst immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <value>Die Länge der im Stream verfügbaren Daten.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Jede Verwendung dieser Eigenschaft.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Position im Stream ab oder legt diese fest. Diese Eigenschaft wird gegenwärtig nicht unterstützt und löst immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <value>Die aktuelle Position in dem Stream.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Jede Verwendung dieser Eigenschaft.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, size As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das dem Speicherort entspricht, an dem aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> gelesene Daten gespeichert werden.</param>
        <param name="offset">Die Position in <c>buffer</c>, an der das Speichern der Daten beginnen soll.</param>
        <param name="size">Die Anzahl der aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> zu lesenden Bytes.</param>
        <summary>Liest Daten aus dem <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>Die Anzahl der aus dem <see cref="T:System.Net.Sockets.NetworkStream" /> gelesenen Bytes – oder 0, wenn der Socket geschlossen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest Daten in den `buffer` Parameter und gibt die Anzahl der erfolgreich Bytes gelesenen. Wenn der Socket geschlossen ist, die <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode gibt 0 zurück. Die <xref:System.Net.Sockets.NetworkStream.Read%2A> Vorgang liest so viele Daten wie verfügbar ist, bis zur Anzahl der Bytes, die gemäß der `size` Parameter. Wenn der remote-Host die Verbindung beendet, und alle verfügbare Daten empfangen wurden, die <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode wird sofort beendet, und gibt 0 (null) Bytes zurück.  
  
> [!NOTE]
>  Überprüfen, wenn die <xref:System.Net.Sockets.NetworkStream> lesbar ist, durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.CanRead%2A> Eigenschaft. Wenn Sie versuchen, das Lesen aus einer <xref:System.Net.Sockets.NetworkStream> nicht lesbar ist, erhalten Sie eine <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.IO.IOException>, überprüfen Sie die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob diese von verursacht wurde eine <xref:System.Net.Sockets.SocketException>. Wenn dies der Fall ist, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode abzurufen, und verweisen in MSDN in der Dokumentation zu API-Code Windows Sockets, Version 2, eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> zu bestimmen, ob Daten gelesen werden kann. Wenn Daten verfügbar ist, liest er aus der <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#4)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#4)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter ist kleiner als 0.  
  
 - oder -   
  
 Der <paramref name="offset" />-Parameter ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 Der <paramref name="size" />-Parameter ist kleiner als 0.  
  
 - oder -   
  
 Der <paramref name="size" />-Parameter ist größer als die Länge von <paramref name="buffer" /> abzüglich des Werts des <paramref name="offset" />-Parameters.  
  
 - oder -   
  
 Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.IOException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wird geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.  
  
 - oder -   
  
 Beim Lesen aus dem Netzwerk tritt ein Fehler auf.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Readable">
      <MemberSignature Language="C#" Value="protected bool Readable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Readable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Readable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Readable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Readable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.NetworkStream" /> gelesen werden kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, um anzugeben, dass der <see cref="T:System.Net.Sockets.NetworkStream" /> gelesen werden kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leiten Sie von der <xref:System.Net.Sockets.NetworkStream> -Klasse die <xref:System.Net.Sockets.NetworkStream.Readable%2A> Eigenschaft. Wenn <xref:System.Net.Sockets.NetworkStream.Readable%2A> ist `true`, <xref:System.Net.Sockets.NetworkStream> können Aufrufe an die <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode. Sie können auch bestimmen, ob eine <xref:System.Net.Sockets.NetworkStream> lesbar ist, indem Sie überprüfen, die öffentlich zugängliche <xref:System.Net.Sockets.NetworkStream.CanRead%2A> Eigenschaft.  
  
 Die <xref:System.Net.Sockets.NetworkStream.Readable%2A> Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel die `CanCommunicate` -Eigenschaft überprüft die <xref:System.Net.Sockets.NetworkStream.Readable%2A> Eigenschaft, um festzustellen, wo die <xref:System.Net.Sockets.NetworkStream> gelesen werden kann.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanRead" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitspanne ab, in der ein Lesevorgang während des Wartens auf Daten blockiert wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, das die Zeitspanne in Millisekunden angibt, nach deren Ablauf ein Lesevorgang fehlschlägt. Der Standardwert <see cref="F:System.Threading.Timeout.Infinite" /> gibt an, dass der Lesevorgang über kein Timeout verfügt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Lesevorgang innerhalb der von dieser Eigenschaft angegebenen Zeit nicht abgeschlossen wird, löst der Lesevorgang aus einer <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Diese Eigenschaft wirkt sich nur auf synchrone Lesevorgänge durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.Read%2A> Methode. Diese Eigenschaft wirkt sich nicht auf asynchrone Lesevorgänge durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Lesetimeout für einen Netzwerkstream auf 10 Millisekunden.  
  
 [!code-csharp[NCLTcpClientSync#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der angegebene Wert ist kleiner oder gleich 0 (null) und nicht <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Dieser Parameter wird nicht verwendet.</param>
        <param name="origin">Dieser Parameter wird nicht verwendet.</param>
        <summary>Legt die aktuelle Position des Streams auf den angegebenen Wert fest. Diese Methode wird gegenwärtig nicht unterstützt und löst immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Die Position im Stream.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Jede Verwendung dieser Eigenschaft.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Dieser Parameter wird nicht verwendet.</param>
        <summary>Legt die Länge des Streams fest. Diese Methode löst immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Jede Verwendung dieser Eigenschaft.</exception>
      </Docs>
    </Member>
    <Member MemberName="Socket">
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Socket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Socket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Socket" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Socket As Socket" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Net::Sockets::Socket ^ Socket { System::Net::Sockets::Socket ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Ein <see cref="T:System.Net.Sockets.Socket" />, der die zugrunde liegende Netzwerkverbindung darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ableiten von Klassen <xref:System.Net.Sockets.NetworkStream> können diese Eigenschaft zum Abrufen des zugrunde liegenden <xref:System.Net.Sockets.Socket>. Verwenden Sie das zugrunde liegende <xref:System.Net.Sockets.Socket> zurückgegeben, die von der <xref:System.Net.Sockets.NetworkStream.Socket%2A> Eigenschaft, wenn Sie benötigen darüber hinaus zuzugreifen, das <xref:System.Net.Sockets.NetworkStream> enthält.  
  
> [!NOTE]
>  Diese Eigenschaft ist nur über diese Klasse oder einer abgeleiteten Klasse zugegriffen werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft das zugrunde liegende <xref:System.Net.Sockets.Socket> eine aktive Verbindung zu überprüfen.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die Daten enthält, die in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden sollen.</param>
        <param name="offset">Die Position in <c>buffer</c>, an der das Schreiben von Daten beginnen soll.</param>
        <param name="size">Die Anzahl der Bytes, die in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden sollen.</param>
        <summary>Schreibt Daten in den <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode beginnt an der angegebenen `offset` und sendet `size` Bytes aus dem Inhalt der `buffer` mit dem Netzwerk. Die <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode blockiert, bis die angeforderte Anzahl von Bytes gesendet wird oder eine <xref:System.Net.Sockets.SocketException> ausgelöst wird. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen, und verweisen in MSDN in der Dokumentation zu API-Code Windows Sockets, Version 2, eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Überprüfen, wenn die <xref:System.Net.Sockets.NetworkStream> beschreibbar ist, durch den Zugriff auf die <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> Eigenschaft. Wenn Sie versuchen, die zum Schreiben einer <xref:System.Net.Sockets.NetworkStream> nicht beschreibbar ist, erhalten Sie eine <xref:System.IO.IOException>. Erhalten Sie eine <xref:System.IO.IOException>, überprüfen Sie die <xref:System.Exception.InnerException%2A> Eigenschaft, um zu bestimmen, ob diese von verursacht wurde eine <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob die <xref:System.Net.Sockets.NetworkStream> geschrieben werden kann. Wenn, klicken Sie dann ist <xref:System.Net.Sockets.NetworkStream.Write%2A> wird verwendet, um eine kleine Nachricht zu schreiben.  
  
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CPP/source.cpp#3)]
 [!code-csharp[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/CS/source.cs#3)]
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Synch_SendAndReceive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter ist kleiner als 0.  
  
 - oder -   
  
 Der <paramref name="offset" />-Parameter ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 Der <paramref name="size" />-Parameter ist kleiner als 0.  
  
 - oder -   
  
 Der <paramref name="size" />-Parameter ist größer als die Länge von <paramref name="buffer" /> abzüglich des Werts des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.IO.IOException">Beim Schreiben in das Netzwerk ist ein Fehler aufgetreten.  
  
 - oder -   
  
 Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.NetworkStream" /> ist geschlossen.  
  
 - oder -   
  
 Beim Lesen aus dem Netzwerk ist ein Fehler aufgetreten.</exception>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Writeable" />
      </Docs>
    </Member>
    <Member MemberName="Writeable">
      <MemberSignature Language="C#" Value="protected bool Writeable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Writeable" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.Writeable" />
      <MemberSignature Language="VB.NET" Value="Protected Property Writeable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Writeable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in den <see cref="T:System.Net.Sockets.NetworkStream" /> geschrieben werden kann.</summary>
        <value>
          <see langword="true" />, wenn Daten in den Stream geschrieben werden können, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leiten Sie von der <xref:System.Net.Sockets.NetworkStream> -Klasse die <xref:System.Net.Sockets.NetworkStream.Writeable%2A> Eigenschaft. Wenn <xref:System.Net.Sockets.NetworkStream.Writeable%2A> ist `true`, <xref:System.Net.Sockets.NetworkStream> können Aufrufe an die <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode. Sie können auch bestimmen, ob eine <xref:System.Net.Sockets.NetworkStream> überschreibbar durch Überprüfen der öffentlich zugängliche <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> Eigenschaft.  
  
 Die <xref:System.Net.Sockets.NetworkStream.Writeable%2A> Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.NetworkStream> initialisiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel die `CanCommunicate` -Eigenschaft überprüft die <xref:System.Net.Sockets.NetworkStream.Writeable%2A> Eigenschaft, um festzustellen, wo die <xref:System.Net.Sockets.NetworkStream> geschrieben werden kann.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CPP/source.cpp#1)]
 [!code-csharp[NetworkStream_Protected_Members#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NetworkStream_Protected_Members/CS/source.cs#1)]
 [!code-vb[NetworkStream_Protected_Members#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NetworkStream_Protected_Members/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.NetworkStream.CanWrite" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.Readable" />
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int size, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.NetworkStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.NetworkStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitspanne ab, in der ein Schreibvorgang während des Wartens auf Daten blockiert wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, das die Zeitspanne in Millisekunden angibt, nach deren Ablauf ein Schreibvorgang fehlschlägt. Der Standardwert <see cref="F:System.Threading.Timeout.Infinite" /> gibt an, dass der Schreibvorgang über kein Timeout verfügt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schreibvorgang nicht innerhalb der von dieser Eigenschaft angegebenen Zeit abgeschlossen wird, löst der Schreibvorgang ein <xref:System.IO.IOException>.  
  
> [!NOTE]
>  Diese Eigenschaft wirkt sich nur auf synchrone Schreibvorgänge durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.Write%2A> Methode. Diese Eigenschaft wirkt sich nicht auf asynchrone Schreibvorgänge durch Aufrufen der <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Write-Timeout für einen Netzwerkstream auf 10 Millisekunden.  
  
 [!code-cpp[NCLTcpServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclTcpServerSync/cpp/tcplistener.cpp#0)]
 [!code-csharp[NCLTcpServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclTcpServerSync/CS/tcplistener.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der angegebene Wert ist kleiner oder gleich 0 (null) und nicht <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>