<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7ca76bb12578121ed0daa4fdc58e686329bada61" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75170541" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementiert die Berkeley-Sockets-Schnittstelle.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket>-Klasse stellt einen umfangreichen Satz von Methoden und Eigenschaften für die Netzwerkkommunikation bereit. Die <xref:System.Net.Sockets.Socket>-Klasse ermöglicht es Ihnen, sowohl synchrone als auch asynchrone Datenübertragungen mithilfe eines der Kommunikationsprotokolle auszuführen, die in der <xref:System.Net.Sockets.ProtocolType>-Enumeration aufgeführt sind.  
  
 Die <xref:System.Net.Sockets.Socket>-Klasse befolgt das .NET Framework Benennungs Muster für asynchrone Methoden. Beispielsweise entspricht die synchrone <xref:System.Net.Sockets.Socket.Receive%2A>-Methode den asynchronen Methoden <xref:System.Net.Sockets.Socket.BeginReceive%2A> und <xref:System.Net.Sockets.Socket.EndReceive%2A>.  
  
 Wenn für die Anwendung nur ein Thread während der Ausführung erforderlich ist, verwenden Sie die folgenden Methoden, die für den synchronen Betriebsmodus vorgesehen sind.  
  
-   Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, kann der Server mit der <xref:System.Net.Sockets.Socket.Listen%2A>-Methode auf Verbindungen lauschen. Die <xref:System.Net.Sockets.Socket.Accept%2A>-Methode verarbeitet alle eingehenden Verbindungsanforderungen und gibt eine <xref:System.Net.Sockets.Socket> zurück, die Sie verwenden können, um Daten mit dem Remote Host zu kommunizieren. Verwenden Sie dieses zurückgegebene <xref:System.Net.Sockets.Socket>, um die <xref:System.Net.Sockets.Socket.Send%2A> oder <xref:System.Net.Sockets.Socket.Receive%2A>-Methode aufzurufen. Rufen Sie die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode auf, bevor Sie die <xref:System.Net.Sockets.Socket.Listen%2A>-Methode aufrufen, wenn Sie die lokale IP-Adresse und die Portnummer angeben möchten. Verwenden Sie die Portnummer 0 (null), wenn der zugrunde liegende Dienstanbieter einen freien Port zuweisen soll. Wenn Sie eine Verbindung mit einem Überwachungshost herstellen möchten, können Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufzurufen. Um Daten zu kommunizieren, können Sie die <xref:System.Net.Sockets.Socket.Send%2A>-oder <xref:System.Net.Sockets.Socket.Receive%2A>-Methode abrufen.  
  
-   Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie nicht auf Verbindungen lauschen. Ruft die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode auf, um eingehende Datagramme zu akzeptieren. Verwenden Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode, um Datagramme an einen Remote Host zu senden.  
  
 Verwenden Sie die folgenden Methoden, die für den asynchronen Betriebsmodus entwickelt wurden, um die Kommunikation mit separaten Threads während der Ausführung zu verarbeiten.  
  
-   Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, verwenden Sie die Methoden <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>und <xref:System.Net.Sockets.Socket.EndConnect%2A>, um eine Verbindung mit einem Überwachungs Host herzustellen. Verwenden Sie die Methoden <xref:System.Net.Sockets.Socket.BeginSend%2A> und <xref:System.Net.Sockets.Socket.EndSend%2A> oder <xref:System.Net.Sockets.Socket.BeginReceive%2A> und <xref:System.Net.Sockets.Socket.EndReceive%2A>, um Daten asynchron zu kommunizieren. Eingehende Verbindungsanforderungen können mithilfe von <xref:System.Net.Sockets.Socket.BeginAccept%2A> und <xref:System.Net.Sockets.Socket.EndAccept%2A>verarbeitet werden.  
  
-   Wenn Sie ein verbindungsloses Protokoll, z. b. UDP, verwenden, können Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> und <xref:System.Net.Sockets.Socket.EndSendTo%2A> verwenden, um Datagramme zu senden, und <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> und <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>, um Datagramme zu empfangen.  
  
 Wenn Sie mehrere asynchrone Vorgänge für einen Socket ausführen, werden diese nicht notwendigerweise in der Reihenfolge, in der Sie gestartet wurden, vervollständigt.  
  
 Wenn Sie mit dem Senden und empfangen von Daten fertig sind, verwenden Sie die <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode, um die <xref:System.Net.Sockets.Socket>zu deaktivieren. Rufen Sie nach dem Aufrufen von <xref:System.Net.Sockets.Socket.Shutdown%2A>die <xref:System.Net.Sockets.Socket.Close%2A>-Methode auf, um alle dem <xref:System.Net.Sockets.Socket>zugeordneten Ressourcen freizugeben.  
  
 Die <xref:System.Net.Sockets.Socket>-Klasse ermöglicht es Ihnen, ihre <xref:System.Net.Sockets.Socket> mithilfe der <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode zu konfigurieren. Rufen Sie diese Einstellungen mithilfe der <xref:System.Net.Sockets.Socket.GetSocketOption%2A>-Methode ab.  
  
> [!NOTE]
>  Wenn Sie eine relativ einfache Anwendung schreiben und keine maximale Leistung benötigen, sollten Sie die Verwendung von <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>und <xref:System.Net.Sockets.UdpClient>in Erwägung gezogen. Diese Klassen stellen eine einfachere und benutzerfreundlichere Oberfläche für die <xref:System.Net.Sockets.Socket> Kommunikation bereit.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Net.Sockets.Socket>-Klasse zum Senden von Daten an einen HTTP-Server und zum Empfangen der Antwort verwendet werden kann. Dieses Beispiel wird so lange blockiert, bis die gesamte Seite empfangen wird.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">, Um eine ausgehende Verbindung herzustellen oder eine eingehende Anforderung zu akzeptieren.</permission>
    <threadsafe>Instanzen dieser Klasse sind Thread sicher.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">Netzwerkprogrammierung in .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">Bewährte Methoden für System.Net-Klassen</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">Cacheverwaltung für Netzwerkanwendungen</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">Internetprotokoll Version 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">Beispiele zur Netzwerkprogrammierung</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">Netzwerkablaufverfolgung in .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">Sicherheit in der Netzwerkprogrammierung</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">Erweiterungen der Socketleistung in Version 3.5</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation">Die von <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> zurückgegebenen Socketinformationen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse mit dem angegebenen Wert, der von <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> zurückgegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den <xref:System.Net.Sockets.Socket.%23ctor%2A>-Konstruktor mehrmals mit dem gleichen Bytearray wie das-Argument für jeden-Befehl aufzurufen, erstellen Sie mehrere verwaltete <xref:System.Net.Sockets.Socket>s mit dem gleichen zugrunde liegenden Socket. Diese Vorgehensweise wird dringend davon abgeraten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</param>
        <param name="protocolType">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse unter Verwendung der angegebenen Sockettyps und Protokolls.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `socketType`-Parameter gibt den Typ der <xref:System.Net.Sockets.Socket> Klasse an, und der `protocolType`-Parameter gibt das Protokoll an, das von <xref:System.Net.Sockets.Socket>verwendet wird. Die beiden Parameter sind nicht unabhängig. Häufig ist der <xref:System.Net.Sockets.Socket> Typ im Protokoll implizit. Wenn die Kombination aus <xref:System.Net.Sockets.Socket> Typ und Protokolltyp zu einem ungültigen <xref:System.Net.Sockets.Socket>führt, löst dieser Konstruktor eine <xref:System.Net.Sockets.SocketException>aus.  
  
> [!NOTE]
>  Wenn dieser Konstruktor eine <xref:System.Net.Sockets.SocketException>auslöst, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Die Kombination von <paramref name="socketType" /> und <paramref name="protocolType" /> führt zu einem ungültigen Socket.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Einer der <see cref="T:System.Net.Sockets.AddressFamily" />-Werte.</param>
        <param name="socketType">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</param>
        <param name="protocolType">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse unter Verwendung der angegebenen Adressfamilie sowie des angegebenen Sockettyps und Protokolls.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `addressFamily`-Parameter gibt das Adressierungs Schema an, das die <xref:System.Net.Sockets.Socket> Klasse verwendet, der `socketType`-Parameter gibt den Typ der <xref:System.Net.Sockets.Socket> Klasse an, und der `protocolType`-Parameter gibt das von <xref:System.Net.Sockets.Socket>verwendete Protokoll an. Die drei Parameter sind nicht unabhängig. Einige Adressfamilien beschränken, welche Protokolle mit Ihnen verwendet werden können, und häufig ist der <xref:System.Net.Sockets.Socket> Typ im Protokoll implizit. Wenn die Kombination aus Adressfamilie, <xref:System.Net.Sockets.Socket> Typ und Protokolltyp zu einem ungültigen <xref:System.Net.Sockets.Socket>führt, löst dieser Konstruktor eine <xref:System.Net.Sockets.SocketException>aus.  
  
> [!NOTE]
>  Wenn dieser Konstruktor eine <xref:System.Net.Sockets.SocketException>auslöst, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine Instanz der <xref:System.Net.Sockets.Socket>-Klasse erstellt wird.  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Die Kombination von <paramref name="addressFamily" />, <paramref name="socketType" /> und <paramref name="protocolType" /> führt zu einem ungültigen Socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Net.Sockets.Socket" /> für eine neu erstellte Verbindung.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" /> für eine neu erstellte Verbindung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> die erste ausstehende Verbindungsanforderung synchron aus der Verbindungs Anforderungs Warteschlange des überwachungssysockets extrahiert und dann eine neue <xref:System.Net.Sockets.Socket>erstellt und zurückgegeben. Sie können dieses zurückgegebene <xref:System.Net.Sockets.Socket> nicht verwenden, um zusätzliche Verbindungen aus der Verbindungs Warteschlange zu akzeptieren. Sie können jedoch die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>-Methode der zurückgegebenen <xref:System.Net.Sockets.Socket> abrufen, um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.  
  
 Im Blockierungs Modus wird <xref:System.Net.Sockets.Socket.Accept%2A> blockiert, bis ein eingehender Verbindungsversuch in die Warteschlange eingereiht wird. Nachdem eine Verbindung akzeptiert wurde, werden die eingehenden Verbindungsanforderungen vom ursprünglichen <xref:System.Net.Sockets.Socket> in die Warteschlange eingereiht, bis Sie Sie schließen.  
  
 Wenn Sie diese Methode mit einer nicht blockierenden <xref:System.Net.Sockets.Socket>aufzurufen und keine Verbindungsanforderungen in die Warteschlange eingereiht werden, löst <xref:System.Net.Sockets.Socket.Accept%2A> eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Bevor Sie die <xref:System.Net.Sockets.Socket.Accept%2A>-Methode aufrufen, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.Listen%2A>-Methode aufrufen, um eingehende Verbindungsanforderungen abzuhören und in die Warteschlange zu  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine einfache <xref:System.Net.Sockets.Socket> Verbindung akzeptiert.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht keine Verbindungen. Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.Accept" /> aufrufen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungs orientierte Protokolle können die <xref:System.Net.Sockets.Socket.AcceptAsync%2A>-Methode verwenden, um eingehende Verbindungsversuche asynchron zu verarbeiten. Durch die asynchrone Annahme von Verbindungen haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden und zu empfangen. Bevor Sie die <xref:System.Net.Sockets.Socket.AcceptAsync%2A>-Methode aufrufen, müssen Sie die <xref:System.Net.Sockets.Socket.Listen%2A>-Methode aufrufen, um eingehende Verbindungsanforderungen abzuhören und in die Warteschlange zu  
  
 Damit Sie über den Abschluss benachrichtigt werden können, müssen Sie eine Rückruf Methode erstellen, die den EventHandler-\<SocketAsyncEventArgs-> Delegaten implementiert und ihn mit dem <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>-Ereignis verknüpft.  
  
 Die folgenden Eigenschaften und Ereignisse für das <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann optional eine vorhandene <xref:System.Net.Sockets.Socket> angeben, die für die eingehende Verbindung verwendet werden soll, indem er das <xref:System.Net.Sockets.Socket> angibt, das mit der <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>-Eigenschaft verwendet  
  
 Wenn die <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>-Eigenschaft NULL ist, wird eine neue <xref:System.Net.Sockets.Socket> mit derselben <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>und <xref:System.Net.Sockets.Socket.ProtocolType%2A> wie der aktuellen <xref:System.Net.Sockets.Socket> erstellt und als <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>-Eigenschaft festgelegt.  
  
 Der Aufrufer kann die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>-Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, bevor die <xref:System.Net.Sockets.Socket.AcceptAsync%2A>-Methode aufgerufen wird, damit die Informationen in der Rückruf Methode abgerufen werden können. Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.  
  
 Optional kann ein Puffer bereitgestellt werden, in dem der anfängliche Datenblock im Socket empfangen werden kann, nachdem die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erfolgreich abgeschlossen wurde. In diesem Fall muss die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>-Eigenschaft auf den Puffer festgelegt werden, der die zu empfangenden Daten enthält, und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>-Eigenschaft muss auf die maximale Anzahl von Daten Bytes festgelegt werden, die im Puffer empfangen werden. Diese Eigenschaften können mit der <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>-Methode festgelegt werden. Ein Teil des verworfenen Puffers wird intern für die Verwendung durch den zugrunde liegenden Winsock-Accept-Accept-Vorgang verwendet. Dies bedeutet, dass die Menge der zurückgegebenen Daten immer kleiner ist als der Wert der <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>-Eigenschaft auf der bereitgestellten <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Instanz. Die intern verwendete Puffergröße variiert abhängig von der Adressfamilie des Sockets. Die mindestens erforderliche Puffergröße beträgt 288 bytes. Wenn eine größere Puffergröße angegeben wird, erwartet die <xref:System.Net.Sockets.Socket> einige zusätzliche Daten, die nicht vom Winsock-Accept-Accept-Befehl empfangen werden, und wartet, bis diese zusätzlichen Daten empfangen wurden. Wenn ein Timeout auftritt, wird die Verbindung zurückgesetzt. Wenn also zusätzliche Daten eines bestimmten Betrags erwartet werden, sollte die Puffergröße auf die minimale Puffergröße Plus diese Menge festgelegt werden.  
  
 Die Beendigungs Rückruf Methode sollte die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>-Eigenschaft überprüfen, um zu bestimmen, ob der <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Vorgang erfolgreich war.  
  
 Das <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis kann in einigen Fällen auftreten, wenn keine Verbindung akzeptiert wurde und die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>-Eigenschaft auf <xref:System.Net.Sockets.SocketError.ConnectionReset>festgelegt wurde. Dies kann das Ergebnis der Überprüfung des Ports mithilfe eines halb geöffneten SYN-typscans sein (eine SYN-> SYN-ACK-> RST-Sequenz). Anwendungen, die die <xref:System.Net.Sockets.Socket.AcceptAsync%2A>-Methode verwenden, sollten darauf vorbereitet sein, diese Bedingung zu verarbeiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument ist ungültig. Diese Ausnahme tritt auf, wenn der bereitgestellte Puffer nicht groß genug ist. Der Puffer muss wenigstens 2 * (sizeof(SOCKADDR_STORAGE + 16) Bytes betragen.  
  
Diese Ausnahme tritt auch auf, wenn mehrere Puffer angegeben werden und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft nicht NULL ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein Argument liegt außerhalb des gültigen Bereichs. Die Ausnahme tritt auf, wenn <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> kleiner als 0 ist.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde eine ungültige Operation angefordert. Diese Ausnahme tritt auf, wenn der annehmende <see cref="T:System.Net.Sockets.Socket" /> keine Verbindungen überwacht oder der angenommene Socket gebunden ist.  
  
Sie müssen die <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />-Methode und die <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />-Methode aufrufen, bevor Sie die <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />-Methode aufrufen.  
  
Diese Ausnahme tritt auch auf, wenn der Socket bereits verbunden ist oder bereits ein Socketvorgang mit dem angegebenen <paramref name="e" />-Parameter ausgeführt wird.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Adressfamilie des <see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Einer der <see cref="T:System.Net.Sockets.AddressFamily" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.AddressFamily> gibt an, die Adressierung von Schemas, die einer Instanz von der <xref:System.Net.Sockets.Socket> Klasse verwenden kann. Diese Eigenschaft ist schreibgeschützt und wird festgelegt, wenn die <xref:System.Net.Sockets.Socket> erstellt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>und <xref:System.Net.Sockets.ProtocolType> in der Konsole angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Datenmenge ab, die über das Netzwerk empfangen wurde und gelesen werden kann.</summary>
        <value>Die Anzahl der Datenbytes, die vom Netzwerk empfangen wurden und zum Lesen zur Verfügung stehen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine nicht blockierende <xref:System.Net.Sockets.Socket>verwenden, ist <xref:System.Net.Sockets.Socket.Available%2A> eine gute Methode, um zu bestimmen, ob Daten vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A>in eine Warteschlange eingereiht werden. Bei den verfügbaren Daten handelt es sich um die Gesamtmenge der Daten im Netzwerk Puffer zum Lesen. Wenn keine Daten im Netzwerk Puffer in die Warteschlange eingereiht werden, gibt <xref:System.Net.Sockets.Socket.Available%2A> 0 zurück.  
  
 Wenn die Verbindung vom Remote Host heruntergefahren oder geschlossen wird, kann <xref:System.Net.Sockets.Socket.Available%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Ergebnisse des Abrufens von IOControl mit "dateread" und der verfügbaren Eigenschaft verglichen.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone <see cref="T:System.Net.Sockets.Socket" />-Erstellung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungs orientierte Protokolle können die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode verwenden, um eingehende Verbindungsversuche asynchron zu verarbeiten. Durch die asynchrone Annahme von Verbindungen haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden und zu empfangen. Bevor Sie die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode aufrufen, müssen Sie die <xref:System.Net.Sockets.Socket.Listen%2A>-Methode aufrufen, um eingehende Verbindungsanforderungen abzuhören und in die Warteschlange zu  
  
 Sie müssen eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode übergibt. Um dies zu erreichen, müssen Sie das Überwachung<xref:System.Net.Sockets.Socket> Objekt an <xref:System.Net.Sockets.Socket.BeginAccept%2A> über den `state`-Parameter übergeben. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, um die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen zu speichern. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieser Klasse an die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginAccept%2A>aufruft, verwendet das System in der Regel einen separaten Thread, um die angegebene Rückruf Methode auszuführen und Blöcke auf <xref:System.Net.Sockets.Socket.EndAccept%2A> auszuführen, bis eine ausstehende Verbindung abgerufen wird. <xref:System.Net.Sockets.Socket.EndAccept%2A> gibt ein neues <xref:System.Net.Sockets.Socket> Objekt zurück, das zum Senden und empfangen von Daten mit dem Remote Host verwendet werden kann. Sie können dieses zurückgegebene <xref:System.Net.Sockets.Socket> nicht verwenden, um zusätzliche Verbindungen aus der Verbindungs Warteschlange zu akzeptieren. Wenn der ursprüngliche Thread blockiert werden soll, nachdem Sie die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode aufgerufen haben, verwenden Sie <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode für eine <xref:System.Threading.ManualResetEvent> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.  
  
 Das System kann auch den aufrufenden Thread verwenden, um die Rückruf Methode aufzurufen. In diesem Fall wird die <xref:System.IAsyncResult.CompletedSynchronously%2A>-Eigenschaft des zurückgegebenen <xref:System.IAsyncResult> festgelegt, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode synchron abgeschlossen wurde.  
  
 Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Um einen ausstehenden aufzurufenden <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode abzubrechen, schließen Sie die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A>-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der für die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode bereitgestellt wird, aufgerufen.  Bei einem nachfolgenden-Rückruf der <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode wird ein <xref:System.ObjectDisposedException> ausgelöst, um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>-Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> verwenden, um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird versucht, asynchron eine eingehende Verbindung zu empfangen.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht keine Verbindungen. Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> aufrufen.  
  
- oder - 
Der angenommene Socket ist gebunden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize">Die Anzahl der Bytes vom Absender, die angenommen werden sollen.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen, und empfängt den ersten von der Clientanwendung gesendeten Datenblock.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone <see cref="T:System.Net.Sockets.Socket" />-Erstellung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungs orientierte Protokolle können die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode verwenden, um eingehende Verbindungsversuche asynchron zu verarbeiten. Das asynchrone akzeptieren von Verbindungen ermöglicht das Senden und empfangen von Daten in einem separaten Ausführungs Thread. Diese Überladung ermöglicht es Ihnen, die Anzahl der Bytes anzugeben, die bei der anfänglichen Übertragung im `receiveSize`-Parameter akzeptiert werden sollen.  
  
 Bevor Sie die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode aufrufen, müssen Sie die <xref:System.Net.Sockets.Socket.Listen%2A>-Methode aufrufen, um eingehende Verbindungsanforderungen abzuhören und in die Warteschlange zu  
  
 Sie müssen eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode übergibt. Um dies zu erreichen, müssen Sie das Überwachung<xref:System.Net.Sockets.Socket> Objekt an <xref:System.Net.Sockets.Socket.BeginAccept%2A> über den `state`-Parameter übergeben. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, um die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen zu speichern. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieser Klasse an die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginAccept%2A>aufruft, verwendet das System in der Regel einen separaten Thread, um die angegebene Rückruf Methode auszuführen und Blöcke auf <xref:System.Net.Sockets.Socket.EndAccept%2A> auszuführen, bis eine ausstehende Verbindung abgerufen wird.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> gibt einen neuen <xref:System.Net.Sockets.Socket> zurück, den Sie zum Senden und empfangen von Daten mit dem Remote Host verwenden können. Sie können dieses zurückgegebene <xref:System.Net.Sockets.Socket> nicht verwenden, um zusätzliche Verbindungen aus der Verbindungs Warteschlange zu akzeptieren. Wenn der ursprüngliche Thread blockiert werden soll, nachdem Sie die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode aufgerufen haben, verwenden Sie <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode für eine <xref:System.Threading.ManualResetEvent> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.  
  
 Das System kann auch den aufrufenden Thread verwenden, um die Rückruf Methode aufzurufen. In diesem Fall wird die <xref:System.IAsyncResult.CompletedSynchronously%2A>-Eigenschaft des zurückgegebenen <xref:System.IAsyncResult> festgelegt, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode synchron abgeschlossen wurde.  
  
 Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Um einen ausstehenden aufzurufenden <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode abzubrechen, schließen Sie die <xref:System.Net.Sockets.Socket>.  Wenn die <xref:System.Net.Sockets.Socket.Close%2A>-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der für die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode bereitgestellt wird, aufgerufen.  Bei einem nachfolgenden-Rückruf der <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode wird ein <xref:System.ObjectDisposedException> ausgelöst, um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Sie können mit der <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>-Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> Objekts aufzurufen, um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket geöffnet und eine asynchrone Verbindung akzeptiert. In diesem Beispiel nimmt der Socket die ersten 10 Bytes an Daten an. Die Anzahl der empfangenen Bytes und die Daten werden vom Rückruf Delegaten in der Konsole angezeigt. Unter <xref:System.Net.Sockets.Socket.BeginReceive%2A> finden Sie eine Beschreibung, wie die verbleibenden Daten empfangen werden.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht keine Verbindungen. Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> aufrufen.  
  
- oder - 
Der angenommene Socket ist gebunden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">Das angenommene <see cref="T:System.Net.Sockets.Socket" />-Objekt. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="receiveSize">Die maximale Anzahl der zu empfangenden Bytes.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung von einem angegebenen Socket anzunehmen, und empfängt den ersten von der Clientanwendung gesendeten Datenblock.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone <see cref="T:System.Net.Sockets.Socket" />-Objekterstellung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungs orientierte Protokolle können die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode verwenden, um eingehende Verbindungsversuche asynchron zu verarbeiten. Durch die asynchrone Annahme von Verbindungen haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden und zu empfangen. Mit dieser Überladung können Sie den akzeptierten Socket im `acceptSocket`-Parameter angeben. Wenn dieser Parameter `null`ist, wird der akzeptierte Socket von der <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode erstellt. Sie können die Anzahl der Bytes angeben, die bei der anfänglichen Übertragung im `receiveSize`-Parameter akzeptiert werden sollen.  
  
 Bevor Sie die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode aufrufen, müssen Sie die <xref:System.Net.Sockets.Socket.Listen%2A>-Methode aufrufen, um eingehende Verbindungsanforderungen abzuhören und in die Warteschlange zu  
  
 Sie müssen eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode übergibt. Um dies zu erreichen, müssen Sie das Überwachung<xref:System.Net.Sockets.Socket> Objekt an <xref:System.Net.Sockets.Socket.BeginAccept%2A> über den `state`-Parameter übergeben. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, um die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen zu speichern. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieser Klasse an die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginAccept%2A>aufruft, verwendet das System in der Regel einen separaten Thread, um die angegebene Rückruf Methode auszuführen und Blöcke auf <xref:System.Net.Sockets.Socket.EndAccept%2A> auszuführen, bis eine ausstehende Verbindung abgerufen wird.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> gibt ein neues <xref:System.Net.Sockets.Socket>-Objekt zurück, das Sie zum Senden und empfangen von Daten mit dem Remote Host verwenden können. Sie können dieses zurückgegebene <xref:System.Net.Sockets.Socket> nicht verwenden, um zusätzliche Verbindungen aus der Verbindungs Warteschlange zu akzeptieren. Wenn der ursprüngliche Thread blockiert werden soll, nachdem Sie die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode aufgerufen haben, verwenden Sie <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode für eine <xref:System.Threading.ManualResetEvent> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.  
  
 Das System kann auch den aufrufenden Thread verwenden, um die Rückruf Methode aufzurufen. In diesem Fall wird die <xref:System.IAsyncResult.CompletedSynchronously%2A>-Eigenschaft des zurückgegebenen <xref:System.IAsyncResult> festgelegt, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode synchron abgeschlossen wurde.  
  
 Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Um einen ausstehenden aufzurufenden <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode abzubrechen, schließen Sie die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A>-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der für die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode bereitgestellt wird, aufgerufen.  Bei einem nachfolgenden-Rückruf der <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode wird ein <xref:System.ObjectDisposedException> ausgelöst, um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>-Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket>-Objekts verwenden, um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket geöffnet und eine asynchrone Verbindung akzeptiert. In diesem Beispiel akzeptiert der Socket die anfänglichen 10 Bytes an Daten, und der `acceptSocket`-Parameter ist `null`, wodurch die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode gezwungen wird, den akzeptierten Socket zu erstellen. Die Anzahl der empfangenen Bytes und die Daten werden vom Rückruf Delegaten in der Konsole angezeigt. Unter <xref:System.Net.Sockets.Socket.BeginReceive%2A> finden Sie eine Beschreibung, wie die verbleibenden Daten empfangen werden.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht keine Verbindungen. Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> aufrufen.  
  
- oder - 
Der angenommene Socket ist gebunden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Ein <see cref="T:System.Net.EndPoint" />, der den Remotehost darstellt.</param>
        <param name="end_point">Ein <see cref="T:System.Net.EndPoint" />, der den Remotehost darstellt.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, startet die <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode eine asynchrone Anforderung für eine Verbindung mit dem `remoteEP`-Parameter. Wenn Sie ein verbindungsloses Protokoll verwenden, stellt <xref:System.Net.Sockets.Socket.BeginConnect%2A> einen Standard Remote Host her. Das asynchrone verbinden oder Festlegen des Standard Remote Hosts ermöglicht Ihnen das Senden und empfangen von Daten in einem separaten Ausführungs Thread.  
  
 Sie können eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode übergibt. Sie müssen die <xref:System.Net.Sockets.Socket> nur minimal an <xref:System.Net.Sockets.Socket.BeginConnect%2A> über den `state`-Parameter übergeben. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, um die <xref:System.Net.Sockets.Socket>und die anderen erforderlichen Informationen zu speichern. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieser Klasse an die <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.Socket.EndConnect%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufruft, verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert <xref:System.Net.Sockets.Socket.EndConnect%2A>, bis der <xref:System.Net.Sockets.Socket> erfolgreich eine Verbindung herstellt oder eine Ausnahme auslöst. Wenn der ursprüngliche Thread blockiert werden soll, nachdem Sie die <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode aufgerufen haben, verwenden Sie <xref:System.Threading.WaitHandle.WaitOne%2A>. Rufen Sie die Set-Methode für eine <xref:System.Threading.ManualResetEvent> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie <xref:System.Net.Sockets.Socket.BeginConnect%2A> vor dem Senden und empfangen von Daten nicht aufzurufen. Sie können <xref:System.Net.Sockets.Socket.BeginSendTo%2A> und <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> verwenden, um mit einem Remote Host zu kommunizieren. Wenn Sie <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufzurufen, werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eintreffen. Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst <xref:System.Net.Sockets.Socket.SetSocketOption%2A> und Broadcast auf `true`festlegen. Wenn dies nicht möglich ist, wird <xref:System.Net.Sockets.Socket.BeginConnect%2A> eine <xref:System.Net.Sockets.SocketException>auslösen.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginConnect%2A>nicht aufrufen, weist der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zu. Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine lokale Netzwerkadresse und eine Portnummer zu, wenn Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A>-oder <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode aufgerufen haben. Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie die <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode erneut mit dem gewünschten Endpunkt abrufen.  
  
 Um einen ausstehenden aufzurufenden <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode abzubrechen, schließen Sie die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A>-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der für die <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode bereitgestellt wird, aufgerufen.  Bei einem nachfolgenden-Rückruf der <xref:System.Net.Sockets.Socket.EndConnect%2A>-Methode wird ein <xref:System.ObjectDisposedException> ausgelöst, um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn dieser Socket bereits getrennt wurde, müssen <xref:System.Net.Sockets.Socket.BeginConnect%2A> für einen Thread aufgerufen werden, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieters.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein asynchroner Verbindungsversuch initiiert.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">Die <see cref="T:System.Net.IPAddress" /> des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <param name="requestCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung. Der Host wird durch eine <see cref="T:System.Net.IPAddress" /> und eine Portnummer angegeben.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.Socket.EndConnect%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `requestCallback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang beendet ist. Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der <xref:System.Net.Sockets.Socket.Connect%2A> Methoden Überladungen oder <xref:System.Net.Sockets.Socket.EndConnect%2A>.  
  
 Um einen ausstehenden aufzurufenden <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode abzubrechen, schließen Sie die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A>-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der für die <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode bereitgestellt wird, aufgerufen.  Bei einem nachfolgenden-Rückruf der <xref:System.Net.Sockets.Socket.EndConnect%2A>-Methode wird ein <xref:System.ObjectDisposedException> ausgelöst, um anzugeben, dass der Vorgang abgebrochen wurde.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) .  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn dieser Socket bereits getrennt wurde, müssen <xref:System.Net.Sockets.Socket.BeginConnect%2A> für einen Thread aufgerufen werden, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieters. Außerdem müssen die <xref:System.Net.EndPoint>, die verwendet werden, unterschiedlich sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein asynchroner Verbindungsversuch initiiert.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Der <see cref="T:System.Net.Sockets.Socket" /> ist nicht in der Socketfamilie enthalten.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="addresses">Mindestens eine <see cref="T:System.Net.IPAddress" />, die den Remotehost angibt.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <param name="requestCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung. Der Host wird durch ein <see cref="T:System.Net.IPAddress" />-Array und eine Portnummer angegeben.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchronen Verbindungen verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.Socket.EndConnect%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `requestCallback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang beendet ist. Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der <xref:System.Net.Sockets.Socket.Connect%2A>-Methoden Überladungen.  
  
 Um einen ausstehenden aufzurufenden <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode abzubrechen, schließen Sie die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A>-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der für die <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode bereitgestellt wird, aufgerufen.  Bei einem nachfolgenden-Rückruf der <xref:System.Net.Sockets.Socket.EndConnect%2A>-Methode wird ein <xref:System.ObjectDisposedException> ausgelöst, um anzugeben, dass der Vorgang abgebrochen wurde.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn dieser Socket bereits getrennt wurde, müssen <xref:System.Net.Sockets.Socket.BeginConnect%2A> für einen Thread aufgerufen werden, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieters. Außerdem müssen die <xref:System.Net.EndPoint>, die verwendet werden, unterschiedlich sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein asynchroner Verbindungsversuch initiiert.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets, die <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> verwenden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="host">Der Name des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <param name="requestCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung. Der Host wird durch einen Hostnamen und eine Portnummer angegeben.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.Socket.EndConnect%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `requestCallback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang beendet ist. Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der <xref:System.Net.Sockets.Socket.Connect%2A>-Methoden Überladungen.  
  
 Um einen ausstehenden aufzurufenden <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode abzubrechen, schließen Sie die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A>-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der für die <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode bereitgestellt wird, aufgerufen.  Bei einem nachfolgenden-Rückruf der <xref:System.Net.Sockets.Socket.EndConnect%2A>-Methode wird ein <xref:System.ObjectDisposedException> ausgelöst, um anzugeben, dass der Vorgang abgebrochen wurde.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) .  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn dieser Socket bereits getrennt wurde, müssen <xref:System.Net.Sockets.Socket.BeginConnect%2A> für einen Thread aufgerufen werden, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieters. Außerdem müssen die <xref:System.Net.EndPoint>, die verwendet werden, unterschiedlich sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein asynchroner Verbindungsversuch initiiert.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" />, wenn dieser Socket wiederverwendet werden kann, nachdem die Verbindung geschlossen wurde, andernfalls <see langword="false" />.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt eine asynchrone Anforderung zum Trennen der Verbindung mit einem Remoteendunkt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das auf den asynchronen Vorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, können Sie die <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>-Methode aufzurufen, um eine Trennung von einem Remote Endpunkt anzufordern. Wenn `reuseSocket` `true`ist, können Sie den Socket wieder verwenden.  
  
 Die <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>-Methode verwendet einen separaten Thread, um die angegebene Rückruf Methode aufzurufen. Die <xref:System.Net.Sockets.Socket.EndDisconnect%2A>-Methode blockiert, bis die ausstehende Trennung abgeschlossen ist. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException> Ausnahme erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Socket für die asynchrone Kommunikation und sendet einige Daten an einen Remote Host. Wenn die Daten gesendet wurden, wird <xref:System.Net.Sockets.Socket.Shutdown%2A> aufgerufen, um die Sende-und Empfangs Aktivität anzuhalten. Anschließend wird <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> aufgerufen, um eine Disconnect-Anforderung zu starten. Wenn die Anforderung abgeschlossen ist, wird die <xref:System.Net.Sockets.Socket.Connected%2A>-Eigenschaft abgefragt, um zu überprüfen, ob der Socket getrennt ist.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `callback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang beendet ist. Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der <xref:System.Net.Sockets.Socket.Receive%2A>-Methoden Überladungen.  
  
 Um einen ausstehenden <xref:System.Net.Sockets.Socket.BeginReceive%2A>abzubrechen, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A>-Methode auf.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `callback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang beendet ist. Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der <xref:System.Net.Sockets.Socket.Receive%2A>-Methoden Überladungen.  
  
 Um einen ausstehenden <xref:System.Net.Sockets.Socket.BeginReceive%2A>abzubrechen, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A>-Methode auf.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="socket_flags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `callback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang beendet ist. Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der <xref:System.Net.Sockets.Socket.Receive%2A>-Methoden Überladungen.  
  
 Um einen ausstehenden <xref:System.Net.Sockets.Socket.BeginReceive%2A>abzubrechen, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A>-Methode auf.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Das folgende Codebeispiel beginnt mit dem asynchronen empfangen von Daten aus einem verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, errorCode, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="offset">Die Position im <paramref name="buffer" />, an der die empfangenen Daten gespeichert werden sollen.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="flags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <param name="error">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `callback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang beendet ist. Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der <xref:System.Net.Sockets.Socket.Receive%2A>-Methoden Überladungen.  
  
 Um einen ausstehenden <xref:System.Net.Sockets.Socket.BeginReceive%2A>abzubrechen, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A>-Methode auf.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der die Daten gespeichert werden.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="socket_flags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein <see cref="T:System.Net.EndPoint" />, der die Datenquelle darstellt.</param>
        <param name="remote_end">Ein <see cref="T:System.Net.EndPoint" />, der die Datenquelle darstellt.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem angegebenen Netzwerkgerät.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode startet das asynchrone Lesen von Verbindungs losen Datagramme von einem Remote Host. Wenn Sie die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode aufrufen, haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu empfangen.  
  
 Sie können eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode übergibt. Um dies zu erreichen, muss der `state` Parameter den verbundenen oder den Standard <xref:System.Net.Sockets.Socket> enthalten, der für die Kommunikation verwendet wird. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, um die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen zu speichern. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieser Klasse an die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>aufruft, verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>, bis der <xref:System.Net.Sockets.Socket> Daten liest oder eine Ausnahme auslöst. Wenn der ursprüngliche Thread blockiert werden soll, nachdem Sie die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode aufgerufen haben, verwenden Sie <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode für ein T:System.Threading.ManualResetEvent in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>müssen Sie die <xref:System.Net.Sockets.Socket> mithilfe der <xref:System.Net.Sockets.Socket.Bind%2A>-Methode explizit an einen lokalen Endpunkt binden, oder <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
 Diese Methode liest Daten in den `buffer`-Parameter und erfasst den Remote Host Endpunkt, von dem die Daten gesendet werden. Informationen zum Abrufen dieses Endpunkts finden Sie unter <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Diese Methode ist besonders nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts asynchron empfangen möchten. In diesen Fällen liest <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> das erste in die Warteschlange eingereihte Datagramm, das in den Puffer des lokalen Netzwerks empfangen wird. Wenn das Datagramm, das Sie empfangen, größer ist als die Größe der `buffer`, wird die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode `buffer` mit dem größtmöglichen Wert der Nachricht aufgefüllt und eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein unzuverlässiges Protokoll verwenden, gehen die Daten verloren. Wenn Sie ein zuverlässiges Protokoll verwenden, werden die überzähligen Daten vom Dienstanbieter aufbewahrt, und Sie können Sie abrufen, indem Sie die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode mit einem ausreichend großen Puffer aufrufen.  
  
 Um sicherzustellen, dass der Remote Host Endpunkt immer zurückgegeben wird, sollte eine Anwendung die <xref:System.Net.Sockets.Socket> mithilfe der <xref:System.Net.Sockets.Socket.Bind%2A>-Methode explizit an einen lokalen Endpunkt binden und dann die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode aufrufen, wobei der `optionLevel`-Parameter auf <xref:System.Net.Sockets.SocketOptionLevel.IP> festgelegt ist, oder <xref:System.Net.Sockets.SocketOptionLevel.IPv6> Parameter auf `optionName` festgelegt ist, und der <xref:System.Net.Sockets.SocketOptionName.PacketInformation>-Parameter, um diese Option zu aktivieren, bevor die `optionValue`-Methode aufgerufen wird.<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Andernfalls ist es möglich, dass der Remote Host Endpunkt nicht zurückgegeben wird, wenn der Absender eine Reihe von Datagramme gesendet hat, bevor der Empfänger die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode aufgerufen hat.  
  
 Obwohl <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> für verbindungslose Protokolle vorgesehen ist, können Sie auch ein Verbindungs orientiertes Protokoll verwenden. Wenn Sie sich dafür entscheiden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode aufrufen oder eine eingehende Verbindungsanforderung akzeptieren, indem Sie die <xref:System.Net.Sockets.Socket.Accept%2A>-oder <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode aufrufen. Wenn Sie die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode vor dem Einrichten oder akzeptieren einer Verbindung aufzurufen, erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode aufrufen. In beiden Fällen ignoriert die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode den `remoteEP`-Parameter und empfängt nur Daten vom verbundenen oder standardmäßigen Remote Host.  
  
 Mit Verbindungs orientierten Sockets lesen <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> so viele Daten, wie Sie bis zur Anzahl der Bytes verfügbar sind, die durch den Parameter `size` angegeben werden.  
  
 Um einen ausstehenden <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>abzubrechen, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A>-Methode auf.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verbindungslose Datagramme von einem Remote Host asynchron empfangen.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der die Daten gespeichert werden.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein <see cref="T:System.Net.EndPoint" />, der die Datenquelle darstellt.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />-Klassen den asynchronen Empfang der angegebenen Anzahl von Datenbytes an der angegebenen Position im Datenpuffer und speichert die Endpunkt- und Paketinformationen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone Empfangsvorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `asyncCallback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Um zu blockieren, bis der Vorgang abgeschlossen ist, verwenden Sie die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>-Methode.  
  
 Um einen ausstehenden <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>abzubrechen, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A>-Methode auf.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) .  
  
 Diese Methode liest Daten in den `buffer`-Parameter und erfasst den Remote Host Endpunkt, von dem die Daten gesendet werden, sowie Informationen über das empfangene Paket. Informationen zum Abrufen dieses Endpunkts finden Sie unter <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Diese Methode ist besonders nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts asynchron empfangen möchten.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode startet einen asynchronen Sendevorgang an den Remote Host, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-, <xref:System.Net.Sockets.Socket.BeginConnect%2A>-, <xref:System.Net.Sockets.Socket.Accept%2A>-oder <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode eingerichtet wurde. <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufgerufen haben. Wenn Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode aufrufen, haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.  
  
 Sie können eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode übergibt. Um dies zu erreichen, muss der `state` Parameter den verbundenen oder den Standard <xref:System.Net.Sockets.Socket> enthalten, der für die Kommunikation verwendet wird. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieser Klasse an die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.Socket.EndSend%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginSend%2A>aufruft, verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A>, bis der <xref:System.Net.Sockets.Socket> die Anzahl der angeforderten Bytes sendet oder eine Ausnahme auslöst. Wenn Sie möchten, dass der ursprüngliche Thread blockiert wird, nachdem Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode aufgerufen haben, verwenden Sie die <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>-Methode. Rufen Sie die Set-Methode für ein T:System.Threading.ManualResetEvent in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl <xref:System.Net.Sockets.Socket.BeginSend%2A> für Verbindungs orientierte Protokolle vorgesehen ist, kann auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode zum Einrichten eines Standard Remote Hosts aufzurufen. Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>verwenden. Es ist in Ordnung, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> auch dann zu verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard Remote Host auch vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginSend%2A> ändern, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufrufen. Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
 Wenn Sie das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode startet einen asynchronen Sendevorgang an den Remote Host, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-, <xref:System.Net.Sockets.Socket.BeginConnect%2A>-, <xref:System.Net.Sockets.Socket.Accept%2A>-oder <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode eingerichtet wurde. <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufgerufen haben. Wenn Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode aufrufen, haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.  
  
 Sie können eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode übergibt. Um dies zu erreichen, muss der `state` Parameter den verbundenen oder den Standard <xref:System.Net.Sockets.Socket> enthalten, der für die Kommunikation verwendet wird. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieser Klasse an die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.Socket.EndSend%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginSend%2A>aufruft, verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A>, bis der <xref:System.Net.Sockets.Socket> die Anzahl der angeforderten Bytes sendet oder eine Ausnahme auslöst. Wenn Sie möchten, dass der ursprüngliche Thread blockiert wird, nachdem Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode aufgerufen haben, verwenden Sie die <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>-Methode. Rufen Sie die Set-Methode für eine <xref:System.Threading.ManualResetEvent> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl <xref:System.Net.Sockets.Socket.BeginSend%2A> für Verbindungs orientierte Protokolle vorgesehen ist, kann auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode zum Einrichten eines Standard Remote Hosts aufzurufen. Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>verwenden. Es ist in Ordnung, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> auch dann zu verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard Remote Host auch vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginSend%2A> ändern, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufrufen. Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
 Wenn Sie das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der mit dem Senden der Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl der zu sendenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode startet einen asynchronen Sendevorgang an den Remote Host, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-, <xref:System.Net.Sockets.Socket.BeginConnect%2A>-, <xref:System.Net.Sockets.Socket.Accept%2A>-oder <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode eingerichtet wurde. <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufgerufen haben. Wenn Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode aufrufen, haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.  
  
 Sie können eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode übergibt. Um dies zu erreichen, muss der `state` Parameter den verbundenen oder den Standard <xref:System.Net.Sockets.Socket> enthalten, der für die Kommunikation verwendet wird. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieser Klasse an die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.Socket.EndSend%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginSend%2A>aufruft, verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A>, bis der <xref:System.Net.Sockets.Socket> die Anzahl der angeforderten Bytes sendet oder eine Ausnahme auslöst. Wenn Sie möchten, dass der ursprüngliche Thread blockiert wird, nachdem Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode aufgerufen haben, verwenden Sie die <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>-Methode. Rufen Sie die Set-Methode für ein T:System.Threading.ManualResetEvent in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl <xref:System.Net.Sockets.Socket.BeginSend%2A> für Verbindungs orientierte Protokolle vorgesehen ist, kann auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode zum Einrichten eines Standard Remote Hosts aufzurufen. Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>verwenden. Es ist in Ordnung, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> auch dann zu verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard Remote Host auch vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginSend%2A> ändern, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufrufen. Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
 Wenn Sie das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist kleiner als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der mit dem Senden der Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl der zu sendenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="socket_flags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode startet einen asynchronen Sendevorgang an den Remote Host, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-, <xref:System.Net.Sockets.Socket.BeginConnect%2A>-, <xref:System.Net.Sockets.Socket.Accept%2A>-oder <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode eingerichtet wurde. <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufgerufen haben. Wenn Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode aufrufen, haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.  
  
 Sie können eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode übergibt. Um dies zu erreichen, muss der `state` Parameter den verbundenen oder den Standard <xref:System.Net.Sockets.Socket> enthalten, der für die Kommunikation verwendet wird. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieser Klasse an die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.Socket.EndSend%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginSend%2A>aufruft, verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A>, bis der <xref:System.Net.Sockets.Socket> die Anzahl der angeforderten Bytes sendet oder eine Ausnahme auslöst. Wenn Sie möchten, dass der ursprüngliche Thread blockiert wird, nachdem Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode aufgerufen haben, verwenden Sie die <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>-Methode. Rufen Sie die Set-Methode für ein T:System.Threading.ManualResetEvent in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl <xref:System.Net.Sockets.Socket.BeginSend%2A> für Verbindungs orientierte Protokolle vorgesehen ist, kann auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode zum Einrichten eines Standard Remote Hosts aufzurufen. Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>verwenden. Es ist in Ordnung, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> auch dann zu verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard Remote Host auch vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginSend%2A> ändern, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufrufen. Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
 Wenn Sie das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Das folgende Codebeispiel beginnt mit dem asynchronen Senden von Daten an einen Remote Host.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist kleiner als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet eine Datei asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Eine Zeichenfolge, die den Pfad und Namen der zu sendenden Datei enthält. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet die Datei <paramref name="fileName" /> unter Verwendung des <see cref="T:System.Net.Sockets.Socket" />-Flags an ein verbundenes <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den asynchronen Sendevorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung sendet die Datei `fileName` an den verbundenen Socket. Wenn sich `fileName` im lokalen Verzeichnis befindet, wird es möglicherweise nur mit dem Namen der Datei identifiziert. Andernfalls müssen der vollständige Pfad und der Name der Datei angegeben werden. Platzhalter ("..\\\MyFile.txt ") und UNC-Freigabe Namen ("\\\\\\\Shared Directory\\\MyFile.txt ") werden unterstützt. Wenn die Datei nicht gefunden wird, wird die Ausnahme <xref:System.IO.FileNotFoundException> ausgelöst.  
  
 Diese Methode verwendet die `TransmitFile`-Funktion, die in der Windows Sockets 2-API enthalten ist. Weitere Informationen zur `TransmitFile` Funktion und ihren Flags finden Sie in der Dokumentation zu [Windows Sockets](/windows/desktop/WinSock/) .  
  
 Die <xref:System.Net.Sockets.Socket.BeginSendFile%2A>-Methode startet einen asynchronen Sendevorgang an den Remote Host, der in den Methoden <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> festgelegt ist. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufgerufen haben. Wenn Sie die <xref:System.Net.Sockets.Socket.BeginSendFile%2A>-Methode aufrufen, können Sie eine Datei in einem separaten Ausführungs Thread senden.  
  
 Um den Vorgang abzuschließen, können Sie eine Rückruf Methode erstellen, die vom <xref:System.AsyncCallback> Delegatparameter aufgerufen wird. Um dies zu erreichen, muss der `state`-Parameter das <xref:System.Net.Sockets.Socket> Objekt enthalten, das für die Kommunikation verwendet wird. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieses benutzerdefinierten Objekts an die <xref:System.Net.Sockets.Socket.BeginSendFile%2A>-Methode.  
  
 Die Rückruf Methode muss die <xref:System.Net.Sockets.Socket.EndSendFile%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginSendFile%2A>aufruft, verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert <xref:System.Net.Sockets.Socket.EndSendFile%2A>, bis der <xref:System.Net.Sockets.Socket> die gesamte Datei sendet oder eine Ausnahme auslöst. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl <xref:System.Net.Sockets.Socket.BeginSendFile%2A> für Verbindungs orientierte Protokolle vorgesehen ist, kann auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode zum Einrichten eines Standard Remote Hosts aufzurufen. Bei Verbindungs losen Protokollen müssen Sie sicherstellen, dass die Größe der Datei nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine <xref:System.Net.Sockets.SocketException> Ausnahme aus.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException> Ausnahme erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket für die asynchrone Kommunikation erstellt und verbunden. Zuerst wird die Datei "Text. txt" asynchron an den Remote Host gesendet. Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> auf, um die Übertragung abzuschließen.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Eine Zeichenfolge, die den Pfad und Namen der zu sendenden Datei enthält. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="preBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, bevor die Datei gesendet wird. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="postBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, nachdem die Datei gesendet wurde. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="flags">Eine bitweise Kombination von <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Werten.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der nach Abschluss dieses Vorgangs aufgerufen werden soll. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="state">Ein benutzerdefiniertes Objekt mit Zustandsinformationen für diese Anforderung. Dieser Parameter kann <see langword="null" /> sein.</param>
        <summary>Sendet eine Datei und Datenpuffer asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung erfordert den Namen der Datei, die Sie senden möchten, und eine bitweise Kombination von <xref:System.Net.Sockets.TransmitFileOptions>-Werten. Der `preBuffer`-Parameter enthält alle Daten, die Sie der Datei vorausgehen möchten. `postBuffer` enthält Daten, die Sie der Datei folgen möchten. Wenn sich `fileName` im lokalen Verzeichnis befindet, wird es möglicherweise nur mit dem Namen der Datei identifiziert. Andernfalls müssen der vollständige Pfad und der Name der Datei angegeben werden. Platzhalter ("..\\\MyFile.txt ") und UNC-Freigabe Namen ("\\\\\\\Shared Directory\\\MyFile.txt ") werden unterstützt. Wenn die Datei nicht gefunden wird, wird die Ausnahme <xref:System.IO.FileNotFoundException> ausgelöst.  
  
 Der `flags`-Parameter stellt dem Window Sockets-Dienstanbieter zusätzliche Informationen über die Dateiübertragung zur Verfügung. Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Diese Methode verwendet die `TransmitFile`-Funktion, die in der Windows Sockets 2-API enthalten ist. Weitere Informationen zur `TransmitFile` Funktion und ihren Flags finden Sie in der Dokumentation zu [Windows Sockets](/windows/desktop/WinSock/) .  
  
 Die <xref:System.Net.Sockets.Socket.BeginSendFile%2A>-Methode startet einen asynchronen Sendevorgang an den Remote Host, der in den Methoden <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> festgelegt ist. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>aufgerufen haben. Wenn Sie die <xref:System.Net.Sockets.Socket.BeginSendFile%2A>-Methode aufrufen, haben Sie die Möglichkeit, eine Datei in einem separaten Ausführungs Thread zu senden.  
  
 Um den Vorgang abzuschließen, können Sie eine Rückruf Methode erstellen, die vom <xref:System.AsyncCallback> Delegatparameter aufgerufen wird. Um dies zu erreichen, muss der `state`-Parameter das <xref:System.Net.Sockets.Socket> Objekt enthalten, das für die Kommunikation verwendet wird. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieses benutzerdefinierten Objekts an die <xref:System.Net.Sockets.Socket.BeginSendFile%2A>-Methode.  
  
 Die Rückruf Methode muss die <xref:System.Net.Sockets.Socket.EndSendFile%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginSendFile%2A>aufruft, verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert <xref:System.Net.Sockets.Socket.EndSendFile%2A>, bis der <xref:System.Net.Sockets.Socket> die gesamte Datei sendet oder eine Ausnahme auslöst. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl <xref:System.Net.Sockets.Socket.BeginSendFile%2A> für Verbindungs orientierte Protokolle vorgesehen ist, kann auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode zum Einrichten eines Standard Remote Hosts aufzurufen. Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe der Datei nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine <xref:System.Net.Sockets.SocketException> Ausnahme aus.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException> Ausnahme erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket für asynchrone Kommunikation erstellt und verknüpft und die Datei "Text. txt" asynchron an den Remote Host gesendet. In diesem Beispiel werden eine `preBuffer` und eine `postBuffer` der Daten erstellt, um Sie mit der Datei zu senden, und der Standard <xref:System.Net.Sockets.TransmitFileOptions> Wert wird verwendet. Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> auf, um die Übertragung abzuschließen.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist nicht Windows NT oder höher.  
  
- oder -
  
 Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />, an der mit dem Senden der Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl der zu sendenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="socket_flags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein <see cref="T:System.Net.EndPoint" />, der das Remotegerät darstellt.</param>
        <param name="remote_end">Ein <see cref="T:System.Net.EndPoint" />, der das Remotegerät darstellt.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein object mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet asynchron Daten an einen angegebenen Remotehost.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSendTo%2A>-Methode startet einen asynchronen Sendevorgang an den im `remoteEP`-Parameter angegebenen Remote Host. Wenn Sie die <xref:System.Net.Sockets.Socket.BeginSendTo%2A>-Methode aufrufen, haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden. Obwohl <xref:System.Net.Sockets.Socket.BeginSendTo%2A> für verbindungslose Protokolle vorgesehen ist, funktioniert sowohl mit Verbindungs orientierten als auch mit Verbindungs orientierten Protokollen.  
  
 Sie können eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert und seinen Namen an die <xref:System.Net.Sockets.Socket.BeginSendTo%2A>-Methode übergibt. Um dies zu erreichen, muss der `state` Parameter den verbundenen oder den Standard <xref:System.Net.Sockets.Socket> enthalten, der für die Kommunikation verwendet wird. Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, um die <xref:System.Net.Sockets.Socket>und die anderen erforderlichen Informationen zu speichern. Übergeben Sie mithilfe des `state`-Parameters eine Instanz dieser Klasse an die <xref:System.Net.Sockets.Socket.BeginSendTo%2A>-Methode.  
  
 Die Rückruf Methode sollte die <xref:System.Net.Sockets.Socket.EndSendTo%2A>-Methode aufrufen. Wenn die Anwendung <xref:System.Net.Sockets.Socket.BeginSendTo%2A>aufruft, verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert <xref:System.Net.Sockets.Socket.EndSendTo%2A>, bis der <xref:System.Net.Sockets.Socket> die Anzahl der angeforderten Bytes sendet oder eine Ausnahme auslöst. Wenn Sie möchten, dass der ursprüngliche Thread blockiert wird, nachdem Sie die <xref:System.Net.Sockets.Socket.BeginSendTo%2A>-Methode aufgerufen haben, verwenden Sie die <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>-Methode. Rufen Sie die Set-Methode für ein T:System.Threading.ManualResetEvent in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst die Methode <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> oder <xref:System.Net.Sockets.Socket.BeginSendTo%2A> einen <xref:System.Net.Sockets.SocketException>auslösen. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> ignoriert den `remoteEP` Parameter und sendet Daten an die <xref:System.Net.EndPoint>, die in der <xref:System.Net.Sockets.Socket.Connect%2A>-, <xref:System.Net.Sockets.Socket.BeginConnect%2A>-, <xref:System.Net.Sockets.Socket.Accept%2A>-oder <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode festgelegt sind.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie vor dem Aufrufen von <xref:System.Net.Sockets.Socket.SendTo%2A>keinen Standard-Remote Host mit der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode einrichten. Dies ist nur erforderlich, wenn Sie beabsichtigen, die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode aufzurufen. Wenn Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode aufrufen, bevor Sie <xref:System.Net.Sockets.Socket.SendTo%2A>aufrufen, überschreibt der `remoteEP`-Parameter den angegebenen Standard Remote Host nur für diesen Sendevorgang. Außerdem ist es nicht erforderlich, die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode aufzurufen. In diesem Fall weist der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zu. Verwenden Sie die Portnummer 0 (null), wenn der zugrunde liegende Dienstanbieter einen freien Port auswählen soll. Wenn Sie die Adresse und die Portnummer des zugewiesenen lokalen Netzwerks identifizieren müssen, können Sie die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>-Eigenschaft verwenden, nachdem die <xref:System.Net.Sockets.Socket.EndSendTo%2A>-Methode erfolgreich abgeschlossen wurde.  
  
 Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode aufzurufen und die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>festlegen. -Sie müssen auch sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.EndSendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
 Wenn Sie das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen <xref:System.Net.Sockets.Socket> Methoden zwischengespeichert. Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Daten asynchron an den angegebenen Remote Host gesendet.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Der lokale <see cref="T:System.Net.EndPoint" />, der dem <see cref="T:System.Net.Sockets.Socket" /> zugeordnet werden soll.</param>
        <summary>Ordnet einem <see cref="T:System.Net.Sockets.Socket" /> einen lokalen Endpunkt zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode, wenn Sie einen bestimmten lokalen Endpunkt verwenden müssen. Sie müssen <xref:System.Net.Sockets.Socket.Bind%2A> abrufen, bevor Sie die <xref:System.Net.Sockets.Socket.Listen%2A>-Methode abrufen können. Sie müssen <xref:System.Net.Sockets.Socket.Bind%2A> nicht vor der Verwendung der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode anrufen, es sei denn, Sie müssen einen bestimmten lokalen Endpunkt verwenden. Sie können die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode für verbindungslose und Verbindungs orientierte Protokolle verwenden.  
  
 Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Bind%2A>müssen Sie zuerst den lokalen <xref:System.Net.IPEndPoint> erstellen, von dem aus Sie Daten übermitteln möchten. Wenn Sie nicht sicher sind, welche lokale Adresse zugewiesen ist, können Sie eine <xref:System.Net.IPEndPoint> mit <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> als Adress Parameter erstellen, und der zugrunde liegende Dienstanbieter weist die am besten geeignete Netzwerkadresse zu. Dies kann dazu beitragen, Ihre Anwendung zu vereinfachen, wenn Sie über mehrere Netzwerkschnittstellen verfügen. Wenn Sie nicht sicher sind, welcher lokale Port verwendet wird, können Sie eine <xref:System.Net.IPEndPoint> mit 0 für die Portnummer erstellen. In diesem Fall weist der Dienstanbieter eine verfügbare Portnummer zwischen 1024 und 5000 zu.  
  
 Wenn Sie den oben genannten Ansatz verwenden, können Sie ermitteln, welche Adresse und Portnummer des lokalen Netzwerks zugewiesen wurden, indem Sie den <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>aufrufen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, gibt <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> die lokal zugewiesene Netzwerkadresse erst zurück, nachdem Sie die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.EndConnect%2A>-Methode aufgerufen haben. Wenn Sie ein verbindungsloses Protokoll verwenden, haben Sie erst dann Zugriff auf diese Informationen, wenn Sie einen Sende-oder Empfangsvorgang abgeschlossen haben.  
  
 Wenn ein UDP-Socket Schnittstellen Informationen zu empfangenen Paketen empfangen möchte, sollte die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode explizit aufgerufen werden, wobei die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.PacketInformation> unmittelbar nach dem Aufrufen der <xref:System.Net.Sockets.Socket.Bind%2A>-Methode festgelegt ist.  
  
> [!NOTE]
>  Wenn Sie beabsichtigen, Multicast Datagramme zu empfangen, müssen Sie die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode mit einer Multicast Portnummer abrufen.  
  
> [!NOTE]
>  Sie müssen die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode abrufen, wenn Sie verbindungslose Datagramme mithilfe der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode empfangen möchten.  
  
> [!NOTE]
>  Wenn Sie beim Aufrufen der <xref:System.Net.Sockets.Socket.Bind%2A>-Methode eine <xref:System.Net.Sockets.SocketException> erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Net.Sockets.Socket> mit dem angegebenen lokalen Endpunkt gebunden.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen von dem Host, der durch <paramref name="localEP" />definiert wird. Zugehörige Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob sich der <see cref="T:System.Net.Sockets.Socket" /> im blockierenden Modus befindet.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> blockiert wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Blocking%2A>-Eigenschaft gibt an, ob sich ein <xref:System.Net.Sockets.Socket> im Blockierungs Modus befindet.  
  
 Wenn Sie sich im Blockierungs Modus befinden und einen Methoden aufzurufen, der nicht sofort abgeschlossen wird, blockiert Ihre Anwendung die Ausführung, bis der angeforderte Vorgang abgeschlossen ist. Wenn die Ausführung fortgesetzt werden soll, obwohl der angeforderte Vorgang nicht vollständig ist, ändern Sie die <xref:System.Net.Sockets.Socket.Blocking%2A>-Eigenschaft in `false`. Die <xref:System.Net.Sockets.Socket.Blocking%2A>-Eigenschaft wirkt sich nicht auf asynchrone Methoden aus. Wenn Sie Daten asynchron senden und empfangen und die Ausführung blockieren möchten, verwenden Sie die <xref:System.Threading.ManualResetEvent>-Klasse.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das verwendet wurde, um die Verbindung mit dem Remotehost durch Aufrufen einer der <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />-Methoden anzufordern.</param>
        <summary>Bricht eine asynchrone Anforderung einer Remotehostverbindung ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> -Methode bricht eine asynchrone Anforderung einer Remotehostverbindung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="e" />-Parameter kann nicht NULL und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> kann nicht NULL sein.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schließt die <see cref="T:System.Net.Sockets.Socket" />-Verbindung und gibt alle zugeordneten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die <see cref="T:System.Net.Sockets.Socket" />-Verbindung und gibt alle zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Close%2A>-Methode schließt die Remote Host Verbindung und gibt alle verwalteten und nicht verwalteten Ressourcen frei, die der <xref:System.Net.Sockets.Socket>zugeordnet sind. Beim Schließen wird die <xref:System.Net.Sockets.Socket.Connected%2A>-Eigenschaft auf `false`festgelegt.  
  
 Bei Verbindungs orientierten Protokollen wird empfohlen, dass Sie <xref:System.Net.Sockets.Socket.Shutdown%2A> aufrufen, bevor Sie die <xref:System.Net.Sockets.Socket.Close%2A>-Methode aufrufen. Dadurch wird sichergestellt, dass alle Daten vor dem Schließen des verbundenen Sockets gesendet und empfangen werden.  
  
 Wenn Sie <xref:System.Net.Sockets.Socket.Close%2A> aufrufen müssen, ohne zuerst <xref:System.Net.Sockets.Socket.Shutdown%2A>aufrufen zu müssen, können Sie sicherstellen, dass die Daten in der Warteschlange für ausgehende Übertragungen gesendet werden, indem Sie die <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>-Option auf `false` festlegen und ein Timeout Intervall angeben, das nicht NULL ist. <xref:System.Net.Sockets.Socket.Close%2A> wird dann blockiert, bis diese Daten gesendet werden oder bis das angegebene Timeout abläuft. Wenn Sie <xref:System.Net.Sockets.SocketOptionName.DontLinger> auf `false` festlegen und ein Timeout Intervall von NULL angeben, wird die Verbindung von <xref:System.Net.Sockets.Socket.Close%2A> freigegeben, und ausgehende Daten in der Warteschlange werden automatisch verworfen.  
  
> [!NOTE]
>  Wenn Sie die <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption auf `false`festlegen möchten, erstellen Sie eine <xref:System.Net.Sockets.LingerOption>, legen Sie die aktivierte Eigenschaft auf `true`fest, und legen Sie die <xref:System.Net.Sockets.LingerOption.LingerTime%2A>-Eigenschaft auf den gewünschten Timeout Zeitraum fest. Verwenden Sie diese <xref:System.Net.Sockets.LingerOption> zusammen mit der Option <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socket, um die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode aufzurufen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Net.Sockets.Socket>geschlossen.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="timeout">Warten Sie bis zu <paramref name="timeout" /> Sekunden, damit alle verbleibenden Daten gesendet werden, und schließen Sie dann den Socket.</param>
        <summary>Schließt die <see cref="T:System.Net.Sockets.Socket" />-Verbindung und gibt alle zugeordneten Ressourcen mit einem angegebenen Timeout frei, damit in der Warteschlange befindliche Daten gesendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Close%2A>-Methode schließt die Remote Host Verbindung und gibt alle verwalteten und nicht verwalteten Ressourcen frei, die der <xref:System.Net.Sockets.Socket>zugeordnet sind. Beim Schließen wird die <xref:System.Net.Sockets.Socket.Connected%2A>-Eigenschaft auf `false`festgelegt.  
  
 Bei Verbindungs orientierten Protokollen wird empfohlen, dass Sie <xref:System.Net.Sockets.Socket.Shutdown%2A> aufrufen, bevor Sie <xref:System.Net.Sockets.Socket.Close%2A>aufrufen. Dadurch wird sichergestellt, dass alle Daten vor dem Schließen des verbundenen Sockets gesendet und empfangen werden.  
  
 Wenn Sie <xref:System.Net.Sockets.Socket.Close%2A> aufrufen müssen, ohne zuerst <xref:System.Net.Sockets.Socket.Shutdown%2A>aufzurufen, können Sie sicherstellen, dass die Daten in der Warteschlange für ausgehende Übertragungen gesendet werden, indem Sie die <xref:System.Net.Sockets.SocketOptionName.DontLinger>-Option auf `false` festlegen und ein Timeout Intervall angeben, das nicht NULL ist. <xref:System.Net.Sockets.Socket.Close%2A> wird dann blockiert, bis diese Daten gesendet werden oder bis das angegebene Timeout abläuft. Wenn Sie <xref:System.Net.Sockets.SocketOptionName.DontLinger> auf `false` festlegen und ein Timeout Intervall von NULL angeben, wird die Verbindung von <xref:System.Net.Sockets.Socket.Close%2A> freigegeben, und ausgehende Daten in der Warteschlange werden automatisch verworfen.  
  
> [!NOTE]
>  Wenn Sie die <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption auf `false`festlegen möchten, erstellen Sie eine <xref:System.Net.Sockets.LingerOption>, legen Sie die aktivierte Eigenschaft auf `true`fest, und legen Sie die <xref:System.Net.Sockets.LingerOption.LingerTime%2A>-Eigenschaft auf den gewünschten Timeout Zeitraum fest. Verwenden Sie diese <xref:System.Net.Sockets.LingerOption> zusammen mit der Option <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socket, um die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode aufzurufen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein <xref:System.Net.Sockets.Socket>geschlossen wird.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt eine Verbindung mit einem Remotehost her.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Ein <see cref="T:System.Net.EndPoint" />, der das Remotegerät darstellt.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, stellt die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und dem angegebenen Remote Endpunkt her. Wenn Sie ein verbindungsloses Protokoll verwenden, stellt <xref:System.Net.Sockets.Socket.Connect%2A> einen Standard Remote Host her. Nachdem Sie <xref:System.Net.Sockets.Socket.Connect%2A>aufgerufen haben, können Sie mit der <xref:System.Net.Sockets.Socket.Send%2A>-Methode Daten an das Remote Gerät senden oder Daten vom Remote Gerät mit der <xref:System.Net.Sockets.Socket.Receive%2A>-Methode empfangen.  
  
 Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und empfangen von Daten nicht aufzurufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> verwenden, um synchron mit einem Remote Host zu kommunizieren. Wenn Sie <xref:System.Net.Sockets.Socket.Connect%2A>aufzurufen, werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eintreffen. Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode und die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>festlegen, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 Die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode wird blockiert, es sei denn, Sie legen die <xref:System.Net.Sockets.Socket.Blocking%2A>-Eigenschaft vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Connect%2A>explizit auf `false` fest. Wenn Sie ein Verbindungs orientiertes Protokoll wie TCP verwenden und die Blockierung deaktivieren, wird <xref:System.Net.Sockets.Socket.Connect%2A> eine <xref:System.Net.Sockets.SocketException> auslösen, da es Zeit benötigt, um die Verbindung herzustellen. Verbindungslose Protokolle lösen keine Ausnahme aus, da Sie einfach einen Standard-Remote Host einrichten. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> verwenden, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers. Wenn der Fehler "WSAEWOULDBLOCK" zurückgegeben wurde, wurde die Remote Host Verbindung von einem Verbindungs orientierten <xref:System.Net.Sockets.Socket>initiiert, aber noch nicht erfolgreich abgeschlossen. Verwenden Sie die <xref:System.Net.Sockets.Socket.Poll%2A>-Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> die Verbindung hergestellt hat.  
  
> [!NOTE]
>  Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Connect%2A>nicht aufgerufen haben, weist der zugrunde liegende Dienstanbieter die Adresse und die Portnummer des lokalen Netzwerks zu. Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine lokale Netzwerkadresse und eine Portnummer zu, wenn Sie einen Sende-oder Empfangsvorgang ausführen. Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit dem gewünschten Endpunkt abrufen.  
  
> [!NOTE]
>  Wenn der Socket bereits getrennt wurde, können Sie diese Methode nicht verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, um die Verbindung wiederherzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieters.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel stellt eine Verbindung mit einem Remote Endpunkt her und überprüft dann die Verbindung.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Herstellen einer Verbindung mit dem Remote Host. Zugehörige Enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">Die IP-Adresse des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her. Der Host wird mit einer IP-Adresse und einer Portnummer angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, stellt die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und dem angegebenen Remote Endpunkt her. Wenn Sie ein verbindungsloses Protokoll verwenden, stellt <xref:System.Net.Sockets.Socket.Connect%2A> einen Standard Remote Host her. Nachdem Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufgerufen haben, können Sie mit der <xref:System.Net.Sockets.Socket.Send%2A>-Methode Daten an das Remote Gerät senden oder Daten vom Remote Gerät mit der <xref:System.Net.Sockets.Socket.Receive%2A>-Methode empfangen.  
  
 Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und empfangen von Daten nicht aufzurufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> verwenden, um synchron mit einem Remote Host zu kommunizieren. Wenn Sie <xref:System.Net.Sockets.Socket.Connect%2A>, werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eintreffen. Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode und die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>festlegen, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Methode wird blockiert, es sei denn, Sie legen die <xref:System.Net.Sockets.Socket.Blocking%2A>-Eigenschaft vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Connect%2A>explizit auf `false` fest. Wenn Sie ein Verbindungs orientiertes Protokoll wie TCP verwenden und die Blockierung deaktivieren, wird <xref:System.Net.Sockets.Socket.Connect%2A> eine <xref:System.Net.Sockets.SocketException> auslösen, da es Zeit benötigt, um die Verbindung herzustellen. Verbindungslose Protokolle lösen keine Ausnahme aus, da Sie einfach einen Standard-Remote Host einrichten. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> verwenden, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers. Wenn der Fehler "WSAEWOULDBLOCK" zurückgegeben wurde, wurde die Remote Host Verbindung von einem Verbindungs orientierten <xref:System.Net.Sockets.Socket>initiiert, aber noch nicht erfolgreich abgeschlossen. Verwenden Sie die <xref:System.Net.Sockets.Socket.Poll%2A>-Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> die Verbindung hergestellt hat.  
  
> [!NOTE]
>  Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Connect%2A>nicht aufgerufen haben, weist der zugrunde liegende Dienstanbieter die Adresse und die Portnummer des lokalen Netzwerks zu. Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine lokale Netzwerkadresse und eine Portnummer zu, wenn Sie einen Sende-oder Empfangsvorgang ausführen. Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit dem gewünschten Endpunkt abrufen.  
  
> [!NOTE]
>  Wenn der Socket bereits getrennt wurde, können Sie diese Methode nicht verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, um die Verbindung wiederherzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieters.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel stellt eine Verbindung mit einem Remote Endpunkt her und überprüft dann die Verbindung.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="addresses">Die IP-Adressen des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her. Der Host wird durch ein Array von IP-Adressen und eine Portnummer angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird in der Regel unmittelbar nach einem <xref:System.Net.Dns.GetHostAddresses%2A>-aufrufzug verwendet, der mehrere IP-Adressen für einen einzelnen Host zurückgeben kann. Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, stellt die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und dem angegebenen Remote Endpunkt her. Wenn Sie ein verbindungsloses Protokoll verwenden, stellt <xref:System.Net.Sockets.Socket.Connect%2A> einen Standard Remote Host her. Nachdem Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufgerufen haben, können Sie mit der <xref:System.Net.Sockets.Socket.Send%2A>-Methode Daten an das Remote Gerät senden oder Daten vom Remote Gerät mit der <xref:System.Net.Sockets.Socket.Receive%2A>-Methode empfangen.  
  
 Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und empfangen von Daten nicht aufzurufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> verwenden, um synchron mit einem Remote Host zu kommunizieren. Wenn Sie <xref:System.Net.Sockets.Socket.Connect%2A>, werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eintreffen. Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode und die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>festlegen, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Methode wird blockiert, es sei denn, Sie legen die <xref:System.Net.Sockets.Socket.Blocking%2A>-Eigenschaft vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Connect%2A>explizit auf `false` fest. Wenn Sie ein Verbindungs orientiertes Protokoll wie TCP verwenden und die Blockierung deaktivieren, wird <xref:System.Net.Sockets.Socket.Connect%2A> eine <xref:System.Net.Sockets.SocketException> auslösen, da es Zeit benötigt, um die Verbindung herzustellen. Verbindungslose Protokolle lösen keine Ausnahme aus, da Sie einfach einen Standard-Remote Host einrichten. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> verwenden, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers. Wenn der Fehler "WSAEWOULDBLOCK" zurückgegeben wurde, wurde die Remote Host Verbindung von einem Verbindungs orientierten <xref:System.Net.Sockets.Socket>initiiert, aber noch nicht erfolgreich abgeschlossen. Verwenden Sie die <xref:System.Net.Sockets.Socket.Poll%2A>-Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> die Verbindung hergestellt hat.  
  
> [!NOTE]
>  Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Connect%2A>nicht aufgerufen haben, weist der zugrunde liegende Dienstanbieter die Adresse und die Portnummer des lokalen Netzwerks zu. Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine lokale Netzwerkadresse und eine Portnummer zu, wenn Sie einen Sende-oder Empfangsvorgang ausführen. Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit dem gewünschten Endpunkt abrufen.  
  
> [!NOTE]
>  Wenn der Socket bereits getrennt wurde, können Sie diese Methode nicht verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, um die Verbindung wiederherzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieters.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel stellt eine Verbindung mit einem Remote Endpunkt her und überprüft dann die Verbindung.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="host">Der Name des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her. Der Host wird durch einen Hostnamen und eine Portnummer angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, stellt die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und dem angegebenen Remote Host her. Wenn Sie ein verbindungsloses Protokoll verwenden, stellt <xref:System.Net.Sockets.Socket.Connect%2A> einen Standard Remote Host her. Nachdem Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufgerufen haben, können Sie mit der <xref:System.Net.Sockets.Socket.Send%2A>-Methode Daten an das Remote Gerät senden oder Daten vom Remote Gerät mit der <xref:System.Net.Sockets.Socket.Receive%2A>-Methode empfangen.  
  
 Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und empfangen von Daten nicht aufzurufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> verwenden, um synchron mit einem Remote Host zu kommunizieren. Wenn Sie <xref:System.Net.Sockets.Socket.Connect%2A>, werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eintreffen. Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode und die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>festlegen, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Methode wird blockiert, es sei denn, Sie legen die <xref:System.Net.Sockets.Socket.Blocking%2A>-Eigenschaft vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Connect%2A>explizit auf `false` fest. Wenn Sie ein Verbindungs orientiertes Protokoll wie TCP verwenden und die Blockierung deaktivieren, wird <xref:System.Net.Sockets.Socket.Connect%2A> eine <xref:System.Net.Sockets.SocketException> auslösen, da es Zeit benötigt, um die Verbindung herzustellen. Verbindungslose Protokolle lösen keine Ausnahme aus, da Sie einfach einen Standard-Remote Host einrichten. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> verwenden, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers. Wenn der Fehler "WSAEWOULDBLOCK" zurückgegeben wurde, wurde die Remote Host Verbindung von einem Verbindungs orientierten <xref:System.Net.Sockets.Socket>initiiert, aber noch nicht erfolgreich abgeschlossen. Verwenden Sie die <xref:System.Net.Sockets.Socket.Poll%2A>-Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> die Verbindung hergestellt hat.  
  
 Wenn IPv6 aktiviert ist und die <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29>-Methode aufgerufen wird, um eine Verbindung mit einem Host herzustellen, der zu IPv6-und IPv4-Adressen aufgelöst wird, wird die Verbindung mit der IPv6-Adresse zuerst vor der IPv4-Adresse versucht. Dies kann dazu führen, dass sich die Zeit zum Herstellen der Verbindung verzögert, wenn der Host nicht an der IPv6-Adresse lauscht.  
  
> [!NOTE]
>  Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Connect%2A>nicht aufgerufen haben, weist der zugrunde liegende Dienstanbieter die Adresse und die Portnummer des lokalen Netzwerks zu. Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine lokale Netzwerkadresse und eine Portnummer zu, wenn Sie einen Sende-oder Empfangsvorgang ausführen. Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit dem gewünschten Endpunkt abrufen.  
  
> [!NOTE]
>  Wenn der Socket bereits getrennt wurde, können Sie diese Methode nicht verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, um die Verbindung wiederherzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieters.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel stellt eine Verbindung mit einem Remote Endpunkt her und überprüft dann die Verbindung.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, startet die <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode eine asynchrone Anforderung für eine Verbindung mit dem Remote Host. Wenn Sie ein verbindungsloses Protokoll verwenden, stellt <xref:System.Net.Sockets.Socket.ConnectAsync%2A> einen Standard Remote Host her.  
  
 Wenn Sie über den Abschluss benachrichtigt werden möchten, müssen Sie eine Rückruf Methode erstellen, die den EventHandler-\<SocketAsyncEventArgs-> Delegaten implementiert und den Rückruf an das <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis anfügt.  
  
 Der Aufrufer muss die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>-Eigenschaft auf die <xref:System.Net.IPEndPoint> des Remote Hosts festlegen, mit dem eine Verbindung hergestellt werden soll.  
  
 Der Aufrufer kann die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>-Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, bevor die <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode aufgerufen wird, damit die Informationen in der Rückruf Methode abgerufen werden können. Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.  
  
 Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie <xref:System.Net.Sockets.Socket.ConnectAsync%2A> vor dem Senden und empfangen von Daten nicht aufzurufen. Sie können <xref:System.Net.Sockets.Socket.SendToAsync%2A> und <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> verwenden, um mit einem Remote Host zu kommunizieren. Wenn Sie <xref:System.Net.Sockets.Socket.ConnectAsync%2A>aufzurufen, werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eintreffen. Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie die <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode erneut mit dem gewünschten Endpunkt abrufen.  
  
 Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst <xref:System.Net.Sockets.Socket.SetSocketOption%2A> und Broadcast auf `true`festlegen. Wenn dies nicht der Fall ist, löst die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode eine <xref:System.Net.Sockets.SocketException>aus.  
  
 Die folgenden Eigenschaften und Ereignisse für das <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Optional kann ein Puffer bereitgestellt werden, der nach erfolgreicher Ausführung der <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode atomisch an den Socket gesendet wird. In diesem Fall muss die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>-Eigenschaft auf den Puffer festgelegt werden, der die zu sendenden Daten enthält, und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>-Eigenschaft muss auf die Anzahl der Daten Bytes festgelegt werden, die aus dem Puffer gesendet werden sollen. Nachdem eine Verbindung hergestellt wurde, wird dieser Datenpuffer gesendet.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufrufen von <xref:System.Net.Sockets.Socket.ConnectAsync%2A>nicht aufrufen, weist der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zu.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine IP-Adresse und Portnummer für das lokale Netzwerk zu, wenn Sie die Methoden <xref:System.Net.Sockets.Socket.SendAsync%2A> oder <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> aufgerufen haben.  
  
 Mit der <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode wird <xref:System.NotSupportedException> ausgelöst, wenn die Adressfamilie des <xref:System.Net.Sockets.Socket> und der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> nicht die gleiche Adressfamilie sind.  
  
> [!NOTE]
>  Wenn Sie beim Aufrufen dieser Methode eine <xref:System.Net.Sockets.SocketException> erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument ist ungültig. Diese Ausnahme tritt auf, wenn mehrere Puffer angegeben werden und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft nicht NULL ist.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="e" />-Parameter kann nicht NULL und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> kann nicht NULL sein.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> führt eine Überwachung durch, oder ein Socketvorgang wird bereits mit dem im <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Parameter angegebenen <paramref name="e" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich. Diese Ausnahme tritt auch auf, wenn der lokale Endpunkt und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nicht die gleiche Adressfamilie aufweisen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</param>
        <param name="protocolType">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</param>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, startet die M:System.net.Sockets.Socket.ConnectAsync (System .net. Sockets. SocketType, System .net. Sockets. ProtocolType, System .net. Sockets. SocketAsyncEventArgs)-Methode eine asynchrone Anforderung für einen Verbindung mit dem Remote Host. Wenn Sie ein verbindungsloses Protokoll verwenden, legt <xref:System.Net.Sockets.Socket.ConnectAsync%2A> einen Standard Remote Host fest, der durch die Parameter `socketType` und `protocolType` angegeben wird.  
  
 Wenn Sie über den Abschluss benachrichtigt werden möchten, müssen Sie eine Rückruf Methode erstellen, die den EventHandler-\<SocketAsyncEventArgs-> Delegaten implementiert und den Rückruf an das <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis anfügt.  
  
 Der Aufrufer muss die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>-Eigenschaft auf die <xref:System.Net.IPEndPoint> des Remote Hosts festlegen, mit dem eine Verbindung hergestellt werden soll.  
  
 Der Aufrufer kann die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>-Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, bevor die <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode aufgerufen wird, damit die Informationen in der Rückruf Methode abgerufen werden können. Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.  
  
 Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie <xref:System.Net.Sockets.Socket.ConnectAsync%2A> vor dem Senden und empfangen von Daten nicht aufzurufen. Sie können <xref:System.Net.Sockets.Socket.SendToAsync%2A> und <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> verwenden, um mit einem Remote Host zu kommunizieren. Wenn Sie <xref:System.Net.Sockets.Socket.ConnectAsync%2A>aufzurufen, werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eintreffen. Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie die <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode erneut mit dem gewünschten Endpunkt abrufen.  
  
 Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst <xref:System.Net.Sockets.Socket.SetSocketOption%2A> und Broadcast auf `true`festlegen. Wenn dies nicht der Fall ist, löst die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode eine <xref:System.Net.Sockets.SocketException>aus.  
  
 Die folgenden Eigenschaften und Ereignisse für das <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Optional kann ein Puffer bereitgestellt werden, der nach erfolgreicher Ausführung der <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode atomisch an den Socket gesendet wird. In diesem Fall muss die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>-Eigenschaft auf den Puffer festgelegt werden, der die zu sendenden Daten enthält, und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>-Eigenschaft muss auf die Anzahl der Daten Bytes festgelegt werden, die aus dem Puffer gesendet werden sollen. Nachdem eine Verbindung hergestellt wurde, wird dieser Datenpuffer gesendet.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufrufen von <xref:System.Net.Sockets.Socket.ConnectAsync%2A>nicht aufrufen, weist der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zu.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine IP-Adresse und Portnummer für das lokale Netzwerk zu, wenn Sie die Methoden <xref:System.Net.Sockets.Socket.SendAsync%2A> oder <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> aufgerufen haben.  
  
 Mit der <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode wird <xref:System.NotSupportedException> ausgelöst, wenn die Adressfamilie des <xref:System.Net.Sockets.Socket> und der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> nicht die gleiche Adressfamilie sind.  
  
> [!NOTE]
>  Wenn Sie beim Aufrufen dieser Methode eine <xref:System.Net.Sockets.SocketException> erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument ist ungültig. Diese Ausnahme tritt auf, wenn mehrere Puffer angegeben werden und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft nicht NULL ist.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="e" />-Parameter kann nicht NULL und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> kann nicht NULL sein.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> führt eine Überwachung durch, oder ein Socketvorgang wird bereits mit dem im <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Parameter angegebenen <paramref name="e" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich. Diese Ausnahme tritt auch auf, wenn der lokale Endpunkt und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nicht die gleiche Adressfamilie aufweisen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein <see cref="T:System.Net.Sockets.Socket" /> mit dem Remotehost des letzten <see cref="Overload:System.Net.Sockets.Socket.Send" />-Vorgangs oder <see cref="Overload:System.Net.Sockets.Socket.Receive" />-Vorgangs verbunden ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Net.Sockets.Socket" /> beim letzten Vorgang mit einer Remoteressource verbunden war, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Connected`-Eigenschaft ruft den Verbindungsstatus des <xref:System.Net.Sockets.Socket> ab, der mit dem letzten e/a-Vorgang ausgeführt wurde. Wenn `false`zurückgegeben wird, war der <xref:System.Net.Sockets.Socket> entweder nie verbunden, oder er ist nicht mehr verbunden.  
  
 Der Wert der <xref:System.Net.Sockets.Socket.Connected%2A>-Eigenschaft gibt den Status der Verbindung beim letzten Vorgang wieder. Wenn Sie den aktuellen Status der Verbindung bestimmen müssen, erstellen Sie einen nicht blockierenden, NULL-Byte-Sendevorgang. Wenn der-Rückruf erfolgreich zurückgegeben wurde oder einen waewouldblock-Fehlercode (10035) auslöst, ist der Socket weiterhin verbunden. Andernfalls ist der Socket nicht mehr verbunden.  
  
 Wenn Sie <xref:System.Net.Sockets.Socket.Connect%2A> für einen UDP-Socket (User Datagram Protocol) aufzurufen, gibt die <xref:System.Net.Sockets.Socket.Connected%2A>-Eigenschaft immer `true`zurück. durch diese Aktion wird jedoch nicht die inhärente verbindungslose Natur von UDP geändert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einem Remote Endpunkt hergestellt, die <xref:System.Net.Sockets.Socket.Connected%2A>-Eigenschaft überprüft und der aktuelle Zustand der Verbindung überprüft.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" />, wenn dieser Socket wiederverwendet werden kann, nachdem die aktuelle Verbindung geschlossen wurde, andernfalls <see langword="false" />.</param>
        <summary>Schließt die Socketverbindung und ermöglicht die Wiederverwendung des Sockets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, können Sie den Socket mit dieser Methode schließen. Diese Methode beendet die Verbindung und legt die <xref:System.Net.Sockets.Socket.Connected%2A>-Eigenschaft auf `false`fest. Wenn `reuseSocket` jedoch `true`ist, können Sie den Socket wieder verwenden.  
  
 Um sicherzustellen, dass alle Daten vor dem Schließen des Sockets gesendet und empfangen werden, sollten Sie <xref:System.Net.Sockets.Socket.Shutdown%2A> aufrufen, bevor Sie die <xref:System.Net.Sockets.Socket.Disconnect%2A>-Methode aufrufen.  
  
 Wenn Sie <xref:System.Net.Sockets.Socket.Disconnect%2A> aufrufen müssen, ohne zuerst <xref:System.Net.Sockets.Socket.Shutdown%2A>aufrufen zu müssen, können Sie die Option <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> auf `false` festlegen und ein Timeout Intervall angeben, das nicht NULL ist, um sicherzustellen, dass Daten in der Warteschlange für ausgehende Übertragungen gesendet werden. <xref:System.Net.Sockets.Socket.Disconnect%2A> dann blockiert, bis die Daten gesendet werden oder bis das angegebene Timeout abläuft. Wenn Sie <xref:System.Net.Sockets.SocketOptionName.DontLinger> auf `false` festlegen und ein Timeout Intervall von NULL angeben, wird die Verbindung von <xref:System.Net.Sockets.Socket.Close%2A> freigegeben, und ausgehende Daten in der Warteschlange werden automatisch verworfen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Socket für die synchrone Kommunikation und sendet einige Daten an einen Remote Host. Anschließend wird <xref:System.Net.Sockets.Socket.Shutdown%2A>aufgerufen, um die Sende-und Empfangs Aktivität zu beenden, und <xref:System.Net.Sockets.Socket.Disconnect%2A>, um die Socketverbindung zu schließen.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Für diese Methode wird Windows 2000 oder früher benötigt, andernfalls wird eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt eine asynchrone Anforderung zum Trennen der Verbindung mit einem Remoteendunkt.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird beim Aufrufen der <xref:System.Net.Sockets.Socket.DisconnectAsync%2A>-Methode die Verbindung von einem Remote Endpunkt getrennt. Wenn Sie <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> auf `true` im `e`-Parameter festlegen, kann der Socket wieder verwendet werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="e" />-Parameter darf nicht NULL sein.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Parameter angegebenen <paramref name="e" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie `Dispose` auf, wenn Sie <xref:System.Net.Sockets.Socket> nicht mehr benötigen. Die `Dispose`-Methode bewirkt, dass <xref:System.Net.Sockets.Socket> nicht mehr verwendet werden kann. Nachdem Sie `Dispose`aufgerufen haben, müssen Sie alle Verweise auf die <xref:System.Net.Sockets.Socket> freigeben, damit der Garbage Collector den Speicher freigeben kann, den der <xref:System.Net.Sockets.Socket> belegt hat.  
  
 Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.  
  
> [!NOTE]
>  Rufen Sie immer `Dispose` auf, bevor Sie den letzten Verweis auf das <xref:System.Net.Sockets.Socket> freigeben. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Net.Sockets.Socket>-Methode des `Finalize`-Objekts aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, wenn ausschließlich nicht verwaltete Ressourcen freigegeben werden sollen.</param>
        <summary>Gibt die vom <see cref="T:System.Net.Sockets.Socket" /> verwendeten, nicht verwalteten Ressourcen frei und verwirft optional auch die verwalteten Ressourcen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen `Dispose()`-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen. `Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist. <xref:System.Object.Finalize%2A> ruft `Dispose` auf, bei dem `disposing` auf `false`festgelegt ist.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Net.Sockets.Socket> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden. Weitere Informationen zum Implementieren von <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.  
  
Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> die Fragmentierung von IP (Internet Protocol)-Datagrammen zulässt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> die Datagrammfragmentierung zulässt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagramme erfordern eine Fragmentierung, wenn ihre Größe die maximale Übertragungseinheit (MTU) des Übertragungsmediums überschreitet. Datagramme können durch den sendenden Host (alle Internetprotokoll Versionen) oder einen zwischen Router (nur Internetprotokoll Version 4) fragmentiert werden. Wenn ein Datagramm fragmentiert werden muss und die <xref:System.Net.Sockets.Socket.DontFragment%2A>-Option festgelegt ist, wird das Datagramm verworfen und eine ICMP (Internet Control Message Protocol)-Fehlermeldung an den Absender des Datagramms zurückgesendet.  
  
 Das Festlegen dieser Eigenschaft auf einen TCP-Socket (Transmission Control Protocol) hat keine Auswirkungen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.DontFragment%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Eigenschaft kann nur für Sockets in der <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />-Familie oder der <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />-Familie festgelegt werden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> ein für IPv4 und IPv6 verwendeter Dualmodussocket ist, oder legt ihn fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> ein Dualmodussocket ist; andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">Die ID des Zielprozesses, in dem ein Duplikat des Socketverweises erstellt wird.</param>
        <summary>Dupliziert den Socketverweis für den Zielprozess und schließt den Socket für diesen Prozess.</summary>
        <returns>Der Socketverweis, der an den Zielprozess übergeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Ziel Prozess sollte <xref:System.Net.Sockets.Socket.%23ctor%2A> verwenden, um die doppelte Socketinstanz zu erstellen.  
  
 Wenn Sie den <xref:System.Net.Sockets.Socket.%23ctor%2A>-Konstruktor mehrmals mit dem gleichen Bytearray wie das-Argument für jeden-Befehl aufzurufen, erstellen Sie mehrere verwaltete <xref:System.Net.Sockets.Socket>-Instanzen mit demselben zugrunde liegenden Socket. Diese Vorgehensweise wird dringend davon abgeraten.  
  
 Wenn der Prozess, der den Socket erstellt, asynchrone Methoden (<xref:System.Net.Sockets.Socket.BeginReceive%2A> oder <xref:System.Net.Sockets.Socket.BeginSend%2A>) verwendet, muss der Prozess zuerst die <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A>-Eigenschaft auf true festlegen. Andernfalls ist der Socket an den Abschlussport des Erstellungs Prozesses gebunden, was dazu führen kann, dass eine <xref:System.ArgumentNullException> für den Ziel Prozess ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" /> ist keine gültige Prozess-ID. 
- oder - 
Die Duplizierung des Socketverweises ist fehlgeschlagen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> Broadcastpakete senden oder empfangen kann, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> Broadcastpakete zulässt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Broadcasting ist auf ein bestimmtes Subnetz beschränkt und muss das User Datagram-Protokoll (UDP) verwenden. Für Internet Protocol, Version 4, können Sie in Ihr lokales Subnetz übertragen, indem Sie ein Paket an 255.255.255.255 senden. oder Sie können die gesteuerte Broadcast Adresse verwenden, bei der es sich um den Netzwerk Teil einer IP-Adresse (Internet Protocol) handelt, bei dem alle Bits im Hostteil festgelegt sind. Wenn Ihre IP-Adresse beispielsweise 192.168.1.40 (eine Class C-Adresse mit einer Netzwerk Maske von 255.255.255.0 ist, der Netzwerk Teil die ersten drei Oktette und der Hostteil das letzte Oktett ist), lautet die gesteuerte Broadcast Adresse 192.168.1.255.  
  
 Das Festlegen dieser Eigenschaft auf einen TCP-Socket (Transmission Control Protocol) hat keine Auswirkungen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.EnableBroadcast%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Diese Option ist nur für Datagrammsockets gültig.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Nimmt einen eingehenden Verbindungsversuch asynchron an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die übertragenen Bytes enthält.</param>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt ein neues <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Remotehostkommunikation. Diese Methode gibt einen Puffer zurück, der die ersten übertragenen Daten enthält.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Kommunikation mit dem Remotehost.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> schließt einen aufzurufenden <xref:System.Net.Sockets.Socket.BeginAccept%2A>ab. Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginAccept%2A>müssen Sie eine Rückruf Methode erstellen, die vom <xref:System.AsyncCallback> Delegaten aufgerufen wird. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode zurückgegeben wurde.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Methode des `asyncResult`-Parameters auf, um die <xref:System.Net.Sockets.Socket> zu erhalten, für die der Verbindungsversuch durchgeführt wird. Nachdem Sie die <xref:System.Net.Sockets.Socket>erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode aufrufen, um den Verbindungsversuch erfolgreich abzuschließen. Der `buffer`-Parameter dieser Überladung enthält die Daten, die im <xref:System.Net.Sockets.Socket.BeginAccept%2A> aufgerufen wurden, und der `bytesTransferred`-Parameter enthält die Anzahl der Bytes, die im-Befehl übertragen wurden.  
  
 Die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode blockiert, bis eine Verbindung in der Warteschlange für eingehende Verbindungen aussteht. Die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode akzeptiert die eingehende Verbindung und gibt eine neue <xref:System.Net.Sockets.Socket> zurück, die zum Senden und empfangen von Daten vom Remote Host verwendet werden kann.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.Socket.BeginAccept%2A> verwendet, um einen Socket zu erstellen und zu verbinden und die ersten 10 Bytes der Daten zu akzeptieren. Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndAccept%2A> auf, um die asynchrone Anforderung zu beenden. Die Anzahl der übertragenen Bytes, und die Daten werden in den `buffer`-und `bytesTransferred` Parametern dieser Methode zurückgegeben und in der Konsole angezeigt.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist leer.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde bereits zuvor aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt einen neuen <see cref="T:System.Net.Sockets.Socket" /> zum Behandeln der Remotehostkommunikation.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" /> zum Behandeln der Kommunikation mit dem Remotehost.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> schließt einen aufzurufenden <xref:System.Net.Sockets.Socket.BeginAccept%2A>ab. Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginAccept%2A>müssen Sie eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode zurückgegeben wurde. Er muss den `asyncResult`-Parameter akzeptieren, der von der <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode zurückgegeben wird.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Methode des `asyncResult`-Parameters auf, um die <xref:System.Net.Sockets.Socket> zu erhalten, für die der Verbindungsversuch durchgeführt wird. Nachdem Sie die <xref:System.Net.Sockets.Socket>erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode aufrufen, um den Verbindungsversuch erfolgreich abzuschließen.  
  
 Die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode blockiert, bis eine Verbindung in der Warteschlange für eingehende Verbindungen aussteht. Die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode akzeptiert die eingehende Verbindung und gibt eine neue <xref:System.Net.Sockets.Socket> zurück, die zum Senden und empfangen von Daten vom Remote Host verwendet werden kann.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine asynchrone Anforderung beendet und eine neue <xref:System.Net.Sockets.Socket> erstellt, um eine eingehende Verbindungsanforderung zu akzeptieren. Ein umfassendes Beispiel, in dem die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter [Beispiele für Socket-Code](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> erstellt.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde bereits zuvor aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * int * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die übertragenen Bytes enthält.</param>
        <param name="bytesTransferred">Die Anzahl der übertragenen Bytes.</param>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt ein neues <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Remotehostkommunikation. Diese Methode gibt einen Puffer zurück, der die ersten Daten und die Anzahl der übertragenen Bytes enthält.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Kommunikation mit dem Remotehost.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> schließt einen aufzurufenden <xref:System.Net.Sockets.Socket.BeginAccept%2A>ab. Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginAccept%2A>müssen Sie eine Rückruf Methode erstellen, die vom <xref:System.AsyncCallback> Delegaten aufgerufen wird. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem die <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode zurückgegeben wurde. Er muss den `asyncResult`-Parameter akzeptieren, der von der <xref:System.Net.Sockets.Socket.BeginAccept%2A>-Methode zurückgegeben wird.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Methode des `asyncResult`-Parameters auf, um die <xref:System.Net.Sockets.Socket> zu erhalten, für die der Verbindungsversuch durchgeführt wird. Nachdem Sie die <xref:System.Net.Sockets.Socket>erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode aufrufen, um den Verbindungsversuch erfolgreich abzuschließen. Der `buffer`-Parameter dieser Überladung enthält die Daten, die im <xref:System.Net.Sockets.Socket.BeginAccept%2A> aufgerufen wurden, und der `bytesTransferred`-Parameter enthält die Anzahl der Bytes, die im-Befehl übertragen wurden.  
  
 Die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode blockiert, bis eine Verbindung in der Warteschlange für eingehende Verbindungen aussteht. Die <xref:System.Net.Sockets.Socket.EndAccept%2A>-Methode akzeptiert die eingehende Verbindung und gibt eine neue <xref:System.Net.Sockets.Socket> zurück, die zum Senden und empfangen von Daten vom Remote Host verwendet werden kann.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.Socket.BeginAccept%2A> verwendet, um einen Socket zu erstellen und zu verbinden und die ersten 10 Bytes der Daten zu akzeptieren. Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndAccept%2A> auf, um die asynchrone Anforderung zu beenden. Die Anzahl der übertragenen Bytes, und die Daten werden in den `buffer`-und `bytesTransferred` Parametern dieser Methode zurückgegeben und in der Konsole angezeigt.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist leer.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde bereits zuvor aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Beendet eine ausstehende asynchrone Verbindungsanforderung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> ist eine blockierende Methode, die die asynchrone Remote Host-Verbindungsanforderung abschließt, die in der <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode gestartet wurde.  
  
 Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginConnect%2A>müssen Sie eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginConnect%2A> zurückgegeben hat. Die Rückruf Methode muss die <xref:System.IAsyncResult> akzeptieren, die von der <xref:System.Net.Sockets.Socket.BeginConnect%2A>-Methode als Parameter zurückgegeben wird.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Methode des <xref:System.IAsyncResult>-Parameters auf, um die <xref:System.Net.Sockets.Socket> zu erhalten, für die der Verbindungsversuch durchgeführt wird. Nachdem Sie die <xref:System.Net.Sockets.Socket>erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndConnect%2A>-Methode aufrufen, um den Verbindungsversuch erfolgreich abzuschließen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der asynchrone Verbindungsversuch beendet. Ein umfassendes Beispiel, in dem die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter [Beispiele für Socket-Code](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> wurde bereits für die asynchrone Verbindung aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Beendet eine ausstehende asynchrone Anforderung zur Trennung der Verbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> schließt einen aufzurufenden <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>ab. Die <xref:System.Net.Sockets.Socket.EndDisconnect%2A>-Methode wird blockiert, bis die Trennung abgeschlossen ist. Weitere Informationen zu asynchronen Vorgängen finden Sie im Thema "Übersicht über die asynchrone Programmierung" in der MSDN Library.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Socket für die asynchrone Kommunikation und sendet einige Daten an einen Remote Host. Wenn die Daten gesendet wurden, wird <xref:System.Net.Sockets.Socket.Shutdown%2A> aufgerufen, um die Sende-und Empfangs Aktivität anzuhalten. Anschließend wird <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> aufgerufen, um eine Disconnect-Anforderung zu starten. Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndDisconnect%2A> auf, um die asynchrone Anforderung zu beenden. Wenn die Anforderung abgeschlossen ist, wird die <xref:System.Net.Sockets.Socket.Connected%2A>-Eigenschaft abgefragt, um zu überprüfen, ob der Socket getrennt ist.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> wurde bereits für die asynchrone Verbindung aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.Net.WebException">Das Timeout der Anforderung zum Trennen der Verbindung wurde überschritten.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode beendet den asynchronen Lesevorgang, der in der <xref:System.Net.Sockets.Socket.BeginReceive%2A>-Methode gestartet wurde.  
  
 Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginReceive%2A>müssen Sie eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgegeben hat. Die Rückruf Methode muss die <xref:System.IAsyncResult> akzeptieren, die von der <xref:System.Net.Sockets.Socket.BeginReceive%2A>-Methode als Parameter zurückgegeben wird.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Methode des <xref:System.IAsyncResult> auf, um das State-Objekt abzurufen, das an die <xref:System.Net.Sockets.Socket.BeginReceive%2A>-Methode übermittelt wird. Extrahieren Sie das empfangende <xref:System.Net.Sockets.Socket> aus diesem Zustands Objekt. Nachdem Sie die <xref:System.Net.Sockets.Socket>erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode aufrufen, um den Lesevorgang erfolgreich abzuschließen und die Anzahl der gelesenen Bytes zurückzugeben.  
  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode wird blockiert, bis die Daten verfügbar sind. Wenn Sie ein verbindungsloses Protokoll verwenden, liest <xref:System.Net.Sockets.Socket.EndReceive%2A> das erste in die Warteschlange eingereihte Datagramm, das im eingehenden Netzwerk Puffer verfügbar ist. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, liest die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode so viele Daten, wie Sie bis zur Anzahl der Bytes verfügbar sind, die Sie im `size`-Parameter der <xref:System.Net.Sockets.Socket.BeginReceive%2A>-Methode angegeben haben. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
 Rufen Sie zum Abrufen der empfangenen Daten die <xref:System.IAsyncResult.AsyncState%2A>-Methode des <xref:System.IAsyncResult>auf, und extrahieren Sie den Puffer, der im resultierenden State-Objekt enthalten ist.  
  
 Um einen ausstehenden <xref:System.Net.Sockets.Socket.BeginReceive%2A>abzubrechen, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A>-Methode auf.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel beendet einen ausstehenden asynchronen Lesevorgang. Ein umfassendes Beispiel, in dem die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter [Beispiele für Socket-Code](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult * SocketError -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode beendet den asynchronen Lesevorgang, der in der <xref:System.Net.Sockets.Socket.BeginReceive%2A>-Methode gestartet wurde.  
  
 Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginReceive%2A>müssen Sie eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgegeben hat. Die Rückruf Methode muss die <xref:System.IAsyncResult> akzeptieren, die von der <xref:System.Net.Sockets.Socket.BeginReceive%2A>-Methode als Parameter zurückgegeben wird.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Methode des <xref:System.IAsyncResult> auf, um das State-Objekt abzurufen, das an die <xref:System.Net.Sockets.Socket.BeginReceive%2A>-Methode übermittelt wird. Extrahieren Sie das empfangende <xref:System.Net.Sockets.Socket> aus diesem Zustands Objekt. Nachdem Sie die <xref:System.Net.Sockets.Socket>erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode aufrufen, um den Lesevorgang erfolgreich abzuschließen und die Anzahl der gelesenen Bytes zurückzugeben.  
  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode wird blockiert, bis die Daten verfügbar sind. Wenn Sie ein verbindungsloses Protokoll verwenden, liest <xref:System.Net.Sockets.Socket.EndReceive%2A> das erste in die Warteschlange eingereihte Datagramm, das im eingehenden Netzwerk Puffer verfügbar ist. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, liest die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode so viele Daten, wie Sie bis zur Anzahl der Bytes verfügbar sind, die Sie im `size`-Parameter der <xref:System.Net.Sockets.Socket.BeginReceive%2A>-Methode angegeben haben. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.EndReceive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
 Rufen Sie zum Abrufen der empfangenen Daten die <xref:System.IAsyncResult.AsyncState%2A>-Methode des <xref:System.IAsyncResult>auf, und extrahieren Sie den Puffer, der im resultierenden State-Objekt enthalten ist.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (asyncResult, endPoint)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="endPoint">Der Quell-<see cref="T:System.Net.EndPoint" />.</param>
        <param name="end_point">Der Quell-<see cref="T:System.Net.EndPoint" />.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten Endpunkt.</summary>
        <returns>Wenn erfolgreich, die Anzahl der empfangenen Bytes. Wenn die Ausführung nicht erfolgreich ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>-Methode beendet den asynchronen Lesevorgang, der in der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode gestartet wurde.  
  
 Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>müssen Sie eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> zurückgegeben hat. Die Rückruf Methode muss die <xref:System.IAsyncResult> akzeptieren, die von der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode als Parameter zurückgegeben wird.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Methode des <xref:System.IAsyncResult> auf, um das State-Objekt abzurufen, das an die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode übermittelt wird. Extrahieren Sie das empfangende <xref:System.Net.Sockets.Socket> aus diesem Zustands Objekt. Nachdem Sie die <xref:System.Net.Sockets.Socket>erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>-Methode aufrufen, um den Lesevorgang erfolgreich abzuschließen und die Anzahl der gelesenen Bytes zurückzugeben.  
  
 Die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>-Methode wird blockiert, bis die Daten verfügbar sind. Wenn Sie ein verbindungsloses Protokoll verwenden, liest <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> das erste in die Warteschlange eingereihte Datagramm, das im eingehenden Netzwerk Puffer verfügbar ist. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, liest die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>-Methode so viele Daten, wie Sie bis zur Anzahl der Bytes verfügbar sind, die Sie im `size`-Parameter der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>-Methode angegeben haben. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück. Rufen Sie zum Abrufen der empfangenen Daten die <xref:System.IAsyncResult.AsyncState%2A>-Methode des <xref:System.IAsyncResult>-Objekts auf, und extrahieren Sie den Puffer, der im resultierenden State-Objekt enthalten ist. Extrahieren Sie zum Identifizieren des Ursprungs Hosts die <xref:System.Net.EndPoint>, und wandeln Sie Sie in eine <xref:System.Net.IPEndPoint>um. Verwenden Sie die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>-Methode, um die IP-Adresse und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Methode zum Abrufen der Portnummer abzurufen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel beendet einen ausstehenden asynchronen Lesevorgang aus einem bestimmten <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte für das empfangene Paket.</param>
        <param name="endPoint">Der Quell-<see cref="T:System.Net.EndPoint" />.</param>
        <param name="ipPacketInformation">Die <see cref="T:System.Net.IPAddress" /> und die Schnittstelle des empfangenen Pakets.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten Endpunkt. Diese Methode stellt außerdem mehr Informationen über das Paket als <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> bereit.</summary>
        <returns>Wenn erfolgreich, die Anzahl der empfangenen Bytes. Wenn die Ausführung nicht erfolgreich ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht abgeschlossen wurde, wird diese Methode blockiert, bis dies erfolgt.  
  
 Verwenden Sie die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>-Methode, um diesen Vorgang synchron auszuführen.  
  
 Überprüfen Sie `ipPacketInformation`, wenn Sie wissen möchten, ob das Datagramm mithilfe einer Unicast-, Multicast-oder Broadcast Adresse gesendet wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist gleich <see langword="null" />.  
  
- oder - 
 <paramref name="endPoint" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformation für den asynchronen Vorgang speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformation für den asynchronen Vorgang speichert.</param>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang.</summary>
        <returns>Wenn erfolgreich, die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> schließt den asynchronen Sendevorgang ab, der in <xref:System.Net.Sockets.Socket.BeginSend%2A>gestartet wurde.  
  
 Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginSend%2A>müssen Sie eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginSend%2A> zurückgegeben hat. Die Rückruf Methode muss die <xref:System.IAsyncResult> akzeptieren, die von der <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode als Parameter zurückgegeben wird.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Methode des <xref:System.IAsyncResult>-Parameters auf, um den sendenden <xref:System.Net.Sockets.Socket>abzurufen. Nachdem Sie die <xref:System.Net.Sockets.Socket>erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndSend%2A>-Methode aufrufen, um den Sendevorgang erfolgreich abzuschließen und die Anzahl der gesendeten Bytes zurückzugeben.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.EndSend%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.EndSend%2A> blockiert, bis ein Teil des Puffers gesendet wurde. Wenn der Rückgabewert von <xref:System.Net.Sockets.Socket.EndSend%2A> angibt, dass der Puffer nicht vollständig gesendet wurde, wird die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode erneut aufgerufen, um den Puffer so zu ändern, dass die nicht gesendeten Daten enthalten sind.  
  
 Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel beendet einen ausstehenden asynchronen Sendevorgang.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> wurde bereits für den asynchronen Sendevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult * SocketError -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformation für den asynchronen Vorgang speichert.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang.</summary>
        <returns>Wenn erfolgreich, die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> schließt den asynchronen Sendevorgang ab, der in <xref:System.Net.Sockets.Socket.BeginSend%2A>gestartet wurde.  
  
 Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginSend%2A>müssen Sie eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginSend%2A> zurückgegeben hat. Die Rückruf Methode muss die <xref:System.IAsyncResult> akzeptieren, die von der <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode als Parameter zurückgegeben wird.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Methode des <xref:System.IAsyncResult>-Parameters auf, um den sendenden <xref:System.Net.Sockets.Socket>abzurufen. Nachdem Sie die <xref:System.Net.Sockets.Socket>erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndSend%2A>-Methode aufrufen, um den Sendevorgang erfolgreich abzuschließen und die Anzahl der gesendeten Bytes zurückzugeben.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.EndSend%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.EndSend%2A> blockiert, bis ein Teil des Puffers gesendet wurde. Wenn der Rückgabewert von <xref:System.Net.Sockets.Socket.EndSend%2A> angibt, dass der Puffer nicht vollständig gesendet wurde, wird die <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode erneut aufgerufen, um den Puffer so zu ändern, dass die nicht gesendeten Daten enthalten sind.  
  
 Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.BeginSend%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> wurde bereits für den asynchronen Sendevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformation für den asynchronen Vorgang speichert.</param>
        <summary>Beendet ein ausstehendes asynchrones Senden einer Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> schließt den asynchronen Sendevorgang ab, der in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>gestartet wurde.  
  
 Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginSendFile%2A>müssen Sie eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zurückgegeben hat. Die Rückruf Methode muss das <xref:System.IAsyncResult> Objekt akzeptieren, das von der <xref:System.Net.Sockets.Socket.BeginSendFile%2A>-Methode als Parameter zurückgegeben wird.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Methode des <xref:System.IAsyncResult>-Parameters auf, um den sendenden <xref:System.Net.Sockets.Socket>abzurufen. Nachdem Sie die <xref:System.Net.Sockets.Socket>erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndSendFile%2A>-Methode aufrufen, um den Sendevorgang erfolgreich abzuschließen.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.EndSendFile%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.EndSendFile%2A> blockiert, bis die gesamte Datei gesendet wird. Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.BeginSendFile%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket für asynchrone Kommunikation erstellt und verknüpft und die Datei "Text. txt" asynchron an den Remote Host gesendet. Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> auf, um die Übertragung abzuschließen.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist leer.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> wurde bereits für das asynchrone <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang an einen bestimmten Zielort.</summary>
        <returns>Wenn erfolgreich, die Anzahl der gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> schließt den asynchronen Sendevorgang ab, der in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>gestartet wurde.  
  
 Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginSendTo%2A>müssen Sie eine Rückruf Methode erstellen, die den <xref:System.AsyncCallback> Delegaten implementiert. Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgegeben hat. Die Rückruf Methode muss die <xref:System.IAsyncResult> akzeptieren, die von der <xref:System.Net.Sockets.Socket.BeginSendTo%2A>-Methode als Parameter zurückgegeben wird.  
  
 Rufen Sie innerhalb der Rückruf Methode die <xref:System.IAsyncResult.AsyncState%2A>-Methode des <xref:System.IAsyncResult>-Parameters auf, um den sendenden <xref:System.Net.Sockets.Socket>abzurufen. Nachdem Sie die <xref:System.Net.Sockets.Socket>erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndSendTo%2A>-Methode aufrufen, um den Sendevorgang erfolgreich abzuschließen und die Anzahl der gesendeten Bytes zurückzugeben.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.EndSendTo%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.EndSendTo%2A> blockiert, bis die angeforderte Anzahl von Bytes gesendet wird. Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.BeginSendTo%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein asynchroner Sendevorgang an eine bestimmte Position beendet.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> wurde bereits für den asynchronen Sendevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> das Binden nur eines einzigen Prozesses an einen Anschluss zulässt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> das Binden nur eines einzigen Sockets an einen bestimmten Anschluss zulässt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" /> für Windows Server 2003 und Windows XP Service Pack 2 und <see langword="false" /> für alle anderen Versionen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> `false`ist, können mehrere Sockets die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode verwenden, um eine Bindung an einen bestimmten Port herzustellen. Allerdings kann nur eine der Sockets Vorgänge für den Netzwerk Datenverkehr ausführen, der an den Port gesendet wird. Wenn mehr als ein Socket versucht, die <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29>-Methode für die Bindung an einen bestimmten Port zu verwenden, wird der Netzwerkverkehr, der mit der spezifischeren IP-Adresse an diesen Port gesendet wird, von dem Netzwerkverkehr behandelt.  
  
 Wenn <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> `true`ist, wird die erste Verwendung der <xref:System.Net.Sockets.Socket.Bind%2A>-Methode versucht, eine Bindung an einen bestimmten Port herzustellen, unabhängig von der IP-Adresse (Internet Protocol). alle nachfolgenden Verwendungszwecke der <xref:System.Net.Sockets.Socket.Bind%2A>-Methode, um zu versuchen, eine Bindung an diesen Port herzustellen, schlagen fehl, bis der ursprüngliche gebundene Socket zerstört wird.  
  
 Diese Eigenschaft muss festgelegt werden, bevor <xref:System.Net.Sockets.Socket.Bind%2A> aufgerufen wird. Andernfalls wird eine <xref:System.InvalidOperationException> ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Für diesen <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> wurde <see cref="T:System.Net.Sockets.Socket" /> aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt von der <see cref="T:System.Net.Sockets.Socket" />-Klasse verwendete Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Net.Sockets.Socket>-Klassen-Finalizer Ruft die <xref:System.Net.Sockets.Socket.Close%2A>-Methode auf, um die <xref:System.Net.Sockets.Socket> und die dem <xref:System.Net.Sockets.Socket>zugeordneten Ressourcen zu schließen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashwert für eine <see cref="T:System.Net.Sockets.Socket" />-Instanz zurück.</summary>
        <returns>Ein ganzzahliger Hashwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Die GetHashCode-Methode gibt einen Hashcode für diese Instanz zurück. Dieser Wert kann als Schlüssel in Hash Tabellen verwendet werden.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Wert einer <see cref="T:System.Net.Sockets.Socket" />-Option zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <summary>Gibt den Wert einer angegebenen, als Objekt dargestellten <see cref="T:System.Net.Sockets.Socket" />-Option zurück.</summary>
        <returns>Ein Objekt, das den Wert der Option darstellt. Wenn der <paramref name="optionName" />-Parameter auf <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> festgelegt ist, ist der Rückgabewert eine Instanz der <see cref="T:System.Net.Sockets.LingerOption" />-Klasse. Wenn <paramref name="optionName" /> auf <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> oder <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> festgelegt ist, ist der Rückgabewert eine Instanz der <see cref="T:System.Net.Sockets.MulticastOption" />-Klasse. Wenn <paramref name="optionName" /> einen anderen Wert hat, ist der Rückgabewert eine ganze Zahl.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Verwenden Sie diese Überladung, um die Optionen <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>und <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> zu erhalten. Verwenden Sie für die Option <xref:System.Net.Sockets.SocketOptionName.Linger> <xref:System.Net.Sockets.Socket> für den `optionLevel`-Parameter. Verwenden Sie für <xref:System.Net.Sockets.SocketOptionName.AddMembership> und <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.SocketOptionLevel.IP>. Wenn Sie den Wert einer der oben aufgeführten Optionen festlegen möchten, verwenden Sie die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Net.Sockets.LingerOption>-und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte abgerufen und in der Konsole angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.  
  
- oder - 
 <paramref name="optionName" /> wurde auf den nicht unterstützten Wert <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> festgelegt.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Ein Array vom Typ <see cref="T:System.Byte" />, das die Optionseinstellung erhalten soll.</param>
        <summary>Gibt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Optionseinstellung als Bytearray dargestellt zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Nach erfolgreichem Abschluss dieser Methode enthält das durch den `optionValue`-Parameter angegebene Array den Wert der angegebenen <xref:System.Net.Sockets.Socket> Option.  
  
 Wenn die Länge des `optionValue` Arrays kleiner ist als die Anzahl der Bytes, die zum Speichern des Werts der angegebenen <xref:System.Net.Sockets.Socket> Option erforderlich sind, wird <xref:System.Net.Sockets.Socket.GetSocketOption%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers. Verwenden Sie diese Überladung für alle Sockets, die durch boolesche Werte oder ganze Zahlen dargestellt werden.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Net.Sockets.LingerOption>-und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte abgerufen und in der Konsole angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.  
  
- oder - 
In .NET Compact Framework-Anwendungen ist der Standardpufferspeicher für Windows CE auf 32768 Bytes festgelegt. Sie können den Pufferspeicher pro Socket durch den Aufruf von <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> ändern.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionLength">Die Länge des erwarteten Rückgabewerts in Bytes.</param>
        <summary>Gibt den Wert der angegebenen <see cref="T:System.Net.Sockets.Socket" />-Option in einem Array zurück.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Byte" />, das den Wert der Socketoption enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `optionLength`-Parameter legt die maximale Größe des zurückgegebenen Bytearrays fest. Wenn der Optionswert weniger Bytes erfordert, enthält das Array nur die Anzahl der Bytes. Wenn für den Optionswert mehr Bytes erforderlich sind, wird <xref:System.Net.Sockets.Socket.GetSocketOption%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Verwenden Sie diese Überladung für alle Sockets, die durch boolesche Werte oder ganze Zahlen dargestellt werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Net.Sockets.LingerOption>-und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte abgerufen und in der Konsole angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.  
  
- oder - 
In .NET Compact Framework-Anwendungen ist der Standardpufferspeicher für Windows CE auf 32768 Bytes festgelegt. Sie können den Pufferspeicher pro Socket durch den Aufruf von <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> ändern.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Betriebssystemhandle für den <see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Ein <see cref="T:System.IntPtr" />, der das Betriebssystemhandle für den <see cref="T:System.Net.Sockets.Socket" /> darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt Betriebsmodi auf niedriger Ebene für den <see cref="T:System.Net.Sockets.Socket" /> fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Ein <see cref="T:System.Int32" />-Wert, der den Steuerungscode des auszuführenden Vorgangs angibt.</param>
        <param name="optionInValue">Ein <see cref="T:System.Byte" />-Array, das die für den Vorgang erforderlichen Eingabedaten enthält.</param>
        <param name="optionOutValue">Ein <see cref="T:System.Byte" />-Array, das die durch den Vorgang zurückgegebenen Ausgabedaten enthält.</param>
        <summary>Legt mit numerischen Steuerungscodes die Betriebsmodi niedriger Ebene für den <see cref="T:System.Net.Sockets.Socket" /> fest.</summary>
        <returns>Die Anzahl der Bytes im <paramref name="optionOutValue" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.IOControl%2A>-Methode bietet Zugriff auf niedriger Ebene auf das Betriebssystem <xref:System.Net.Sockets.Socket> der aktuellen Instanz der <xref:System.Net.Sockets.Socket>-Klasse zugrunde liegt. Weitere Informationen finden Sie in der [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) -Dokumentation.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Ergebnisse von "fonread" und der verfügbaren Eigenschaft verglichen.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, den blockierenden Modus ohne Verwendung der <see cref="P:System.Net.Sockets.Socket.Blocking" />-Eigenschaft zu ändern.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Ausführen von nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Ein <see cref="T:System.Net.Sockets.IOControlCode" />-Wert, der den Steuerungscode des auszuführenden Vorgangs angibt.</param>
        <param name="optionInValue">Ein Array vom Typ <see cref="T:System.Byte" />, das die für den Vorgang erforderlichen Eingabedaten enthält.</param>
        <param name="optionOutValue">Ein Array vom Typ <see cref="T:System.Byte" />, das die von dem Vorgang zurückgegebenen Ausgabedaten enthält.</param>
        <summary>Legt mithilfe der <see cref="T:System.Net.Sockets.Socket" />-Enumeration zum Angeben von Steuerungscodes Betriebsmodi niedriger Ebene für den <see cref="T:System.Net.Sockets.IOControlCode" /> fest.</summary>
        <returns>Die Anzahl der Bytes im <paramref name="optionOutValue" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet Zugriff auf niedriger Ebene auf das Betriebssystem <xref:System.Net.Sockets.Socket> der aktuellen Instanz der <xref:System.Net.Sockets.Socket> Klasse zugrunde liegt. Weitere Informationen finden Sie in der [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) -Dokumentation.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Ergebnisse der aufrufenden <xref:System.Net.Sockets.Socket.IOControl%2A> mit <xref:System.Net.Sockets.IOControlCode.DataToRead> und der <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verglichen.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, den blockierenden Modus ohne Verwendung der <see cref="P:System.Net.Sockets.Socket.Blocking" />-Eigenschaft zu ändern.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Ausführen von nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> an einen bestimmten lokalen Anschluss gebunden ist.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> an einen lokalen Anschluss gebunden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Socket wird als gebunden an einen lokalen Port betrachtet, wenn er durch Aufrufen der <xref:System.Net.Sockets.Socket.Bind%2A> Methode explizit gebunden wird, oder durch Aufrufen von Membern wie <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>oder <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, die einen kurzlebigen lokalen Port verwenden (ein freier Port größer als 1024, der vom Betriebssystem ausgewählt wird). -Server verwenden die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode, um eine Bindung an einen bekannten Port herzustellen, damit Clients eine Verbindung mit Ihnen herstellen können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.IsBound%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> bei einem Versuch, alle ausstehenden Daten zu senden, das Schließen eines Sockets verzögert, oder legt diesen fest.</summary>
        <value>Eine <see cref="T:System.Net.Sockets.LingerOption" />, die angibt, wie der Nachlauf während des Schließens eines Sockets erfolgen soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.LingerState%2A>-Eigenschaft ändert die Art und Weise, wie <xref:System.Net.Sockets.Socket.Close%2A> Methode verhält. Diese Eigenschaft, wenn Set die Bedingungen ändert, unter denen die Verbindung von Winsock zurückgesetzt werden kann. Verbindungs Aufstellungen können weiterhin basierend auf dem IP-Protokoll Verhalten auftreten.  
  
 Diese Eigenschaft steuert die Zeitspanne, in der eine Verbindungs orientierte Verbindung nach einem Aufruf von <xref:System.Net.Sockets.Socket.Close%2A> geöffnet bleibt, wenn die Daten noch gesendet werden sollen.  
  
 Wenn Sie Methoden zum Senden von Daten an einen Peer aufzurufen, werden diese Daten im ausgehenden Netzwerk Puffer platziert. Diese Eigenschaft kann verwendet werden, um sicherzustellen, dass diese Daten an den Remote Host gesendet werden, bevor die <xref:System.Net.Sockets.TcpClient.Close%2A> Methode die Verbindung löscht.  
  
 Erstellen Sie eine <xref:System.Net.Sockets.LingerOption>-Instanz, die die gewünschten Werte enthält, und legen Sie die <xref:System.Net.Sockets.Socket.LingerState%2A>-Eigenschaft auf diese Instanz fest, um einen veralteten Wert zu aktivieren.  
  
 In der folgenden Tabelle wird das Verhalten der <xref:System.Net.Sockets.Socket.Close%2A>-Methode für die möglichen Werte der <xref:System.Net.Sockets.LingerOption.Enabled%2A>-Eigenschaft und die <xref:System.Net.Sockets.LingerOption.LingerTime%2A>-Eigenschaft beschrieben, die in der <xref:System.Net.Sockets.Socket.LingerState%2A>-Eigenschaft gespeichert ist.  
  
|LingerState.Enabled|LingerState.LingerTime|Verhalten|  
|-------------------------|----------------------------|--------------|  
|`false` (deaktiviert), der Standardwert|Das Timeout ist nicht anwendbar (Standard).|Versucht, ausstehende Daten zu senden, bis der Standard-IP-Protokoll Timeout abläuft.|  
|`true` (aktiviert)|Ein Timeout ungleich 0 (null)|Versucht, ausstehende Daten zu senden, bis das angegebene Timeout abläuft. wenn der Versuch fehlschlägt, setzt Winsock die Verbindung zurück.|  
|`true` (aktiviert)|Ein Timeout von NULL.|Verwirft alle ausstehenden Daten. Für Verbindungs orientierten Socket (z. b. TCP) setzt Winsock die Verbindung zurück.|  
  
 Der IP-Stapel berechnet den Standard Timeout Zeitraum für das IP-Protokoll, der basierend auf der Roundtripzeit der Verbindung verwendet werden soll. In den meisten Fällen ist der durch den Stapel berechnete Timeout relevanter als der von einer Anwendung definierte Timeout. Dies ist das Standardverhalten für einen Socket, wenn die <xref:System.Net.Sockets.Socket.LingerState%2A>-Eigenschaft nicht festgelegt ist.  
  
 Wenn die <xref:System.Net.Sockets.LingerOption.LingerTime%2A>-Eigenschaft, die in der <xref:System.Net.Sockets.Socket.LingerState%2A>-Eigenschaft gespeichert ist, größer als das Standard Timeout für den IP-Protokoll Wert ist, wird das Standard Timeout für das IP-Protokoll weiterhin angewendet und außer Kraft gesetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.LingerState%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Die maximale Länge der Warteschlange für ausstehende Verbindungen.</param>
        <summary>Versetzt einen <see cref="T:System.Net.Sockets.Socket" /> in den Überwachungszustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> bewirkt, dass ein Verbindungs orientierter <xref:System.Net.Sockets.Socket> auf eingehende Verbindungsversuche lauscht. Der `backlog`-Parameter gibt die Anzahl eingehender Verbindungen an, die zur Annahme in die Warteschlange eingereiht werden können. Um die maximale Anzahl von Verbindungen zu bestimmen, die Sie angeben können, rufen Sie den <xref:System.Net.Sockets.SocketOptionName.MaxConnections> Wert ab. <xref:System.Net.Sockets.Socket.Listen%2A> wird nicht blockiert.  
  
 Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers. Verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> oder <xref:System.Net.Sockets.Socket.BeginAccept%2A>, um eine Verbindung aus der Warteschlange zu akzeptieren.  
  
> [!NOTE]
>  Sie müssen die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode aufrufen, bevor Sie <xref:System.Net.Sockets.Socket.Listen%2A>aufrufen, oder <xref:System.Net.Sockets.Socket.Listen%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Rückstands Parameter ist abhängig vom Betriebs System auf unterschiedliche Werte beschränkt. Sie können einen höheren Wert angeben, der Rückstand wird jedoch auf Grundlage des Betriebssystems beschränkt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.Socket> verwendet, um auf eingehende Verbindungen zu lauschen.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den lokalen Endpunkt ab.</summary>
        <value>Der <see cref="T:System.Net.EndPoint" />, den der <see cref="T:System.Net.Sockets.Socket" /> für die Kommunikation verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>-Eigenschaft ruft eine <xref:System.Net.EndPoint> ab, die die lokale IP-Adresse und die Portnummer enthält, an die ihr <xref:System.Net.Sockets.Socket> gebunden ist. Sie müssen diese <xref:System.Net.EndPoint> in eine <xref:System.Net.IPEndPoint> umwandeln, bevor Sie Informationen abrufen. Sie können dann die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>-Methode aufrufen, um den lokalen <xref:System.Net.IPAddress>abzurufen, und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>-Methode, um die lokale Portnummer abzurufen.  
  
 Die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>-Eigenschaft wird normalerweise festgelegt, nachdem Sie die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode aufgerufen haben. Wenn Sie zulassen, dass das System die lokale IP-Adresse und Portnummer Ihres Sockets zuweist, wird die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>-Eigenschaft nach dem ersten e/a-Vorgang festgelegt. Bei Verbindungs orientierten Protokollen wäre der erste e/a-Vorgang ein aufzurufende <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Bei Verbindungs losen Protokollen wäre der erste e/a-Vorgang einer der Sende-oder Empfangs Aufrufe.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die lokalen und Remote Endpunkte abgerufen und angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ausgehende Multicastpakete an die sendende Anwendung übermittelt werden, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> ausgehende Multicastpakete empfängt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multicast ist eine skalierbare Methode für die m:n-Kommunikation im Internet. Ein Prozess abonniert eine Multicast Adresse. Anschließend werden alle Pakete, die von einem abonnierten Prozess gesendet werden, von jedem anderen Prozess empfangen, der die Multicast Adresse abonniert hat.  
  
 Das Festlegen dieser Eigenschaft auf einen TCP-Socket (Transmission Control Protocol) hat keine Auswirkungen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.MulticastLoopback%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der Stream-<see cref="T:System.Net.Sockets.Socket" /> den Nagle-Algorithmus verwendet, oder legt diesen fest.</summary>
        <value><see langword="false" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> den Nagle-Algorithmus verwendet, andernfalls <see langword="true" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Nagle-Algorithmus ist darauf ausgelegt, den Netzwerk Datenverkehr zu verringern, indem der Socket kleine Pakete puffert und Sie dann in einem Paket unter bestimmten Umständen kombiniert und sendet. Ein TCP-Paket besteht aus 40 Bytes des Headers und den gesendeten Daten. Wenn kleine Datenpakete mit TCP gesendet werden, kann der mehr Aufwand, der sich aus dem TCP-Header ergibt, zu einem erheblichen Teil des Netzwerk Datenverkehrs werden. Bei stark ausgelasteten Netzwerken kann die Überlastung, die sich aus diesem Aufwand ergibt, zu verlorenen Datagramme und erneuten Übertragungen sowie zu einer übermäßigen propagierungs Zeit führen, die durch eine Überlastung verursacht wird Der Nagle-Algorithmus hemmt das Senden neuer TCP-Segmente, wenn neue ausgehende Daten vom Benutzer empfangen werden, wenn zuvor übertragene Daten über die Verbindung nicht bestätigt bleiben.  
  
 Die Mehrzahl der Netzwerkanwendungen sollte den Nagle-Algorithmus verwenden.  
  
 Das Festlegen dieser Eigenschaft für einen UDP-Socket (User Datagram Protocol) hat keine Auswirkungen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.NoDelay%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob das zugrunde liegende Betriebssystem und die Netzwerkkarten IPv4 (Internet Protocol, Version 4) unterstützen.</summary>
        <value><see langword="true" />, wenn das Betriebssystem und die Netzwerkkarten das IPv4-Protokoll unterstützen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem unterstützt möglicherweise sowohl IPv4-als auch IPv6-Protokolle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob das zugrunde liegende Betriebssystem und die Netzwerkkarten IPv6 (Internet Protocol, Version 6) unterstützen.</summary>
        <value><see langword="true" />, wenn das Betriebssystem und die Netzwerkkarten das Protokoll IPv6 unterstützen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem unterstützt möglicherweise sowohl IPv4-als auch IPv6-Protokolle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds">Die Zeit in Mikrosekunden, die auf eine Antwort gewartet werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.Net.Sockets.SelectMode" />-Werte.</param>
        <summary>Bestimmt den Status des <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Der Status des <see cref="T:System.Net.Sockets.Socket" /> basierend auf dem im <paramref name="mode" />-Parameter übergebenen Abfragemoduswert.  
  
 <list type="table"><listheader><term> Modus 
 </term><description> Rückgabewert 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" />, wenn <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> aufgerufen wurde und eine Verbindung aussteht. 
- oder - 
 <see langword="true" />, wenn Daten zum Lesen verfügbar sind. 
- oder - 
 <see langword="true" />, wenn die Verbindung geschlossen, zurückgesetzt oder beendet wurde. 
Andernfalls wird <see langword="false" /> zurückgegeben.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, wenn ein <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> verarbeitet wird und die Verbindung erfolgreich war. 
- oder - 
 <see langword="true" />, wenn Daten gesendet werden können. 
Andernfalls wird <see langword="false" /> zurückgegeben.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" />, wenn ein <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> ohne Blockierung verarbeitet wird und der Verbindungsaufbau fehlgeschlagen ist. 
- oder - 
 <see langword="true" />, wenn <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> nicht festgelegt ist und Out-of-Band-Daten verfügbar sind. 
Andernfalls wird <see langword="false" /> zurückgegeben.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Net.Sockets.Socket.Poll%2A>-Methode wird der Status des <xref:System.Net.Sockets.Socket>überprüft. Geben Sie <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> für den `selectMode`-Parameter an, um zu bestimmen, ob die <xref:System.Net.Sockets.Socket> lesbar ist. Geben Sie <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> an, um zu bestimmen, ob die <xref:System.Net.Sockets.Socket> schreibgeschützt ist. Verwenden Sie <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType>, um eine Fehlerbedingung zu erkennen. <xref:System.Net.Sockets.Socket.Poll%2A> wird die Ausführung blockieren, bis der angegebene Zeitraum, gemessen in `microseconds`, abläuft. Legen Sie den `microSeconds`-Parameter auf eine negative Ganzzahl fest, wenn Sie unbegrenzt auf eine Antwort warten möchten. Wenn Sie den Status mehrerer Sockets überprüfen möchten, empfiehlt es sich, die <xref:System.Net.Sockets.Socket.Select%2A>-Methode zu verwenden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Diese Methode kann bestimmte Arten von Verbindungsproblemen, wie z. b. ein fehlerhaftes Netzwerkkabel, nicht erkennen, oder der Remote Host wurde nicht ordnungsgemäß heruntergefahren. Sie müssen versuchen, Daten zu senden oder zu empfangen, um diese Arten von Fehlern zu erkennen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Socket, stellt eine Verbindung mit einem Server her und verwendet <xref:System.Net.Sockets.Socket.Poll%2A>, um den Status des Sockets zu überprüfen.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der <paramref name="mode" />-Parameter ist keiner der <see cref="T:System.Net.Sockets.SelectMode" />-Werte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie in den Hinweisen weiter unten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Protokolltyp des <see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ProtocolType%2A>-Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.Socket> erstellt wird, und gibt das von dieser <xref:System.Net.Sockets.Socket>verwendete Protokoll an.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>und <xref:System.Net.Sockets.ProtocolType> in der Konsole angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können <xref:System.Net.Sockets.Socket.Receive%2A> sowohl aus Verbindungs orientierten als auch mit Verbindungs losen Sockets abrufen.  
  
 Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer bereitstellen. Der Puffer Offset ist standardmäßig auf 0 (null) eingestellt, der Standardwert ist die Länge des Puffer Parameters, und der <xref:System.Net.Sockets.SocketFlags> Wert ist standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A>, um eine eingehende Verbindung vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A>zu akzeptieren. Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest nur Daten, die vom Remote Host empfangen werden, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode verwenden. mit <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie Daten empfangen, die von einem beliebigen Host empfangen werden.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode blockiert, bis Daten verfügbar sind, es sei denn, es wurde ein Timeout Wert mit <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, liest die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
 Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, liest <xref:System.Net.Sockets.Socket.Receive%2A> das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode angeben. Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer`-Parameters ist, werden `buffer` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und es wird ein <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Daten in einem verbundenen <xref:System.Net.Sockets.Socket>empfangen.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste mit <see cref="T:System.ArraySegment`1" />s vom Typ <see cref="T:System.Byte" />, die die empfangenen Daten enthält.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> und fügt sie in die Liste der Empfangspuffer ein.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest Daten in den Puffer Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.  
  
 Diese Überladung erfordert, dass Sie einen oder mehrere Empfangs Puffer bereitstellen.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A>, um eine eingehende Verbindung vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A>zu akzeptieren. Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest nur Daten, die von der Remote Host Verbindung empfangen werden, die in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode verwenden. mit <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie Daten empfangen, die von einem beliebigen Host empfangen werden.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode blockiert, bis Daten verfügbar sind, es sei denn, es wurde ein Timeout Wert mit <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, liest die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
 Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, liest <xref:System.Net.Sockets.Socket.Receive%2A> das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode angeben. Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffers`-Parameters ist, werden `buffers` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und es wird ein <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 **Hinweis** Dieser Member gibt Ablauf Verfolgungs Informationen aus, wenn Sie die Netzwerk Ablauf Verfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Eine Spanne von Bytes, die der Speicherort für die empfangenen Daten ist.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können <xref:System.Net.Sockets.Socket.Receive%2A> sowohl aus Verbindungs orientierten als auch mit Verbindungs losen Sockets abrufen.

Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer bereitstellen. Der Puffer Offset ist standardmäßig auf 0 (null) eingestellt, der Standardwert ist die Länge des Puffer Parameters, und der <xref:System.Net.Sockets.SocketFlags> Wert ist standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.

Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A>, um eine eingehende Verbindung zu akzeptieren, bevor Sie <xref:System.Net.Sockets.Socket.Receive%2A>aufrufen. Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest nur Daten, die vom Remote Host empfangen werden, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode verwenden. mit <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie Daten empfangen, die von einem beliebigen Host empfangen werden.

Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode blockiert, bis Daten verfügbar sind, es sei denn, es wurde ein Timeout Wert mit <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wird, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.

Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, liest die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.

Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, liest <xref:System.Net.Sockets.Socket.Receive%2A> das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode angeben. Wenn das Datagramm, das Sie empfangen, größer ist als die Größe des `buffer`-Parameters, wird `buffer` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und es wird eine <xref:System.Net.Sockets.SocketException> ausgelöst.

> [!NOTE]
> Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.

Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">Verbindungen aus dem Netzwerk werden akzeptiert. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können <xref:System.Net.Sockets.Socket.Receive%2A> sowohl aus Verbindungs orientierten als auch mit Verbindungs losen Sockets abrufen.  
  
 Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer und die erforderlichen <xref:System.Net.Sockets.SocketFlags>bereitstellen. Der Puffer Offset ist standardmäßig 0, und die Größe ist standardmäßig auf die Länge des Byte-Parameters eingestellt.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A>, um eine eingehende Verbindung vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A>zu akzeptieren. Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest nur Daten, die vom Remote Host empfangen werden, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode verwenden. mit <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie Daten empfangen, die von einem beliebigen Host empfangen werden.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode blockiert, bis die Daten verfügbar sind. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, liest die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode so viele Daten, wie bis zur Größe des Puffers verfügbar ist. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
 Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, liest <xref:System.Net.Sockets.Socket.Receive%2A> das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode angeben. Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer`-Parameters ist, werden `buffer` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und es wird ein <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Datenpuffer und <xref:System.Net.Sockets.SocketFlags> zum Empfangen von Daten auf einem verbundenen <xref:System.Net.Sockets.Socket>angegeben.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">Verbindungen aus dem Netzwerk werden akzeptiert. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste mit <see cref="T:System.ArraySegment`1" />s vom Typ <see cref="T:System.Byte" />, die die empfangenen Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in der Liste der Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest Daten in den `buffers`-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.  
  
 Diese Überladung erfordert, dass Sie einen oder mehrere Empfangs Puffer bereitstellen. Der <xref:System.Net.Sockets.SocketFlags> Wert ist standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A>, um eine eingehende Verbindung vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A>zu akzeptieren. Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest nur Daten, die von der Remote Host Verbindung empfangen werden, die in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode verwenden. mit <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie Daten empfangen, die von einem beliebigen Host empfangen werden.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode blockiert, bis Daten verfügbar sind, es sei denn, es wurde ein Timeout Wert mit <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, liest die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
 Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, liest <xref:System.Net.Sockets.Socket.Receive%2A> das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode angeben. Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffers`-Parameters ist, werden `buffers` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und es wird ein <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Daten für eine verbundene <xref:System.Net.Sockets.Socket>empfangen werden.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="buffers" />.Count ist 0 (null).</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Eine Spanne von Bytes, die der Speicherort für die empfangenen Daten ist.</param>
        <param name="socketFlags">Eine bitweise Kombination der Enumerationswerte, die das Sende- und Empfangsverhalten angeben.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können <xref:System.Net.Sockets.Socket.Receive%2A> sowohl aus Verbindungs orientierten als auch mit Verbindungs losen Sockets abrufen.

Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer bereitstellen. Der Puffer Offset ist standardmäßig auf 0 (null) eingestellt, der Standardwert ist die Länge des Puffer Parameters, und der <xref:System.Net.Sockets.SocketFlags> Wert ist standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.

Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A>, um eine eingehende Verbindung vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A>zu akzeptieren. Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest nur Daten, die vom Remote Host empfangen werden, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode verwenden. mit <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie Daten empfangen, die von einem beliebigen Host empfangen werden.

Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode blockiert, bis Daten verfügbar sind, es sei denn, es wurde ein Timeout Wert mit <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wird, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.

Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, liest die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.

Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, liest <xref:System.Net.Sockets.Socket.Receive%2A> das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode angeben. Wenn das Datagramm, das Sie empfangen, größer ist als die Größe des `buffer`-Parameters, wird `buffer` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und es wird eine <xref:System.Net.Sockets.SocketException> ausgelöst.

> [!NOTE]
> Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.

Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt die angegebene Anzahl von Datenbytes aus einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest Daten in den `buffer`-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können <xref:System.Net.Sockets.Socket.Receive%2A> sowohl aus Verbindungs orientierten als auch mit Verbindungs losen Sockets abrufen.  
  
 Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer, die Anzahl der zu empfangenden Bytes und die erforderlichen <xref:System.Net.Sockets.SocketFlags>bereitstellen.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A>, um eine eingehende Verbindung vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A>zu akzeptieren. Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest nur Daten, die vom Remote Host empfangen werden, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode verwenden. mit <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie Daten empfangen, die von einem beliebigen Host empfangen werden.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode blockiert, bis Daten verfügbar sind, es sei denn, es wurde ein Timeout Wert mit <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, liest die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode so viele Daten wie verfügbar, bis zu der Anzahl der Bytes, die durch den `size`-Parameter angegeben werden. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
 Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, liest <xref:System.Net.Sockets.Socket.Receive%2A> das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode angeben. Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer`-Parameters ist, werden `buffer` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und es wird ein <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden werden die in `buffer`gefundenen Daten empfangen und <xref:System.Net.Sockets.SocketFlags.None> für <xref:System.Net.Sockets.SocketFlags>angegeben.  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> ist größer als <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste mit <see cref="T:System.ArraySegment`1" />s vom Typ <see cref="T:System.Byte" />, die die empfangenen Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in der Liste der Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest Daten in den `buffers`-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.  
  
 Diese Überladung erfordert, dass Sie einen oder mehrere Empfangs Puffer bereitstellen. Der <xref:System.Net.Sockets.SocketFlags> Wert ist standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A>, um eine eingehende Verbindung vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A>zu akzeptieren. Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest nur Daten, die von der Remote Host Verbindung empfangen werden, die in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode verwenden. mit <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie Daten empfangen, die von einem beliebigen Host empfangen werden.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode blockiert, bis Daten verfügbar sind, es sei denn, es wurde ein Timeout Wert mit <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, liest die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
 Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, liest<xref:System.Net.Sockets.Socket.Receive%2A> das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode angeben. Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffers`-Parameters ist, werden `buffers` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und es wird ein <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="buffers" />.Count ist 0 (null).</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Eine Spanne von Bytes, die der Speicherort für die empfangenen Daten ist.</param>
        <param name="socketFlags">Eine bitweise Kombination der Enumerationswerte, die das Sende- und Empfangsverhalten angeben.</param>
        <param name="errorCode">Diese Methode gibt einen der Enumerationswerte zurück, der Fehlercodes für den Socket definiert.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können <xref:System.Net.Sockets.Socket.Receive%2A> sowohl aus Verbindungs orientierten als auch mit Verbindungs losen Sockets abrufen.  

Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer bereitstellen. Der Puffer Offset ist standardmäßig auf 0 (null) eingestellt, der Standardwert ist die Länge des Puffer Parameters, und der <xref:System.Net.Sockets.SocketFlags> Wert ist standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  

Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A>, um eine eingehende Verbindung vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A>zu akzeptieren. Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest nur Daten, die vom Remote Host empfangen werden, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode verwenden. mit <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie Daten empfangen, die von einem beliebigen Host empfangen werden.  

Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode blockiert, bis Daten verfügbar sind, es sei denn, es wurde ein Timeout Wert mit <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wird, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  

Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, liest die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  

Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, liest <xref:System.Net.Sockets.Socket.Receive%2A> das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode angeben. Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer`-Parameters ist, werden `buffer` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und es wird ein <xref:System.Net.Sockets.SocketException> ausgelöst.  

> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  

> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="offset">Die Position im <paramref name="buffer" />, an der die empfangenen Daten gespeichert werden sollen.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt die angegebene Anzahl von Bytes aus einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> an der angegebenen Offsetposition des Empfangspuffers, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können <xref:System.Net.Sockets.Socket.Receive%2A> sowohl aus Verbindungs orientierten als auch mit Verbindungs losen Sockets abrufen.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A>, um eine eingehende Verbindung vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A>zu akzeptieren. Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest nur Daten, die vom Remote Host empfangen werden, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode verwenden. mit <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie Daten empfangen, die von einem beliebigen Host empfangen werden.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode blockiert, bis Daten verfügbar sind, es sei denn, es wurde ein Timeout Wert mit <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Fehler beim Versuch, auf den Socket zuzugreifen. Siehe folgende Hinweise. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, liest die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode so viele Daten wie verfügbar, bis zu der Anzahl der Bytes, die durch den size-Parameter angegeben werden. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
 Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, liest <xref:System.Net.Sockets.Socket.Receive%2A> das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode angeben. Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer`-Parameters ist, werden `buffer` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und es wird ein <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden ein Datenpuffer, ein Offset, eine Größe und ein Socketflag angegeben, bevor Daten für eine verbundene <xref:System.Net.Sockets.Socket>empfangen werden.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder - 
Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="offset">Die Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden sollen.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können <xref:System.Net.Sockets.Socket.Receive%2A> sowohl aus Verbindungs orientierten als auch mit Verbindungs losen Sockets abrufen.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A>, um eine eingehende Verbindung vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A>zu akzeptieren. Die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode liest nur Daten, die vom Remote Host empfangen werden, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode verwenden. mit <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie Daten empfangen, die von einem beliebigen Host empfangen werden.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode blockiert, bis Daten verfügbar sind, es sei denn, es wurde ein Timeout Wert mit <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Fehler beim Versuch, auf den Socket zuzugreifen. Siehe folgende Hinweise. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, liest die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode so viele Daten wie verfügbar, bis zu der Anzahl der Bytes, die durch den size-Parameter angegeben werden. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
 Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, liest <xref:System.Net.Sockets.Socket.Receive%2A> das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode angeben. Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer`-Parameters ist, werden `buffer` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und es wird ein <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder - 
Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft ist nicht festgelegt.  
  
- oder - 
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Startet eine asynchrone Anforderung, um Daten von einem verbundenen <see cref="T:System.Net.Sockets.Socket" />-Objekt zu empfangen.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>-Methode wird für verbundene Sockets oder gebundene verbindungslose Sockets verwendet und zum Lesen eingehender Daten verwendet. Die lokale Adresse des Sockets muss bekannt sein.  
  
 Für gebundene verbindungslose Sockets schränkt diese Funktion die Adressen ein, von denen empfangene Nachrichten akzeptiert werden. Die-Funktion gibt nur Nachrichten von der in der Verbindung angegebenen Remote Adresse zurück. Nachrichten von anderen Adressen werden automatisch verworfen.  
  
 Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>-Eigenschaft des `e`-Parameters stellt dem Window Sockets-Dienstanbieter zusätzliche Informationen über die Lese Anforderung bereit. Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Die folgenden Eigenschaften und Ereignisse für das <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> oder <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>-Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, bevor die <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>-Methode aufgerufen wird, damit die Informationen in der Rückruf Methode abgerufen werden können. Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.  
  
 Bei Bytes im Bytestream werden eingehende Daten in den Puffer eingefügt, bis der Puffer gefüllt wird, die Verbindung geschlossen wird oder die intern gepufferten Daten aufgebraucht sind.  
  
 Bei Nachrichten orientierten Sockets wird eine eingehende Nachricht bis zur Gesamtgröße des Puffers in den Puffer eingefügt, der dem `e`-Parameter zugeordnet ist. Wenn die Nachricht größer als der Puffer ist, wird der Puffer mit dem ersten Teil der Nachricht gefüllt.  
  
 Bei Verbindungs orientierten Sockets kann die <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>-Methode die ordnungsgemäße Beendigung der virtuellen Verbindung auf eine von zwei Arten angeben, die davon abhängen, ob der Socket ein Bytestream oder eine Nachrichten orientierte ist. Bei Bytestreams geben NULL Bytes, die gelesen wurden, eine ordnungsgemäße Sperre an, und es werden nie mehr Bytes gelesen. Bei Nachrichten orientierten Sockets, bei denen eine Meldung mit dem Wert 0 (null) häufig zulässig ist, wird ein <xref:System.Net.Sockets.SocketException> mit dem <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> auf den systemeigenen Winsock-wsaediscon-Fehlercode (10101) festgelegt, um eine ordnungsgemäße Schließung anzugeben. In jedem Fall weist eine <xref:System.Net.Sockets.SocketException>, bei der die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> auf den nativen Winsock-WSAECONNRESET-Fehlercode (10054) festgelegt ist, darauf hin, dass ein Abbruch aufgetreten ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument war ungültig. Die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft oder <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft des <paramref name="e" />-Parameters muss auf gültige Puffer verweisen. Eine dieser Eigenschaften kann festgelegt werden, nicht jedoch beide gleichzeitig.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Parameter angegebenen <paramref name="e" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Größe des Empfangspuffers des <see cref="T:System.Net.Sockets.Socket" /> angibt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, das die Größe des Empfangspuffer in Bytes enthält. Der Standard ist 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine größere Puffergröße reduziert möglicherweise die Anzahl der leeren Bestätigungen (TCP-Pakete ohne Daten Anteil), kann aber auch die Erkennung von Verbindungsproblemen verzögern. Erhöhen Sie ggf. die Puffergröße, wenn Sie große Dateien übertragen, oder Sie verwenden eine Verbindung mit hoher Bandbreite und hoher Latenz (z. b. einem Satelliten-Breitbandanbieter).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen set-Vorgang angegebene Wert ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Empfängt ein Datagramm und speichert den Endpunkt der Quelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt ein Datagramm im Datenpuffer und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode liest Daten in den `buffer`-Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes zurück und erfasst den Remote Host Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts empfangen möchten.  
  
 Diese Überladung erfordert nur, dass Sie einen Empfangs `buffer`und eine <xref:System.Net.EndPoint> bereitstellen, die den Remote Host darstellt. Der Puffer Offset ist standardmäßig 0. Der Standardwert ist die Länge des `buffer`-Parameters, und der `socketFlags` Wert ist standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
> [!NOTE]
>  Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>müssen Sie die <xref:System.Net.Sockets.Socket> mithilfe der <xref:System.Net.Sockets.Socket.Bind%2A>-Methode explizit an einen lokalen Endpunkt binden. Wenn dies nicht der Fall ist, wird <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> eine <xref:System.Net.Sockets.SocketException>auslösen.  
  
 Bei Verbindungs losen Protokollen liest <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> das erste in die Warteschlange eingereihte Datagramm, das in den Puffer des lokalen Netzwerks empfangen wurde. Wenn das Datagramm, das Sie empfangen, größer ist als die Größe der `buffer`, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode `buffer` mit dem größtmöglichen Wert der Nachricht aufgefüllt und eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein unzuverlässiges Protokoll verwenden, gehen die Daten verloren. Wenn Sie ein zuverlässiges Protokoll verwenden, werden die überzähligen Daten vom Dienstanbieter aufbewahrt, und Sie können Sie abrufen, indem Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode mit einem ausreichend großen Puffer aufrufen.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode blockiert, bis die Daten verfügbar sind. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> für verbindungslose Protokolle vorgesehen ist, können Sie auch ein Verbindungs orientiertes Protokoll verwenden. Wenn Sie sich dafür entscheiden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen oder eine eingehende Remote Host Verbindung akzeptieren, indem Sie die <xref:System.Net.Sockets.Socket.Accept%2A>-Methode aufrufen. Wenn Sie keine Verbindung einrichten oder akzeptieren, bevor Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode aufrufen, erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode aufrufen. In beiden Fällen ignoriert die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode den `remoteEP`-Parameter und empfängt nur Daten vom verbundenen oder standardmäßigen Remote Host.  
  
 Mit Verbindungs orientierten Sockets werden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> so viele Daten lesen, wie bis `buffer`verfügbar ist. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> der in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> verwendeten <xref:System.Net.EndPoint> muss mit der <xref:System.Net.Sockets.AddressFamily> der in <xref:System.Net.EndPoint> verwendeten <xref:System.Net.Sockets.Socket.SendTo%2A>identisch sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remote Host empfangen.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt mithilfe der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> ein Datagramm im Datenpuffer und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode liest Daten in den `buffer`-Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes zurück und erfasst den Remote Host Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts empfangen möchten.  
  
 Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer, die erforderliche <xref:System.Net.Sockets.SocketFlags>und eine <xref:System.Net.EndPoint> bereitstellen, die den Remote Host darstellt. Der Offset ist standardmäßig 0, und die Größe ist standardmäßig auf die Länge des Puffer Parameters eingestellt.  
  
> [!NOTE]
>  Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>müssen Sie die <xref:System.Net.Sockets.Socket> mithilfe der <xref:System.Net.Sockets.Socket.Bind%2A>-Methode explizit an einen lokalen Endpunkt binden. Wenn dies nicht der Fall ist, wird <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> eine <xref:System.Net.Sockets.SocketException>auslösen.  
  
 Bei Verbindungs losen Protokollen liest <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> das erste in die Warteschlange eingereihte Datagramm, das in den Puffer des lokalen Netzwerks empfangen wurde. Wenn das Datagramm, das Sie empfangen, größer ist als die Größe der `buffer`, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode `buffer` mit dem größtmöglichen Wert der Nachricht aufgefüllt und eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein unzuverlässiges Protokoll verwenden, gehen die Daten verloren. Wenn Sie ein zuverlässiges Protokoll verwenden, werden die überzähligen Daten vom Dienstanbieter aufbewahrt, und Sie können Sie abrufen, indem Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode mit einem ausreichend großen Puffer aufrufen.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode blockiert, bis die Daten verfügbar sind. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> für verbindungslose Protokolle vorgesehen ist, können Sie auch ein Verbindungs orientiertes Protokoll verwenden. Wenn Sie sich dafür entscheiden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen oder eine eingehende Remote Host Verbindung akzeptieren, indem Sie die <xref:System.Net.Sockets.Socket.Accept%2A>-Methode aufrufen. Wenn Sie keine Verbindung einrichten oder akzeptieren, bevor Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode aufrufen, erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode aufrufen. In beiden Fällen ignoriert die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode den `remoteEP`-Parameter und empfängt nur Daten vom verbundenen oder standardmäßigen Remote Host.  
  
 Mit Verbindungs orientierten Sockets werden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> so viele Daten lesen, wie bis `buffer`verfügbar ist. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> der in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> verwendeten <xref:System.Net.EndPoint> muss mit der <xref:System.Net.Sockets.AddressFamily> der in <xref:System.Net.EndPoint> verwendeten <xref:System.Net.Sockets.Socket.SendTo%2A>identisch sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remote Host empfangen. <xref:System.Net.Sockets.SocketFlags> werden an die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode übermittelt.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt mithilfe der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> die angegebene Anzahl von Bytes im Datenpuffer und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode liest Daten in den `buffer`-Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes zurück und erfasst den Remote Host Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts empfangen möchten.  
  
 Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer, die Anzahl der zu empfangenden Bytes, die erforderliche <xref:System.Net.Sockets.SocketFlags>und eine <xref:System.Net.EndPoint> angeben, die den Remote Host darstellt. Der Puffer Offset ist standardmäßig 0.  
  
 Bei Verbindungs losen Protokollen liest <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> das erste in die Warteschlange eingereihte Datagramm, das in den Puffer des lokalen Netzwerks empfangen wurde. Wenn das Datagramm, das Sie empfangen, größer ist als die Größe der `buffer`, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode `buffer` mit dem größtmöglichen Wert der Nachricht aufgefüllt und eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein unzuverlässiges Protokoll verwenden, gehen die Daten verloren. Wenn Sie ein zuverlässiges Protokoll verwenden, werden die überzähligen Daten vom Dienstanbieter aufbewahrt, und Sie können Sie abrufen, indem Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode mit einem ausreichend großen Puffer aufrufen.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode blockiert, bis die Daten verfügbar sind. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> für verbindungslose Protokolle vorgesehen ist, können Sie auch ein Verbindungs orientiertes Protokoll verwenden. Wenn Sie sich dafür entscheiden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen oder eine eingehende Remote Host Verbindung akzeptieren, indem Sie die <xref:System.Net.Sockets.Socket.Accept%2A>-Methode aufrufen. Wenn Sie keine Verbindung einrichten oder akzeptieren, bevor Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode aufrufen, erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode aufrufen. In beiden Fällen ignoriert die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode den `remoteEP`-Parameter und empfängt nur Daten vom verbundenen oder standardmäßigen Remote Host.  
  
 Mit Verbindungs orientierten Sockets lesen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> so viele Daten, wie Sie bis zur Anzahl der Bytes verfügbar sind, die durch den Parameter `size` angegeben werden. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
> [!NOTE]
>  Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>müssen Sie die <xref:System.Net.Sockets.Socket> mithilfe der <xref:System.Net.Sockets.Socket.Bind%2A>-Methode explizit an einen lokalen Endpunkt binden. Wenn dies nicht der Fall ist, wird <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> der in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> verwendeten <xref:System.Net.EndPoint> muss mit der <xref:System.Net.Sockets.AddressFamily> der in <xref:System.Net.EndPoint> verwendeten <xref:System.Net.Sockets.Socket.SendTo%2A>identisch sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remote Host empfangen. Die Puffergröße und <xref:System.Net.Sockets.SocketFlags> werden an die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode übermittelt.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder - 
Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="offset">Die Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden sollen.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt die angegebene Anzahl von Datenbytes an der angegebenen Position im Datenpuffer, verwendet dabei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode liest Daten in den `buffer`-Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes zurück und erfasst den Remote Host Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts empfangen möchten.  
  
 Bei Verbindungs losen Protokollen liest <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> das erste in die Warteschlange eingereihte Datagramm, das in den Puffer des lokalen Netzwerks empfangen wurde. Wenn das Datagramm, das Sie empfangen, größer ist als die Größe der `buffer`, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode `buffer` mit dem größtmöglichen Wert der Nachricht aufgefüllt und eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein unzuverlässiges Protokoll verwenden, gehen die Daten verloren. Wenn Sie ein zuverlässiges Protokoll verwenden, werden die überzähligen Daten vom Dienstanbieter aufbewahrt, und Sie können Sie abrufen, indem Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode mit einem ausreichend großen Puffer aufrufen.  
  
 Wenn keine Daten zum Lesen verfügbar sind, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode blockiert, bis die Daten verfügbar sind. Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode sofort beendet und eine <xref:System.Net.Sockets.SocketException>ausgelöst. Sie können die <xref:System.Net.Sockets.Socket.Available%2A>-Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> für verbindungslose Protokolle vorgesehen ist, können Sie auch ein Verbindungs orientiertes Protokoll verwenden. Wenn Sie sich dafür entscheiden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen oder eine eingehende Remote Host Verbindung akzeptieren, indem Sie die <xref:System.Net.Sockets.Socket.Accept%2A>-Methode aufrufen. Wenn Sie keine Verbindung einrichten oder akzeptieren, bevor Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode aufrufen, erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode aufrufen. In beiden Fällen ignoriert die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode den `remoteEP`-Parameter und empfängt nur Daten vom verbundenen oder standardmäßigen Remote Host.  
  
 Mit Verbindungs orientierten Sockets lesen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> so viele Daten wie verfügbar, die bis zu dem vom `size`-Parameter angegebenen Byte Umfang verfügbar sind. Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode sofort abgeschlossen und gibt NULL Bytes zurück.  
  
> [!NOTE]
>  Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>müssen Sie die <xref:System.Net.Sockets.Socket> mithilfe der <xref:System.Net.Sockets.Socket.Bind%2A>-Methode explizit an einen lokalen Endpunkt binden. Wenn dies nicht der Fall ist, wird <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> der in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> verwendeten <xref:System.Net.EndPoint> muss mit der <xref:System.Net.Sockets.AddressFamily> der in <xref:System.Net.EndPoint> verwendeten <xref:System.Net.Sockets.Socket.SendTo%2A>identisch sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remote Host empfangen. Der Offset, die Puffergröße und <xref:System.Net.Sockets.SocketFlags> werden an die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>-Methode übermittelt.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des offset-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder - 
Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem angegebenen Netzwerkgerät.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>-Methode wird hauptsächlich verwendet, um Daten auf einem Verbindungs losen Socket zu empfangen. Die lokale Adresse des Sockets muss bekannt sein.  
  
 Der Aufrufer muss die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>-Eigenschaft auf die <xref:System.Net.IPEndPoint> des Remote Hosts festlegen, von dem die Daten empfangen werden sollen.  
  
 Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>-Eigenschaft des `e`-Parameters stellt dem Window Sockets-Dienstanbieter zusätzliche Informationen über die Lese Anforderung bereit. Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Die folgenden Eigenschaften und Ereignisse für das <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>-Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, bevor die <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>-Methode aufgerufen wird, damit die Informationen in der Rückruf Methode abgerufen werden können. Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.  
  
 Bei Nachrichten orientierten Sockets wird eine eingehende Nachricht bis zur Gesamtgröße des Puffers in den Puffer eingefügt. Die Eigenschaften "<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>" und "<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>" bestimmen, wo die Daten im Puffer abgelegt werden, und die Datenmenge.  
  
 Bei Bytes im Bytestream werden eingehende Daten in den Puffer eingefügt, bis der Puffer gefüllt wird, die Verbindung geschlossen wird oder die intern gepufferten Daten aufgebraucht sind. Die Eigenschaften "<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>" und "<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>" bestimmen, wo die Daten im Puffer abgelegt werden, und die Datenmenge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht NULL sein.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Parameter angegebenen <paramref name="e" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="offset">Die Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden sollen.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <param name="ipPacketInformation">Ein <see cref="T:System.Net.Sockets.IPPacketInformation" />-Objekt, das Adress- und Schnittstelleninformationen enthält.</param>
        <summary>Empfängt die angegebene Anzahl von Datenbytes an der angegebenen Position im Datenpuffer, verwendet dabei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> und speichert die Endpunkt- und Paketinformationen.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>-Methode liest Daten in den `buffer`-Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes zurück und erfasst den Remote Host Endpunkt, von dem die Daten gesendet wurden, sowie Informationen über das empfangene Paket.  
  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>-Methode wird hauptsächlich verwendet, um Nachrichten Daten in einem Verbindungs losen Socket zu empfangen. Die lokale Adresse des Sockets muss bekannt sein. Diese Methode kann nur mit Datagramm-und RAW-Sockets verwendet werden. Der Socket muss initialisiert werden, wenn der socketyp auf <xref:System.Net.Sockets.SocketType.Dgram> oder <xref:System.Net.Sockets.SocketType.Raw> festgelegt ist, bevor diese Methode aufgerufen wird. Dies kann geschehen, wenn der Socket mithilfe <xref:System.Net.Sockets.Socket.%23ctor%2A>erstellt wird.  
  
 Bei Nachrichten orientierten Sockets wird eine eingehende Nachricht bis zur Gesamtgröße, die im `size`-Parameter angegeben ist, in den `buffer`-Parameter eingefügt. Der `offset`-Parameter bestimmt, an welcher Stelle im `buffer` die Daten abgelegt werden. Die tatsächliche Datenmenge, die in der `buffer` abgelegt wird, wird von der <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>-Methode zurückgegeben.  
  
 Bei der automatischen Methode <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode wird die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socket-Option auf `true` festgelegt, wenn Sie zum ersten Mal für eine bestimmte <xref:System.Net.Sockets.Socket>aufgerufen wird. Das zurückgegebene <xref:System.Net.Sockets.IPPacketInformation> Objekt ist jedoch nur für Pakete gültig, die auf dem lokalen Computer eintreffen, nachdem die Socketoption festgelegt wurde. Wenn ein Socket Pakete sendet, die zwischen dem Binden an einen lokalen Endpunkt (explizit durch die <xref:System.Net.Sockets.Socket.Bind%2A> Methode oder implizit durch eine der Methoden <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>oder <xref:System.Net.Sockets.Socket.SendToAsync%2A>) und des ersten Aufrufs der <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>-Methode gesendet werden, geben Aufrufe der <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode für diese Pakete ungültige <xref:System.Net.Sockets.IPPacketInformation> Objekte zurück.  
  
 Um sicherzustellen, dass alle <xref:System.Net.Sockets.IPPacketInformation>-Objekte gültig sind, sollte eine Anwendung die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socket-Option auf `true` festlegen, bevor Sie mithilfe der <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>-Methode an einen lokalen Endpunkt gebunden wird.  
  
 Eine Anwendung kann den `ipPacketInformation`-Parameter untersuchen, wenn er wissen muss, ob das Datagramm mithilfe einer Unicast-, Multicast-oder Broadcast Adresse gesendet wurde.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> der in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> verwendeten <xref:System.Net.EndPoint> muss mit der <xref:System.Net.Sockets.AddressFamily> der in <xref:System.Net.EndPoint> verwendeten <xref:System.Net.Sockets.Socket.SendTo%2A>identisch sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des offset-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder - 
Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
.NET Framework wird mit einem AMD 64 Bit-Prozessor ausgeführt.  
  
- oder - 
Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen aus dem Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt unter Verwendung der angegebenen <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> den asynchronen Empfang der angegebenen Anzahl von Datenbytes an der angegebenen Position im Datenpuffer und speichert die Endpunkt- und Paketinformationen.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>-Methode wird hauptsächlich verwendet, um Nachrichten Daten in einem Verbindungs losen Socket zu empfangen. Die lokale Adresse des Sockets muss bekannt sein. Diese Methode kann nur mit Datagramm-und RAW-Sockets verwendet werden. Der Socket muss initialisiert werden, wenn der socketyp auf <xref:System.Net.Sockets.SocketType.Dgram> oder <xref:System.Net.Sockets.SocketType.Raw> festgelegt ist, bevor diese Methode aufgerufen wird. Dies kann geschehen, wenn der Socket mithilfe <xref:System.Net.Sockets.Socket.%23ctor%2A>erstellt wird.  
  
 Der Aufrufer muss die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>-Eigenschaft auf die <xref:System.Net.IPEndPoint> des Remote Hosts festlegen, von dem die Daten empfangen werden sollen.  
  
 Die folgenden Eigenschaften und Ereignisse für das <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>-Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, bevor die <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>-Methode aufgerufen wird, damit die Informationen in der Rückruf Methode abgerufen werden können. Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.  
  
 Bei Nachrichten orientierten Sockets wird eine eingehende Nachricht bis zur Gesamtgröße des Puffers in den Puffer eingefügt. Die Eigenschaften "<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>" und "<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>" bestimmen, wo die Daten im Puffer abgelegt werden, und die Datenmenge.  
  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>-Methode legt die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socket-Option automatisch auf `true` fest, wenn Sie zum ersten Mal für eine bestimmte <xref:System.Net.Sockets.Socket>aufgerufen wird. Das <xref:System.Net.Sockets.IPPacketInformation>-Objekt ist jedoch nur für Pakete gültig, die auf dem lokalen Computer eintreffen, nachdem die Socketoption festgelegt wurde. Wenn ein Socket zwischen der Bindung des Sockets an einen lokalen Endpunkt (explizit durch die <xref:System.Net.Sockets.Socket.Bind%2A> Methode oder implizit durch eine der Methoden <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>oder <xref:System.Net.Sockets.Socket.SendToAsync%2A>) gesendet wird, und der erste Aufruf der <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>-Methode, führen Aufrufe der <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>-Methode zu ungültigen <xref:System.Net.Sockets.IPPacketInformation> Objekten für diese Pakete.  
  
 Um sicherzustellen, dass alle <xref:System.Net.Sockets.IPPacketInformation>-Objekte gültig sind, sollte eine Anwendung die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socket-Option auf`true` festlegen, bevor Sie mithilfe der <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>-Methode an einen lokalen Endpunkt gebunden wird.  
  
 Eine Anwendung kann die resultierenden <xref:System.Net.Sockets.IPPacketInformation> Objekte untersuchen, wenn Sie wissen muss, ob das Datagramm mithilfe einer Unicast-, Multicast-oder Broadcast Adresse gesendet wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht NULL sein.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zeitspanne bis zum Timeout eines synchronen <see cref="Overload:System.Net.Sockets.Socket.Receive" />-Aufrufs angibt, oder legt diesen fest.</summary>
        <value>Der Timeoutwert in Millisekunden. Der Standardwert ist 0 und gibt ein unendliches Timeoutintervall an. Durch die Angabe von -1 wird ebenfalls ein unendliches Timeoutintervall angegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Option gilt nur für synchrone <xref:System.Net.Sockets.Socket.Receive%2A> Aufrufe. Wenn der Timeout Zeitraum überschritten wird, löst die <xref:System.Net.Sockets.Socket.Receive%2A> Methode eine <xref:System.Net.Sockets.SocketException>aus.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen set-Vorgang angegebene Wert ist kleiner als -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Remoteendpunkt ab.</summary>
        <value>Der <see cref="T:System.Net.EndPoint" />, mit dem der <see cref="T:System.Net.Sockets.Socket" /> kommuniziert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, ruft die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>-Eigenschaft den <xref:System.Net.EndPoint> ab, der die Remote-IP-Adresse und die Portnummer enthält, mit der die <xref:System.Net.Sockets.Socket> verbunden ist. Wenn Sie ein verbindungsloses Protokoll verwenden, enthält <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> die Standard-Remote-IP-Adresse und die Portnummer, mit der die <xref:System.Net.Sockets.Socket> kommunizieren wird. Sie müssen diese <xref:System.Net.EndPoint> in eine <xref:System.Net.IPEndPoint> umwandeln, bevor Sie Informationen abrufen. Sie können dann die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>-Methode aufrufen, um den Remote <xref:System.Net.IPAddress>abzurufen, und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>-Methode, um die Remote Portnummer abzurufen.  
  
 Die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> wird nach einem <xref:System.Net.Sockets.Socket.Accept%2A>-oder <xref:System.Net.Sockets.Socket.Connect%2A>-Aufrufsatz festgelegt. Wenn Sie versuchen, zuvor auf diese Eigenschaft zuzugreifen, wird <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die lokalen und Remote Endpunkte abgerufen und angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Net.Sockets.SafeSocketHandle" /> ab, das den Sockethandle darstellt, der vom aktuellen <see cref="T:System.Net.Sockets.Socket" />-Objekt gekapselt wird.</summary>
        <value>Ein Sockethandle, das auf sichere Weise für den Socket verfügbar gemacht wird, der vom aktuellen <see cref="T:System.Net.Sockets.Socket" />-Objekt gekapselt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> Wenn Sie die <xref:System.Net.Sockets.SafeSocketHandle> verwenden, um den Socket direkt auszuführen, kann dies zu einem nicht dokumentierten Status führen. 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="checkRead">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, bei denen geprüft werden soll, ob sie gelesen werden können.</param>
        <param name="checkWrite">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, bei denen geprüft werden soll, ob in sie geschrieben werden kann.</param>
        <param name="checkError">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, die auf Fehler überprüft werden sollen.</param>
        <param name="microSeconds">Der Timeoutwert in Mikrosekunden. Ein Wert von -1 gibt ein unendliches Timeout an.</param>
        <summary>Bestimmt den Status von einem oder mehreren Sockets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> ist eine statische Methode, die den Status von mindestens einer <xref:System.Net.Sockets.Socket> Instanz bestimmt. Sie müssen eine oder mehrere Sockets in eine <xref:System.Collections.IList> platzieren, bevor Sie die <xref:System.Net.Sockets.Socket.Select%2A>-Methode verwenden können. Überprüfen Sie die Lesbarkeit, indem Sie <xref:System.Net.Sockets.Socket.Select%2A> mit dem <xref:System.Collections.IList> als `checkRead` Parameter aufrufen. Verwenden Sie den `checkWrite`-Parameter, um die Sockets auf die Schreib barkeit zu überprüfen. Verwenden Sie zum Erkennen von Fehlerbedingungen `checkError`. Nach dem Aufrufen von <xref:System.Net.Sockets.Socket.Select%2A>werden die <xref:System.Collections.IList> nur mit den Sockets aufgefüllt, die die Bedingungen erfüllen.  
  
 Wenn Sie sich in einem Empfangs Zustand befinden, bedeutet die Lesbarkeit, dass ein <xref:System.Net.Sockets.Socket.Accept%2A>-Aufrufe ohne Blockierung erfolgreich verlaufen wird. Wenn Sie die Verbindung bereits angenommen haben, bedeutet die Lesbarkeit, dass Daten zum Lesen verfügbar sind. In diesen Fällen werden alle Empfangs Vorgänge ohne Blockierung erfolgreich ausgeführt. Die Lesbarkeit kann auch angeben, ob die Remote <xref:System.Net.Sockets.Socket> die Verbindung heruntergefahren hat. in diesem Fall wird ein Aufruf<xref:System.Net.Sockets.Socket.Receive%2A> sofort zurückgegeben, wobei null Bytes zurückgegeben werden.  
  
 <xref:System.Net.Sockets.Socket.Select%2A> wird zurückgegeben, wenn mindestens eine der zu berücksichtigenden Sockets (die Sockets in der `checkRead`, `checkWrite`und `checkError` Listen) die angegebenen Kriterien erfüllt oder der `microSeconds` Parameter überschritten wird, je nachdem, welcher Wert zuerst eintritt. Wenn Sie `microSeconds` auf-1 festlegen, wird ein unendliches Timeout angegeben.  
  
 Wenn Sie einen nicht blockierenden Aufrufs<xref:System.Net.Sockets.Socket.Connect%2A>vornehmen, bedeutet Schreibbarkeit, dass Sie erfolgreich eine Verbindung hergestellt haben. Wenn Sie bereits eine Verbindung hergestellt haben, bedeutet die Schreib barkeit, dass alle Sende Vorgänge ohne Blockierung erfolgreich ausgeführt werden.  
  
 Wenn Sie einen nicht blockierenden <xref:System.Net.Sockets.Socket.Connect%2A>aufgerufen haben, identifiziert der `checkerror` Parameter Sockets, die nicht erfolgreich verbunden wurden.  
  
> [!NOTE]
>  Verwenden Sie die <xref:System.Net.Sockets.Socket.Poll%2A>-Methode, wenn Sie nur den Status eines einzelnen <xref:System.Net.Sockets.Socket>bestimmen möchten.  
  
> [!NOTE]
>  Diese Methode kann bestimmte Arten von Verbindungsproblemen, wie z. b. ein fehlerhaftes Netzwerkkabel, nicht erkennen, oder der Remote Host wurde nicht ordnungsgemäß heruntergefahren. Sie müssen versuchen, Daten zu senden oder zu empfangen, um diese Arten von Fehlern zu erkennen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.Socket.Select%2A> verwendet, um zu bestimmen, welche Abhör Sockets eine Verbindungsanforderung haben.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="checkRead" />-Parameter ist <see langword="null" /> oder leer.  
  
-und- 
Der <paramref name="checkWrite" />-Parameter ist <see langword="null" /> oder leer. 
-und- 
Der <paramref name="checkError" />-Parameter ist <see langword="null" /> oder leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet Daten an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <summary>Sendet Daten an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchron Daten an den Remote Host sendet, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode angegeben ist, und gibt die Anzahl der erfolgreich gesendeten Bytes zurück. <xref:System.Net.Sockets.Socket.Send%2A> können sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.  
  
 Diese Überladung erfordert einen Puffer, der die Daten enthält, die Sie senden möchten. Der <xref:System.Net.Sockets.SocketFlags> Wert ist standardmäßig 0, der Puffer Offset ist standardmäßig auf 0 und die Anzahl der zu sendenden Bytes standardmäßig auf die Größe des Puffers.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen, oder <xref:System.Net.Sockets.Socket.Send%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode verwenden. Wenn Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode nicht verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-aufrufbefehl <xref:System.Net.Sockets.Socket.Send%2A>abrufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch dann verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard-Remote Host auch vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Send%2A> ändern, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A>einen weiteren Aufruf ausführen.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Im nicht blockierenden Modus können <xref:System.Net.Sockets.Socket.Send%2A> erfolgreich abgeschlossen werden, auch wenn Sie weniger als die Anzahl der Bytes im Puffer sendet. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.Send%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Senden von Daten auf einem verbundenen <xref:System.Net.Sockets.Socket>veranschaulicht.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste von <see cref="T:System.ArraySegment`1" /> vom Typ <see cref="T:System.Byte" /> mit den zu sendenden Daten.</param>
        <summary>Sendet den Satz der Puffer in der Liste an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> können sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.  
  
 Diese Überladung erfordert mindestens einen Puffer, der die Daten enthält, die Sie senden möchten.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen, oder <xref:System.Net.Sockets.Socket.Send%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode verwenden. Wenn Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode nicht verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-aufrufbefehl <xref:System.Net.Sockets.Socket.Send%2A>abrufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch dann verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard-Remote Host auch vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Send%2A> ändern, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A>einen weiteren Aufruf ausführen.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Im nicht blockierenden Modus können <xref:System.Net.Sockets.Socket.Send%2A> erfolgreich abgeschlossen werden, auch wenn Sie weniger als die Anzahl der Bytes im Puffer sendet. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.Send%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Eins Spanne von Bytes, die die zu sendenden Daten enthält.</param>
        <summary>Sendet Daten an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> synchron Daten an den Remote Host sendet, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode angegeben ist, und gibt die Anzahl der erfolgreich gesendeten Bytes zurück. <xref:System.Net.Sockets.Socket.Send%2A> können sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.

Diese Überladung erfordert einen Puffer, der die Daten enthält, die Sie senden möchten. Der <xref:System.Net.Sockets.SocketFlags> Wert ist standardmäßig 0, der Puffer Offset ist standardmäßig auf 0 und die Anzahl der zu sendenden Bytes standardmäßig auf die Größe des Puffers.

Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen, oder <xref:System.Net.Sockets.Socket.Send%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.

Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode verwenden. Wenn Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode nicht verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-aufrufbefehl <xref:System.Net.Sockets.Socket.Send%2A>abrufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch dann verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard-Remote Host auch ändern, bevor Sie <xref:System.Net.Sockets.Socket.Send%2A> aufrufen, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A>einen weiteren Aufruf ausführen.

Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Im nicht blockierenden Modus können <xref:System.Net.Sockets.Socket.Send%2A> erfolgreich abgeschlossen werden, auch wenn Sie weniger als die Anzahl der Bytes im Puffer sendet. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.Send%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.

> [!NOTE]
>Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.

Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).

> [!IMPORTANT]
>Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet Daten mithilfe der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchron Daten an den Remote Host sendet, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde, und gibt die Anzahl der erfolgreich gesendeten Bytes zurück. Die <xref:System.Net.Sockets.Socket.Send%2A>-Methode kann sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.  
  
 Diese Überladung erfordert einen Puffer, der die Daten enthält, die Sie senden möchten, und eine bitweise Kombination aus <xref:System.Net.Sockets.SocketFlags>. Der Puffer Offset ist standardmäßig auf 0 und die Anzahl der zu sendenden Bytes standardmäßig auf die Größe des Puffers eingestellt. Wenn Sie das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags` Parameterwert angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen, oder <xref:System.Net.Sockets.Socket.Send%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode verwenden. Wenn Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode nicht verwenden, müssen Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode vor jedem-Befehl <xref:System.Net.Sockets.Socket.Send%2A>abrufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch dann verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard-Remote Host auch vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Send%2A> ändern, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A>einen weiteren Aufruf ausführen.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Im nicht blockierenden Modus können <xref:System.Net.Sockets.Socket.Send%2A> erfolgreich abgeschlossen werden, auch wenn Sie weniger als die Anzahl der Bytes im Puffer sendet. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.Send%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Sie müssen sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Senden von Daten auf einem verbundenen <xref:System.Net.Sockets.Socket>veranschaulicht.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste von <see cref="T:System.ArraySegment`1" /> vom Typ <see cref="T:System.Byte" /> mit den zu sendenden Daten.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet den Satz von Puffern in der Liste unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung erfordert mindestens einen Puffer, der die Daten enthält, die Sie senden möchten. Der <xref:System.Net.Sockets.SocketFlags> Wert ist standardmäßig 0. Wenn Sie das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketFlags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen, oder <xref:System.Net.Sockets.Socket.Send%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode verwenden. Wenn Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode nicht verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-aufrufbefehl <xref:System.Net.Sockets.Socket.Send%2A>abrufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch dann verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard-Remote Host auch vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Send%2A> ändern, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A>einen weiteren Aufruf ausführen.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Im nicht blockierenden Modus wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er weniger als die Anzahl der Bytes im Puffer sendet. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.Send%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Eins Spanne von Bytes, die die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der Enumerationswerte, die das Sende- und Empfangsverhalten angeben.</param>
        <summary>Sendet Daten mithilfe der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  

  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="size">Die Anzahl der zu sendenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> synchron Daten an den Remote Host sendet, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode eingerichtet wurde, und gibt die Anzahl der erfolgreich gesendeten Bytes zurück. <xref:System.Net.Sockets.Socket.Send%2A> können sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.

Diese Überladung erfordert einen Puffer, der die Daten enthält, die Sie senden möchten, die Anzahl der zu sendenden Bytes und eine bitweise Kombination aus beliebigen <xref:System.Net.Sockets.SocketFlags>. Wenn Sie das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.

Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen, oder <xref:System.Net.Sockets.Socket.Send%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.

Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode verwenden. Wenn Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode nicht mehr benötigen, müssen Sie vor jedem Aufrufen der <xref:System.Net.Sockets.Socket.Send%2A>-Methode die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch dann verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard-Remote Host auch ändern, bevor Sie <xref:System.Net.Sockets.Socket.Send%2A> aufrufen, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A>einen weiteren Aufruf ausführen.

Bei einem Verbindungs orientierten Protokoll wird <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis die angeforderte Anzahl von Bytes gesendet wird, es sei denn, ein Timeout wurde mit <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Im nicht blockierenden Modus können <xref:System.Net.Sockets.Socket.Send%2A> erfolgreich abgeschlossen werden, auch wenn Sie weniger als die Anzahl der von Ihnen angeforderten Bytes sendet. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.Send%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.

> [!NOTE]
> Sie müssen sicherstellen, dass die Größe die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.

Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).

> [!IMPORTANT]
>Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.

## Examples

Im folgenden Codebeispiel werden die in buffer gefundenen Daten gesendet und <xref:System.Net.Sockets.SocketFlags.None> für <xref:System.Net.Sockets.SocketFlags>angegeben.

[!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
[!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
[!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> ist größer als 0 oder übersteigt die Puffergröße.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder - 
Beim Zugriff auf den Socket ist ein Fehler auf Betriebssystemebene aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste von <see cref="T:System.ArraySegment`1" /> vom Typ <see cref="T:System.Byte" /> mit den zu sendenden Daten.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Sendet den Satz von Puffern in der Liste unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung erfordert mindestens einen Puffer, der die Daten enthält, die Sie senden möchten. Der <xref:System.Net.Sockets.SocketFlags> Wert ist standardmäßig 0. Wenn Sie das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketFlags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen, oder <xref:System.Net.Sockets.Socket.Send%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode verwenden. Wenn Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode nicht verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-aufrufbefehl <xref:System.Net.Sockets.Socket.Send%2A>abrufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch dann verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard-Remote Host auch vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Send%2A> ändern, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A>einen weiteren Aufruf ausführen.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Im nicht blockierenden Modus wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er weniger als die Anzahl der Bytes im Puffer sendet. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.Send%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Eins Spanne von Bytes, die die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der Enumerationswerte, die das Sende- und Empfangsverhalten angeben.</param>
        <param name="errorCode">Diese Methode gibt einen der Enumerationswerte zurück, der Fehlercodes für den Socket definiert.</param>
        <summary>Sendet Daten mithilfe der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> synchron Daten an den Remote Host sendet, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode angegeben ist, und gibt die Anzahl der erfolgreich gesendeten Bytes zurück. <xref:System.Net.Sockets.Socket.Send%2A> können sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.

Diese Überladung erfordert einen Puffer, der die Daten enthält, die Sie senden möchten. Der <xref:System.Net.Sockets.SocketFlags> Wert ist standardmäßig 0, der Puffer Offset ist standardmäßig auf 0 und die Anzahl der zu sendenden Bytes standardmäßig auf die Größe des Puffers.

Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen, oder <xref:System.Net.Sockets.Socket.Send%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.

Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode verwenden. Wenn Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode nicht verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-aufrufbefehl <xref:System.Net.Sockets.Socket.Send%2A>abrufen. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch dann verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard-Remote Host auch ändern, bevor Sie <xref:System.Net.Sockets.Socket.Send%2A> aufrufen, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A>einen weiteren Aufruf ausführen.

Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Im nicht blockierenden Modus können <xref:System.Net.Sockets.Socket.Send%2A> erfolgreich abgeschlossen werden, auch wenn Sie weniger als die Anzahl der Bytes im Puffer sendet. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.Send%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.

> [!NOTE]
>Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation für Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.

Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).

> [!IMPORTANT]
>Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl der zu sendenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />, beginnend bei einem angegebenen Offset und unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchron Daten an den Remote Host sendet, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode angegeben ist, und gibt die Anzahl der erfolgreich gesendeten Bytes zurück. <xref:System.Net.Sockets.Socket.Send%2A> können sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.  
  
 Wenn Sie in dieser Überladung das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen, oder <xref:System.Net.Sockets.Socket.Send%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie <xref:System.Net.Sockets.Socket.SendTo%2A>verwenden. Wenn Sie <xref:System.Net.Sockets.Socket.SendTo%2A>nicht verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-aufrufbefehl <xref:System.Net.Sockets.Socket.Send%2A>abrufen. Es ist in Ordnung, <xref:System.Net.Sockets.Socket.SendTo%2A> auch dann zu verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard-Remote Host auch vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Send%2A> ändern, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A>einen weiteren Aufruf ausführen.  
  
 Außerdem müssen Sie sicherstellen, dass die Größe die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis die angeforderte Anzahl von Bytes gesendet wird, es sei denn, ein Timeout wurde mit <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Im nicht blockierenden Modus können <xref:System.Net.Sockets.Socket.Send%2A> erfolgreich abgeschlossen werden, auch wenn Sie weniger als die Anzahl der von Ihnen angeforderten Bytes sendet. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.Send%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden der Datenpuffer, ein Offset, eine Größe und <xref:System.Net.Sockets.SocketFlags> für das Senden von Daten an eine verbundene <xref:System.Net.Sockets.Socket>angegeben.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder - 
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl der zu sendenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Sendet unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.Socket" /> die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />, beginnend beim angegebenen Offset.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchron Daten an den Remote Host sendet, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode angegeben ist, und gibt die Anzahl der erfolgreich gesendeten Bytes zurück. <xref:System.Net.Sockets.Socket.Send%2A> können sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.  
  
 Wenn Sie in dieser Überladung das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen, oder <xref:System.Net.Sockets.Socket.Send%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie <xref:System.Net.Sockets.Socket.SendTo%2A>verwenden. Wenn Sie <xref:System.Net.Sockets.Socket.SendTo%2A>nicht verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-aufrufbefehl <xref:System.Net.Sockets.Socket.Send%2A>abrufen. Es ist in Ordnung, <xref:System.Net.Sockets.Socket.SendTo%2A> auch dann zu verwenden, wenn Sie einen Standard-Remote Host mit <xref:System.Net.Sockets.Socket.Connect%2A>eingerichtet haben. Sie können den Standard-Remote Host auch vor dem Aufrufen von <xref:System.Net.Sockets.Socket.Send%2A> ändern, indem Sie <xref:System.Net.Sockets.Socket.Connect%2A>einen weiteren Aufruf ausführen.  
  
 Außerdem müssen Sie sicherstellen, dass die Größe die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis die angeforderte Anzahl von Bytes gesendet wird, es sei denn, ein Timeout wurde mit <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>festgelegt. Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf eine <xref:System.Net.Sockets.SocketException>aus. Im nicht blockierenden Modus können <xref:System.Net.Sockets.Socket.Send%2A> erfolgreich abgeschlossen werden, auch wenn Sie weniger als die Anzahl der von Ihnen angeforderten Bytes sendet. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.Send%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden. Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden der Datenpuffer, ein Offset, eine Größe und <xref:System.Net.Sockets.SocketFlags> für das Senden von Daten an eine verbundene <xref:System.Net.Sockets.Socket>angegeben.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder - 
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Sendet Daten asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SendAsync%2A>-Methode wird verwendet, um ausgehende Daten von einem oder mehreren Puffern in einem Verbindungs orientierten Socket zu schreiben. Diese Methode kann jedoch auch für verbindungslose Sockets verwendet werden, die einen Remote Host für einen Verbindungsvorgang angegeben haben.  
  
 Die <xref:System.Net.Sockets.Socket.SendAsync%2A>-Methode startet einen asynchronen Sendevorgang an den Remote Host, der in der <xref:System.Net.Sockets.Socket.Accept%2A>-, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>-, <xref:System.Net.Sockets.Socket.BeginAccept%2A>-, <xref:System.Net.Sockets.Socket.BeginConnect%2A>-, <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode eingerichtet wurde.  
  
 Die folgenden Eigenschaften und Ereignisse für das <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> oder <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>-Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, bevor die <xref:System.Net.Sockets.Socket.SendAsync%2A>-Methode aufgerufen wird, damit die Informationen in der Rückruf Methode abgerufen werden können. Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.  
  
 Die <xref:System.Net.Sockets.Socket.SendAsync%2A>-Methode löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A>aufzurufen.  
  
 Wenn Sie die <xref:System.Net.Sockets.Socket.SendAsync%2A>-Methode aufrufen, haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.  
  
 Überschreiten Sie für Nachrichten orientierte Sockets nicht die maximale Nachrichtengröße des zugrunde liegenden Windows Sockets-Dienstanbieters. Wenn die Daten zu lang sind, um atomisch über den zugrunde liegenden Dienstanbieter zu übergeben, werden keine Daten übertragen, und die <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode löst eine <xref:System.Net.Sockets.SocketException> mit dem <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> auf den nativen Winsock-wsaemsgsize-Fehlercode (10040) aus.  
  
 Beachten Sie, dass der erfolgreiche Abschluss der <xref:System.Net.Sockets.Socket.SendAsync%2A>-Methode nicht anzeigt, dass die Daten erfolgreich übermittelt wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft oder <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft des <paramref name="e" />-Parameters muss auf gültige Puffer verweisen. Eine dieser Eigenschaften kann festgelegt werden, nicht jedoch beide gleichzeitig.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Parameter angegebenen <paramref name="e" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Der <see cref="T:System.Net.Sockets.Socket" /> ist noch nicht verbunden oder wurde nicht über eine <see cref="M:System.Net.Sockets.Socket.Accept" />-<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />- oder <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />-Methode abgerufen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Größe des Sendepuffers für den <see cref="T:System.Net.Sockets.Socket" /> angibt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, das die Größe des Sendepuffer in Bytes enthält. Der Standard ist 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine größere Puffergröße kann das Erkennen von Verbindungsproblemen verzögern. Erhöhen Sie ggf. die Puffergröße, wenn Sie große Dateien übertragen, oder Sie verwenden eine Verbindung mit hoher Bandbreite und hoher Latenz (z. b. einem Satelliten-Breitbandanbieter).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.SendBufferSize%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen set-Vorgang angegebene Wert ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet eine Datei und optionale Daten synchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Ein <see cref="T:System.String" />, der den Pfad und Namen der Datei enthält, die gesendet werden soll. Dieser Parameter kann <see langword="null" /> sein.</param>
        <summary>Sendet die Datei <paramref name="fileName" /> mit dem <see cref="T:System.Net.Sockets.Socket" />-Übertragungsflag an ein verbundenes <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung sendet die Datei `fileName` an den verbundenen Socket. Der `flags`-Parameter ist standardmäßig <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), und die Parameter `preBuffer` und `postBuffer` werden standardmäßig auf `null`. Wenn sich `fileName` im lokalen Verzeichnis befindet, wird es möglicherweise nur mit dem Namen der Datei identifiziert. Andernfalls müssen der vollständige Pfad und der Name der Datei angegeben werden. Platzhalter ("..\\\MyFile.txt ") und UNC-Freigabe Namen ("\\\\\\\Shared Directory\\\MyFile.txt ") werden unterstützt. Wenn die Datei nicht gefunden wird, wird die Ausnahme <xref:System.IO.FileNotFoundException> ausgelöst.  
  
 Diese Methode verwendet die `TransmitFile`-Funktion, die in der Windows Sockets 2-API enthalten ist. Weitere Informationen zur `TransmitFile` Funktion und ihren Flags finden Sie in der Dokumentation zu [Windows Sockets](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> synchron eine Datei an den Remote Host sendet, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode angegeben ist. <xref:System.Net.Sockets.Socket.SendFile%2A> können sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen; andernfalls löst <xref:System.Net.Sockets.Socket.SendFile%2A> eine <xref:System.Net.Sockets.SocketException> Ausnahme aus. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.SendFile%2A> blockiert, bis die Datei gesendet wird. Im nicht blockierenden Modus können <xref:System.Net.Sockets.Socket.SendFile%2A> erfolgreich abgeschlossen werden, bevor die gesamte Datei gesendet wurde. Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.SendFile%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket erstellt und verbunden, und anschließend wird eine Datei an den Remote Host gesendet. Die Datei "Test. txt" befindet sich im Stammverzeichnis des lokalen Computers.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt ist nicht im Blockierungsmodus und kann diesen synchronen Aufruf nicht annehmen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Ein <see cref="T:System.String" />, der den Pfad und Namen der Datei enthält, die gesendet werden soll. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="preBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, bevor die Datei gesendet wird. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="postBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, nachdem die Datei gesendet wurde. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="flags">Mindestens ein <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Wert.</param>
        <summary>Sendet die Datei <paramref name="fileName" /> und puffert Daten mit dem angegebenen <see cref="T:System.Net.Sockets.Socket" />-Wert in einem verbundenen <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung erfordert den Namen der Datei, die Sie senden möchten, und eine bitweise Kombination von <xref:System.Net.Sockets.TransmitFileOptions>-Werten. Der `preBuffer`-Parameter enthält alle Daten, die Sie der Datei vorausgehen möchten. `postBuffer` enthält Daten, die Sie der Datei folgen möchten. Wenn sich `fileName` im aktuellen Arbeitsverzeichnis befindet, wird es möglicherweise nur mit dem Namen der Datei identifiziert. Andernfalls müssen der vollständige Pfad und der Name der Datei angegeben werden. Platzhalter ("..\\\MyFile.txt ") und UNC-Freigabe Namen ("\\\\\\\Shared Directory\\\MyFile.txt ") werden unterstützt.  
  
 Der `flags`-Parameter stellt dem Window Sockets-Dienstanbieter zusätzliche Informationen über die Dateiübertragung zur Verfügung. Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Diese Methode verwendet die `TransmitFile`-Funktion, die in der Windows Sockets 2-API enthalten ist. Weitere Informationen zur `TransmitFile` Funktion und ihren Flags finden Sie in der Dokumentation zu [Windows Sockets](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> synchron eine Datei an den Remote Host sendet, der in der <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.Accept%2A>-Methode angegeben ist. <xref:System.Net.Sockets.Socket.SendFile%2A> können sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor Sie diese Methode aufrufen. Andernfalls wird <xref:System.Net.Sockets.Socket.SendFile%2A> eine <xref:System.Net.Sockets.SocketException>auslöst. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder <xref:System.Net.Sockets.Socket.Connect%2A> verwenden, um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> verwenden, um eine eingehende Verbindung zu akzeptieren.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.SendFile%2A> blockiert, bis die gesamte Datei gesendet wird. Im nicht blockierenden Modus können <xref:System.Net.Sockets.Socket.SendFile%2A> erfolgreich abgeschlossen werden, bevor die gesamte Datei gesendet wurde. Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.SendFile%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket erstellt und verbunden. Die Datei "Test. txt" befindet sich im Stammverzeichnis des lokalen Computers. In diesem Beispiel erstellen wir einen vorab Puffer und einen postBuffer von Daten und senden diese mit der Datei an den Remote Host. Die Standard <xref:System.Net.Sockets.TransmitFileOptions> werden verwendet.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist nicht Windows NT oder höher.  
  
- oder -
  
 Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt ist nicht im Blockierungsmodus und kann diesen synchronen Aufruf nicht annehmen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Sendet eine Auflistung von Dateien oder Datenpuffern im Speicher asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>-Methode wird verwendet, um eine Auflistung von Dateien oder in Arbeitsspeicher-Daten Puffern an den Remote Host zu senden. Der <xref:System.Net.Sockets.Socket> muss bereits mit dem Remote Host verbunden sein.  
  
 Wenn eine <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> auf eine Datei im Arbeitsverzeichnis verweist, kann Sie nur mit dem Namen der Datei identifiziert werden. Andernfalls müssen der vollständige Pfad und der Name der Datei angegeben werden. Platzhalter und UNC-Freigabe Namen werden unterstützt. Wenn die Datei nicht gefunden wird, wird <xref:System.IO.FileNotFoundException> ausgelöst.  
  
 Wenn Sie über den Abschluss benachrichtigt werden möchten, müssen Sie eine Rückruf Methode erstellen, die den EventHandler-\<SocketAsyncEventArgs-> Delegaten implementiert und den Rückruf an das <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis anfügt.  
  
 Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>-Eigenschaft des `e`-Parameters stellt dem Window Sockets-Dienstanbieter zusätzliche Informationen über die Dateiübertragung zur Verfügung. Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Die folgenden Eigenschaften und Ereignisse für das <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>-Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, bevor die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>-Methode aufgerufen wird, damit die Informationen in der Rückruf Methode abgerufen werden können. Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.  
  
 Diese Methode verwendet die transmitpaketen-Funktion, die in der Windows Sockets 2-API enthalten ist. Weitere Informationen zur transmitpaketen-Funktion und ihren Flags finden Sie in der [Windows Sockets](/windows/desktop/WinSock/) -Dokumentation.  
  
 Obwohl die-Methode für Verbindungs orientierte Protokolle vorgesehen ist, kann die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>-Methode auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die Methode <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> zum Einrichten eines Standard Remote Hosts aufruft. Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe der Datei nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> löst eine <xref:System.Net.Sockets.SocketException> Ausnahme aus.  
  
 Die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>-Methode wird entsprechend dem Betriebssystem optimiert, in dem Sie verwendet wird. Bei Windows Server-Editionen ist die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>-Methode für eine hohe Leistung optimiert.  
  
 In den Windows-Client Editionen ist die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>-Methode für die minimale Arbeitsspeicher-und Ressourcenauslastung optimiert.  
  
 Die Verwendung des <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType>-Flags in der <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>-Eigenschaft des `e`-Parameters kann zu erheblichen Leistungsvorteilen führen. Wenn der Thread, der den <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methoden aufzurufen initiiert, für hohe Berechnungen verwendet wird, ist es möglich, dass die APCs nicht gestartet werden können, obwohl dies unwahrscheinlich ist. Beachten Sie, dass es einen Unterschied zwischen Kernel-und benutzermodusapcs gibt. Kernel-APCs werden gestartet, wenn sich ein Thread in einem Wartezustand befindet. Benutzermodusapcs wird gestartet, wenn sich ein Thread in einem wartewarnbaren Wartestatus befindet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Die in der <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" />-Eigenschaft angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Parameter angegebenen <paramref name="e" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich. Diese Ausnahme tritt auch auf, wenn <see cref="T:System.Net.Sockets.Socket" /> nicht mit einem Remotehost verbunden ist.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ein verbindungsloser <see cref="T:System.Net.Sockets.Socket" /> wird verwendet, und die verwendete Datei überschreitet die maximale Paketgröße des zugrunde liegenden Transports.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zeitspanne bis zum Timeout eines synchronen <see cref="Overload:System.Net.Sockets.Socket.Send" />-Aufrufs angibt, oder legt diesen fest.</summary>
        <value>Der Timeoutwert in Millisekunden. Wenn Sie die Eigenschaft auf einen Wert zwischen 1 und 499 festlegen, wird der Wert in 500 geändert. Der Standardwert ist 0 und gibt ein unendliches Timeoutintervall an. Durch die Angabe von -1 wird ebenfalls ein unendliches Timeoutintervall angegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Option gilt nur für synchrone <xref:System.Net.Sockets.Socket.Send%2A> Aufrufe. Wenn der Timeout Zeitraum überschritten wird, löst die <xref:System.Net.Sockets.Socket.Send%2A> Methode eine <xref:System.Net.Sockets.SocketException>aus.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.SendTimeout%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen set-Vorgang angegebene Wert ist kleiner als -1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet Daten an einen bestimmten Endpunkt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="remoteEP">Der <see cref="T:System.Net.EndPoint" />, der das Ziel der Daten darstellt.</param>
        <summary>Sendet Daten an den angegebenen Endpunkt.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Überladung ist der Puffer Offset standardmäßig auf 0, die Anzahl der zu sendenden Bytes standardmäßig auf die Größe des `buffer`-Parameters und der <xref:System.Net.Sockets.SocketFlags> Wert standardmäßig auf 0 (null) eingestellt.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie vor dem Aufrufen von <xref:System.Net.Sockets.Socket.SendTo%2A>keinen Standard-Remote Host mit der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode erstellen. Dies ist nur erforderlich, wenn Sie beabsichtigen, die <xref:System.Net.Sockets.Socket.Send%2A>-Methode aufzurufen. Wenn Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen, bevor Sie <xref:System.Net.Sockets.Socket.SendTo%2A>aufrufen, überschreibt der `remoteEP`-Parameter den angegebenen Standard Remote Host nur für diesen Sendevorgang. Außerdem ist es nicht erforderlich, die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode aufzurufen, da der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zuweist. Wenn Sie die Adresse und die Portnummer des zugewiesenen lokalen Netzwerks identifizieren müssen, können Sie die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>-Eigenschaft verwenden, nachdem die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode erfolgreich abgeschlossen wurde.  
  
 Obwohl <xref:System.Net.Sockets.Socket.SendTo%2A> für verbindungslose Protokolle vorgesehen ist, funktioniert auch mit Verbindungs orientierten Protokollen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen oder eine eingehende Verbindungsanforderung mit der <xref:System.Net.Sockets.Socket.Accept%2A>-Methode akzeptieren. Wenn Sie keine Remote Host Verbindung einrichten oder akzeptieren, wird <xref:System.Net.Sockets.Socket.SendTo%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode aufrufen. In beiden Fällen ignoriert <xref:System.Net.Sockets.Socket.SendTo%2A> den `remoteEP`-Parameter und sendet nur Daten an den verbundenen oder standardmäßigen Remote Host.  
  
 Blockierende Sockets werden blockiert, bis alle Bytes im Puffer gesendet werden. Da eine nicht blockierende <xref:System.Net.Sockets.Socket> sofort abgeschlossen wird, sendet Sie möglicherweise nicht alle Bytes in der `buffer`. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung alle Bytes im `buffer`sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
 Wenn Sie ein verbindungsloses Protokoll im Blockierungs Modus verwenden, wird <xref:System.Net.Sockets.Socket.SendTo%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode aufzurufen und die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>festlegen. Außerdem müssen Sie sicherstellen, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm an den angegebenen Remote Host gesendet.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Der <see cref="T:System.Net.EndPoint" />, der den Zielort der Daten darstellt.</param>
        <summary>Sendet Daten an einen bestimmten Endpunkt unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Überladung wird der Puffer Offset standardmäßig auf 0 und die Anzahl der zu sendenden Bytes standardmäßig auf die Größe der `buffer`. Wenn Sie das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie vor dem Aufrufen von <xref:System.Net.Sockets.Socket.SendTo%2A>keinen Standard-Remote Host mit der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode erstellen. Dies ist nur erforderlich, wenn Sie beabsichtigen, die <xref:System.Net.Sockets.Socket.Send%2A>-Methode aufzurufen. Wenn Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen, bevor Sie <xref:System.Net.Sockets.Socket.SendTo%2A>aufrufen, überschreibt der `remoteEP`-Parameter den angegebenen Standard Remote Host nur für diesen Sendevorgang. Außerdem ist es nicht erforderlich, die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode aufzurufen, da der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zuweist. Wenn Sie die Adresse und die Portnummer des zugewiesenen lokalen Netzwerks identifizieren müssen, können Sie die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>-Eigenschaft verwenden, nachdem die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode erfolgreich abgeschlossen wurde.  
  
 Obwohl <xref:System.Net.Sockets.Socket.SendTo%2A> für verbindungslose Protokolle vorgesehen ist, funktioniert auch mit Verbindungs orientierten Protokollen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen oder eine eingehende Verbindungsanforderung mit der <xref:System.Net.Sockets.Socket.Accept%2A>-Methode akzeptieren. Wenn Sie keine Remote Host Verbindung einrichten oder akzeptieren, wird <xref:System.Net.Sockets.Socket.SendTo%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode aufrufen. In beiden Fällen ignoriert <xref:System.Net.Sockets.Socket.SendTo%2A> den `remoteEP`-Parameter und sendet nur Daten an den verbundenen oder standardmäßigen Remote Host.  
  
 Blockierende Sockets werden blockiert, bis die angeforderten gesamten Bytes im `buffer` gesendet werden. Da eine nicht blockierende <xref:System.Net.Sockets.Socket> sofort abgeschlossen wird, sendet Sie möglicherweise nicht alle Bytes in der `buffer`. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung alle Bytes im `buffer`sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
 Wenn Sie ein verbindungsloses Protokoll im Blockierungs Modus verwenden, wird <xref:System.Net.Sockets.Socket.SendTo%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode aufzurufen und die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>festlegen. Außerdem müssen Sie sicherstellen, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm an den angegebenen Remote Host gesendet. <xref:System.Net.Sockets.SocketFlags> werden an die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode übermittelt.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="size">Die Anzahl der zu sendenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Der <see cref="T:System.Net.EndPoint" />, der den Zielort der Daten darstellt.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an den angegebenen Endpunkt, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Überladung wird der Puffer Offset standardmäßig auf 0 eingestellt. Wenn Sie das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie vor dem Aufrufen von <xref:System.Net.Sockets.Socket.SendTo%2A>keinen Standard-Remote Host mit der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode erstellen. Dies ist nur erforderlich, wenn Sie beabsichtigen, die <xref:System.Net.Sockets.Socket.Send%2A>-Methode aufzurufen. Wenn Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen, bevor Sie <xref:System.Net.Sockets.Socket.SendTo%2A>aufrufen, überschreibt der `remoteEP`-Parameter den angegebenen Standard Remote Host nur für diesen Sendevorgang. Außerdem ist es nicht erforderlich, die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode aufzurufen, da der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zuweist. Wenn Sie die Adresse und die Portnummer des zugewiesenen lokalen Netzwerks identifizieren müssen, können Sie die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>-Eigenschaft verwenden, nachdem die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode erfolgreich abgeschlossen wurde.  
  
 Obwohl <xref:System.Net.Sockets.Socket.SendTo%2A> für verbindungslose Protokolle vorgesehen ist, funktioniert auch mit Verbindungs orientierten Protokollen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen oder eine eingehende Verbindungsanforderung mit der <xref:System.Net.Sockets.Socket.Accept%2A>-Methode akzeptieren. Wenn Sie keine Remote Host Verbindung einrichten oder akzeptieren, wird <xref:System.Net.Sockets.Socket.SendTo%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode aufrufen. In beiden Fällen ignoriert <xref:System.Net.Sockets.Socket.SendTo%2A> den `remoteEP`-Parameter und sendet nur Daten an den verbundenen oder standardmäßigen Remote Host.  
  
 Blockierende Sockets werden blockiert, bis die angeforderte Anzahl von Bytes gesendet wird. Da eine nicht blockierende <xref:System.Net.Sockets.Socket> sofort abgeschlossen wird, werden möglicherweise nicht alle in einem einzelnen Vorgang angeforderten Bytes gesendet. Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
 Wenn Sie ein verbindungsloses Protokoll im Blockierungs Modus verwenden, wird <xref:System.Net.Sockets.Socket.SendTo%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode aufzurufen und die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>festlegen. Außerdem müssen Sie sicherstellen, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm an den angegebenen Remote Host gesendet. Die Größe und <xref:System.Net.Sockets.SocketFlags> werden an die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode übermittelt.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die angegebene <paramref name="size" /> ist größer als <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl der zu sendenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Der <see cref="T:System.Net.EndPoint" />, der den Zielort der Daten darstellt.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an den angegebenen Endpunkt und beginnt dabei an der angegebenen Position im Puffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie in dieser Überladung das <xref:System.Net.Sockets.SocketFlags.DontRoute>-Flag als `socketflags`-Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie vor dem Aufrufen von <xref:System.Net.Sockets.Socket.SendTo%2A>keinen Standard-Remote Host mit der <xref:System.Net.Sockets.Socket.Connect%2A>-Methode erstellen. Dies ist nur erforderlich, wenn Sie beabsichtigen, die <xref:System.Net.Sockets.Socket.Send%2A>-Methode aufzurufen. Wenn Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen, bevor Sie <xref:System.Net.Sockets.Socket.SendTo%2A>aufrufen, überschreibt der `remoteEP`-Parameter den angegebenen Standard Remote Host nur für diesen Sendevorgang. Außerdem ist es nicht erforderlich, die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode aufzurufen, da der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zuweist. Wenn Sie die Adresse und die Portnummer des zugewiesenen lokalen Netzwerks identifizieren müssen, können Sie die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>-Eigenschaft verwenden, nachdem die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode erfolgreich abgeschlossen wurde.  
  
 Obwohl <xref:System.Net.Sockets.Socket.SendTo%2A> für verbindungslose Protokolle vorgesehen ist, funktioniert auch mit Verbindungs orientierten Protokollen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufrufen oder eine eingehende Verbindungsanforderung mit der <xref:System.Net.Sockets.Socket.Accept%2A>-Methode akzeptieren. Wenn Sie keine Remote Host Verbindung einrichten oder akzeptieren, wird <xref:System.Net.Sockets.Socket.SendTo%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode aufrufen. In beiden Fällen ignoriert <xref:System.Net.Sockets.Socket.SendTo%2A> den `remoteEP`-Parameter und sendet nur Daten an den verbundenen oder standardmäßigen Remote Host.  
  
 Blockierende Sockets werden blockiert, bis die angeforderte Anzahl von Bytes gesendet wird. Da eine nicht blockierende <xref:System.Net.Sockets.Socket> sofort abgeschlossen wird, werden möglicherweise nicht alle in einem einzelnen Vorgang angeforderten Bytes gesendet. Ihre Anwendungen sind dafür verantwortlich, die Anzahl der gesendeten Bytes zu verfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird. Ein erfolgreicher Abschluss der <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.  
  
 Wenn Sie ein verbindungsloses Protokoll im Blockierungs Modus verwenden, wird <xref:System.Net.Sockets.Socket.SendTo%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode aufzurufen und die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>festlegen. Außerdem müssen Sie sicherstellen, dass die Größe die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm an den angegebenen Remote Host gesendet. Offset, Größe und <xref:System.Net.Sockets.SocketFlags> werden an die <xref:System.Net.Sockets.Socket.SendTo%2A>-Methode übermittelt.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 <paramref name="size" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder - 
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Sendet asynchron Daten an einen angegebenen Remotehost.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SendToAsync%2A>-Methode startet einen asynchronen Sendevorgang an den Remote Host, der in der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>-Eigenschaft des `e`-Parameters angegeben ist. Wenn Sie die <xref:System.Net.Sockets.Socket.SendToAsync%2A>-Methode aufrufen, haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden. Obwohl diese Methode für verbindungslose Protokolle vorgesehen ist, <xref:System.Net.Sockets.Socket.SendToAsync%2A> sowohl mit Verbindungs orientierten Protokollen als auch mit Verbindungs orientierten Protokollen arbeiten.  
  
 Wenn Sie über den Abschluss benachrichtigt werden möchten, müssen Sie eine Rückruf Methode erstellen, die den EventHandler-\<SocketAsyncEventArgs-> Delegaten implementiert und den Rückruf an das <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis anfügt.  
  
 Die folgenden Eigenschaften und Ereignisse für das <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>-Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, bevor die <xref:System.Net.Sockets.Socket.SendToAsync%2A>-Methode aufgerufen wird, damit die Informationen in der Rückruf Methode abgerufen werden können. Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.  
  
 Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst die Methode <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> aufzurufen. Andernfalls wird <xref:System.Net.Sockets.Socket.SendToAsync%2A> eine <xref:System.Net.Sockets.SocketException>auslösen. Bei Verwendung eines Verbindungs orientierten Protokolls ignoriert die <xref:System.Net.Sockets.Socket.SendToAsync%2A>-Methode die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>-Eigenschaft und sendet Daten an die <xref:System.Net.EndPoint?displayProperty=nameWithType>, die in der <xref:System.Net.Sockets.Socket.Accept%2A>-, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>-, <xref:System.Net.Sockets.Socket.BeginAccept%2A>-, <xref:System.Net.Sockets.Socket.BeginConnect%2A>-, <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode festgelegt werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie vor dem Aufrufen von <xref:System.Net.Sockets.Socket.SendToAsync%2A>keinen Standard-Remote Host mit der <xref:System.Net.Sockets.Socket.BeginConnect%2A>-, <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode einrichten. Dies ist nur erforderlich, wenn Sie beabsichtigen, die Methoden <xref:System.Net.Sockets.Socket.BeginSend%2A> oder <xref:System.Net.Sockets.Socket.SendAsync%2A> aufzurufen. Wenn Sie die <xref:System.Net.Sockets.Socket.BeginConnect%2A>-, <xref:System.Net.Sockets.Socket.Connect%2A>-oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode aufrufen, bevor Sie <xref:System.Net.Sockets.Socket.SendToAsync%2A>aufrufen, überschreibt die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>-Eigenschaft nur den angegebenen Standard Remote Host für diesen Sendevorgang. Außerdem ist es nicht erforderlich, die <xref:System.Net.Sockets.Socket.Bind%2A>-Methode aufzurufen. In diesem Fall weist der zugrunde liegende Dienstanbieter die am besten geeignete IP-Adresse und Portnummer für das lokale Netzwerk zu. Verwenden Sie die Portnummer 0 (null), wenn der zugrunde liegende Dienstanbieter einen freien Port auswählen soll. Wenn Sie die IP-Adresse und Portnummer des zugewiesenen lokalen Netzwerks identifizieren müssen, können Sie die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>-Eigenschaft verwenden, nachdem das <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>-Ereignis signalisiert und die zugeordneten Delegaten aufgerufen wurden.  
  
 Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A>-Methode und die Socketoption für <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> auf "true" festlegen. Außerdem müssen Sie sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.SendToAsync%2A> löst eine <xref:System.Net.Sockets.SocketException>aus.  
  
 Wenn Sie das DontRoute-Flag in der <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>-Eigenschaft angeben, werden die Daten, die Sie senden, nicht weitergeleitet.  
  
 Bei Nachrichten orientierten Sockets muss darauf geachtet werden, dass die maximale Nachrichtengröße des zugrunde liegenden Transports nicht überschritten wird. Wenn die Größe des Puffers die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet, wird das Datagramm nicht gesendet, und <xref:System.Net.Sockets.Socket.SendToAsync%2A> löst eine <xref:System.Net.Sockets.SocketException>aus. Der erfolgreiche Abschluss einer <xref:System.Net.Sockets.Socket.SendToAsync%2A>-Methode zeigt nicht an, dass die Daten erfolgreich übermittelt wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht NULL sein.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Parameter angegebenen <paramref name="e" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Das angegebene Protokoll ist verbindungsorientiert, aber der <see cref="T:System.Net.Sockets.Socket" /> wurde noch nicht verbunden.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="level">Die für diesen Socket festzulegende IP-Schutzebene.</param>
        <summary>Legt die IP-Schutzebene für einen Socket fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>-Methode ermöglicht das Einschränken eines IPv6-oder IP-Sockets zum lauschen an einem bestimmten Bereich, z. b. Adressen mit demselben Link lokalen oder Standort lokalen Präfix. Mit dieser Socketoption können Anwendungen Zugriffs Einschränkungen für IPv6 oder IP-Sockets platzieren. Mit solchen Einschränkungen kann sich eine im privaten LAN ausgeführte Anwendung selbst einfach und stabil vor externen Angriffen schützen. Diese Socketoption kann auch verwendet werden, um Zugriffs Einschränkungen zu entfernen, wenn der `level` Parameter auf <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>festgelegt ist. Diese Socketoption erweitert oder beschränkt den Bereich eines empfangsbereiten Sockets und ermöglicht so bei Bedarf den uneingeschränkten Zugriff von öffentlichen und privaten Benutzern oder beschränkt den Zugriff nur auf denselben Standort.  
  
 Für diese Socketoption sind in der <xref:System.Net.Sockets.IPProtectionLevel>-Enumeration angegebene Schutzebenen definiert.  
  
 Die <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>-Methode wird verwendet, um Network Address Traversal (NAT) für eine <xref:System.Net.Sockets.Socket> Instanz zu aktivieren oder zu deaktivieren. NAT-Durchlauf kann mithilfe von Teredo, IPv6-zu-IPv4 oder einem ISATAP-Tunnel bereitgestellt werden.  
  
 Wenn der `level`-Parameter auf <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>oder <xref:System.Net.Sockets.IPProtectionLevel.Restricted>festgelegt ist, wird der NAT-Durchlauf für eine <xref:System.Net.Sockets.Socket> Instanz explizit deaktiviert.  
  
 Wenn der `level`-Parameter auf "<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>" festgelegt ist, kann der NAT-Durchlauf für eine <xref:System.Net.Sockets.Socket> abhängig von Firewallregeln, die im System vorhanden sind, zulässig sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="level" />-Parameter darf nicht <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /> sein. Die IP-Schutzebene kann nicht auf nicht angegeben festgelegt werden.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Net.Sockets.AddressFamily" /> des Sockets muss <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> sein.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt eine <see cref="T:System.Net.Sockets.Socket" />-Option fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Der als <see cref="T:System.Boolean" />-Wert dargestellte Wert der Option.</param>
        <summary>Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen <see cref="T:System.Boolean" />-Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Legen Sie `optionValue` auf `true` fest, um die Option zu aktivieren, oder, um die Option zu `false`.  
  
 <xref:System.Net.Sockets.Socket> Optionen werden nach Ebene der Protokoll Unterstützung gruppiert.  
  
 Im folgenden sind die verschiedenen <xref:System.Net.Sockets.Socket> Optionen aufgeführt, die mit dieser Überladung festgelegt werden können. Diese Optionen werden nach dem entsprechenden <xref:System.Net.Sockets.SocketOptionLevel> Wert gruppiert. Wenn Sie eine dieser Optionen festlegen möchten, achten Sie darauf, dass Sie den entsprechenden <xref:System.Net.Sockets.SocketOptionLevel> Wert für den `optionLevel`-Parameter verwenden. Die Option, die Sie festlegen möchten, muss im `optionName`-Parameter angegeben werden. Wenn Sie den aktuellen Wert einer der aufgelisteten Optionen erhalten möchten, verwenden Sie die <xref:System.Net.Sockets.Socket.GetSocketOption%2A>-Methode.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Weitere Informationen zu diesen Optionen finden Sie in der <xref:System.Net.Sockets.SocketOptionName>-Enumeration.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException> Ausnahme erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket geöffnet, und die Optionen `DontLinger` und `OutOfBandInline` Socketoptionen werden aktiviert.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Ein Array vom Typ <see cref="T:System.Byte" />, das den Wert der Option darstellt.</param>
        <summary>Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen, als Bytearray dargestellten Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Verwenden Sie diese Überladung, um diese <xref:System.Net.Sockets.Socket> Optionen festzulegen, für die ein Bytearray als Optionswert erforderlich ist.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Net.Sockets.LingerOption>-und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte festgelegt.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Ein Wert der Option.</param>
        <summary>Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen ganzzahligen Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Für eine Option mit einem <xref:System.Boolean>-Datentyp geben Sie einen Wert ungleich 0 (null) an, um die Option zu aktivieren, und einen Nullwert, um die Option zu deaktivieren. Geben Sie für eine Option mit einem Integer-Datentyp den entsprechenden Wert an. <xref:System.Net.Sockets.Socket> Optionen werden nach Ebene der Protokoll Unterstützung gruppiert.  
  
 Im folgenden sind die verschiedenen <xref:System.Net.Sockets.Socket> Optionen aufgeführt, die mit dieser Überladung festgelegt werden können. Diese Optionen werden nach dem entsprechenden <xref:System.Net.Sockets.SocketOptionLevel>gruppiert. Wenn Sie eine dieser Optionen festlegen möchten, achten Sie darauf, dass Sie die entsprechende <xref:System.Net.Sockets.SocketOptionLevel> für den `optionLevel`-Parameter verwenden. Die Option, die Sie festlegen möchten, muss im `optionName`-Parameter angegeben werden. Wenn Sie den aktuellen Wert einer der aufgelisteten Optionen erhalten möchten, verwenden Sie die <xref:System.Net.Sockets.Socket.GetSocketOption%2A>-Methode.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Weitere Informationen zu diesen Optionen finden Sie in der <xref:System.Net.Sockets.SocketOptionName>-Enumeration.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Net.Sockets.LingerOption>-und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte festgelegt.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Eine <see cref="T:System.Net.Sockets.LingerOption" /> oder <see cref="T:System.Net.Sockets.MulticastOption" /> mit dem Wert der Option.</param>
        <summary>Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen, als Objekt dargestellten Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Verwenden Sie diese Überladung, um die Optionen <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>und <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> festzulegen. Verwenden Sie für die Option <xref:System.Net.Sockets.SocketOptionName.Linger> <xref:System.Net.Sockets.Socket> für den `optionLevel`-Parameter. Verwenden Sie für <xref:System.Net.Sockets.SocketOptionName.AddMembership> und <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.SocketOptionLevel.IP>. Wenn Sie den aktuellen Wert einer der oben aufgeführten Optionen erhalten möchten, verwenden Sie die <xref:System.Net.Sockets.Socket.GetSocketOption%2A>-Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Net.Sockets.LingerOption>-und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte festgelegt.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Einer der <see cref="T:System.Net.Sockets.SocketShutdown" />-Werte, der den Vorgang angibt, der nicht mehr zulässig ist.</param>
        <summary>Deaktiviert Senden und Empfangen für einen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie einen Verbindungs orientierten <xref:System.Net.Sockets.Socket>verwenden, sollten Sie vor dem Schließen der <xref:System.Net.Sockets.Socket>stets die <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode aufzurufen. Dadurch wird sichergestellt, dass alle Daten vor dem Schließen des verbundenen Sockets gesendet und empfangen werden.  
  
 Ruft die <xref:System.Net.Sockets.Socket.Close%2A>-Methode auf, um alle verwalteten und nicht verwalteten Ressourcen freizugeben, die der <xref:System.Net.Sockets.Socket>zugeordnet sind. Versuchen Sie nicht, die <xref:System.Net.Sockets.Socket> nach dem Schließen wiederzuverwenden.  
  
 Die folgende Tabelle zeigt die <xref:System.Net.Sockets.SocketShutdown> Enumerationswerte, die für den `how`-Parameter gültig sind.  
  
|Wert|Beschreibung|  
|-----------|-----------------|  
|Send|Das Senden auf diesem <xref:System.Net.Sockets.Socket>deaktivieren.|  
|Empfangen|Hiermit wird der Empfang auf diesem <xref:System.Net.Sockets.Socket>deaktiviert.|  
|Beide|Hiermit wird das Senden und empfangen von auf diesem <xref:System.Net.Sockets.Socket>deaktiviert.|  
  
 Wenn Sie `how` auf <xref:System.Net.Sockets.SocketShutdown.Send> festlegen, wird angegeben, dass nachfolgende Aufrufe von <xref:System.Net.Sockets.Socket.Send%2A> nicht zulässig sind. Wenn Sie einen Verbindungs losen <xref:System.Net.Sockets.Socket>verwenden, hat die Angabe <xref:System.Net.Sockets.SocketShutdown.Send> keine Auswirkung.  
  
 Wenn Sie `how` auf <xref:System.Net.Sockets.SocketShutdown.Receive> festlegen, wird angegeben, dass nachfolgende Aufrufe von <xref:System.Net.Sockets.Socket.Receive%2A> nicht zulässig sind. Dies hat keine Auswirkung auf niedrigere Protokoll Ebenen. Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird die Verbindung beendet, wenn eine der folgenden Bedingungen erfüllt ist, nachdem <xref:System.Net.Sockets.Socket.Shutdown%2A> aufgerufen wurde:  
  
-   Die Daten befinden sich im eingehenden Netzwerk Puffer, der darauf wartet, empfangen zu werden.  
  
-   Es wurden weitere Daten gefunden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, werden Datagramme akzeptiert und in die Warteschlange eingereiht. Wenn jedoch kein Pufferspeicher für zusätzliche Eingehende Datagramme verfügbar ist, werden Sie verworfen, und es wird kein Fehler an den Absender zurückgegeben. Die Verwendung von <xref:System.Net.Sockets.Socket.Shutdown%2A> auf einem Verbindungs losen <xref:System.Net.Sockets.Socket> wird nicht empfohlen.  
  
 Wenn Sie `how` auf <xref:System.Net.Sockets.SocketShutdown.Both> festlegen, werden Sende-und Empfangs Vorgänge wie oben beschrieben deaktiviert.  
  
> [!NOTE]
>  Wenn Sie beim Aufrufen der <xref:System.Net.Sockets.Socket.Shutdown%2A>-Methode eine <xref:System.Net.Sockets.SocketException> erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.Socket.Shutdown%2A> verwendet, um die <xref:System.Net.Sockets.Socket>zu deaktivieren.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des <see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 der <xref:System.Net.Sockets.Socket.SocketType%2A> ist schreibgeschützt und wird festgelegt, wenn die <xref:System.Net.Sockets.Socket> erstellt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>und <xref:System.Net.Sockets.ProtocolType> in der Konsole angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob IPv4-Unterstützung verfügbar und auf dem aktuellen Host aktiviert ist.</summary>
        <value><see langword="true" />, wenn der aktuelle Host das Protokoll IPv4 unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem unterstützt möglicherweise sowohl IPv4-als auch IPv6-Protokolle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Framework IPv6 für bestimmte veraltete <see cref="T:System.Net.Dns" />-Member unterstützt.</summary>
        <value><see langword="true" />, wenn das Framework IPv6 für bestimmte veraltete <see cref="T:System.Net.Dns" />-Methoden unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem unterstützt möglicherweise sowohl IPv4-als auch IPv6-Protokolle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Veröffentlicht alle durch den <see cref="T:System.Net.Sockets.Socket" /> verwendeten Ressourcen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Wenn Sie die <xref:System.Net.Sockets.Socket>nicht mehr benötigen, nennen Sie iverwerf. verwerfen. Die iverwerf. verwerfen-Methode verbleibt die <xref:System.Net.Sockets.Socket> in einem nicht verwendbaren Zustand. Nach dem Aufrufen von "iverwerf. verwerfen" müssen Sie alle Verweise auf die <xref:System.Net.Sockets.Socket> freigeben, damit der Garbage Collector den Speicher freigeben kann, den der <xref:System.Net.Sockets.Socket> belegt hat. Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.

> [!NOTE] 
> Bevor Sie den letzten Verweis auf die <xref:System.Net.Sockets.Socket>freigeben, müssen Sie immer "iverwerf. verwerfen" anrufen. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Net.Sockets.Socket>-Methode des `Finalize`-Objekts aufruft.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Gültigkeitsdauer (TTL) von IP (Internet Protocol)-Paketen angibt, die vom <see cref="T:System.Net.Sockets.Socket" /> gesendet werden.</summary>
        <value>Der TTL-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der TTL-Wert gibt die maximale Anzahl von Routern an, die das Paket durchlaufen kann, bevor der Router das Paket verwirft und eine ICMP-Fehlermeldung (Internet Control Message Protocol), die an den Absender überschritten wird.  
  
 Der TTL-Wert kann auf einen Wert zwischen 0 und 255 festgelegt werden. Wenn diese Eigenschaft nicht festgelegt ist, ist der standardmäßige TTL-Wert für einen Socket 32.  
  
 Das Festlegen dieser Eigenschaft für einen TCP-Socket (Transmission Control Protocol) wird vom TCP/IP-Stapel ignoriert, wenn eine erfolgreiche Verbindung mithilfe des Sockets hergestellt wurde.  
  
 Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.Ttl%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für den TTL-Wert kann keine negative Zahl festgelegt werden.</exception>
        <exception cref="T:System.NotSupportedException">Diese Eigenschaft kann nur für Sockets in der <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />-Familie oder der <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />-Familie festgelegt werden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Dieser Fehler wird auch zurückgegeben, wenn versucht wird, TTL auf einen höheren Wert als 255 festzulegen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Socket nur den Modus für überlappende E/A-Vorgänge verwenden soll.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> nur überlappende E/A-Vorgänge verwendet, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft für eine <xref:System.Net.Sockets.Socket>, die <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>aufgerufen werden soll, auf `true` fest. Andernfalls weist das Framework möglicherweise dem Socket einen Abschlussport zu, was die Verwendung von <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>untersagt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Socket wurde an einen Abschlussanschluss gebunden.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
